<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- 
This manual is for GNU Java Training Wheels (version 1.1,
29 May 2016), which is a system for making it easier for novices
to learn to program in the Java language.

Copyright (C) 2016 Davin Pearson.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
"GNU Free Documentation License". -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GNU Java Training Wheels 1.1: Tutorial 15 Introducing inheritance</title>

<meta name="description" content="GNU Java Training Wheels 1.1: Tutorial 15 Introducing inheritance">
<meta name="keywords" content="GNU Java Training Wheels 1.1: Tutorial 15 Introducing inheritance">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="J_002eT_002eW_002e-Tutorials.html#J_002eT_002eW_002e-Tutorials" rel="up" title="J.T.W. Tutorials">
<link href="Tutorial-16-More-inheritance.html#Tutorial-16-More-inheritance" rel="next" title="Tutorial 16 More inheritance">
<link href="Tutorial-14-Linked-lists.html#Tutorial-14-Linked-lists" rel="prev" title="Tutorial 14 Linked lists">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Tutorial-15-Introducing-inheritance"></a>
<div class="header">
<p>
Next: <a href="Tutorial-16-More-inheritance.html#Tutorial-16-More-inheritance" accesskey="n" rel="next">Tutorial 16 More inheritance</a>, Previous: <a href="Tutorial-14-Linked-lists.html#Tutorial-14-Linked-lists" accesskey="p" rel="prev">Tutorial 14 Linked lists</a>, Up: <a href="J_002eT_002eW_002e-Tutorials.html#J_002eT_002eW_002e-Tutorials" accesskey="u" rel="up">J.T.W. Tutorials</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Tutorial-15-Introducing-inheritance-1"></a>
<h3 class="section">4.15 Tutorial 15 Introducing inheritance</h3>

<a name="Basic-Inheritance"></a>
<h4 class="subsection">4.15.1 Basic Inheritance</h4>

<a name="index-Inheritance"></a>

<p>When you see the following code: <strong><code>class</code></strong> <code>X</code> extends <code>Y</code>, it means
that <strong><code>class</code></strong> <code>X</code> inherits from the <strong><code>class</code></strong> <code>Y</code>. Class <code>X</code> is called
the subclass and the <strong><code>class</code></strong> <code>Y</code> is called the super-class or sometimes the
parent <strong><code>class</code></strong>. When the class <code>X</code> extends from <code>Y</code>, it pulls in all of the
non-private methods and properties from the super-class Y. Inherited
methods can override the behaviour of that same method in the
super-class to give behaviour that is specific to the subclass. The
concept of methods overriding other methods is called dynamic method
binding or more commonly the more impressive-sounding name:
polymorphism. The main thing that this tutorial shows is the idea that
inheritance is a non-symmetrical relationship. For example: in the
code that follows, the Bird class inherits from the Animal class,
which corresponds to the idea that every bird is an animal. The
reverse, every animal is a bird is plainly not true! Inheritance
forces you to recognize this.
</p>
<p><strong>Question 4.15.1:</strong> Study, compile and run the following code. The
following code shows how inheritance works. In the following code, the
<code>Bird</code> <strong><code>class</code></strong> inherits from the <code>Animal</code> <strong><code>class</code></strong>. The <code>Bird</code> <strong><code>class</code></strong> pulls in
the Animal class&rsquo;s <code>age</code> property and the <code>canFly</code> and <code>talk</code>
methods. Importantly the <code>canFly</code> property overrides the behaviour of
the canFly method of the parent Animal class, which reflects that fact
that generally speaking, birds can fly. In the code that follows, note
that int properties are initialized to zero by default and the super
method (also known as the constructor of the super-class) is called by
default if there is a zero parameter constructor in the super-class,
which there is by default, even if you don&rsquo;t write one!
</p>
<div class="example">
<pre class="example"><strong><code>class</code></strong> Animal
<strong><code>begin</code></strong>

&nbsp;&nbsp;&nbsp; <strong><code>property</code></strong> int age;    <em>// Animal's age in years</em>
&nbsp;&nbsp;&nbsp; <strong><code>property</code></strong> int health; <em>// Animal's health in hit points</em>

&nbsp;&nbsp;&nbsp; <strong><code>constructor</code></strong> Animal()
&nbsp;&nbsp;&nbsp; <strong><code>begin</code></strong>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; age    = 0; <em>// NOTE: not needed as set by default</em>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; health = 100;
&nbsp;&nbsp;&nbsp; <strong><code>end</code></strong>

&nbsp;&nbsp;&nbsp; <strong><code>method</code></strong> boolean canFly()
&nbsp;&nbsp;&nbsp; <strong><code>begin</code></strong>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return <strong><code>false</code></strong>;
&nbsp;&nbsp;&nbsp; <strong><code>end</code></strong>

&nbsp;&nbsp;&nbsp; <strong><code>method</code></strong> void talk()
&nbsp;&nbsp;&nbsp; <strong><code>begin</code></strong>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;Hello&quot;);
&nbsp;&nbsp;&nbsp; <strong><code>end</code></strong>
<strong><code>end</code></strong>

<strong><code>class</code></strong> Bird extends Animal
<strong><code>begin</code></strong>

&nbsp;&nbsp;&nbsp; <strong><code>property</code></strong> double flySpeed;) <em>// Bird's speed in km/h</em>

&nbsp;&nbsp;&nbsp; <strong><code>constructor</code></strong> Bird()
&nbsp;&nbsp;&nbsp; <strong><code>begin</code></strong>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; super();      <em>// NOTE: not needed as called by default</em>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; flySpeed = 0; <em>// NOTE: not needed as set by default</em>
&nbsp;&nbsp;&nbsp; <strong><code>end</code></strong>

&nbsp;&nbsp;&nbsp; <strong><code>method</code></strong> boolean canFly()
&nbsp;&nbsp;&nbsp; <strong><code>begin</code></strong>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <strong><code>return</code></strong> <strong><code>true</code></strong>;
&nbsp;&nbsp;&nbsp; <strong><code>end</code></strong>

&nbsp;&nbsp;&nbsp; <strong><code>method</code></strong> void peck()
&nbsp;&nbsp;&nbsp; <strong><code>begin</code></strong>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(&quot;peck&quot;);
&nbsp;&nbsp;&nbsp; <strong><code>end</code></strong>
<strong><code>end</code></strong>

<strong><code>class</code></strong> InheriTest
<strong><code>begin</code></strong>
&nbsp;&nbsp;&nbsp; <strong><code>beginMain</code></strong>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <strong><code>var</code></strong> Bird eagle = new Bird();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; eagle.talk();
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; eagle.peck();
&nbsp;&nbsp;&nbsp; <strong><code>endMain</code></strong>
<strong><code>end</code></strong>
</pre></div>

<p><strong>Question 4.15.2:</strong> Override the talk method of the Animal class in the
Bird class to print out &ldquo;Tweet Tweet!&rdquo; rather than &ldquo;hello&rdquo; to give
more accurate talking of bird objects.
</p>
<p><strong>Question 4.15.3:</strong> By copying the pattern established in the Bird class,
change the eagle from an instance of the Bird class to its own class
in its own right and then create an instance of that class in the <strong><code>main</code></strong>
<strong><code>function</code></strong> of InheriTest. Your Eagle class should have one <strong><code>property</code></strong>: <code>int
numberOfKills</code> and one <strong><code>method</code></strong>: <code>void attack()</code> that internally increments
the value of <code>numberOfKills</code>. In the <strong><code>main</code></strong> <strong><code>function</code></strong> you should call every
method of the Eagle class and its super-classes.
</p>
<p><strong>Question 4.15.4:</strong> What is the advantage of using a new separate class to
represent a new object rather than using an instance of an existing
class?
</p>
<a name="index-Writing-your-own-classes"></a>

<p><strong>Question 4.15.5:</strong> Create a new <strong><code>class</code></strong> <code>Kiwi</code> that inherits from the
<code>Bird</code> <strong><code>class</code></strong>. Your <code>Kiwi</code> <strong><code>class</code></strong> should override the <code>canFly</code>
method to return <strong><code>false</code></strong>, which reflects the fact that generally
speaking birds can fly, but the kiwi bird in particular does not
fly. Your <code>Kiwi</code> <strong><code>class</code></strong> have a <strong><code>property</code></strong> <code>numberOfWorms</code>. Once you
have written the <code>Kiwi</code> <strong><code>class</code></strong> you should create an instance of the
<code>Kiwi</code> <strong><code>class</code></strong> in the <strong><code>main</code></strong> <strong><code>function</code></strong>.
</p>
<p><strong>Question 4.15.6:</strong> Why does the following line of code in the <strong><code>main</code></strong>
<strong><code>function</code></strong> print out 100 but there is no setting of that variable to
that value in the Kiwi class?
</p>
<div class="example">
<pre class="example">System.out.println(k.health);
</pre></div>

<p><strong>Question 4.15.7:</strong> In the classes <code>Animal</code>, <code>Bird</code>, <code>Eagle</code> and
<code>Kiwi</code>, remove all of the <code>canFly</code> methods and replace it with a
single <code>canFly</code> property of the Animal class. In the constructors
you will need to set the value of the <code>canFly</code> <strong><code>property</code></strong> to a value
that is appropriate for that class. For example in the <code>Bird</code>
class&rsquo;s constructor you should set the <code>canFly</code> <strong><code>property</code></strong> to <strong><code>true</code></strong>,
while in the <code>Kiwi</code> <strong><code>class</code></strong>&rsquo;s constructor you should set the
<code>canFly</code> <strong><code>property</code></strong> to <strong><code>false</code></strong>.
</p>
<p><strong>Question 4.15.8:</strong> What is the advantage of having a <code>canFly</code>
<strong><code>property</code></strong> over a bunch of <code>canFly</code> methods?
</p>
<p>There is an equally valid alternative to having a <strong><code>public</code></strong> <strong><code>property</code></strong> in
the <code>Animal</code> <strong><code>class</code></strong> and that is to have in the <code>Animal</code> <strong><code>class</code></strong> a
<strong><code>private</code></strong> <strong><code>property</code></strong> <code>canFly</code> and a pair of methods for getting and
setting the value of the <code>canFly</code> property like so. These methods in
J.T.W. and Java are called getter methods and setter methods since, as
their names suggest, getters are used for getting the value of
something and setters are used for setting the value of
something. Nore that the <code>canFly</code> <strong><code>method</code></strong> of the code above
corresponds to <code>getCanFly</code> <strong><code>method</code></strong> in the code below.
</p>
<div class="example">
<pre class="example"><strong><code>private</code></strong> <strong><code>property</code></strong> boolean canFly;

<strong><code>method</code></strong> boolean getCanFly()
<strong><code>begin</code></strong>
&nbsp;&nbsp;&nbsp; <strong><code>return</code></strong> canFly;
<strong><code>end</code></strong>

<strong><code>method</code></strong> void setCanFly(boolean aCanFly)
<strong><code>begin</code></strong>
&nbsp;&nbsp;&nbsp; canFly = aCanFly;
<strong><code>end</code></strong>
</pre></div>

<a name="index-Getter-and-setter-methods"></a>
<a name="index-Setter-and-getter-methods"></a>

<p>You might think that it is simpler to have one thing (a single
non-private property) rather than three things (a private property and
a non-private getter method and a non-private setter method) and you
would be right. However from the point of view of the client code that
uses the Animal <strong><code>class</code></strong>, the two approaches are identical. Later on when
you learn more you will understand under what circumstances the second
getter and setter approach is better.
</p>
<p><strong>Question 4.15.9:</strong> Change the <strong><code>main</code></strong> <strong><code>function</code></strong> to what follows:
</p>
<div class="example">
<pre class="example"><strong><code>beginMain</code></strong>
&nbsp;&nbsp;&nbsp; <strong><code>var</code></strong> Bird b = new Bird(10);
&nbsp;&nbsp;&nbsp; <strong><code>var</code></strong> Animal a = b;
&nbsp;&nbsp;&nbsp; a.talk();
&nbsp;&nbsp;&nbsp; a.peck();
<strong><code>endMain</code></strong>
</pre></div>

<p>When you compile this code it gives a compilation error. What line
gives the error and what is the reason for the error?
</p>
<p><strong>Question 4.15.10:</strong> Change the <strong><code>main</code></strong> <strong><code>function</code></strong> to what follows:
</p>
<div class="example">
<pre class="example"><strong><code>beginMain</code></strong>
&nbsp;&nbsp;&nbsp; <strong><code>var</code></strong> Animal a = new Animal();
&nbsp;&nbsp;&nbsp; <strong><code>var</code></strong> Bird b = a;
&nbsp;&nbsp;&nbsp; b.talk();
&nbsp;&nbsp;&nbsp; b.peck();
<strong><code>endMain</code></strong>
</pre></div>

<p>When you compile this code it gives a compilation error. What line
gives the error and what is the reason for the error?
</p>
<a name="Run_002dtime-type-inquiry"></a>
<h4 class="subsection">4.15.2 Run-time type inquiry</h4>

<p>In J.T.W. and Java there is a keyword called <strong><code>instanceof</code></strong> that does
a run-time check on the type of an object. The following <strong><code>function</code></strong>:
</p>
<div class="example">
<pre class="example"><strong><code>function</code></strong> void say(Animal a)
<strong><code>begin</code></strong>
&nbsp;&nbsp;&nbsp; System.out.println(a instanceof Bird);
<strong><code>end</code></strong>
</pre></div>

<p>uses the <strong><code>instanceof</code></strong> keyword to determine the run-time type of the
reference a and prints out whether or not the reference is referring
to a <code>Bird</code> object. Some examples should clarify the situation:
</p>
<a name="index-instanceof-keyword"></a>

<ul>
<li> <code>say(new Bird())</code> prints <strong><code>true</code></strong>, Since the parameter a is pointing to a bird object at run-time,
</li><li> <code>say(new Animal())</code> prints <strong><code>false</code></strong> since not every animal is a bird,
</li><li> <code>say(new Eagle())</code> prints <strong><code>true</code></strong>, since every eagle is a bird, and
</li><li> <code>say(new Kiwi())</code> prints <strong><code>true</code></strong>, since every kiwi is a bird.
</li><li> <code><strong><code>var</code></strong> Animal a = new Animal(); say(a);</code> prints <strong><code>false</code></strong> since at run-time a is not pointing to a bird object
</li><li> <code><strong><code>var</code></strong> Animal a = new Bird(); say(a);</code> prints <strong><code>true</code></strong> since at run-time a is pointing to a bird object.
</li></ul>

<p>In Tutorial 17 you will learn why in most cases it is better to use
polymorphism instead of the instanceof keyword for run-time type
enquiry.
</p>
<a name="The-superclass-of-all-objects"></a>
<h4 class="subsection">4.15.3 The superclass of all objects</h4>
<a name="index-Object-superclass-of-all-objects"></a>

<p>Every <strong><code>class</code></strong> in Java inherits either directly or indirectly from a
<strong><code>class</code></strong> called <code>Object</code>. That is to say if <code>x</code> is a reference
variable, then the run-time expression <code>x instanceof Object</code> is
always <strong><code>true</code></strong> except for the pathological case where <code>x</code> is <strong><code>null</code></strong>
(i.e. is currently pointing to no object). The <code>Object</code> <strong><code>class</code></strong>
contains a method called <code>toString</code> that returns a string containing
the run-time <strong><code>class</code></strong> name of the object concatenated with the hash code
of the memory address of the object in base 16 (also known as
hexadecimal) format. Since every <strong><code>class</code></strong> inherits from Object, every
object can have <code>toString</code> invoked upon it. Even better, every <strong><code>class</code></strong>
<code>X</code> can override <code>toString</code> to provide debugging information that
is tailored to <code>X</code>. Therefore the <code>toString</code> <strong><code>method</code></strong> is convenient
for debugging. Since the <code>toString</code> <strong><code>method</code></strong> is a <strong><code>public</code></strong> <strong><code>method</code></strong> of the
<code>Object</code> <strong><code>class</code></strong> it must be overridden as a <strong><code>public</code></strong> method, since your
overridden <strong><code>function</code></strong> cannot have weaker access privileges.
</p>
<a name="index-The-toString-method-and-its-usefulness-in-debugging_002e"></a>


<hr>
<div class="header">
<p>
Next: <a href="Tutorial-16-More-inheritance.html#Tutorial-16-More-inheritance" accesskey="n" rel="next">Tutorial 16 More inheritance</a>, Previous: <a href="Tutorial-14-Linked-lists.html#Tutorial-14-Linked-lists" accesskey="p" rel="prev">Tutorial 14 Linked lists</a>, Up: <a href="J_002eT_002eW_002e-Tutorials.html#J_002eT_002eW_002e-Tutorials" accesskey="u" rel="up">J.T.W. Tutorials</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
