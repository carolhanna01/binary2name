This is libavl.info, produced by makeinfo version 4.0b from libavl.texi.


File: libavl.info,  Node: BST Traverser Insert Initialization,  Next: BST Traverser Copying,  Prev: BST Traverser Find Initialization,  Up: Better Iterative Traversal

4.9.3.5 Starting at an Inserted Node
....................................

   Another operation that can be useful is to insert a new node and
construct a traverser to the inserted node in a single operation.  The
following code does this:

68. <BST traverser insertion initializer 68> =
void *
bst_t_insert (struct bst_traverser *trav, struct bst_table *tree, void *item)
{
  struct bst_node **q;

  assert (tree != NULL && item != NULL);

  trav->bst_table = tree;
  trav->bst_height = 0;

  q = &tree->bst_root;
  while (*q != NULL)
    {
      int x = tree->bst_compare (item, (*q)->bst_data, tree->bst_param);
      if (x == 0)
        {
          trav->bst_node = *q;
          trav->bst_generation = tree->bst_generation;
          return (*q)->bst_data;
        }

      if (trav->bst_height >= BST_MAX_HEIGHT)
        {
          bst_balance (tree);
          return bst_t_insert (trav, tree, item);
        }
      trav->bst_stack[trav->bst_height++] = *q;

      q = &(*q)->bst_link[x > 0];
    }

  trav->bst_node = *q = tree->bst_alloc->libavl_malloc (tree->bst_alloc,
                                                        sizeof **q);
  if (*q == NULL)
    {
      trav->bst_node = NULL;
      trav->bst_generation = tree->bst_generation;
      return NULL;
    }

  (*q)->bst_link[0] = (*q)->bst_link[1] = NULL;
  (*q)->bst_data = item;
  tree->bst_count++;
  trav->bst_generation = tree->bst_generation;
  return (*q)->bst_data;
}

This code is included in *Note 63: BST traversal functions.


File: libavl.info,  Node: BST Traverser Copying,  Next: BST Traverser Advancing,  Prev: BST Traverser Insert Initialization,  Up: Better Iterative Traversal

4.9.3.6 Initialization by Copying
.................................

   This function copies one traverser to another.  It only copies the
stack of parent pointers if they are up-to-date:

69. <BST traverser copy initializer 69> =
void *
bst_t_copy (struct bst_traverser *trav, const struct bst_traverser *src)
{
  assert (trav != NULL && src != NULL);

  if (trav != src)
    {
      trav->bst_table = src->bst_table;
      trav->bst_node = src->bst_node;
      trav->bst_generation = src->bst_generation;
      if (trav->bst_generation == trav->bst_table->bst_generation)
        {
          trav->bst_height = src->bst_height;
          memcpy (trav->bst_stack, (const void *) src->bst_stack,
                  sizeof *trav->bst_stack * trav->bst_height);
        }
    }

  return trav->bst_node != NULL ? trav->bst_node->bst_data : NULL;
}

This code is included in *Note 63: BST traversal functions and *Note
178: AVL traversal functions.

Exercises:

1. Without the check that trav != src before copying src into trav,
what might happen?


File: libavl.info,  Node: BST Traverser Advancing,  Next: BST Traverser Retreating,  Prev: BST Traverser Copying,  Up: Better Iterative Traversal

4.9.3.7 Advancing to the Next Node
..................................

   The algorithm of bst_t_next(), the function for finding a successor,
divides neatly into three cases.  Two of these are the ones that we
discussed earlier in the introduction to this kind of traverser (*note
Better Iterative Traversal::).  The third case occurs when the last
node returned was NULL, in which case we return the least node in the
table, in accordance with the semantics for `libavl' tables.  The
function outline is this:

70. <BST traverser advance function 70> =
void *
bst_t_next (struct bst_traverser *trav)
{
  struct bst_node *x;

  assert (trav != NULL);

  if (trav->bst_generation != trav->bst_table->bst_generation)
    trav_refresh (trav);

  x = trav->bst_node;
  if (x == NULL)
    {
      return bst_t_first (trav, trav->bst_table);
    }
  else if (x->bst_link[1] != NULL)
    {
      <*Note Handle case where |x| has a right child:: 71>
    }
  else
    {
      <*Note Handle case where |x| has no right child:: 72>
    }
  trav->bst_node = x;

  return x->bst_data;
}

This code is included in *Note 63: BST traversal functions.

   The case where the current node has a right child is accomplished by
stepping to the right, then to the left until we can't go any farther,
as discussed in detail earlier.  The only difference is that we must
check for stack overflow.  When stack overflow does occur, we recover by
calling trav_balance(), then restarting bst_t_next() using a
tail-recursive call.  The tail recursion will never happen more than
once, because trav_balance() ensures that the tree's height is small
enough that the stack cannot overflow again:

71. <Handle case where x has a right child 71> =
if (trav->bst_height >= BST_MAX_HEIGHT)
  {
    bst_balance (trav->bst_table);
    return bst_t_next (trav);
  }

trav->bst_stack[trav->bst_height++] = x;
x = x->bst_link[1];

while (x->bst_link[0] != NULL)
  {
    if (trav->bst_height >= BST_MAX_HEIGHT)
      {
        bst_balance (trav->bst_table);
        return bst_t_next (trav);
      }

    trav->bst_stack[trav->bst_height++] = x;
    x = x->bst_link[0];
  }

This code is included in *Note 70: BST traverser advance function.

   In the case where the current node has no right child, we move
upward in the tree based on the stack of parent pointers that we saved,
as described before.  When the stack underflows, we know that we've run
out of nodes in the tree:

72. <Handle case where x has no right child 72> =
struct bst_node *y;

do
  {
    if (trav->bst_height == 0)
      {
        trav->bst_node = NULL;
        return NULL;
      }

    y = x;
    x = trav->bst_stack[--trav->bst_height];
  }
while (y == x->bst_link[1]);

This code is included in *Note 70: BST traverser advance function.


File: libavl.info,  Node: BST Traverser Retreating,  Next: BST Traversal Current Item,  Prev: BST Traverser Advancing,  Up: Better Iterative Traversal

4.9.3.8 Backing Up to the Previous Node
.......................................

   Moving to the previous node is analogous to moving to the next node.
The only difference, in fact, is that directions are reversed from left
to right.

73. <BST traverser back up function 73> =
void *
bst_t_prev (struct bst_traverser *trav)
{
  struct bst_node *x;

  assert (trav != NULL);

  if (trav->bst_generation != trav->bst_table->bst_generation)
    trav_refresh (trav);

  x = trav->bst_node;
  if (x == NULL)
    {
      return bst_t_last (trav, trav->bst_table);
    }
  else if (x->bst_link[0] != NULL)
    {
      if (trav->bst_height >= BST_MAX_HEIGHT)
        {
          bst_balance (trav->bst_table);
          return bst_t_prev (trav);
        }

      trav->bst_stack[trav->bst_height++] = x;
      x = x->bst_link[0];

      while (x->bst_link[1] != NULL)
        {
          if (trav->bst_height >= BST_MAX_HEIGHT)
            {
              bst_balance (trav->bst_table);
              return bst_t_prev (trav);
            }

          trav->bst_stack[trav->bst_height++] = x;
          x = x->bst_link[1];
        }
    }
  else
    {
      struct bst_node *y;

      do
        {
          if (trav->bst_height == 0)
            {
              trav->bst_node = NULL;
              return NULL;
            }

          y = x;
          x = trav->bst_stack[--trav->bst_height];
        }
      while (y == x->bst_link[0]);
    }
  trav->bst_node = x;

  return x->bst_data;
}

This code is included in *Note 63: BST traversal functions.


File: libavl.info,  Node: BST Traversal Current Item,  Next: BST Traversal Replacing the Current Item,  Prev: BST Traverser Retreating,  Up: Better Iterative Traversal

4.9.3.9 Getting the Current Item
................................

74. <BST traverser current item function 74> =
void *
bst_t_cur (struct bst_traverser *trav)
{
  assert (trav != NULL);

  return trav->bst_node != NULL ? trav->bst_node->bst_data : NULL;
}

This code is included in *Note 63: BST traversal functions, *Note 178:
AVL traversal functions, *Note 268: TBST traversal functions, *Note
395: RTBST traversal functions, *Note 502: PBST traversal functions,
and *Note 546: PAVL traversal functions.


File: libavl.info,  Node: BST Traversal Replacing the Current Item,  Prev: BST Traversal Current Item,  Up: Better Iterative Traversal

4.9.3.10 Replacing the Current Item
...................................

75. <BST traverser replacement function 75> =
void *
bst_t_replace (struct bst_traverser *trav, void *new)
{
  struct bst_node *old;

  assert (trav != NULL && trav->bst_node != NULL && new != NULL);
  old = trav->bst_node->bst_data;
  trav->bst_node->bst_data = new;
  return old;
}

This code is included in *Note 63: BST traversal functions, *Note 178:
AVL traversal functions, *Note 268: TBST traversal functions, *Note
395: RTBST traversal functions, *Note 502: PBST traversal functions,
and *Note 546: PAVL traversal functions.


File: libavl.info,  Node: Copying a BST,  Next: Destroying a BST,  Prev: Traversing a BST,  Up: Binary Search Trees

4.10 Copying
============

   In this section, we're going to write function bst_copy() to make a
copy of a binary tree.  This is the most complicated function of all
those needed for BST functionality, so pay careful attention as we
proceed.

* Menu:

* Copying a BST Recursively::
* Copying a BST Iteratively::
* Handling errors during iterative BST copying::


File: libavl.info,  Node: Copying a BST Recursively,  Next: Copying a BST Iteratively,  Prev: Copying a BST,  Up: Copying a BST

4.10.1 Recursive Copying
------------------------

   The "obvious" way to copy a binary tree is recursive.  Here's a basic
recursive copy, hard-wired to allocate memory with malloc() for
simplicity:

76. <Recursive copy of BST, take 1 76> =
/* Makes and returns a new copy of tree rooted at x. */
static struct bst_node *
bst_copy_recursive_1 (struct bst_node *x)
{
  struct bst_node *y;

  if (x == NULL)
    return NULL;

  y = malloc (sizeof *y);
  if (y == NULL)
    return NULL;

  y->bst_data = x->bst_data;
  y->bst_link[0] = bst_copy_recursive_1 (x->bst_link[0]);
  y->bst_link[1] = bst_copy_recursive_1 (x->bst_link[1]);
  return y;
}

   But, again, it would be nice to rewrite this iteratively, both
because the iterative version is likely to be faster and for the sheer
mental exercise of it.  Recall, from our earlier discussion of inorder
traversal, that tail recursion (recursion where a function calls itself
as its last action) is easier to convert to iteration than other types.
Unfortunately, neither of the recursive calls above are tail-recursive.

   Fortunately, we can rewrite it so that it is, if we change the way we
allocate data:

77. <Recursive copy of BST, take 2 77> =
/* Copies tree rooted at x to y, which latter is allocated but not
   yet initialized. */
static void
bst_copy_recursive_2 (struct bst_node *x, struct bst_node *y)
{
  y->bst_data = x->bst_data;

  if (x->bst_link[0] != NULL)
    {
      y->bst_link[0] = malloc (sizeof *y->bst_link[0]);
      bst_copy_recursive_2 (x->bst_link[0], y->bst_link[0]);
    }
  else
    y->bst_link[0] = NULL;

  if (x->bst_link[1] != NULL)
    {
      y->bst_link[1] = malloc (sizeof *y->bst_link[1]);
      bst_copy_recursive_2 (x->bst_link[1], y->bst_link[1]);
    }
  else
    y->bst_link[1] = NULL;
}

Exercises:

1. When malloc() returns a null pointer, bst_copy_recursive_1() fails
"silently", that is, without notifying its caller about the error, and
the output is a partial copy of the original tree.  Without removing the
recursion, implement two different ways to propagate such errors upward
to the function's caller:

  a. Change the function's prototype to:

         static int bst_robust_copy_recursive_1 (struct bst_node *,
                                                 struct bst_node **);

  b. Without changing the function's prototype.  (Hint: use a statically
     declared struct bst_node).

In each case make sure that any allocated memory is safely freed if an
allocation error occurs.

2. bst_copy_recursive_2() is even worse than bst_copy_recursive_1() at
handling allocation failure.  It actually invokes undefined behavior
when an allocation fails.  Fix this, changing it to return an int, with
nonzero return values indicating success.  Be careful not to leak
memory.


File: libavl.info,  Node: Copying a BST Iteratively,  Next: Handling errors during iterative BST copying,  Prev: Copying a BST Recursively,  Up: Copying a BST

4.10.2 Iterative Copying
------------------------

   Now we can factor out the recursion, starting with the tail
recursion.  This process is very similar to what we did with the
traversal code, so the details are left for Exercise 1.  Let's look at
the results part by part:

78. <Iterative copy of BST 78> =
/* Copies org to a newly created tree, which is returned. */
struct bst_table *
bst_copy_iterative (const struct bst_table *org)
{
  struct bst_node *stack[2 * (BST_MAX_HEIGHT + 1)];
                                     /* Stack. */
  int height = 0;                    /* Stack height. */

See also *Note 79: Iterative copy of BST-2, *Note 80: Iterative copy of
BST-3, and*Note 81: Iterative copy of BST-4.

   This time, our stack will have two pointers added to it at a time,
one from the original tree and one from the copy.  Thus, the stack
needs to be twice as big.  In addition, we'll see below that there'll
be an extra item on the stack representing the pointer to the tree's
root, so our stack needs room for an extra pair of items, which is the
reason for the "+ 1" in stack[]'s size.

79. <Iterative copy of BST 78> +=
  struct bst_table *new;             /* New tree. */
  const struct bst_node *x;          /* Node currently being copied. */
  struct bst_node *y;                /* New node being copied from x. */

  new = bst_create (org->bst_compare, org->bst_param, org->bst_alloc);
  new->bst_count = org->bst_count;
  if (new->bst_count == 0)
    return new;

  x = (const struct bst_node *) &org->bst_root;
  y = (struct bst_node *) &new->bst_root;

   This is the same kind of "dirty trick" already described in Exercise
5.7-1.

80. <Iterative copy of BST 78> +=
  for (;;)
    {
      while (x->bst_link[0] != NULL)
        {
          y->bst_link[0]
            = org->bst_alloc->libavl_malloc (org->bst_alloc,
                                             sizeof *y->bst_link[0]);
          stack[height++] = (struct bst_node *) x;
          stack[height++] = y;
          x = x->bst_link[0];
          y = y->bst_link[0];
        }
      y->bst_link[0] = NULL;

   This code moves x down and to the left in the tree until it runs out
of nodes, allocating space in the new tree for left children and pushing
nodes from the original tree and the copy onto the stack as it goes.
The cast on x suppresses a warning or error due to x, a pointer to a
const structure, being stored into a non-constant pointer in stack[].
We won't ever try to store into the pointer that we store in there, so
this is legitimate.

   We've switched from using malloc() to using the allocation function
provided by the user.  This is easy now because we have the tree
structure to work with.  To do this earlier, we would have had to
somehow pass the tree structure to each recursive call of the copy
function, wasting time and space.

81. <Iterative copy of BST 78> +=
      for (;;)
        {
          y->bst_data = x->bst_data;

          if (x->bst_link[1] != NULL)
            {
              y->bst_link[1] =
                org->bst_alloc->libavl_malloc (org->bst_alloc,
                                              sizeof *y->bst_link[1]);
              x = x->bst_link[1];
              y = y->bst_link[1];
              break;
            }
          else
            y->bst_link[1] = NULL;

          if (height <= 2)
            return new;

          y = stack[--height];
          x = stack[--height];
        }
    }
}

   We do not pop the bottommost pair of items off the stack because
these items contain the fake struct bst_node pointer that is actually
the address of bst_root.  When we get down to these items, we're done
copying and can return the new tree.

See also:  *Note Knuth 1997::, algorithm 2.3.1C; *Note ISO 1990::,
section 6.5.2.1.

Exercises:

1. Suggest a step between bst_copy_recursive_2() and
bst_copy_iterative().


File: libavl.info,  Node: Handling errors during iterative BST copying,  Prev: Copying a BST Iteratively,  Up: Copying a BST

4.10.3 Error Handling
---------------------

   So far, outside the exercises, we've ignored the question of handling
memory allocation errors during copying.  In our other routines, we've
been careful to implement to handle allocation failures by cleaning up
and returning an error indication to the caller.  Now we will apply this
same policy to tree copying, as `libavl' semantics require (*note
Creation and Destruction::): a memory allocation error causes the
partially copied tree to be destroyed and returns a null pointer to the
caller.

   This is a little harder to do than recovering after a single
operation, because there are potentially many nodes that have to be
freed, and each node might include additional user data that also has
to be freed.  The new BST might have as-yet-uninitialized pointer
fields as well, and we must be careful to avoid reading from these
fields as we destroy the tree.

   We could use a number of strategies to destroy the partially copied
tree while avoiding uninitialized pointers.  The strategy that we will
actually use is to initialize these pointers to NULL, then call the
general tree destruction routine bst_destroy().  We haven't yet written
bst_destroy(), so for now we'll treat it as a "black box" (*note black
box::) that does what we want, even if we don't understand how.

   Next question: _which_ pointers in the tree are not initialized?
The answer is simple: during the copy, we will not revisit nodes not
currently on the stack, so only pointers in the current node (y) and on
the stack can be uninitialized.  For its part, depending on what we're
doing to it, y might not have any of its fields initialized.  As for
the stack, nodes are pushed onto it because we have to come back later
and build their right subtrees, so we must set their right child
pointers to NULL.

   We will need this error recovery code in a number of places, so it is
worth making it into a small helper function:

82. <BST copy error helper function 82> =
static void
copy_error_recovery (struct bst_node **stack, int height, 
                     struct bst_table *new, bst_item_func *destroy)
{
  assert (stack != NULL && height >= 0 && new != NULL);

  for (; height > 2; height -= 2)
    stack[height - 1]->bst_link[1] = NULL;
  bst_destroy (new, destroy);
}

This code is included in *Note 83: BST copy function and *Note 185: AVL
copy function.

   Another problem that can arise in copying a binary tree is stack
overflow.  We will handle stack overflow by destroying the partial copy,
balancing the original tree, and then restarting the copy.  The balanced
tree is guaranteed to have small enough height that it will not overflow
the stack.

   The code below for our final version of bst_copy() takes three new
parameters: two function pointers and a memory allocator.  The meaning
of these parameters was explained earlier (*note Creation and
Destruction::).  Their use within the function should be
self-explanatory.

83. <BST copy function 83> =
<*Note BST copy error helper function:: 82>

struct bst_table *
bst_copy (const struct bst_table *org, bst_copy_func *copy,
          bst_item_func *destroy, struct libavl_allocator *allocator)
{
  struct bst_node *stack[2 * (BST_MAX_HEIGHT + 1)];
  int height = 0;

  struct bst_table *new;
  const struct bst_node *x;
  struct bst_node *y;

  assert (org != NULL);
  new = bst_create (org->bst_compare, org->bst_param, 
                    allocator != NULL ? allocator : org->bst_alloc);
  if (new == NULL)
    return NULL;
  new->bst_count = org->bst_count;
  if (new->bst_count == 0)
    return new;

  x = (const struct bst_node *) &org->bst_root;
  y = (struct bst_node *) &new->bst_root;
  for (;;)
    {
      while (x->bst_link[0] != NULL)
        {
          if (height >= 2 * (BST_MAX_HEIGHT + 1))
            {
              y->bst_data = NULL;
              y->bst_link[0] = y->bst_link[1] = NULL;
              copy_error_recovery (stack, height, new, destroy);

              bst_balance ((struct bst_table *) org);
              return bst_copy (org, copy, destroy, allocator);
            }

          y->bst_link[0] =
            new->bst_alloc->libavl_malloc (new->bst_alloc,
                                           sizeof *y->bst_link[0]);
          if (y->bst_link[0] == NULL)
            {
              if (y != (struct bst_node *) &new->bst_root)
                {
                  y->bst_data = NULL;
                  y->bst_link[1] = NULL;
                }

              copy_error_recovery (stack, height, new, destroy);
              return NULL;
            }

          stack[height++] = (struct bst_node *) x;
          stack[height++] = y;
          x = x->bst_link[0];
          y = y->bst_link[0];
        }
      y->bst_link[0] = NULL;

      for (;;)
        {
          if (copy == NULL) 
            y->bst_data = x->bst_data;
          else
            {
              y->bst_data = copy (x->bst_data, org->bst_param);
              if (y->bst_data == NULL)
                {
                  y->bst_link[1] = NULL;
                  copy_error_recovery (stack, height, new, destroy);
                  return NULL;
                }
            }

          if (x->bst_link[1] != NULL)
            {
              y->bst_link[1] =
                new->bst_alloc->libavl_malloc (new->bst_alloc,
                                               sizeof *y->bst_link[1]);
              if (y->bst_link[1] == NULL)
                {
                  copy_error_recovery (stack, height, new, destroy);
                  return NULL;
                }

              x = x->bst_link[1];
              y = y->bst_link[1];
              break;
            }
          else
            y->bst_link[1] = NULL;

          if (height <= 2)
            return new;

          y = stack[--height];
          x = stack[--height];
        }
    }
}

This code is included in *Note 29: BST operations.


File: libavl.info,  Node: Destroying a BST,  Next: Balancing a BST,  Prev: Copying a BST,  Up: Binary Search Trees

4.11 Destruction
================

   Eventually, we'll want to get rid of the trees we've spent all this
time constructing.  When this happens, it's time to destroy them by
freeing their memory.

* Menu:

* Destroying a BST by Rotation::
* Destroying a BST Recursively::
* Destroying a BST Iteratively::


File: libavl.info,  Node: Destroying a BST by Rotation,  Next: Destroying a BST Recursively,  Prev: Destroying a BST,  Up: Destroying a BST

4.11.1 Destruction by Rotation
------------------------------

   The method actually used in `libavl' for destruction of binary trees
is somewhat novel.  This section will cover this method.  Later
sections will cover more conventional techniques using recursive or
iterative "postorder traversal" (*note postorder traversal::).

   To destroy a binary tree, we must visit and free each node.  We have
already covered one way to traverse a tree (inorder traversal) and used
this technique for traversing and copying a binary tree.  But, both
times before, we were subject to both the explicit constraint that we
had to visit the nodes in sorted order and the implicit constraint that
we were not to change the structure of the tree, or at least not to
change it for the worse.

   Neither of these constraints holds for destruction of a binary tree.
As long as the tree finally ends up freed, it doesn't matter how much
it is mangled in the process.  In this case, "the end justifies the
means" and we are free to do it however we like.

   So let's consider why we needed a stack before.  It was to keep
track of nodes whose left subtree we were currently visiting, in order
to go back later and visit them and their right subtrees.  Hmm...what
if we rearranged nodes so that they _didn't have_ any left subtrees?
Then we could just descend to the right, without need to keep track of
anything on a stack.

   We can do this.  For the case where the current node p has a left
child q, consider the transformation below where we rotate right at p:

                               p        q
                              / \      / \
                             q   c => a   p
                             ^            ^
                            a b          b c
 
  where a, b, and c are arbitrary subtrees or even empty trees.  This
transformation shifts nodes from the left to the right side of the root
(which is now q).  If it is performed enough times, the root node will
no longer have a left child.  After the transformation, q becomes the
current node.

For the case where the current node has no left child, we can just
destroy the current node and descend to its right.  Because the
transformation used does not change the tree's ordering, we end up
destroying nodes in inorder.  It is instructive to verify this by
simulating with paper and pencil the destruction of a few trees this
way.

   The code to implement destruction in this manner is brief and
straightforward:

84. <BST destruction function 84> =
void
bst_destroy (struct bst_table *tree, bst_item_func *destroy)
{
  struct bst_node *p, *q;

  assert (tree != NULL);

  for (p = tree->bst_root; p != NULL; p = q)
    if (p->bst_link[0] == NULL)
      {
        q = p->bst_link[1];
        if (destroy != NULL && p->bst_data != NULL) 
          destroy (p->bst_data, tree->bst_param);
        tree->bst_alloc->libavl_free (tree->bst_alloc, p);
      }
    else
      {
        q = p->bst_link[0];
        p->bst_link[0] = q->bst_link[1];
        q->bst_link[1] = p;
      }

  tree->bst_alloc->libavl_free (tree->bst_alloc, tree);
}

This code is included in *Note 29: BST operations, *Note 145: AVL
functions, *Note 196: RB functions, *Note 489: PBST functions, *Note
522: PAVL functions, and *Note 554: PRB functions.

See also:  *Note Stout 1986::, tree_to_vine procedure.

Exercises:

1. Before calling destroy() above, we first test that we are not passing
it a NULL pointer, because we do not want destroy() to have to deal
with this case.  How can such a pointer get into the tree in the first
place, since bst_probe() refuses to insert such a pointer into a tree?


File: libavl.info,  Node: Destroying a BST Recursively,  Next: Destroying a BST Iteratively,  Prev: Destroying a BST by Rotation,  Up: Destroying a BST

4.11.2 Aside: Recursive Destruction
-----------------------------------

   The algorithm used in the previous section is easy and fast, but it
is not the most common method for destroying a tree.  The usual way is
to perform a traversal of the tree, in much the same way we did for tree
traversal and copying.  Once again, we'll start from a recursive
implementation, because these are so easy to write.  The only tricky
part is that subtrees have to be freed _before_ the root.  This code is
hard-wired to use free() for simplicity:

85. <Destroy a BST recursively 85> =
static void
bst_destroy_recursive (struct bst_node *node)
{
  if (node == NULL)
    return;

  bst_destroy_recursive (node->bst_link[0]);
  bst_destroy_recursive (node->bst_link[1]);
  free (node);
}


File: libavl.info,  Node: Destroying a BST Iteratively,  Prev: Destroying a BST Recursively,  Up: Destroying a BST

4.11.3 Aside: Iterative Destruction
-----------------------------------

   In this case, neither recursive call is tail recursive, and we can't
easily modify the code so that it is.  We could still factor out the
recursion by our usual methods, although it would be more difficult, but
this problem is simple enough to figure out from first principles.
Let's do it that way, instead, this time.

   The idea is that, for the tree's root, we traverse its left subtree,
then its right subtree, then free the root.  This pattern is called a
"postorder traversal" (*note postorder traversal::).

   Let's think about how much state we need to keep track of.  When
we're traversing the root's left subtree, we still need to remember the
root, in order to come back to it later.  The same is true while
traversing the root's right subtree, because we still need to come back
to free the root.  What's more, we need to keep track of what state
we're in: have we traversed the root's left subtree or not, have we
traversed the root's right subtree or not?

   This naturally suggests a stack that holds two-part items (root,
state), where root is the root of the tree or subtree and state is the
state of the traversal at that node.  We start by selecting the tree's
root as our current node p, then pushing (p, 0) onto the stack and
moving down to the left as far as we can, pushing as we go.  Then we
start popping off the stack into (p, state) and notice that state is 0,
which tells us that we've traversed p's left subtree but not its right.
So, we push (p, 1) back onto the stack, then we traverse p's right
subtree.  When, later, we pop off that same node back off the stack,
the 1 tells us that we've already traversed both subtrees, so we free
the node and keep popping.  The pattern follows as we continue back up
the tree.

   That sounds pretty complicated, so let's work through an example to
help clarify.  Consider this binary search tree:

                                    4
                                   / \
                                  2   5
                                  ^
                                 1 3
 
 Abstractly speaking, we start with 4 as p and an empty stack.  First,
we work our way down the left-child pointers, pushing onto the stack as
we go.  We push (4, 0), then (2, 0), then (1, 0), and then p is NULL
and we've fallen off the bottom of the tree.  We pop the top item off
the stack into (p, state), getting (1, 0).  Noticing that we have 0 for
state, we push (1, 1) on the stack and traverse 1's right subtree, but
it is empty so there is nothing to do.  We pop again and notice that
state is 1, meaning that we've fully traversed 1's subtrees, so we free
node 1.  We pop again, getting 2 for p and 0 for state.  Because state
is 0, we push (2, 1) and traverse 2's right subtree, which means that
we push (3, 0).  We traverse 3's null right subtree (again, it is empty
so there is nothing to do), pushing and popping (3, 1), then free node
3, then move back up to 2.  Because we've traversed 2's right subtree,
state is 1 and p is 2, and we free node 2.  You should be able to
figure out how 4 and 5 get freed.

A straightforward implementation of this approach looks like this:

86. <Destroy a BST iteratively 86> =
void
bst_destroy (struct bst_table *tree, bst_item_func *destroy)
{
  struct bst_node *stack[BST_MAX_HEIGHT];
  unsigned char state[BST_MAX_HEIGHT];
  int height = 0;

  struct bst_node *p;

  assert (tree != NULL);
  p = tree->bst_root;
  for (;;)
    {
      while (p != NULL)
        {
          if (height >= BST_MAX_HEIGHT)
            {
              fprintf (stderr, "tree too deep\n");
              exit (EXIT_FAILURE);
            }
          stack[height] = p;
          state[height] = 0;
          height++;

          p = p->bst_link[0];
        }

      for (;;)
        {
          if (height == 0)
            {
              tree->bst_alloc->libavl_free (tree->bst_alloc, tree);
              return;
            }

          height--;
          p = stack[height];
          if (state[height] == 0)
            {
              state[height++] = 1;
              p = p->bst_link[1];
              break;
            }
          else
            {
              if (destroy != NULL && p->bst_data != NULL)
                destroy (p->bst_data, tree->bst_param);
              tree->bst_alloc->libavl_free (tree->bst_alloc, p);
            }
        }
    }
}

See also:  *Note Knuth 1997::, exercise 13 in section 2.3.1.


File: libavl.info,  Node: Balancing a BST,  Next: Joining BSTs,  Prev: Destroying a BST,  Up: Binary Search Trees

4.12 Balance
============

   Sometimes binary trees can grow to become much taller than their
optimum height.  For example, the following binary tree was one of the
tallest from a sample of 100 15-node trees built by inserting nodes in
random order:

                       0
                        `-..__
                              5
                            _' `---...___
                           3             12
                         _' \     __..--'  \
                        1    4   7          13
                         \      / `-.__       \
                          2    6       11      14
                                   _.-'
                                  8
                                   `_
                                     10
                                    /
                                   9
 
 The average number of comparisons required to find a random node in
this tree is (1 + 2 + (3 * 2) + (4 * 4) + (5 * 4) + 6 + 7 + 8) / 15 =
4.4 comparisons.  In contrast, the corresponding optimal binary tree,
shown below, requires only (1 + (2 * 2) + (3 * 4) + (4 * 8))/15 = 3.3
comparisons, on average.  Moreover, the optimal tree requires a maximum
of 4, as opposed to 8, comparisons for any search:

                                7
                             _.' `-..__
                            3          11
                           / \      _.'  `_
                          1   5    9       13
                          ^   ^   / \     /  \
                         0 2 4 6 8   10  12   14
 
 Besides this inefficiency in time, trees that grow too tall can cause
inefficiency in space, leading to an overflow of the stack in
bst_t_next(), bst_copy(), or other functions.  For both reasons, it is
helpful to have a routine to rearrange a tree to its minimum possible
height, that is, to "balance" (*note balance::) the tree.

The algorithm we will use for balancing proceeds in two stages.  In the
first stage, the binary tree is "flattened" into a pathological, linear
binary tree, called a "vine."  In the second stage, binary tree
structure is restored by repeatedly "compressing" the vine into a
minimal-height binary tree.

   Here's a top-level view of the balancing function:

87. <BST balance function 87> =
<*Note BST to vine function:: 89>
<*Note Vine to balanced BST function:: 90>

void
bst_balance (struct bst_table *tree)
{
  assert (tree != NULL);

  tree_to_vine (tree);
  vine_to_tree (tree);
  tree->bst_generation++;
}

This code is included in *Note 29: BST operations.

88. <BST extra function prototypes 88> =

/* Special BST functions. */
void bst_balance (struct bst_table *tree);

This code is included in *Note 24: bsth, *Note 247: tbsth, *Note 372:
rtbsth, and *Note 486: pbsth.

See also:  *Note Stout 1986::, rebalance procedure.

* Menu:

* Transforming a BST into a Vine::
* Transforming a Vine into a Balanced BST::


File: libavl.info,  Node: Transforming a BST into a Vine,  Next: Transforming a Vine into a Balanced BST,  Prev: Balancing a BST,  Up: Balancing a BST

4.12.1 From Tree to Vine
------------------------

   The first stage of balancing converts a binary tree into a linear
structure resembling a linked list, called a "vine" (*note vine::).
The vines we will create have the greatest value in the binary tree at
the root and decrease descending to the left.  Any binary search tree
that contains a particular set of values, no matter its shape,
corresponds to the same vine of this type.  For instance, all binary
search trees of the integers 0...4 will be transformed into the
following vine:

                                        4
                                       /
                                      3
                                     /
                                    2
                                   /
                                  1
                                 /
                                0
 
 The method for transforming a tree into a vine of this type is similar
to that used for destroying a tree by rotation (*note Destroying a BST
by Rotation::).  We step pointer p through the tree, starting at the
root of the tree, maintaining pointer q as p's parent.  (Because we're
building a vine, p is always the left child of q.)  At each step, we do
one of two things:

   * If p has no right child, then this part of the tree is already the
     shape we want it to be.  We step p and q down to the left and
     continue.

   * If p has a right child r, then we rotate left at p, performing the
     following transformation:

                                      |          |
                                      q          q
                                   _.'         _'
                                  p           r
                                 / \    =>   / \
                                a   r       p   c
                                    ^       ^
                                   b c     a b
      
     
 where a, b, and c are arbitrary subtrees or empty trees.  Node r
     then becomes the new p.  If c is an empty tree, then, in the next
     step, we will continue down the tree.  Otherwise, the right
     subtree of p is smaller (contains fewer nodes) than previously, so
     we're on the right track.

   This is all it takes:

89. <BST to vine function 89> =
/* Converts tree into a vine. */
static void
tree_to_vine (struct bst_table *tree)
{
  struct bst_node *q, *p;

  q = (struct bst_node *) &tree->bst_root;
  p = tree->bst_root;
  while (p != NULL)
    if (p->bst_link[1] == NULL)
      {
        q = p;
        p = p->bst_link[0];
      }
    else
      {
        struct bst_node *r = p->bst_link[1];
        p->bst_link[1] = r->bst_link[0];
        r->bst_link[0] = p;
        p = r;
        q->bst_link[0] = r;
      }
}

This code is included in *Note 87: BST balance function, *Note 511:
PBST balance function, and *Note 679: PBST balance function with
integrated parent updates.

See also:  *Note Stout 1986::, tree_to_vine procedure.


File: libavl.info,  Node: Transforming a Vine into a Balanced BST,  Prev: Transforming a BST into a Vine,  Up: Balancing a BST

4.12.2 From Vine to Balanced Tree
---------------------------------

   Converting the vine, once we have it, into a balanced tree is the
interesting and clever part of the balancing operation.  However, at
first it may be somewhat less than obvious how this is actually done.
We will tackle the subject by presenting an example, then the
generalized form.

   Suppose we have a vine, as above, with 2**n - 1 nodes for positive
integer n.  For the sake of example, take n = 4, corresponding to a
tree with 15 nodes.  We convert this vine into a balanced tree by
performing three successive "compression" (*note compression::)
operations.

   To perform the first compression, move down the vine, starting at the
root.  Conceptually assign each node a "color", alternating between red
and black and starting with red at the root.(1) Then, take each red
node, except the bottommost, and remove it from the vine, making it the
child of its black former child node.

   After this transformation, we have something that looks a little more
like a tree.  Instead of a 15-node vine, we have a 7-node black vine
with a 7-node red vine as its right children and a single red node as
its left child.  Graphically, this first compression step on a 15-node
vine looks like this:

                                                                   14
                                                                   <b>
                                                             __..-'   \
               15                                           12         15
               <r>                                          <b>        <r>
             _'                                       __..-'   \
            14                                       10         13
            <b>                                      <b>        <r>
          _'                                   __..-'   \
         13                                    8         11
         <r>                                  <b>        <r>
       _'          =>                   __..-'   \
      ...                               6          9
    _'                                 <b>        <r>
    2                            __..-'   \
   <b>                           4          7
 _'                             <b>        <r>
 1                        __..-'   \
<r>                       2          5
                         <b>        <r>
                       _'   \
                       1      3
                      <r>    <r>
 
 To perform the second compression, recolor all the red nodes to white,
then change the color of alternate black nodes to red, starting at the
root.  As before, extract each red node, except the bottommost, and
reattach it as the child of its black former child node.  Attach each
black node's right subtree as the left subtree of the corresponding red
node.  Thus, we have the following:

                                  14
                                  <r>
                             __.-'   \
                            12        15
                            <b>                                         12
                       __.-'   \                                        <b>
                      10        13                            ___...---'   `_
                      <r>                                     8              14
                  _.-'   \                                   <b>             <r>
                  8       11                        ___...--'   `_          /   \
                 <b>                                4             10       13    15
             _.-'   \                    =>        <b>            <r>
             6       9                         _.-'   `_         /   \
            <r>                                2         6      9     11
        _.-'   \                              <r>       <r>
        4       7                            /   \     /   \
       <b>                                  1     3   5     7
   _.-'   \
   2       5
  <r>
 /   \
1     3
 
 The third compression is the same as the first two.  Nodes 12 and 4 are
recolored red, then node 12 is removed and reattached as the right
child of its black former child node 8, receiving node 8's right subtree
as its left subtree:

                        12
                        <r>                     8
               ___...--'   `_                  <b>
               8             14           __.-'   `--..__
              <b>           /  \          4              12
         __.-'   `_        13   15       <r>             <r>
         4         10              =>   /   \        _.-'   `_
        <r>       /  \                 2     6      10        14
       /   \     9    11               ^     ^     /  \      /  \
      2     6                         1 3   5 7   9    11   13   15
      ^     ^
     1 3   5 7
 
 The result is a fully balanced tree.

* Menu:

* Balancing General Trees::
* Balancing Implementation::
* Implementing compress()::

   ---------- Footnotes ----------

   (1) These colors are for the purpose of illustration only.  They are
not stored in the nodes and are not related to those used in a
"red-black tree" (*note red-black tree::).


File: libavl.info,  Node: Balancing General Trees,  Next: Balancing Implementation,  Prev: Transforming a Vine into a Balanced BST,  Up: Transforming a Vine into a Balanced BST

4.12.2.1 General Trees
......................

   A compression is the repeated application of a right rotation, called
in this context a "compression transformation", once for each black
node, like so:

                              |          |
                              R          B
                             <r>        <b>
                         _.-'   \      /   `_
                         B       c => a       R
                        <b>                  <r>
                       /   \                /   \
                      a     b              b     c

So far, all of the compressions we've performed have involved all 2**k
- 1 nodes composing the "main vine."  This works out well for an
initial vine of exactly 2**n - 1 nodes.  In this case, a total of n - 1
compressions are required, where for successive compressions k = n, n -
1, ..., 2.

   For trees that do not have exactly one fewer than a power of two
nodes, we need to begin with a compression that does not involve all of
the nodes in the vine.  Suppose that our vine has m nodes, where 2**n -
1 < m < 2**(n+1) - 1 for some value of n.  Then, by applying the
compression transformation shown above m - (2**n - 1) times, we reduce
the length of the main vine to exactly 2**n - 1 nodes.  After that, we
can treat the problem in the same way as the former case.  The result
is a balanced tree with n full levels of nodes, and a bottom level
containing m - (2**n - 1) nodes and (2**(n + 1) - 1) - m vacancies.

   An example is indicated.  Suppose that the vine contains m == 9 nodes
numbered from 1 to 9.  Then n == 3 since we have 2**3 - 1 = 7 < 9 < 15
= 2**4 - 1, and we must perform the compression transformation shown
above 9 - (2**3 - 1) = 2 times initially, reducing the main vine's
length to 7 nodes.  Afterward, we treat the problem the same way as for
a tree that started off with only 7 nodes, performing one compression
with k == 3 and one with k == 2.  The entire sequence, omitting the
initial vine, looks like this:

                       8                    6
                      <r>                  <r>           4
                  _.-'   \             _.-'   \         <r>
                  6       9            4       8       /   `_
                 <b>                  <b>      ^      2      6
               _'   \             _.-'   \    7 9 =>  ^     / \
               5     7      =>    2       5          1 3   5   8
              <r>                <r>                           ^
            _'                  /   \                         7 9
           ...                 1     3
         _'
         1
        <r>
 
 Now we have a general technique that can be applied to a vine of any
size.


File: libavl.info,  Node: Balancing Implementation,  Next: Implementing compress(),  Prev: Balancing General Trees,  Up: Transforming a Vine into a Balanced BST

4.12.2.2 Implementation
.......................

Implementing this algorithm is more or less straightforward.  Let's
start from an outline:

90. <Vine to balanced BST function 90> =
<*Note BST compression function:: 95>

/* Converts tree, which must be in the shape of a vine, into a balanced
   tree. */
static void
vine_to_tree (struct bst_table *tree)
{
  unsigned long vine;   /* Number of nodes in main vine. */
  unsigned long leaves; /* Nodes in incomplete bottom level, if any. */
  int height;           /* Height of produced balanced tree. */

  <*Note Calculate |leaves|:: 91>
  <*Note Reduce vine general case to special case:: 92>
  <*Note Make special case vine into balanced tree and count height:: 93>
  <*Note Check for tree height in range:: 94>
}

This code is included in *Note 87: BST balance function.

   The first step is to calculate the number of compression
transformations necessary to reduce the general case of a tree with m
nodes to the special case of exactly 2**n - 1 nodes, i.e., calculate m
- (2**n - 1), and store it in variable leaves.  We are given only the
value of m, as tree->bst_count.  Rewriting the calculation as the
equivalent m + 1 - 2**n, one way to calculate it is evident from
looking at the pattern in binary:

               m    n      m + 1        2**n       m + 1 - 2**n
               1    1     2 = 00010   2 = 00010    0 = 00000
               2    1     3 = 00011   2 = 00010    1 = 00001
               3    2     4 = 00100   4 = 00100    0 = 00000
               4    2     5 = 00101   4 = 00100    1 = 00001
               5    2     6 = 00110   4 = 00100    2 = 00010
               6    2     7 = 00111   4 = 00100    3 = 00011
               7    3     8 = 01000   8 = 01000    0 = 00000
               8    3     9 = 01001   8 = 01000    1 = 00000
               9    3    10 = 01001   8 = 01000    2 = 00000

   See the pattern?  It's simply that m + 1 - 2**n is m with the
leftmost 1-bit turned off.  So, if we can find the leftmost 1-bit in ,
we can figure out the number of leaves.

   In turn, there are numerous ways to find the leftmost 1-bit in a
number.  The one used here is based on the principle that, if x is a
positive integer, then x & (x - 1) is x with its rightmost 1-bit turned
off.

   Here's the code that calculates the number of leaves and stores it in
leaves:

91. <Calculate leaves 91> =
leaves = tree->bst_count + 1;
for (;;)
  {
    unsigned long next = leaves & (leaves - 1);
    if (next == 0)
      break;
    leaves = next;
  }
leaves = tree->bst_count + 1 - leaves;

This code is included in *Note 90: Vine to balanced BST function, *Note
285: TBST vine-to-tree function, *Note 512: Vine to balanced PBST
function, and *Note 680: Vine to balanced PBST function with parent
updates.

   Once we have the number of leaves, we perform a compression composed
of leaves compression transformations.  That's all it takes to reduce
the general case to the 2**n - 1 special case.  We'll write the
compress() function itself later:

92. <Reduce vine general case to special case 92> =
compress ((struct bst_node *) &tree->bst_root, leaves);

This code is included in *Note 90: Vine to balanced BST function, *Note
512: Vine to balanced PBST function, and *Note 680: Vine to balanced
PBST function with parent updates.

   The heart of the function is the compression of the vine into the
tree.  Before each compression, vine contains the number of nodes in
the main vine of the tree.  The number of compression transformations
necessary for the compression is vine / 2; e.g., when the main vine
contains 7 nodes, 7 / 2 = 3 transformations are necessary.  The number
of nodes in the vine afterward is the same number (*note Transforming a
Vine into a Balanced BST::).

   At the same time, we keep track of the height of the balanced tree.
The final tree always has height at least 1.  Each compression step
means that it is one level taller than that.  If the tree needed
general-to-special-case transformations, that is, leaves > 0, then it's
one more than that.

93. <Make special case vine into balanced tree and count height 93> =
vine = tree->bst_count - leaves;
height = 1 + (leaves > 0);
while (vine > 1)
  {
    compress ((struct bst_node *) &tree->bst_root, vine / 2);
    vine /= 2;
    height++;
  }

This code is included in *Note 90: Vine to balanced BST function, *Note
512: Vine to balanced PBST function, and *Note 680: Vine to balanced
PBST function with parent updates.

   Finally, we make sure that the height of the tree is within range for
what the functions that use stacks can handle.  Otherwise, we could end
up with an infinite loop, with bst_t_next() (for example) calling
bst_balance() repeatedly to balance the tree in order to reduce its
height to the acceptable range.

94. <Check for tree height in range 94> =
if (height > BST_MAX_HEIGHT)
  {
    fprintf (stderr, "libavl: Tree too big (%lu nodes) to handle.",
             (unsigned long) tree->bst_count);
    exit (EXIT_FAILURE);
  }

This code is included in *Note 90: Vine to balanced BST function.

