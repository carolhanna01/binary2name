This is libavl.info, produced by makeinfo version 4.0b from libavl.texi.


File: libavl.info,  Node: TRB insertion symmetric case,  Prev: Step 3 in TRB Insertion,  Up: Inserting into a TRB tree

9.3.3 Symmetric Case
--------------------

345. <Right-side rebalancing after TRB insertion 345> =
struct trb_node *y = pa[k - 2]->trb_link[0];
if (pa[k - 2]->trb_tag[0] == TRB_CHILD && y->trb_color == TRB_RED)
  {
    <*Note Case 1 in right-side TRB insertion rebalancing:: 346>
  }
else
  {
    struct trb_node *x;

    if (da[k - 1] == 1)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in right-side TRB insertion rebalancing:: 348>
      }

    <*Note Case 2 in right-side TRB insertion rebalancing:: 347>
    break;
  }

This code is included in *Note 340: Step 3 Rebalance after TRB
insertion.

346. <Case 1 in right-side TRB insertion rebalancing 346> =
<*Note Case 1 in right-side RB insertion rebalancing:: 207>

This code is included in *Note 345: Right-side rebalancing after TRB
insertion.

347. <Case 2 in right-side TRB insertion rebalancing 347> =
<*Note Case 2 in right-side RB insertion rebalancing:: 208>

if (y->trb_tag[0] == TRB_THREAD)
  {
    y->trb_tag[0] = TRB_CHILD;
    x->trb_tag[1] = TRB_THREAD;
    x->trb_link[1] = y;
  }

This code is included in *Note 345: Right-side rebalancing after TRB
insertion.

348. <Case 3 in right-side TRB insertion rebalancing 348> =
<*Note Case 3 in right-side RB insertion rebalancing:: 209>

if (y->trb_tag[1] == TRB_THREAD)
  {
    y->trb_tag[1] = TRB_CHILD;
    x->trb_tag[0] = TRB_THREAD;
    x->trb_link[0] = y;
  }

This code is included in *Note 345: Right-side rebalancing after TRB
insertion.

Exercises:

1. It could be argued that the algorithm here is "impure" because it
uses a stack, when elimination of the need for a stack is one of the
reasons originally given for using threaded trees.  Write a version of
trb_probe() that avoids the use of a stack.  You can use find_parent()
from <*Note Find parent of a TBST node:: 327> as a substitute.


File: libavl.info,  Node: Deleting from a TRB Tree,  Next: Testing TRB Trees,  Prev: Inserting into a TRB tree,  Up: Threaded Red-Black Trees

9.4 Deletion
============

   The outline for the deletion function follows the usual pattern.

349. <TRB item deletion function 349> =
void *
trb_delete (struct trb_table *tree, const void *item)
{
  struct trb_node *pa[TRB_MAX_HEIGHT]; /* Nodes on stack. */
  unsigned char da[TRB_MAX_HEIGHT];    /* Directions moved from stack nodes. */
  int k = 0;                           /* Stack height. */

  struct trb_node *p;
  int cmp, dir;

  assert (tree != NULL && item != NULL);

  <*Note Step 1 Search TRB tree for item to delete:: 350>
  <*Note Step 2 Delete item from TRB tree:: 351>
  <*Note Step 3 Rebalance tree after TRB deletion:: 356>
  <*Note Step 4 Finish up after TRB deletion:: 362>
}

This code is included in *Note 336: TRB functions.

* Menu:

* Deleting a TRB node step 1 - Search::
* Deleting a TRB node step 2 - Delete::
* Deleting a TRB node step 3 - Rebalance::
* Deleting a TRB node step 4 - Finish up::
* TRB deletion symmetric case::


File: libavl.info,  Node: Deleting a TRB node step 1 - Search,  Next: Deleting a TRB node step 2 - Delete,  Prev: Deleting from a TRB Tree,  Up: Deleting from a TRB Tree

9.4.1 Step 1: Search
--------------------

   There's nothing new or interesting in the search code.

350. <Step 1: Search TRB tree for item to delete 350> =
if (tree->trb_root == NULL)
  return NULL;

p = (struct trb_node *) &tree->trb_root;
for (cmp = -1; cmp != 0;
     cmp = tree->trb_compare (item, p->trb_data, tree->trb_param))
  {
    dir = cmp > 0;
    pa[k] = p;
    da[k++] = dir;

    if (p->trb_tag[dir] == TRB_THREAD)
      return NULL;
    p = p->trb_link[dir];
  }
item = p->trb_data;

This code is included in *Note 349: TRB item deletion function and
*Note 659: TAVL item deletion function with stack.


File: libavl.info,  Node: Deleting a TRB node step 2 - Delete,  Next: Deleting a TRB node step 3 - Rebalance,  Prev: Deleting a TRB node step 1 - Search,  Up: Deleting from a TRB Tree

9.4.2 Step 2: Delete
--------------------

   The code for node deletion is a combination of RB deletion (*note
Deleting an RB node step 2 - Delete::) and TBST deletion (*note
Deleting from a TBST::).  The node to delete is p, and after deletion
the stack contains all the nodes down to where rebalancing begins.  The
cases are the same as for TBST deletion:

351. <Step 2: Delete item from TRB tree 351> =
if (p->trb_tag[1] == TRB_THREAD)
  {
    if (p->trb_tag[0] == TRB_CHILD)
      {
        <*Note Case 1 in TRB deletion:: 352>
      }
    else
      {
        <*Note Case 2 in TRB deletion:: 353>
      }
  }
else
  {
    enum trb_color t;
    struct trb_node *r = p->trb_link[1];

    if (r->trb_tag[0] == TRB_THREAD)
      {
        <*Note Case 3 in TRB deletion:: 354>
      }
    else
      {
        <*Note Case 4 in TRB deletion:: 355>
      }
  }

This code is included in *Note 349: TRB item deletion function.

Case 1: p has a right thread and a left child
.............................................

   If the node to delete p has a right thread and a left child, then we
replace it by its left child.  We also have to chase down the right
thread that pointed to p.  The code is almost the same as <*Note Case 1
in TBST deletion:: 260>, but we use the stack here instead of a single
parent pointer.

352. <Case 1 in TRB deletion 352> =
struct trb_node *t = p->trb_link[0];
while (t->trb_tag[1] == TRB_CHILD)
  t = t->trb_link[1];
t->trb_link[1] = p->trb_link[1];
pa[k - 1]->trb_link[da[k - 1]] = p->trb_link[0];

This code is included in *Note 351: Step 2 Delete item from TRB tree.

Case 2: p has a right thread and a left thread
..............................................

   Deleting a leaf node is the same process as for a TBST.  The changes
from <*Note Case 2 in TBST deletion:: 261> are again due to the use of
a stack.

353. <Case 2 in TRB deletion 353> =
pa[k - 1]->trb_link[da[k - 1]] = p->trb_link[da[k - 1]];
if (pa[k - 1] != (struct trb_node *) &tree->trb_root)
  pa[k - 1]->trb_tag[da[k - 1]] = TRB_THREAD;

This code is included in *Note 351: Step 2 Delete item from TRB tree.

Case 3: p's right child has a left thread
.........................................

   The code for case 3 merges <*Note Case 3 in TBST deletion:: 262>
with <*Note Case 2 in RB deletion:: 223>.  First, the node is deleted
in the same way used for a TBST.  Then the colors of p and r are
swapped, and r is added to the stack, in the same way as for RB
deletion.

354. <Case 3 in TRB deletion 354> =
r->trb_link[0] = p->trb_link[0];
r->trb_tag[0] = p->trb_tag[0];
if (r->trb_tag[0] == TRB_CHILD)
  {
    struct trb_node *t = r->trb_link[0];
    while (t->trb_tag[1] == TRB_CHILD)
      t = t->trb_link[1];
    t->trb_link[1] = r;
  }
pa[k - 1]->trb_link[da[k - 1]] = r;
t = r->trb_color;
r->trb_color = p->trb_color;
p->trb_color = t;
da[k] = 1;
pa[k++] = r;

This code is included in *Note 351: Step 2 Delete item from TRB tree.

Case 4: p's right child has a left child
........................................

   Case 4 is a mix of <*Note Case 4 in TBST deletion:: 263> and <*Note
Case 3 in RB deletion:: 224>.  It follows the outline of TBST deletion,
but updates the stack.  After the deletion it also swaps the colors of
p and s as in RB deletion.

355. <Case 4 in TRB deletion 355> =
struct trb_node *s;
int j = k++;

for (;;)
  {
    da[k] = 0;
    pa[k++] = r;
    s = r->trb_link[0];
    if (s->trb_tag[0] == TRB_THREAD)
      break;

    r = s;
  }

da[j] = 1;
pa[j] = s;
if (s->trb_tag[1] == TRB_CHILD)
  r->trb_link[0] = s->trb_link[1];
else
  {
    r->trb_link[0] = s;
    r->trb_tag[0] = TRB_THREAD;
  }

s->trb_link[0] = p->trb_link[0];
if (p->trb_tag[0] == TRB_CHILD)
  {
    struct trb_node *t = p->trb_link[0];
    while (t->trb_tag[1] == TRB_CHILD)
      t = t->trb_link[1];
    t->trb_link[1] = s;

    s->trb_tag[0] = TRB_CHILD;
  }

s->trb_link[1] = p->trb_link[1];
s->trb_tag[1] = TRB_CHILD;

t = s->trb_color;
s->trb_color = p->trb_color;
p->trb_color = t;

pa[j - 1]->trb_link[da[j - 1]] = s;

This code is included in *Note 351: Step 2 Delete item from TRB tree.

Exercises:

1. Rewrite <*Note Case 4 in TAVL deletion:: 317> to replace the deleted
node's tavl_data by its successor, then delete the successor, instead of
shuffling pointers.  (Refer back to Exercise 5.8-3 for an explanation
of why this approach cannot be used in `libavl'.)


File: libavl.info,  Node: Deleting a TRB node step 3 - Rebalance,  Next: Deleting a TRB node step 4 - Finish up,  Prev: Deleting a TRB node step 2 - Delete,  Up: Deleting from a TRB Tree

9.4.3 Step 3: Rebalance
-----------------------

   The outline for rebalancing after threaded RB deletion is the same as
for the unthreaded case (*note Deleting an RB node step 3 -
Rebalance::):

356. <Step 3: Rebalance tree after TRB deletion 356> =
if (p->trb_color == TRB_BLACK)
  {
    for (; k > 1; k--)
      {
        if (pa[k - 1]->trb_tag[da[k - 1]] == TRB_CHILD)
          {
            struct trb_node *x = pa[k - 1]->trb_link[da[k - 1]];
            if (x->trb_color == TRB_RED)
              {
                x->trb_color = TRB_BLACK;
                break;
              }
          }

        if (da[k - 1] == 0)
          {
            <*Note Left-side rebalancing after TRB deletion:: 357>
          }
        else
          {
            <*Note Right-side rebalancing after TRB deletion:: 363>
          }
      }

    if (tree->trb_root != NULL)
      tree->trb_root->trb_color = TRB_BLACK;
  }

This code is included in *Note 349: TRB item deletion function.

   The rebalancing cases are the same, too.  We need to check for thread
tags, not for null pointers, though, in some places:

357. <Left-side rebalancing after TRB deletion 357> =
struct trb_node *w = pa[k - 1]->trb_link[1];

if (w->trb_color == TRB_RED) 
  {
    <*Note Ensure |w| is black in left-side TRB deletion rebalancing:: 358>
  }

if ((w->trb_tag[0] == TRB_THREAD
     || w->trb_link[0]->trb_color == TRB_BLACK)
    && (w->trb_tag[1] == TRB_THREAD
        || w->trb_link[1]->trb_color == TRB_BLACK))
  {
    <*Note Case 1 in left-side TRB deletion rebalancing:: 359>
  }
else
  {
    if (w->trb_tag[1] == TRB_THREAD
        || w->trb_link[1]->trb_color == TRB_BLACK)
      {
        <*Note Transform left-side TRB deletion rebalancing case 3 into case 2:: 361>
      }

    <*Note Case 2 in left-side TRB deletion rebalancing:: 360>
    break;
  }

This code is included in *Note 356: Step 3 Rebalance tree after TRB
deletion.

Case Reduction: Ensure w is black
.................................

   This transformation does not move around any subtrees that might be
threads, so there is no need for it to change.

358. <Ensure w is black in left-side TRB deletion rebalancing 358> =
<*Note Ensure |w| is black in left-side RB deletion rebalancing:: 228>

This code is included in *Note 357: Left-side rebalancing after TRB
deletion.

Case 1: w has no red children
.............................

   This transformation just recolors nodes, so it also does not need any
changes.

359. <Case 1 in left-side TRB deletion rebalancing 359> =
<*Note Case 1 in left-side RB deletion rebalancing:: 229>

This code is included in *Note 357: Left-side rebalancing after TRB
deletion.

Case 2: w's right child is red
..............................

   If w has a red right child and a left thread, then it is necessary to
adjust tags and links after the left rotation at w and recoloring, as
shown in this diagram:

                   |                                    |
               pa[x-1],B                                C
                  <g>                                  <g>
           _.-'         `._                      __..-'   `_
          x,A              w,C                   B           D
          <b>              <b>        =>        <b>         <b>
         /   \           _'   `_            _.-'   \       /   \
        a     b         [B]      D          A       [C]   d     e
                                <r>        <b>
                               /   \      /   \
                              d     e    a     b
360. <Case 2 in left-side TRB deletion rebalancing 360> =
<*Note Case 2 in left-side RB deletion rebalancing:: 230>

if (w->trb_tag[0] == TRB_THREAD)
  {
    w->trb_tag[0] = TRB_CHILD;
    pa[k - 1]->trb_tag[1] = TRB_THREAD;
    pa[k - 1]->trb_link[1] = w;
  }

This code is included in *Note 357: Left-side rebalancing after TRB
deletion.

Case 3: w's left child is red
.............................

   If w has a red left child, which has a right thread, then we again
need to adjust tags and links after right rotation at w and recoloring,
as shown here:

                |                                 |
            pa[k-1],B                         pa[k-1],B
               <g>                               <g>
        _.-'         `--...___            _.-'         `_
       x,A                    w,D        x,A             w,C
       <b>                    <b>   =>   <b>             <b>
      /   \             __..-'   \      /   \           /   `._
     a     b            C         e    a     b         c        D
                       <r>                                     <r>
                      /   \                                  _'   \
                     c     [D]                              [C]    e
361. <Transform left-side TRB deletion rebalancing case 3 into case 2 361> =
<*Note Transform left-side RB deletion rebalancing case 3 into case 2:: 231>

if (w->trb_tag[1] == TRB_THREAD)
  {
    w->trb_tag[1] = TRB_CHILD;
    w->trb_link[1]->trb_tag[0] = TRB_THREAD;
    w->trb_link[1]->trb_link[0] = w;
  }

This code is included in *Note 357: Left-side rebalancing after TRB
deletion.


File: libavl.info,  Node: Deleting a TRB node step 4 - Finish up,  Next: TRB deletion symmetric case,  Prev: Deleting a TRB node step 3 - Rebalance,  Up: Deleting from a TRB Tree

9.4.4 Step 4: Finish Up
-----------------------

   All that's left to do is free the node, update the count, and return
the deleted item:

362. <Step 4: Finish up after TRB deletion 362> =
tree->trb_alloc->libavl_free (tree->trb_alloc, p);
tree->trb_count--;
return (void *) item;

This code is included in *Note 349: TRB item deletion function.


File: libavl.info,  Node: TRB deletion symmetric case,  Prev: Deleting a TRB node step 4 - Finish up,  Up: Deleting from a TRB Tree

9.4.5 Symmetric Case
--------------------

363. <Right-side rebalancing after TRB deletion 363> =
struct trb_node *w = pa[k - 1]->trb_link[0];

if (w->trb_color == TRB_RED) 
  {
    <*Note Ensure |w| is black in right-side TRB deletion rebalancing:: 364>
  }

if ((w->trb_tag[0] == TRB_THREAD
     || w->trb_link[0]->trb_color == TRB_BLACK)
    && (w->trb_tag[1] == TRB_THREAD
        || w->trb_link[1]->trb_color == TRB_BLACK))
  {
    <*Note Case 1 in right-side TRB deletion rebalancing:: 365>
  }
else
  {
    if (w->trb_tag[0] == TRB_THREAD
        || w->trb_link[0]->trb_color == TRB_BLACK)
      {
        <*Note Transform right-side TRB deletion rebalancing case 3 into case 2:: 367>
      }

    <*Note Case 2 in right-side TRB deletion rebalancing:: 366>
    break;
  }

This code is included in *Note 356: Step 3 Rebalance tree after TRB
deletion.

364. <Ensure w is black in right-side TRB deletion rebalancing 364> =
<*Note Ensure |w| is black in right-side RB deletion rebalancing:: 234>

This code is included in *Note 363: Right-side rebalancing after TRB
deletion.

365. <Case 1 in right-side TRB deletion rebalancing 365> =
<*Note Case 1 in right-side RB deletion rebalancing:: 235>

This code is included in *Note 363: Right-side rebalancing after TRB
deletion.

366. <Case 2 in right-side TRB deletion rebalancing 366> =
<*Note Case 2 in right-side RB deletion rebalancing:: 237>

if (w->trb_tag[1] == TRB_THREAD)
  {
    w->trb_tag[1] = TRB_CHILD;
    pa[k - 1]->trb_tag[0] = TRB_THREAD;
    pa[k - 1]->trb_link[0] = w;
  }

This code is included in *Note 363: Right-side rebalancing after TRB
deletion.

367. <Transform right-side TRB deletion rebalancing case 3 into case 2 367> =
<*Note Transform right-side RB deletion rebalancing case 3 into case 2:: 236>

if (w->trb_tag[0] == TRB_THREAD)
  {
    w->trb_tag[0] = TRB_CHILD;
    w->trb_link[0]->trb_tag[1] = TRB_THREAD;
    w->trb_link[0]->trb_link[1] = w;
  }

This code is included in *Note 363: Right-side rebalancing after TRB
deletion.

Exercises:

1. Write another version of trb_delete() that does not use a stack.  You
can use <*Note Find parent of a TBST node:: 327> to find the parent of
a node.


File: libavl.info,  Node: Testing TRB Trees,  Prev: Deleting from a TRB Tree,  Up: Threaded Red-Black Trees

9.5 Testing
===========

   The testing code harbors no surprises.

368. <trb-test.c 368> =
<*Note License:: 1>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "trb.h"
#include "test.h"

<*Note TBST print function:: 291>
<*Note BST traverser check function:: 104>
<*Note Compare two TRB trees for structure and content:: 369>
<*Note Recursively verify TRB tree structure:: 370>
<*Note RB tree verify function:: 244>
<*Note BST test function:: 100>
<*Note BST overflow test function:: 122>

369. <Compare two TRB trees for structure and content 369> =
static int
compare_trees (struct trb_node *a, struct trb_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      if (a != NULL || b != NULL)
        {
          printf (" a=%d b=%d\n",
                  a ? *(int *) a->trb_data : -1,
                  b ? *(int *) b->trb_data : -1);
          assert (0);
        }
      return 1;
    }
  assert (a != b);

  if (*(int *) a->trb_data != *(int *) b->trb_data
      || a->trb_tag[0] != b->trb_tag[0]
      || a->trb_tag[1] != b->trb_tag[1]
      || a->trb_color != b->trb_color)
    {
      printf (" Copied nodes differ: a=%d%c b=%d%c a:",
              *(int *) a->trb_data, a->trb_color == TRB_RED ? 'r' : 'b',
              *(int *) b->trb_data, b->trb_color == TRB_RED ? 'r' : 'b');

      if (a->trb_tag[0] == TRB_CHILD)
        printf ("l");
      if (a->trb_tag[1] == TRB_CHILD)
        printf ("r");

      printf (" b:");
      if (b->trb_tag[0] == TRB_CHILD)
        printf ("l");
      if (b->trb_tag[1] == TRB_CHILD)
        printf ("r");

      printf ("\n");
      return 0;
    }

  if (a->trb_tag[0] == TRB_THREAD)
    assert ((a->trb_link[0] == NULL) != (a->trb_link[0] != b->trb_link[0]));
  if (a->trb_tag[1] == TRB_THREAD)
    assert ((a->trb_link[1] == NULL) != (a->trb_link[1] != b->trb_link[1]));

  okay = 1;
  if (a->trb_tag[0] == TRB_CHILD)
    okay &= compare_trees (a->trb_link[0], b->trb_link[0]);
  if (a->trb_tag[1] == TRB_CHILD)
    okay &= compare_trees (a->trb_link[1], b->trb_link[1]);
  return okay;
}

This code is included in *Note 368: trb-testc.

370. <Recursively verify TRB tree structure 370> =
static void
recurse_verify_tree (struct trb_node *node, int *okay, size_t *count, 
                     int min, int max, int *bh)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */
  int subbh[2];         /* Black-heights of subtrees. */

  if (node == NULL)
    {
      *count = 0;
      *bh = 0;
      return;
    }
  d = *(int *) node->trb_data;

  <*Note Verify binary search tree ordering:: 114>

  subcount[0] = subcount[1] = 0;
  subbh[0] = subbh[1] = 0;
  if (node->trb_tag[0] == TRB_CHILD)
    recurse_verify_tree (node->trb_link[0], okay, &subcount[0], 
                         min, d - 1, &subbh[0]);
  if (node->trb_tag[1] == TRB_CHILD)
    recurse_verify_tree (node->trb_link[1], okay, &subcount[1], 
                         d + 1, max, &subbh[1]);
  *count = 1 + subcount[0] + subcount[1];
  *bh = (node->trb_color == TRB_BLACK) + subbh[0];

  <*Note Verify RB node color:: 241>
  <*Note Verify TRB node rule 1 compliance:: 371>
  <*Note Verify RB node rule 2 compliance:: 243>
}

This code is included in *Note 368: trb-testc.

371. <Verify TRB node rule 1 compliance 371> =
/* Verify compliance with rule 1. */
if (node->trb_color == TRB_RED)
  {
    if (node->trb_tag[0] == TRB_CHILD
        && node->trb_link[0]->trb_color == TRB_RED)
      {
        printf (" Red node %d has red left child %d\n",
                d, *(int *) node->trb_link[0]->trb_data);
        *okay = 0;
      }

    if (node->trb_tag[1] == TRB_CHILD
        && node->trb_link[1]->trb_color == TRB_RED)
      {
        printf (" Red node %d has red right child %d\n",
                d, *(int *) node->trb_link[1]->trb_data);
        *okay = 0;
      }
  }

This code is included in *Note 370: Recursively verify TRB tree
structure.


File: libavl.info,  Node: Right-Threaded Binary Search Trees,  Next: Right-Threaded AVL Trees,  Prev: Threaded Red-Black Trees,  Up: Top

10 Right-Threaded Binary Search Trees
*************************************

   We originally introduced threaded trees to allow for traversal
without maintaining a stack explicitly.  This worked out well, so we
implemented tables using threaded BSTs and AVL and RB trees.  However,
maintaining the threads can take some time.  It would be nice if we
could have the advantages of threads without so much of the overhead.

   In one common special case, we can.  Threaded trees are symmetric:
there are left threads for moving to node predecessors and right
threads for move to node successors.  But traversals are not symmetric:
many algorithms that traverse table entries only from least to
greatest, never backing up.  This suggests a matching asymmetric tree
structure that has only right threads.

   We can do this.  In this chapter, we will develop a table
implementation for a new kind of binary tree, called a right-threaded
binary search tree, "right-threaded tree" (*note right-threaded
tree::), or simply "RTBST", that has threads only on the right side of
nodes.  Construction and modification of such trees can be faster and
simpler than threaded trees because there is no need to maintain the
left threads.

   There isn't anything fundamentally new here, but just for
completeness, here's an example of a right-threaded tree:

                               3
                           _.-' `--..__
                          2            6
                      _.-' \     __..-' `-.__
                     1      [3] 4            8
                      \          \       _.-' \
                       [2]        5     7      9
                                   \     \      \
                                    [6]   [8]    []
 
 Keep in mind that although it is not efficient, it is still possible to
traverse a right-threaded tree in order from greatest to least.(1)  If
it were not possible at all, then we could not build a complete table
implementation based on right-threaded trees, because the definition of
a table includes the ability to traverse it in either direction (*note
Manipulators::).

Here's the outline of the RTBST code, which uses the prefix rtbst_:

372. <rtbst.h 372> =
<*Note License:: 1>
#ifndef RTBST_H
#define RTBST_H 1

#include <stddef.h>

<*Note Table types:: 14>
<*Note TBST table structure:: 250>
<*Note RTBST node structure:: 374>
<*Note TBST traverser structure:: 267>
<*Note Table function prototypes:: 15>
<*Note BST extra function prototypes:: 88>

#endif /* rtbst.h */

373. <rtbst.c 373> =
<*Note License:: 1>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "rtbst.h"

<*Note RTBST functions:: 375>

See also:  *Note Knuth 1997::, section 2.3.1.

Exercises:

1. We can define a "left-threaded tree" (*note left-threaded tree::) in
a way analogous to a right-threaded tree, as a binary search tree with
threads only on the left sides of nodes.  Is this a useful thing to do?

* Menu:

* RTBST Data Types::
* RTBST Operations::
* Searching an RTBST::
* Inserting into an RTBST::
* Deleting from an RTBST::
* Traversing an RTBST::
* Copying an RTBST::
* Destroying an RTBST::
* Balancing an RTBST::
* Testing RTBSTs::

   ---------- Footnotes ----------

   (1) It can be efficient if we use a stack to do it, but that kills
the advantage of threading the tree.  It would be possible to implement
two sets of traversers for right-threaded trees, one with a stack, one
without, but in that case it's probably better to just use a threaded
tree.


File: libavl.info,  Node: RTBST Data Types,  Next: RTBST Operations,  Prev: Right-Threaded Binary Search Trees,  Up: Right-Threaded Binary Search Trees

10.1 Data Types
===============

374. <RTBST node structure 374> =
/* Characterizes a link as a child pointer or a thread. */
enum rtbst_tag
  {
    RTBST_CHILD,                     /* Child pointer. */
    RTBST_THREAD                     /* Thread. */
  };

/* A threaded binary search tree node. */
struct rtbst_node
  {
    struct rtbst_node *rtbst_link[2]; /* Subtrees. */
    void *rtbst_data;                 /* Pointer to data. */
    unsigned char rtbst_rtag;         /* Tag field. */
  };

This code is included in *Note 372: rtbsth.


File: libavl.info,  Node: RTBST Operations,  Next: Searching an RTBST,  Prev: RTBST Data Types,  Up: Right-Threaded Binary Search Trees

10.2 Operations
===============

375. <RTBST functions 375> =
<*Note TBST creation function:: 252>
<*Note RTBST search function:: 376>
<*Note RTBST item insertion function:: 377>
<*Note Table insertion convenience functions:: 592>
<*Note RTBST item deletion function:: 380>
<*Note RTBST traversal functions:: 395>
<*Note RTBST copy function:: 406>
<*Note RTBST destruction function:: 407>
<*Note RTBST balance function:: 408>
<*Note Default memory allocation functions:: 6>
<*Note Table assertion functions:: 594>

This code is included in *Note 373: rtbstc.


File: libavl.info,  Node: Searching an RTBST,  Next: Inserting into an RTBST,  Prev: RTBST Operations,  Up: Right-Threaded Binary Search Trees

10.3 Search
===========

   A right-threaded tree is inherently asymmetric, so many of the
algorithms on it will necessarily be asymmetric as well.  The search
function is the simplest demonstration of this.  For descent to the
left, we test for a null left child with rtbst_link[0]; for descent to
the right, we test for a right thread with rtbst_rtag.  Otherwise, the
code is familiar:

376. <RTBST search function 376> =
void *
rtbst_find (const struct rtbst_table *tree, const void *item)
{
  const struct rtbst_node *p;
  int dir;

  assert (tree != NULL && item != NULL);

  if (tree->rtbst_root == NULL)
    return NULL;

  for (p = tree->rtbst_root; ; p = p->rtbst_link[dir])
    {
      int cmp = tree->rtbst_compare (item, p->rtbst_data, tree->rtbst_param);
      if (cmp == 0)
        return p->rtbst_data;
      dir = cmp > 0;

      if (dir == 0)
        {
          if (p->rtbst_link[0] == NULL)
            return NULL;
        }
      else /* dir == 1 */
        {
          if (p->rtbst_rtag == RTBST_THREAD)
            return NULL;
        }
    }
}

This code is included in *Note 375: RTBST functions, *Note 418: RTAVL
functions, and *Note 455: RTRB functions.


File: libavl.info,  Node: Inserting into an RTBST,  Next: Deleting from an RTBST,  Prev: Searching an RTBST,  Up: Right-Threaded Binary Search Trees

10.4 Insertion
==============

   Regardless of the kind of binary tree we're dealing with, adding a
new node requires setting three pointer fields: the parent pointer and
the two child pointers of the new node.  On the other hand, we do save a
tiny bit on tags: we set either 1 or 2 tags here as opposed to a
constant of 3 in <*Note TBST item insertion function:: 254>.

   Here is the outline:

377. <RTBST item insertion function 377> =
void **
rtbst_probe (struct rtbst_table *tree, void *item)
{
  struct rtbst_node *p; /* Current node in search. */
  int dir;              /* Side of p on which to insert the new node. */

  struct rtbst_node *n; /* New node. */

  <*Note Step 1 Search RTBST for insertion point:: 378>
  <*Note Step 2 Insert new node into RTBST tree:: 379>
}

This code is included in *Note 375: RTBST functions.

   The code to search for the insertion point is not unusual:

378. <Step 1: Search RTBST for insertion point 378> =
if (tree->rtbst_root != NULL)
  for (p = tree->rtbst_root; ; p = p->rtbst_link[dir])
    {
      int cmp = tree->rtbst_compare (item, p->rtbst_data, tree->rtbst_param);
      if (cmp == 0)
        return &p->rtbst_data;
      dir = cmp > 0;

      if (dir == 0)
        {
          if (p->rtbst_link[0] == NULL)
            break;
        }
      else /* dir == 1 */
        {
          if (p->rtbst_rtag == RTBST_THREAD)
            break;
        }
    }
else
  {
    p = (struct rtbst_node *) &tree->rtbst_root;
    dir = 0;
  }

This code is included in *Note 377: RTBST item insertion function.

   Now for the insertion code.  An insertion to the left of a node p in
a right-threaded tree replaces the left link by the new node n.  The
new node in turn has a null left child and a right thread pointing back
to p:

                                         |
                             |           p
                             p       _.-' \
                              \  => n      a
                               a     \
                                      [p]
 
 An insertion to the right of p replaces the right thread by the new
child node n.  The new node has a null left child and a right thread
that points where p's right thread formerly pointed:

                                                 |
                                |                s
                                s     ____...---'
                       ___...--'     ...
                      ...               `_
                         `_       =>      p
                           p             / \
                          / \           a   n
                         a   [s]             \
                                              [s]
 
 We can handle both of these cases in one code segment.  The difference
is in the treatment of n's right child and p's right tag.  Insertion
into an empty tree is handled as a special case as well:

379. <Step 2: Insert new node into RTBST tree 379> =
n = tree->rtbst_alloc->libavl_malloc (tree->rtbst_alloc, sizeof *n);
if (n == NULL)
  return NULL;

tree->rtbst_count++;
n->rtbst_data = item;
n->rtbst_link[0] = NULL;
if (dir == 0)
  {
    if (tree->rtbst_root != NULL)
      n->rtbst_link[1] = p;
    else
      n->rtbst_link[1] = NULL;
  }
else /* dir == 1 */
  {
    p->rtbst_rtag = RTBST_CHILD;
    n->rtbst_link[1] = p->rtbst_link[1];
  }
n->rtbst_rtag = RTBST_THREAD;
p->rtbst_link[dir] = n;

return &n->rtbst_data;

This code is included in *Note 377: RTBST item insertion function.


File: libavl.info,  Node: Deleting from an RTBST,  Next: Traversing an RTBST,  Prev: Inserting into an RTBST,  Up: Right-Threaded Binary Search Trees

10.5 Deletion
=============

   Deleting a node from an RTBST can be done using the same ideas as for
other kinds of trees we've seen.  However, as it turns out, a variant of
this usual technique allows for faster code.  In this section, we will
implement the usual method, then the improved version.  The latter is
actually used in `libavl'.

   Here is the outline of the function.  Step 2 is the only part that
varies between versions:

380. <RTBST item deletion function 380> =
void *
rtbst_delete (struct rtbst_table *tree, const void *item)
{
  struct rtbst_node *p;	/* Node to delete. */
  struct rtbst_node *q;	/* Parent of p. */
  int dir;              /* Index into q->rtbst_link[] that leads to p. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1 Find RTBST node to delete:: 381>
  <*Note Step 2 Delete RTBST node left-looking:: 388>
  <*Note Step 3 Finish up after deleting RTBST node:: 382>
}

This code is included in *Note 375: RTBST functions.

   The first step just finds the node to delete.  After it executes, p
is the node to delete and q and dir are set such that
q->rtbst_link[dir] == p.

381. <Step 1: Find RTBST node to delete 381> =
if (tree->rtbst_root == NULL)
  return NULL;

p = tree->rtbst_root;
q = (struct rtbst_node *) &tree->rtbst_root;
dir = 0;
if (p == NULL)
  return NULL;

for (;;)
  {
    int cmp = tree->rtbst_compare (item, p->rtbst_data, tree->rtbst_param);
    if (cmp == 0) 
      break;

    dir = cmp > 0;
    if (dir == 0)
      {
        if (p->rtbst_link[0] == NULL)
          return NULL;
      }
    else /* dir == 1 */
      {
        if (p->rtbst_rtag == RTBST_THREAD)
          return NULL;
      }

    q = p;
    p = p->rtbst_link[dir];
  }
item = p->rtbst_data;

This code is included in *Note 380: RTBST item deletion function.

   The final step is also common.  We just clean up and return:

382. <Step 3: Finish up after deleting RTBST node 382> =
tree->rtbst_alloc->libavl_free (tree->rtbst_alloc, p);
tree->rtbst_count--;
return (void *) item;

This code is included in *Note 380: RTBST item deletion function.

* Menu:

* Right-looking deletion in a RTBST::
* Left-looking deletion in an RTBST::
* Comparing deletion algorithms::


File: libavl.info,  Node: Right-looking deletion in a RTBST,  Next: Left-looking deletion in an RTBST,  Prev: Deleting from an RTBST,  Up: Deleting from an RTBST

10.5.1 Right-Looking Deletion
-----------------------------

   Our usual algorithm for deletion looks at the right subtree of the
node to be deleted, so we call it "right-looking."  The outline for this
kind of deletion is the same as in TBST deletion (*note Deleting from a
TBST::):

383. <Step 2: Delete RTBST node, right-looking 383> =
if (p->rtbst_rtag == RTBST_THREAD)
  {
    if (p->rtbst_link[0] != NULL)
      {
        <*Note Case 1 in right-looking RTBST deletion:: 384>
      }
    else
      {
        <*Note Case 2 in right-looking RTBST deletion:: 385>
      }
  }
else
  {
    struct rtbst_node *r = p->rtbst_link[1];
    if (r->rtbst_link[0] == NULL)
      {
        <*Note Case 3 in right-looking RTBST deletion:: 386>
      }
    else
      {
        <*Note Case 4 in right-looking RTBST deletion:: 387>
      }
  }

   Each of the four cases, presented below, is closely analogous to the
same case in TBST deletion.

Case 1: p has a right thread and a left child
.............................................

   In this case, node p has a right thread and a left child.  As in a
TBST, this means that after deleting p we must update the right thread
in p's former left subtree to point to p's replacement.  The only
difference from <*Note Case 1 in TBST deletion:: 260> is in structure
members:

384. <Case 1 in right-looking RTBST deletion 384> =
struct rtbst_node *t = p->rtbst_link[0];
while (t->rtbst_rtag == RTBST_CHILD)
  t = t->rtbst_link[1];
t->rtbst_link[1] = p->rtbst_link[1];
q->rtbst_link[dir] = p->rtbst_link[0];

This code is included in *Note 383: Step 2 Delete RTBST node
right-looking.

Case 2: p has a right thread and no left child
..............................................

   If node p is a leaf, then there are two subcases, according to
whether p is a left child or a right child of its parent q.  If dir is
0, then p is a left child and the pointer from its parent must be set to
NULL.  If dir is 1, then p is a right child and the link from its
parent must be changed to a thread to its successor.

   In either of these cases we must set q->rtbst_link[dir]: if dir is
0, we set it to NULL, otherwise dir is 1 and we set it to
p->rtbst_link[1].  However, we know that p->rtbst_link[0] is NULL,
because p is a leaf, so we can instead unconditionally assign
p->rtbst_link[dir].  In addition, if dir is 1, then we must tag q's
right link as a thread.

   If q is the pseudo-root, then dir is 0 and everything works out fine
with no need for a special case.

385. <Case 2 in right-looking RTBST deletion 385> =
q->rtbst_link[dir] = p->rtbst_link[dir];
if (dir == 1)
  q->rtbst_rtag = RTBST_THREAD;

This code is included in *Note 383: Step 2 Delete RTBST node
right-looking.

Case 3: p's right child has no left child
.........................................

   Code for this case, where p has a right child r that itself has no
left child, is almost identical to <*Note Case 3 in TBST deletion::
262>.  There is no left tag to copy, but it is still necessary to chase
down the right thread in r's new left subtree (the same as p's former
left subtree):

386. <Case 3 in right-looking RTBST deletion 386> =
r->rtbst_link[0] = p->rtbst_link[0];
if (r->rtbst_link[0] != NULL)
  {
    struct rtbst_node *t = r->rtbst_link[0];
    while (t->rtbst_rtag == RTBST_CHILD)
      t = t->rtbst_link[1];
    t->rtbst_link[1] = r;
  }
q->rtbst_link[dir] = r;

This code is included in *Note 383: Step 2 Delete RTBST node
right-looking.

Case 4: p's right child has a left child
........................................

   Code for case 4, the most general case, is very similar to <*Note
Case 4 in TBST deletion:: 263>.  The only notable difference is in the
subcase where s has a right thread: in that case we just set r's left
link to NULL instead of having to set it up as a thread.

387. <Case 4 in right-looking RTBST deletion 387> =
struct rtbst_node *s;

for (;;)
  {
    s = r->rtbst_link[0];
    if (s->rtbst_link[0] == NULL)
      break;

    r = s;
  }

if (s->rtbst_rtag == RTBST_CHILD)
  r->rtbst_link[0] = s->rtbst_link[1];
else
  r->rtbst_link[0] = NULL;

s->rtbst_link[0] = p->rtbst_link[0];
if (p->rtbst_link[0] != NULL)
  {
    struct rtbst_node *t = p->rtbst_link[0];
    while (t->rtbst_rtag == RTBST_CHILD)
      t = t->rtbst_link[1];
    t->rtbst_link[1] = s;
  }

s->rtbst_link[1] = p->rtbst_link[1];
s->rtbst_rtag = RTBST_CHILD;

q->rtbst_link[dir] = s;

This code is included in *Note 383: Step 2 Delete RTBST node
right-looking.

Exercises:

1. Rewrite <*Note Case 4 in right-looking RTBST deletion:: 387> to
replace the deleted node's rtavl_data by its successor, then delete the
successor, instead of shuffling pointers.  (Refer back to Exercise
5.8-3 for an explanation of why this approach cannot be used in
`libavl'.)


File: libavl.info,  Node: Left-looking deletion in an RTBST,  Next: Comparing deletion algorithms,  Prev: Right-looking deletion in a RTBST,  Up: Deleting from an RTBST

10.5.2 Left-Looking Deletion
----------------------------

   The previous section implemented the "right-looking" form of
deletion used elsewhere in `libavl'.  Compared to deletion in a fully
threaded binary tree, the benefits to using an RTBST with this kind of
deletion are minimal:

   * Cases 1 and 2 are similar code in both TBST and RTBST deletion.

   * Case 3 in an RTBST avoids one tag copy required in TBST deletion.

   * One subcase of case 4 in an RTBST avoids one tag assignment
     required in the same subcase of TBST deletion.

   This is hardly worth it.  We saved at most one assignment per call.
We need something better if it's ever going to be worthwhile to use
right-threaded trees.

   Fortunately, there is a way that we can save a little more.  This is
by changing our right-looking deletion into left-looking deletion, by
switching the use of left and right children in the algorithm.  In a
BST or TBST, this symmetrical change in the algorithm would have no
effect, because the BST and TBST node structures are themselves
symmetric.  But in an asymmetric RTBST even a symmetric change can have
a significant effect on an algorithm, as we'll see.

   The cases for left-looking deletion are outlined in the same way as
for right-looking deletion:

388. <Step 2: Delete RTBST node, left-looking 388> =
if (p->rtbst_link[0] == NULL)
  {
    if (p->rtbst_rtag == RTBST_CHILD)
      {
        <*Note Case 1 in left-looking RTBST deletion:: 389>
      }
    else
      {
        <*Note Case 2 in left-looking RTBST deletion:: 390>
      }
  }
else
  {
    struct rtbst_node *r = p->rtbst_link[0];
    if (r->rtbst_rtag == RTBST_THREAD)
      {
        <*Note Case 3 in left-looking RTBST deletion:: 391>
      }
    else
      {
        <*Note Case 4 in left-looking RTBST deletion:: 392>
      }
  }

This code is included in *Note 380: RTBST item deletion function.

Case 1: p has a right child but no left child
.............................................

   If the node to delete p has a right child but no left child, we can
just replace it by its right child.  There is no right thread to update
in p's left subtree because p has no left child, and there is no left
thread to update because a right-threaded tree has no left threads.

   The deletion looks like this if p's right child is designated x:

                               |
                               p        |
                                \       x
                                 x  =>  ^
                                 ^     a b
                                a b
389. <Case 1 in left-looking RTBST deletion 389> =
q->rtbst_link[dir] = p->rtbst_link[1];

This code is included in *Note 388: Step 2 Delete RTBST node
left-looking.

Case 2: p has a right thread and no left child
..............................................

   This case is analogous to case 2 in right-looking deletion covered
earlier.  The same discussion applies.

390. <Case 2 in left-looking RTBST deletion 390> =
q->rtbst_link[dir] = p->rtbst_link[dir];
if (dir == 1)
  q->rtbst_rtag = RTBST_THREAD;

This code is included in *Note 388: Step 2 Delete RTBST node
left-looking.

Case 3: p's left child has a right thread
.........................................

   If p has a left child r that itself has a right thread, then we
replace p by r.  Node r receives p's former right link, as shown here:

                                   |
                                   p       |
                               _.-' \      r
                              r      b =>  ^
                             / \          a b
                            a   [p]
 
 There is no need to fiddle with threads.  If r has a right thread then
it gets replaced by p's right child or thread anyhow.  Any right thread
within r's left subtree either points within that subtree or to r.
Finally, r's right subtree cannot cause problems.

391. <Case 3 in left-looking RTBST deletion 391> =
r->rtbst_link[1] = p->rtbst_link[1];
r->rtbst_rtag = p->rtbst_rtag;
q->rtbst_link[dir] = r;

This code is included in *Note 388: Step 2 Delete RTBST node
left-looking.

Case 4: p's left child has a right child
........................................

   The final case handles deletion of a node p with a left child r that
in turn has a right child.  The code here follows the same pattern as
<*Note Case 4 in TBST deletion:: 263> (see the discussion there for
details).  The first step is to find the predecessor s of node p:

392. <Case 4 in left-looking RTBST deletion 392> =
struct rtbst_node *s;

for (;;)
  {
    s = r->rtbst_link[1];
    if (s->rtbst_rtag == RTBST_THREAD)
      break;

    r = s;
  }

See also *Note 393: Case 4 in left-looking RTBST deletion-2 and *Note
394: Case 4 in left-looking RTBST deletion-3.
This code is included in *Note 388: Step 2 Delete RTBST node
left-looking.

   Next, we update r, handling two subcases depending on whether s has
a left child:

393. <Case 4 in left-looking RTBST deletion 392> +=
if (s->rtbst_link[0] != NULL)
  r->rtbst_link[1] = s->rtbst_link[0];
else
  {
    r->rtbst_link[1] = s;
    r->rtbst_rtag = RTBST_THREAD;
  }

   The final step is to copy p's fields into s, then set q's child
pointer to point to s instead of p.  There is no need to chase down any
threads.

394. <Case 4 in left-looking RTBST deletion 392> +=
s->rtbst_link[0] = p->rtbst_link[0];
s->rtbst_link[1] = p->rtbst_link[1];
s->rtbst_rtag = p->rtbst_rtag;

q->rtbst_link[dir] = s;

Exercises:

1. Rewrite <*Note Case 4 in left-looking RTBST deletion:: 392> to
replace the deleted node's rtavl_data by its predecessor, then delete
the predecessor, instead of shuffling pointers.  (Refer back to
Exercise 5.8-3 for an explanation of why this approach cannot be used
in `libavl'.)


File: libavl.info,  Node: Comparing deletion algorithms,  Prev: Left-looking deletion in an RTBST,  Up: Deleting from an RTBST

10.5.3 Aside: Comparison of Deletion Algorithms
-----------------------------------------------

   This book has presented algorithms for deletion from BSTs, TBSTs, and
RTBSTs.  In fact, we implemented two algorithms for RTBSTs.  Each of
these four algorithms has slightly different performance
characteristics.  The following table summarizes the behavior of all of
the cases in these algorithms.  Each cell describes the actions that
take place: "link" is the number of link fields set, "tag" the number
of tag fields set, and "succ/pred" the number of general successor or
predecessors found during the case.

                 BST*           TBST           Right-Looking  Left-Looking
                                               TBST           TBST
                                                               
     Case 1      1 link         2 links        2 links        1 link
                                1 succ/pred    1 succ/pred    
                                                              
     Case 2      1 link         1 link         1 link         1 link
                                1 tag          1 tag          1 tag
                                                              
     Case 3      2 links        3 links        3 links        2 links
                                1 tag                         1 tag
                                1 succ/pred    1 succ/pred    
                                                              
     Case 4      4 links        5 links        5 links        4 links
     subcase 1                  2 tags         1 tag          1 tag
                 1 succ/pred    2 succ/pred    2 succ/pred    1 succ/pred
                                                              
     Case 4      4 links        5 links        5 links        4 links
     subcase 2                  2 tags         1 tag          1 tag
                 1 succ/pred    2 succ/pred    2 succ/pred    1 succ/pred
                                                              

     * Listed cases 1 and 2 both correspond to BST deletion case 1, and
     listed cases 3 and 4 to BST deletion cases 2 and 3, respectively.
     BST deletion does not have any subcases in its case 3 (listed case
     4), so it also saves a test to distinguish subcases.

   As you can see, the penalty for left-looking deletion from a RTBST,
compared to a plain BST, is at most one tag assignment in any given
case, except for the need to distinguish subcases of case 4.  In this
sense at least, left-looking deletion from an RTBST is considerably
faster than deletion from a TBST or right-looking deletion from a
RTBST.  This means that it can indeed be worthwhile to implement
right-threaded trees instead of BSTs or TBSTs.


File: libavl.info,  Node: Traversing an RTBST,  Next: Copying an RTBST,  Prev: Deleting from an RTBST,  Up: Right-Threaded Binary Search Trees

10.6 Traversal
==============

   Traversal in an RTBST is unusual due to its asymmetry.  Moving from
smaller nodes to larger nodes is easy: we do it with the same algorithm
used in a TBST.  Moving the other way is more difficult and inefficient
besides: we have neither a stack of parent nodes to fall back on nor
left threads to short-circuit.

   RTBSTs use the same traversal structure as TBSTs, so we can reuse
some of the functions from TBST traversers.  We also get a few directly
from the implementations for BSTs.  Other than that, everything has to
be written anew here:

395. <RTBST traversal functions 395> =
<*Note TBST traverser null initializer:: 269>
<*Note RTBST traverser first initializer:: 396>
<*Note RTBST traverser last initializer:: 397>
<*Note RTBST traverser search initializer:: 398>
<*Note TBST traverser insertion initializer:: 273>
<*Note TBST traverser copy initializer:: 274>
<*Note RTBST traverser advance function:: 399>
<*Note RTBST traverser back up function:: 400>
<*Note BST traverser current item function:: 74>
<*Note BST traverser replacement function:: 75>

This code is included in *Note 375: RTBST functions, *Note 418: RTAVL
functions, and *Note 455: RTRB functions.

* Menu:

* RTBST Traverser First Initialization::
* RTBST Traverser Last Initialization::
* RTBST Traverser Find Initialization::
* RTBST Traverser Advancing::
* RTBST Traverser Retreating::


File: libavl.info,  Node: RTBST Traverser First Initialization,  Next: RTBST Traverser Last Initialization,  Prev: Traversing an RTBST,  Up: Traversing an RTBST

10.6.1 Starting at the First Node
---------------------------------

   To find the first (least) item in the tree, we just descend all the
way to the left, as usual.  In an RTBST, as in a BST, this involves
checking for null pointers.

396. <RTBST traverser first initializer 396> =
void *
rtbst_t_first (struct rtbst_traverser *trav, struct rtbst_table *tree)
{
  assert (tree != NULL && trav != NULL);

  trav->rtbst_table = tree;
  trav->rtbst_node = tree->rtbst_root;
  if (trav->rtbst_node != NULL)
    {
      while (trav->rtbst_node->rtbst_link[0] != NULL)
        trav->rtbst_node = trav->rtbst_node->rtbst_link[0];
      return trav->rtbst_node->rtbst_data;
    }
  else
    return NULL;
}

This code is included in *Note 395: RTBST traversal functions.


File: libavl.info,  Node: RTBST Traverser Last Initialization,  Next: RTBST Traverser Find Initialization,  Prev: RTBST Traverser First Initialization,  Up: Traversing an RTBST

10.6.2 Starting at the Last Node
--------------------------------

   To start at the last (greatest) item in the tree, we descend all the
way to the right.  In an RTBST, as in a TBST, this involves checking for
thread links.

397. <RTBST traverser last initializer 397> =
void *
rtbst_t_last (struct rtbst_traverser *trav, struct rtbst_table *tree)
{
  assert (tree != NULL && trav != NULL);

  trav->rtbst_table = tree;
  trav->rtbst_node = tree->rtbst_root;
  if (trav->rtbst_node != NULL)
    {
      while (trav->rtbst_node->rtbst_rtag == RTBST_CHILD)
        trav->rtbst_node = trav->rtbst_node->rtbst_link[1];
      return trav->rtbst_node->rtbst_data;
    }
  else
    return NULL;
}

This code is included in *Note 395: RTBST traversal functions.

