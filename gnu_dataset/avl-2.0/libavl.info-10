This is libavl.info, produced by makeinfo version 4.0b from libavl.texi.


File: libavl.info,  Node: Threaded AVL Trees,  Next: Threaded Red-Black Trees,  Prev: Threaded Binary Search Trees,  Up: Top

8 Threaded AVL Trees
********************

   The previous chapter introduced a new concept in BSTs, the idea of
threads.  Threads allowed us to simplify traversals and eliminate the
use of stacks.  On the other hand, threaded trees can still grow tall
enough that they reduce the program's performance unacceptably, the
problem that balanced trees were meant to solve.  Ideally, we'd like to
add threads to balanced trees, to produce threaded balanced trees that
combine the best of both worlds.

   We can do this, and it's not even very difficult.  This chapter will
show how to add threads to AVL trees.  The next will show how to add
them to red-black trees.

   Here's an outline of the table implementation for threaded AVL or
"TAVL" trees that we'll develop in this chapter.  Note the usage of
prefix tavl_ for these functions.

297. <tavl.h 297> =
<*Note License:: 1>
#ifndef TAVL_H
#define TAVL_H 1

#include <stddef.h>

<*Note Table types:: 14>
<*Note BST maximum height:: 28>
<*Note TBST table structure:: 250>
<*Note TAVL node structure:: 299>
<*Note TBST traverser structure:: 267>
<*Note Table function prototypes:: 15>

#endif /* tavl.h */

298. <tavl.c 298> =
<*Note License:: 1>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "tavl.h"

<*Note TAVL functions:: 300>

* Menu:

* TAVL Data Types::
* TBST Rotations::
* TAVL Operations::
* Inserting into a TAVL tree::
* Deleting from a TAVL tree::
* Copying a TAVL Tree::
* Testing TAVL Trees::


File: libavl.info,  Node: TAVL Data Types,  Next: TBST Rotations,  Prev: Threaded AVL Trees,  Up: Threaded AVL Trees

8.1 Data Types
==============

   The TAVL node structure takes the basic fields for a BST and adds a
balance factor for AVL balancing and a pair of tag fields to allow for
threading.

299. <TAVL node structure 299> =
/* Characterizes a link as a child pointer or a thread. */
enum tavl_tag
  {
    TAVL_CHILD,                     /* Child pointer. */
    TAVL_THREAD                     /* Thread. */
  };

/* An TAVL tree node. */
struct tavl_node
  {
    struct tavl_node *tavl_link[2]; /* Subtrees. */
    void *tavl_data;                /* Pointer to data. */
    unsigned char tavl_tag[2];      /* Tag fields. */
    signed char tavl_balance;       /* Balance factor. */
  };

This code is included in *Note 297: tavlh.

Exercises:

1. struct avl_node contains three pointer members and a single
character member, whereas struct tavl_node additionally contains an
array of two characters.  Is struct tavl_node necessarily larger than
struct avl_node?


File: libavl.info,  Node: TBST Rotations,  Next: TAVL Operations,  Prev: TAVL Data Types,  Up: Threaded AVL Trees

8.2 Rotations
=============

   Rotations are just as useful in threaded BSTs as they are in
unthreaded ones.  We do need to re-examine the idea, though, to see how
the presence of threads affect rotations.

   A generic rotation looks like this diagram taken from *Note BST
Rotations:::

                               |        |
                               Y        X
                              / \      / \
                             X   c    a   Y
                             ^            ^
                            a b          b c
 
 Any of the subtrees labeled a, b, and c may be in fact threads.  In
the most extreme case, all of them are threads, and the rotation looks
like this:

                               Y         X
                           _.-' \       / `._
                          X      []    []    Y
                         / \               _' \
                        []  [Y]           [X]  []
 
 As you can see, the thread from X to Y, represented by subtree b,
reverses direction and becomes a thread from Y to X following a right
rotation.  This has to be handled as a special case in code for
rotation.  See Exercise 1 for details.

On the other hand, there is no need to do anything special with threads
originating in subtrees of a rotated node.  This is a direct
consequence of the locality and order-preserving properties of a
rotation (*note BST Rotations::).  Here's an example diagram to
demonstrate.  Note in particular that the threads from A, B, and C
point to the same nodes in both trees:

                          Y                  X
                  ___..--' `._           _.-' `--..___
                 X            C         A             Y
             _.-' `._       _' \       / \        _.-' `._
            A        B     [Y]  []    []  [X]    B        C
           / \     _' \                        _' \     _' \
          []  [X] [X]  [Y]                    [X]  [Y] [Y]  []
 
   Exercises:

1. Write functions for right and left rotations in threaded BSTs,
analogous to those for unthreaded BSTs developed in Exercise 5.3-2.


File: libavl.info,  Node: TAVL Operations,  Next: Inserting into a TAVL tree,  Prev: TBST Rotations,  Up: Threaded AVL Trees

8.3 Operations
==============

   Now we'll implement all the usual operations for TAVL trees.  We can
reuse everything from TBSTs except insertion, deletion, and copy
functions.  Most of the copy function code will in fact be reused also.
Here's the outline:

300. <TAVL functions 300> =
<*Note TBST creation function:: 252>
<*Note TBST search function:: 253>
<*Note TAVL item insertion function:: 301>
<*Note Table insertion convenience functions:: 592>
<*Note TAVL item deletion function:: 311>
<*Note TBST traversal functions:: 268>
<*Note TAVL copy function:: 329>
<*Note TBST destruction function:: 281>
<*Note Default memory allocation functions:: 6>
<*Note Table assertion functions:: 594>

This code is included in *Note 298: tavlc.


File: libavl.info,  Node: Inserting into a TAVL tree,  Next: Deleting from a TAVL tree,  Prev: TAVL Operations,  Up: Threaded AVL Trees

8.4 Insertion
=============

   Insertion into an AVL tree is not complicated much by the need to
update threads.  The outline is the same as before, and the code for
step 3 and the local variable declarations can be reused entirely:

301. <TAVL item insertion function 301> =
void **
tavl_probe (struct tavl_table *tree, void *item)
{
  <*Note |avl_probe()| local variables:: 147>

  assert (tree != NULL && item != NULL);

  <*Note Step 1 Search TAVL tree for insertion point:: 302>
  <*Note Step 2 Insert TAVL node:: 303>
  <*Note Step 3 Update balance factors after AVL insertion:: 150>
  <*Note Step 4 Rebalance after TAVL insertion:: 304>
}

This code is included in *Note 300: TAVL functions.

* Menu:

* Steps 1 and 2 in TAVL Insertion::
* Rebalancing TAVL trees::
* TAVL insertion symmetric case::


File: libavl.info,  Node: Steps 1 and 2 in TAVL Insertion,  Next: Rebalancing TAVL trees,  Prev: Inserting into a TAVL tree,  Up: Inserting into a TAVL tree

8.4.1 Steps 1 and 2: Search and Insert
--------------------------------------

   The first step is a lot like the unthreaded AVL version in <*Note
Step 1 Search AVL tree for insertion point:: 148>.  There is an
unfortunate special case for an empty tree, because a null pointer for
tavl_root indicates an empty tree but in a nonempty tree we must seek a
thread link.  After we're done, p, not q as before, is the node below
which a new node should be inserted, because the test for stepping
outside the binary tree now comes before advancing p.

302. <Step 1: Search TAVL tree for insertion point 302> =
z = (struct tavl_node *) &tree->tavl_root;
y = tree->tavl_root;
if (y != NULL)
  {
    for (q = z, p = y; ; q = p, p = p->tavl_link[dir])
      {
        int cmp = tree->tavl_compare (item, p->tavl_data, tree->tavl_param);
        if (cmp == 0)
          return &p->tavl_data;

        if (p->tavl_balance != 0)
          z = q, y = p, k = 0;
        da[k++] = dir = cmp > 0;

        if (p->tavl_tag[dir] == TAVL_THREAD)
          break;
      }
  }
else
  {
    p = z;
    dir = 0;
  }

This code is included in *Note 301: TAVL item insertion function.

   The insertion adds to the TBST code by setting the balance factor of
the new node and handling the first insertion into an empty tree as a
special case:

303. <Step 2: Insert TAVL node 303> =
<*Note Step 2 Insert TBST node:: 256>
n->tavl_balance = 0;
if (tree->tavl_root == n)
  return &n->tavl_data;

This code is included in *Note 301: TAVL item insertion function.


File: libavl.info,  Node: Rebalancing TAVL trees,  Next: TAVL insertion symmetric case,  Prev: Steps 1 and 2 in TAVL Insertion,  Up: Inserting into a TAVL tree

8.4.2 Step 4: Rebalance
-----------------------

   Now we're finally to the interesting part, the rebalancing step.  We
can tell whether rebalancing is necessary based on the balance factor
of y, the same as in unthreaded AVL insertion:

304. <Step 4: Rebalance after TAVL insertion 304> =
if (y->tavl_balance == -2)
  {
    <*Note Rebalance TAVL tree after insertion in left subtree:: 305>
  }
else if (y->tavl_balance == +2)
  {
    <*Note Rebalance TAVL tree after insertion in right subtree:: 308>
  }
else
  return &n->tavl_data;
z->tavl_link[y != z->tavl_link[0]] = w;

return &n->tavl_data;

This code is included in *Note 301: TAVL item insertion function.

   We will examine the case of insertion in the left subtree of y, the
node at which we must rebalance.  We take x as y's child on the side of
the new node, then, as for unthreaded AVL insertion, we distinguish two
cases based on the balance factor of x:

305. <Rebalance TAVL tree after insertion in left subtree 305> =
struct tavl_node *x = y->tavl_link[0];
if (x->tavl_balance == -1)
  {
    <*Note Rebalance for |-| balance factor in TAVL insertion in left subtree:: 306>
  } 
else
  {
    <*Note Rebalance for |+| balance factor in TAVL insertion in left subtree:: 307>
  }

This code is included in *Note 304: Step 4 Rebalance after TAVL
insertion.

Case 1: x has - balance factor
..............................

   As for unthreaded insertion, we rotate right at y (*note Rebalancing
AVL trees::).  Notice the resemblance of the following code to
rotate_right() in the solution to Exercise 9.2-1.

306. <Rebalance for - balance factor in TAVL insertion in left subtree 306> =
w = x;
if (x->tavl_tag[1] == TAVL_THREAD)
  {
    x->tavl_tag[1] = TAVL_CHILD;
    y->tavl_tag[0] = TAVL_THREAD;
    y->tavl_link[0] = x;
  }
else
  y->tavl_link[0] = x->tavl_link[1];
x->tavl_link[1] = y;
x->tavl_balance = y->tavl_balance = 0;

This code is included in *Note 305: Rebalance TAVL tree after insertion
in left subtree.

Case 2: x has + balance factor
..............................

   When x has a + balance factor, we perform the transformation shown
below, which consists of a left rotation at x followed by a right
rotation at y.  This is the same transformation used in unthreaded
insertion:

                                 |
                                 y           |
                               <-->          w
                          __.-'    \        <0>
                          x         d      /   \
                         <+>          =>  x     y
                        /   \             ^     ^
                       a     w           a b   c d
                             ^
                            b c
 
 We could simply apply the standard code from Exercise 9.2-1 in each
rotation (see Exercise 1), but it is just as straightforward to do both
of the rotations together, then clean up any threads.  Subtrees a and d
cannot cause thread-related trouble, because they are not disturbed
during the transformation: a remains x's left child and d remains y's
right child.  The children of w, subtrees b and c, do require handling.
If subtree b is a thread, then after the rotation and before fix-up
x's right link points to itself, and, similarly, if c is a thread then
y's left link points to itself.  These links must be changed into
threads to w instead, and w's links must be tagged as child pointers.

If both b and c are threads then the transformation looks like the
diagram below, showing pre-rebalancing and post-rebalancing,
post-fix-up views.  The AVL balance rule implies that if b and c are
threads then a and d are also:

                               |
                               y                |
                             <-->               w
                   ___...---'    \             <0>
                   x              []       _.-'   `._
                  <+>                =>   x          y
                 /   `._                 / \       _' \
                []      w               []  [w]   [w]  []
                      _' \
                     [x]  [y]
 
 The required code is heavily based on the corresponding code for
unthreaded AVL rebalancing:

307. <Rebalance for + balance factor in TAVL insertion in left subtree 307> =
<*Note Rotate left at |x| then right at |y| in AVL tree:: 156>
if (w->tavl_tag[0] == TAVL_THREAD)
  {
    x->tavl_tag[1] = TAVL_THREAD;
    x->tavl_link[1] = w;
    w->tavl_tag[0] = TAVL_CHILD;
  }
if (w->tavl_tag[1] == TAVL_THREAD)
  {
    y->tavl_tag[0] = TAVL_THREAD;
    y->tavl_link[0] = w;
    w->tavl_tag[1] = TAVL_CHILD;
  }

This code is included in *Note 305: Rebalance TAVL tree after insertion
in left subtree, *Note 324: Rebalance for |+| balance factor after TAVL
deletion in right subtree, and *Note 667: Steps 3 and 4 Symmetric case
in TAVL deletion with stack.

Exercises:

1. Rewrite <*Note Rebalance for |+| balance factor in TAVL insertion in
left subtree:: 307> in terms of the routines from Exercise 9.2-1.


File: libavl.info,  Node: TAVL insertion symmetric case,  Prev: Rebalancing TAVL trees,  Up: Inserting into a TAVL tree

8.4.3 Symmetric Case
--------------------

   Here is the corresponding code for the case where insertion occurs in
the right subtree of y.

308. <Rebalance TAVL tree after insertion in right subtree 308> =
struct tavl_node *x = y->tavl_link[1];
if (x->tavl_balance == +1)
  {
    <*Note Rebalance for |+| balance factor in TAVL insertion in right subtree:: 309>
  } 
else
  {
    <*Note Rebalance for |-| balance factor in TAVL insertion in right subtree:: 310>
  }

This code is included in *Note 304: Step 4 Rebalance after TAVL
insertion.

309. <Rebalance for + balance factor in TAVL insertion in right subtree 309> =
w = x;
if (x->tavl_tag[0] == TAVL_THREAD)
  {
    x->tavl_tag[0] = TAVL_CHILD;
    y->tavl_tag[1] = TAVL_THREAD;
    y->tavl_link[1] = x;
  }
else
  y->tavl_link[1] = x->tavl_link[0];
x->tavl_link[0] = y;
x->tavl_balance = y->tavl_balance = 0;

This code is included in *Note 308: Rebalance TAVL tree after insertion
in right subtree.

310. <Rebalance for - balance factor in TAVL insertion in right subtree 310> =
<*Note Rotate right at |x| then left at |y| in AVL tree:: 159>
if (w->tavl_tag[0] == TAVL_THREAD)
  {
    y->tavl_tag[1] = TAVL_THREAD;
    y->tavl_link[1] = w;
    w->tavl_tag[0] = TAVL_CHILD;
  }
if (w->tavl_tag[1] == TAVL_THREAD)
  {
    x->tavl_tag[0] = TAVL_THREAD;
    x->tavl_link[0] = w;
    w->tavl_tag[1] = TAVL_CHILD;
  }

This code is included in *Note 308: Rebalance TAVL tree after insertion
in right subtree, *Note 320: Rebalance for |-| balance factor after
TAVL deletion in left subtree, and *Note 666: Step 4 Rebalance after
TAVL deletion with stack.


File: libavl.info,  Node: Deleting from a TAVL tree,  Next: Copying a TAVL Tree,  Prev: Inserting into a TAVL tree,  Up: Threaded AVL Trees

8.5 Deletion
============

   Deletion from a TAVL tree can be accomplished by combining our
knowledge about AVL trees and threaded trees.  From one perspective, we
add rebalancing to TBST deletion.  From the other perspective, we add
thread handling to AVL tree deletion.

   The function outline is about the same as usual.  We do add a helper
function for finding the parent of a TAVL node:

311. <TAVL item deletion function 311> =
<*Note Find parent of a TBST node:: 327>

void *
tavl_delete (struct tavl_table *tree, const void *item)
{
  struct tavl_node *p; /* Traverses tree to find node to delete. */
  struct tavl_node *q; /* Parent of p. */
  int dir;             /* Index into q->tavl_link[] to get p. */
  int cmp;             /* Result of comparison between item and p. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1 Search TAVL tree for item to delete:: 312>
  <*Note Step 2 Delete item from TAVL tree:: 313>
  <*Note Steps 3 and 4 Update balance factors and rebalance after TAVL deletion:: 318>
}

This code is included in *Note 300: TAVL functions.

* Menu:

* Deleting a TAVL node step 1 - Search::
* Deleting a TAVL node step 2 - Delete::
* Deleting a TAVL node step 3 - Update::
* Deleting a TAVL node step 4 - Rebalance::
* TAVL deletion symmetric case::
* Finding the Parent of a TBST Node::


File: libavl.info,  Node: Deleting a TAVL node step 1 - Search,  Next: Deleting a TAVL node step 2 - Delete,  Prev: Deleting from a TAVL tree,  Up: Deleting from a TAVL tree

8.5.1 Step 1: Search
--------------------

   We use p to search down the tree and keep track of p's parent with
q.  We keep the invariant at the beginning of the loop here that
q->tavl_link[dir] == p.  As the final step, we record the item deleted
and update the tree's item count.

312. <Step 1: Search TAVL tree for item to delete 312> =
if (tree->tavl_root == NULL)
  return NULL;

p = (struct tavl_node *) &tree->tavl_root;
for (cmp = -1; cmp != 0;
     cmp = tree->tavl_compare (item, p->tavl_data, tree->tavl_param))
  {
    dir = cmp > 0;

    q = p;
    if (p->tavl_tag[dir] == TAVL_THREAD)
      return NULL;
    p = p->tavl_link[dir];
  }
item = p->tavl_data;

This code is included in *Note 311: TAVL item deletion function and
*Note 670: TRB item deletion function without stack.


File: libavl.info,  Node: Deleting a TAVL node step 2 - Delete,  Next: Deleting a TAVL node step 3 - Update,  Prev: Deleting a TAVL node step 1 - Search,  Up: Deleting from a TAVL tree

8.5.2 Step 2: Delete
--------------------

   The cases for deletion are the same as for a TBST (*note Deleting
from a TBST::).  The difference is that we have to copy around balance
factors and keep track of where balancing needs to start.  After the
deletion, q is the node at which balance factors must be updated and
possible rebalancing occurs and dir is the side of q from which the
node was deleted.  For cases 1 and 2, q need not change from its
current value as the parent of the deleted node.  For cases 3 and 4, q
will need to be changed.

313. <Step 2: Delete item from TAVL tree 313> =
if (p->tavl_tag[1] == TAVL_THREAD)
  {
    if (p->tavl_tag[0] == TAVL_CHILD)
      {
        <*Note Case 1 in TAVL deletion:: 314>
      }
    else
      {
        <*Note Case 2 in TAVL deletion:: 315>
      }
  }
else
  {
    struct tavl_node *r = p->tavl_link[1];
    if (r->tavl_tag[0] == TAVL_THREAD)
      {
        <*Note Case 3 in TAVL deletion:: 316>
      }
    else
      {
        <*Note Case 4 in TAVL deletion:: 317>
      }
  }

tree->tavl_alloc->libavl_free (tree->tavl_alloc, p);

This code is included in *Note 311: TAVL item deletion function.

Case 1: p has a right thread and a left child
.............................................

   If p has a right thread and a left child, then we replace it by its
left child.  Rebalancing must begin right above p, which is already set
as q.  There's no need to change the TBST code:

314. <Case 1 in TAVL deletion 314> =
<*Note Case 1 in TBST deletion:: 260>

This code is included in *Note 313: Step 2 Delete item from TAVL tree.

Case 2: p has a right thread and a left thread
..............................................

   If p is a leaf, then we change q's pointer to p into a thread.
Again, rebalancing must begin at the node that's already set up as q
and there's no need to change the TBST code:

315. <Case 2 in TAVL deletion 315> =
<*Note Case 2 in TBST deletion:: 261>

This code is included in *Note 313: Step 2 Delete item from TAVL tree.

Case 3: p's right child has a left thread
.........................................

   If p has a right child r, which in turn has no left child, then we
move r in place of p.  In this case r, having replaced p, acquires p's
former balance factor and rebalancing must start from there.  The
deletion in this case is always on the right side of the node.

316. <Case 3 in TAVL deletion 316> =
<*Note Case 3 in TBST deletion:: 262>
r->tavl_balance = p->tavl_balance;
q = r;
dir = 1;

This code is included in *Note 313: Step 2 Delete item from TAVL tree.

Case 4: p's right child has a left child
........................................

   The most general case comes up when p's right child has a left child,
where we replace p by its successor s.  In that case s acquires p's
former balance factor and rebalancing begins from s's parent r.  Node s
is always the left child of r.

317. <Case 4 in TAVL deletion 317> =
<*Note Case 4 in TBST deletion:: 263>
s->tavl_balance = p->tavl_balance;
q = r;
dir = 0;

This code is included in *Note 313: Step 2 Delete item from TAVL tree.

Exercises:

1. Rewrite <*Note Case 4 in TAVL deletion:: 317> to replace the deleted
node's tavl_data by its successor, then delete the successor, instead of
shuffling pointers.  (Refer back to Exercise 5.8-3 for an explanation
of why this approach cannot be used in `libavl'.)


File: libavl.info,  Node: Deleting a TAVL node step 3 - Update,  Next: Deleting a TAVL node step 4 - Rebalance,  Prev: Deleting a TAVL node step 2 - Delete,  Up: Deleting from a TAVL tree

8.5.3 Step 3: Update Balance Factors
------------------------------------

   Rebalancing begins from node q, from whose side dir a node was
deleted.  Node q at the beginning of the iteration becomes node y, the
root of the balance factor update and rebalancing, and dir at the
beginning of the iteration is used to separate the left-side and
right-side deletion cases.

   The loop also updates the values of q and dir for rebalancing and
for use in the next iteration of the loop, if any.  These new values can
only be assigned after the old ones are no longer needed, but must be
assigned before any rebalancing so that the parent link to y can be
changed.  For q this is after y receives q's old value and before
rebalancing.  For dir, it is after the branch point that separates the
left-side and right-side deletion cases, so the dir assignment is
duplicated in each branch.  The code used to update q is discussed
later.

318. <Steps 3 and 4: Update balance factors and rebalance after TAVL deletion 318> =
while (q != (struct tavl_node *) &tree->tavl_root)
  {
    struct tavl_node *y = q;

    q = find_parent (tree, y);

    if (dir == 0)
      {
        dir = q->tavl_link[0] != y;
        y->tavl_balance++;
        if (y->tavl_balance == +1)
          break;
        else if (y->tavl_balance == +2)
          {
            <*Note Step 4 Rebalance after TAVL deletion:: 319>
          }
      }
    else
      {
        <*Note Steps 3 and 4 Symmetric case in TAVL deletion:: 323>
      }
  }

tree->tavl_count--;
return (void *) item;

This code is included in *Note 311: TAVL item deletion function.


File: libavl.info,  Node: Deleting a TAVL node step 4 - Rebalance,  Next: TAVL deletion symmetric case,  Prev: Deleting a TAVL node step 3 - Update,  Up: Deleting from a TAVL tree

8.5.4 Step 4: Rebalance
-----------------------

   Rebalancing after deletion in a TAVL tree divides into three cases.
The first of these is analogous to case 1 in unthreaded AVL deletion,
the other two to case 2 (*note Inserting into a TBST::).  The cases are
distinguished, as usual, based on the balance factor of right child x
of the node y at which rebalancing occurs:

319. <Step 4: Rebalance after TAVL deletion 319> =
struct tavl_node *x = y->tavl_link[1];

assert (x != NULL);
if (x->tavl_balance == -1)
  {
    <*Note Rebalance for |-| balance factor after TAVL deletion in left subtree:: 320>
  }
else
  {
    q->tavl_link[dir] = x;

    if (x->tavl_balance == 0)
      {
        <*Note Rebalance for 0 balance factor after TAVL deletion in left subtree:: 321>
        break;
      }
    else /* x->tavl_balance == +1 */
      {
        <*Note Rebalance for |+| balance factor after TAVL deletion in left subtree:: 322>
      }
  }

This code is included in *Note 318: Steps 3 and 4 Update balance
factors and rebalance after TAVL deletion.

Case 1: x has - balance factor
..............................

   This case is just like case 2 in TAVL insertion.  In fact, we can
even reuse the code:

320. <Rebalance for - balance factor after TAVL deletion in left subtree 320> =
struct tavl_node *w;

<*Note Rebalance for |-| balance factor in TAVL insertion in right subtree:: 310>
q->tavl_link[dir] = w;

This code is included in *Note 319: Step 4 Rebalance after TAVL
deletion.

Case 2: x has 0 balance factor
..............................

   If x has a 0 balance factor, then we perform a left rotation at y.
The transformation looks like this, with subtree heights listed under
their labels:

                          |                     |
                          s                     r
                        <++>                   <->
                      _'    `_             _.-'   \
                      a        r    =>     s       c
                     h-1      <0>         <+>      h
                             /   \      _'   \
                            b     c     a     b
                            h     h    h-1    h
 
 Subtree b is taller than subtree a, so even if h takes its minimum
value of 1, then subtree b has height h == 1 and, therefore, it must
contain at least one node and there is no need to do any checking for
threads.  The code is simple:

321. <Rebalance for 0 balance factor after TAVL deletion in left subtree 321> =
y->tavl_link[1] = x->tavl_link[0];
x->tavl_link[0] = y;
x->tavl_balance = -1;
y->tavl_balance = +1;

This code is included in *Note 319: Step 4 Rebalance after TAVL
deletion and *Note 443: Rebalance for 0 balance factor after left-side
RTAVL deletion.

Case 3: x has + balance factor
..............................

   If x has a + balance factor, we perform a left rotation at y, same
as for case 2, and the transformation looks like this:

                        |                        |
                        s                        s
                      <++>                      <0>
                    _'    `._             __..-'   \
                    a         r    =>     r         c
                   h-1       <+>         <0>        h
                           _'   \      _'   \
                           b     c     a      b
                          h-1    h    h-1    h-1

One difference from case 2 is in the resulting balance factors.  The
other is that if h == 1, then subtrees a and b have height h - 1 == 0,
so a and b may actually be threads.  In that case, the transformation
must be done this way:

                 |
                 s                              |
               <++>                             r
              /    `._                         <0>
             []        r                 __..-'   `._
                      <+>          =>    s            c
                    _'   `._            <0>          <0>
                   [s]       c         /   \       _'   \
                            <0>       []    [r]   [r]    []
                          _'   \
                         [r]    []

This code handles both possibilities:

322. <Rebalance for + balance factor after TAVL deletion in left subtree 322> =
if (x->tavl_tag[0] == TAVL_CHILD)
  y->tavl_link[1] = x->tavl_link[0];
else
  {
    y->tavl_tag[1] = TAVL_THREAD;
    x->tavl_tag[0] = TAVL_CHILD;
  }
x->tavl_link[0] = y;  
y->tavl_balance = x->tavl_balance = 0;

This code is included in *Note 319: Step 4 Rebalance after TAVL
deletion.


File: libavl.info,  Node: TAVL deletion symmetric case,  Next: Finding the Parent of a TBST Node,  Prev: Deleting a TAVL node step 4 - Rebalance,  Up: Deleting from a TAVL tree

8.5.5 Symmetric Case
--------------------

   Here's the code for the symmetric case.

323. <Steps 3 and 4: Symmetric case in TAVL deletion 323> =
dir = q->tavl_link[0] != y;
y->tavl_balance--;
if (y->tavl_balance == -1)
  break;
else if (y->tavl_balance == -2)
  {
    struct tavl_node *x = y->tavl_link[0];
    assert (x != NULL);
    if (x->tavl_balance == +1)
      {
        <*Note Rebalance for |+| balance factor after TAVL deletion in right subtree:: 324>
      }
    else
      {
        q->tavl_link[dir] = x;

        if (x->tavl_balance == 0)
          {
            <*Note Rebalance for 0 balance factor after TAVL deletion in right subtree:: 325>
            break;
          }
        else /* x->tavl_balance == -1 */
          {
            <*Note Rebalance for |-| balance factor after TAVL deletion in right subtree:: 326>
          }
      }
  }

This code is included in *Note 318: Steps 3 and 4 Update balance
factors and rebalance after TAVL deletion.

324. <Rebalance for + balance factor after TAVL deletion in right subtree 324> =
struct tavl_node *w;

<*Note Rebalance for |+| balance factor in TAVL insertion in left subtree:: 307>
q->tavl_link[dir] = w;

This code is included in *Note 323: Steps 3 and 4 Symmetric case in
TAVL deletion.

325. <Rebalance for 0 balance factor after TAVL deletion in right subtree 325> =
y->tavl_link[0] = x->tavl_link[1];
x->tavl_link[1] = y;
x->tavl_balance = +1;
y->tavl_balance = -1;

This code is included in *Note 323: Steps 3 and 4 Symmetric case in
TAVL deletion and *Note 444: Rebalance for 0 balance factor after
right-side RTAVL deletion.

326. <Rebalance for - balance factor after TAVL deletion in right subtree 326> =
if (x->tavl_tag[1] == TAVL_CHILD)
  y->tavl_link[0] = x->tavl_link[1];
else
  {
    y->tavl_tag[0] = TAVL_THREAD;
    x->tavl_tag[1] = TAVL_CHILD;
  }
x->tavl_link[1] = y;  
y->tavl_balance = x->tavl_balance = 0;

This code is included in *Note 323: Steps 3 and 4 Symmetric case in
TAVL deletion.


File: libavl.info,  Node: Finding the Parent of a TBST Node,  Prev: TAVL deletion symmetric case,  Up: Deleting from a TAVL tree

8.5.6 Finding the Parent of a Node
----------------------------------

   The last component of tavl_delete() left undiscussed is the
implementation of its helper function find_parent(), which requires an
algorithm for finding the parent of an arbitrary node in a TAVL tree.
If there were no efficient algorithm for this purpose, we would have to
keep a stack of parent nodes as we did for unthreaded AVL trees.  (This
is still an option, as shown in Exercise 3.)  We are fortunate that
such an algorithm does exist.  Let's discover it.

   Because child pointers always lead downward in a BST, the only way
that we're going to get from one node to another one above it is by
following a thread.  Almost directly from our definition of threads, we
know that if a node q has a right child p, then there is a left thread
in the subtree rooted at p that points back to q.  Because a left
thread points from a node to its predecessor, this left thread to q
must come from q's successor, which we'll call s.  The situation looks
like this:

                               q
                              / `--...___
                             a           p
                                       _' \
                                      ...  b
                                    _'
                                   s
                                 _' \
                                [q]  c
 
 This leads immediately to an algorithm to find q given p, if p is q's
right child.  We simply follow left links starting at p until we we
reach a thread, then we follow that thread.  On the other hand, it
doesn't help if p is q's left child, but there's an analogous situation
with q's predecessor in that case.

Will this algorithm work for any node in a TBST?  It won't work for the
root node, because no thread points above the root (see
Exercise 2).  It will work for any other node, because any node other
than the root has its successor or predecessor as its parent.

   Here is the actual code, which finds and returns the parent of node.
It traverses both the left and right subtrees of node at once, using x
to move down to the left and y to move down to the right.  When it hits
a thread on one side, it checks whether it leads to node's parent.  If
it does, then we're done.  If it doesn't, then we continue traversing
along the other side, which is guaranteed to lead to node's parent.

327. <Find parent of a TBST node 327> =
/* Returns the parent of node within tree,
   or a pointer to tbst_root if s is the root of the tree. */
static struct tbst_node *
find_parent (struct tbst_table *tree, struct tbst_node *node)
{
  if (node != tree->tbst_root)
    {
      struct tbst_node *x, *y;

      for (x = y = node; ; x = x->tbst_link[0], y = y->tbst_link[1])
        if (y->tbst_tag[1] == TBST_THREAD)
          {
            struct tbst_node *p = y->tbst_link[1];
            if (p == NULL || p->tbst_link[0] != node)
              {
                while (x->tbst_tag[0] == TBST_CHILD)
                  x = x->tbst_link[0];
                p = x->tbst_link[0];
              }
            return p;
          }
        else if (x->tbst_tag[0] == TBST_THREAD)
          {
            struct tbst_node *p = x->tbst_link[0];
            if (p == NULL || p->tbst_link[1] != node)
              {
                while (y->tbst_tag[1] == TBST_CHILD)
                  y = y->tbst_link[1];
                p = y->tbst_link[1];
              }
            return p;
          }
    }
  else
    return (struct tbst_node *) &tree->tbst_root;
}

This code is included in *Note 311: TAVL item deletion function, *Note
668: TRB item insertion function without stack, and *Note 670: TRB item
deletion function without stack.

See also:  *Note Knuth 1997::, exercise 2.3.1-19.

Exercises:

*1. Show that finding the parent of a given node using this algorithm,
averaged over all the node within a TBST, requires only a constant
number of links to be followed.

2. The structure of threads in our TBSTs force finding the parent of the
root node to be special-cased.  Suggest a modification to the tree
structure to avoid this.

3. It can take several steps to find the parent of an arbitrary node in
a TBST, even though the operation is "efficient" in the sense of
Exercise 8.7-4.  On the other hand, finding the parent of a node is
very fast with a stack, but it costs time to construct the stack.
Rewrite tavl_delete() to use a stack instead of the parent node
algorithm.


File: libavl.info,  Node: Copying a TAVL Tree,  Next: Testing TAVL Trees,  Prev: Deleting from a TAVL tree,  Up: Threaded AVL Trees

8.6 Copying
===========

   We can use the tree copy function for TBSTs almost verbatim here.
The one necessary change is that copy_node() must copy node balance
factors.  Here's the new version:

328. <TAVL node copy function 328> =
static int
copy_node (struct tavl_table *tree,
           struct tavl_node *dst, int dir,
           const struct tavl_node *src, tavl_copy_func *copy)
{
  struct tavl_node *new =
    tree->tavl_alloc->libavl_malloc (tree->tavl_alloc, sizeof *new);
  if (new == NULL)
    return 0;

  new->tavl_link[dir] = dst->tavl_link[dir];
  new->tavl_tag[dir] = TAVL_THREAD;
  new->tavl_link[!dir] = dst;
  new->tavl_tag[!dir] = TAVL_THREAD;
  dst->tavl_link[dir] = new;
  dst->tavl_tag[dir] = TAVL_CHILD;

  new->tavl_balance = src->tavl_balance;
  if (copy == NULL)
    new->tavl_data = src->tavl_data;
  else
    {
      new->tavl_data = copy (src->tavl_data, tree->tavl_param);
      if (new->tavl_data == NULL)
        return 0;
    }

  return 1;
}

This code is included in *Note 329: TAVL copy function.

329. <TAVL copy function 329> =
<*Note TAVL node copy function:: 328>
<*Note TBST copy error helper function:: 280>
<*Note TBST main copy function:: 279>

This code is included in *Note 300: TAVL functions and *Note 336: TRB
functions.


File: libavl.info,  Node: Testing TAVL Trees,  Prev: Copying a TAVL Tree,  Up: Threaded AVL Trees

8.7 Testing
===========

   The testing code harbors no surprises.

330. <tavl-test.c 330> =
<*Note License:: 1>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "tavl.h"
#include "test.h"

<*Note TBST print function:: 291>
<*Note BST traverser check function:: 104>
<*Note Compare two TAVL trees for structure and content:: 331>
<*Note Recursively verify TAVL tree structure:: 332>
<*Note AVL tree verify function:: 190>
<*Note BST test function:: 100>
<*Note BST overflow test function:: 122>

331. <Compare two TAVL trees for structure and content 331> =
static int
compare_trees (struct tavl_node *a, struct tavl_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      if (a != NULL || b != NULL)
        {
          printf (" a=%d b=%d\n",
                  a ? *(int *) a->tavl_data : -1,
                  b ? *(int *) b->tavl_data : -1);
          assert (0);
        }
      return 1;
    }
  assert (a != b);

  if (*(int *) a->tavl_data != *(int *) b->tavl_data
      || a->tavl_tag[0] != b->tavl_tag[0]
      || a->tavl_tag[1] != b->tavl_tag[1]
      || a->tavl_balance != b->tavl_balance)
    {
      printf (" Copied nodes differ: a=%d (bal=%d) b=%d (bal=%d) a:",
              *(int *) a->tavl_data, a->tavl_balance,
              *(int *) b->tavl_data, b->tavl_balance);

      if (a->tavl_tag[0] == TAVL_CHILD)
        printf ("l");
      if (a->tavl_tag[1] == TAVL_CHILD)
        printf ("r");

      printf (" b:");
      if (b->tavl_tag[0] == TAVL_CHILD)
        printf ("l");
      if (b->tavl_tag[1] == TAVL_CHILD)
        printf ("r");

      printf ("\n");
      return 0;
    }

  if (a->tavl_tag[0] == TAVL_THREAD)
    assert ((a->tavl_link[0] == NULL) != (a->tavl_link[0] != b->tavl_link[0]));
  if (a->tavl_tag[1] == TAVL_THREAD)
    assert ((a->tavl_link[1] == NULL) != (a->tavl_link[1] != b->tavl_link[1]));

  okay = 1;
  if (a->tavl_tag[0] == TAVL_CHILD)
    okay &= compare_trees (a->tavl_link[0], b->tavl_link[0]);
  if (a->tavl_tag[1] == TAVL_CHILD)
    okay &= compare_trees (a->tavl_link[1], b->tavl_link[1]);
  return okay;
}

This code is included in *Note 330: tavl-testc.

332. <Recursively verify TAVL tree structure 332> =
static void
recurse_verify_tree (struct tavl_node *node, int *okay, size_t *count, 
                     int min, int max, int *height)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */
  int subheight[2];     /* Heights of subtrees. */

  if (node == NULL)
    {
      *count = 0;
      *height = 0;
      return;
    }
  d = *(int *) node->tavl_data;

  <*Note Verify binary search tree ordering:: 114>

  subcount[0] = subcount[1] = 0;
  subheight[0] = subheight[1] = 0;
  if (node->tavl_tag[0] == TAVL_CHILD)
    recurse_verify_tree (node->tavl_link[0], okay, &subcount[0], 
                         min, d -  1, &subheight[0]);
  if (node->tavl_tag[1] == TAVL_CHILD)
    recurse_verify_tree (node->tavl_link[1], okay, &subcount[1], 
                         d + 1, max, &subheight[1]);
  *count = 1 + subcount[0] + subcount[1];
  *height = 1 + (subheight[0] > subheight[1] ? subheight[0] : subheight[1]);

  <*Note Verify AVL node balance factor:: 189>
}

This code is included in *Note 330: tavl-testc.


File: libavl.info,  Node: Threaded Red-Black Trees,  Next: Right-Threaded Binary Search Trees,  Prev: Threaded AVL Trees,  Up: Top

9 Threaded Red-Black Trees
**************************

   In the last two chapters, we introduced the idea of a threaded binary
search tree, then applied that idea to AVL trees to produce threaded AVL
trees.  In this chapter, we will apply the idea of threading to
red-black trees, resulting in threaded red-black or "TRB" trees.

   Here's an outline of the table implementation for threaded RB trees,
which use a trb_ prefix.

333. <trb.h 333> =
<*Note License:: 1>
#ifndef TRB_H
#define TRB_H 1

#include <stddef.h>

<*Note Table types:: 14>
<*Note RB maximum height:: 195>
<*Note TBST table structure:: 250>
<*Note TRB node structure:: 335>
<*Note TBST traverser structure:: 267>
<*Note Table function prototypes:: 15>

#endif /* trb.h */

334. <trb.c 334> =
<*Note License:: 1>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "trb.h"

<*Note TRB functions:: 336>

* Menu:

* TRB Data Types::
* TRB Operations::
* Inserting into a TRB tree::
* Deleting from a TRB Tree::
* Testing TRB Trees::


File: libavl.info,  Node: TRB Data Types,  Next: TRB Operations,  Prev: Threaded Red-Black Trees,  Up: Threaded Red-Black Trees

9.1 Data Types
==============

   To make a RB tree node structure into a threaded RB tree node
structure, we just add a pair of tag fields.  We also reintroduce a
maximum height definition here.  It is not used by traversers, only by
by the default versions of trb_probe() and trb_delete(), for maximum
efficiency.

335. <TRB node structure 335> =
/* Color of a red-black node. */
enum trb_color
  {
    TRB_BLACK,                     /* Black. */
    TRB_RED                        /* Red. */
  };

/* Characterizes a link as a child pointer or a thread. */
enum trb_tag
  {
    TRB_CHILD,                     /* Child pointer. */
    TRB_THREAD                     /* Thread. */
  };

/* An TRB tree node. */
struct trb_node
  {
    struct trb_node *trb_link[2];  /* Subtrees. */
    void *trb_data;                /* Pointer to data. */
    unsigned char trb_color;       /* Color. */
    unsigned char trb_tag[2];      /* Tag fields. */
  };

This code is included in *Note 333: trbh.


File: libavl.info,  Node: TRB Operations,  Next: Inserting into a TRB tree,  Prev: TRB Data Types,  Up: Threaded Red-Black Trees

9.2 Operations
==============

   Now we'll implement all the usual operations for TRB trees.  Here's
the outline.  We can reuse everything from TBSTs except insertion,
deletion, and copy functions.  The copy function is implemented by
reusing the version for TAVL trees, but copying colors instead of
balance factors.

336. <TRB functions 336> =
<*Note TBST creation function:: 252>
<*Note TBST search function:: 253>
<*Note TRB item insertion function:: 337>
<*Note Table insertion convenience functions:: 592>
<*Note TRB item deletion function:: 349>
<*Note TBST traversal functions:: 268>
<*Note TAVL copy function:: 329>
<*Note TBST destruction function:: 281>
<*Note Default memory allocation functions:: 6>
<*Note Table assertion functions:: 594>

This code is included in *Note 334: trbc.


File: libavl.info,  Node: Inserting into a TRB tree,  Next: Deleting from a TRB Tree,  Prev: TRB Operations,  Up: Threaded Red-Black Trees

9.3 Insertion
=============

   The structure of the insertion routine is predictable:

337. <TRB item insertion function 337> =
void **
trb_probe (struct trb_table *tree, void *item)
{
  struct trb_node *pa[TRB_MAX_HEIGHT]; /* Nodes on stack. */
  unsigned char da[TRB_MAX_HEIGHT];    /* Directions moved from stack nodes. */
  int k;                               /* Stack height. */

  struct trb_node *p; /* Traverses tree looking for insertion point. */
  struct trb_node *n; /* Newly inserted node. */
  int dir;            /* Side of p on which n is inserted. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1 Search TRB tree for insertion point:: 338>
  <*Note Step 2 Insert TRB node:: 339>
  <*Note Step 3 Rebalance after TRB insertion:: 340>

  return &n->trb_data;
}

This code is included in *Note 336: TRB functions.

* Menu:

* Steps 1 and 2 in TRB Insertion::
* Step 3 in TRB Insertion::
* TRB insertion symmetric case::


File: libavl.info,  Node: Steps 1 and 2 in TRB Insertion,  Next: Step 3 in TRB Insertion,  Prev: Inserting into a TRB tree,  Up: Inserting into a TRB tree

9.3.1 Steps 1 and 2: Search and Insert
--------------------------------------

   As usual, we search the tree from the root and record parents as we
go.

338. <Step 1: Search TRB tree for insertion point 338> =
da[0] = 0;
pa[0] = (struct trb_node *) &tree->trb_root;
k = 1;
if (tree->trb_root != NULL)
  {
    for (p = tree->trb_root; ; p = p->trb_link[dir])
      {
        int cmp = tree->trb_compare (item, p->trb_data, tree->trb_param);
        if (cmp == 0)
          return &p->trb_data;

        pa[k] = p;
        da[k++] = dir = cmp > 0;

        if (p->trb_tag[dir] == TRB_THREAD)
          break;
      }
  }
else
  {
    p = (struct trb_node *) &tree->trb_root;
    dir = 0;
  }

This code is included in *Note 337: TRB item insertion function.

   The code for insertion is included within the loop for easy access to
the dir variable.

339. <Step 2: Insert TRB node 339> =
<*Note Step 2 Insert TBST node:: 256>
n->trb_color = TRB_RED;

This code is included in *Note 337: TRB item insertion function and
*Note 668: TRB item insertion function without stack.


File: libavl.info,  Node: Step 3 in TRB Insertion,  Next: TRB insertion symmetric case,  Prev: Steps 1 and 2 in TRB Insertion,  Up: Inserting into a TRB tree

9.3.2 Step 3: Rebalance
-----------------------

   The basic rebalancing loop is unchanged from <*Note Step 3 Rebalance
after RB insertion:: 201>.

340. <Step 3: Rebalance after TRB insertion 340> =
while (k >= 3 && pa[k - 1]->trb_color == TRB_RED)
  {
    if (da[k - 2] == 0)
      {
        <*Note Left-side rebalancing after TRB insertion:: 341>
      }
    else
      {
        <*Note Right-side rebalancing after TRB insertion:: 345>
      }
  }
tree->trb_root->trb_color = TRB_BLACK;

This code is included in *Note 337: TRB item insertion function.

   The cases for rebalancing are the same as in <*Note Left-side
rebalancing after RB insertion:: 202>, too.  We do need to check for
threads, instead of null pointers.

341. <Left-side rebalancing after TRB insertion 341> =
struct trb_node *y = pa[k - 2]->trb_link[1];
if (pa[k - 2]->trb_tag[1] == TRB_CHILD && y->trb_color == TRB_RED)
  {
    <*Note Case 1 in left-side TRB insertion rebalancing:: 342>
  }
else
  {
    struct trb_node *x;

    if (da[k - 1] == 0)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in left-side TRB insertion rebalancing:: 344>
      }

    <*Note Case 2 in left-side TRB insertion rebalancing:: 343>
    break;
  }

This code is included in *Note 340: Step 3 Rebalance after TRB
insertion.

   The rest of this section deals with the individual rebalancing cases,
the same as in unthreaded RB insertion (*note Inserting an RB node step
3 - Rebalance::).  Each iteration deals with a node whose color has
just been changed to red, which is the newly inserted node n in the
first trip through the loop.  In the discussion, we'll call this node q.

Case 1: q's uncle is red
........................

   If node q has an red "uncle", then only recoloring is required.
Because no links are changed, no threads need to be updated, and we can
reuse the code for RB insertion without change:

342. <Case 1 in left-side TRB insertion rebalancing 342> =
<*Note Case 1 in left-side RB insertion rebalancing:: 203>

This code is included in *Note 341: Left-side rebalancing after TRB
insertion.

Case 2: q is the left child of its parent
.........................................

   If q is the left child of its parent, we rotate right at q's
grandparent, and recolor a few nodes.  Here's the transformation:

                                 |
                             pa[k-2],x              |
                                <b>                 y
                   ___...---'         \            <b>
                  pa[k-1],y            d       _.-'   `_
                     <r>                 =>    q         x
              _.-'         \                  <r>       <r>
              q             c                /   \     /   \
             <r>                            a     b   c     d
            /   \
           a     b

This transformation can only cause thread problems with subtree c,
since the other subtrees stay firmly in place.  If c is a thread, then
we need to make adjustments after the transformation to account for the
difference between threaded and unthreaded rotation, so that the final
operation looks like this:

                                  |
                              pa[k-2],x              |
                                 <b>                 y
                  ____....---'         \            <b>
                 pa[k-1],y              d       _.-'   `._
                    <r>                   =>    q          x
             _.-'         \                    <r>        <r>
             q             [x]                /   \     _'   \
            <r>                              a     b   [y]    d
           /   \
          a     b
343. <Case 2 in left-side TRB insertion rebalancing 343> =
<*Note Case 2 in left-side RB insertion rebalancing:: 204>

if (y->trb_tag[1] == TRB_THREAD)
  {
    y->trb_tag[1] = TRB_CHILD;
    x->trb_tag[0] = TRB_THREAD;
    x->trb_link[0] = y;
  }

This code is included in *Note 341: Left-side rebalancing after TRB
insertion.

Case 3: q is the right child of its parent
..........................................

   The modification to case 3 is the same as the modification to case 2,
but it applies to a left rotation instead of a right rotation.  The
adjusted case looks like this:

                                 |                        |
                              pa[k-2]                    <b>
                                <b>                  _.-'   \
              _____.....-----'       \               y       d
             pa[k-1],x                d             <r>
                <r>                     =>    __..-'   \
            /         `._                     x         c
           a             w,y                 <r>
                         <r>                /   \
                       _'   \              a     [y]
                      [x]    c
344. <Case 3 in left-side TRB insertion rebalancing 344> =
<*Note Case 3 in left-side RB insertion rebalancing:: 205>

if (y->trb_tag[0] == TRB_THREAD)
  {
    y->trb_tag[0] = TRB_CHILD;
    x->trb_tag[1] = TRB_THREAD;
    x->trb_link[1] = y;
  }

This code is included in *Note 341: Left-side rebalancing after TRB
insertion.

