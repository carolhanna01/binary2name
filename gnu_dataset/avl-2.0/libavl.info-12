This is libavl.info, produced by makeinfo version 4.0b from libavl.texi.


File: libavl.info,  Node: RTBST Traverser Find Initialization,  Next: RTBST Traverser Advancing,  Prev: RTBST Traverser Last Initialization,  Up: Traversing an RTBST

10.6.3 Starting at a Found Node
-------------------------------

   To start from an item found in the tree, we use the same algorithm as
rtbst_find().

398. <RTBST traverser search initializer 398> =
void *
rtbst_t_find (struct rtbst_traverser *trav, struct rtbst_table *tree,
              void *item)
{
  struct rtbst_node *p;

  assert (trav != NULL && tree != NULL && item != NULL);

  trav->rtbst_table = tree;
  trav->rtbst_node = NULL;

  p = tree->rtbst_root;
  if (p == NULL)
    return NULL;

  for (;;)
    {
      int cmp = tree->rtbst_compare (item, p->rtbst_data, tree->rtbst_param);
      if (cmp == 0)
        {
          trav->rtbst_node = p;
          return p->rtbst_data;
        }

      if (cmp < 0)
        {
          p = p->rtbst_link[0];
          if (p == NULL)
            return NULL;
        }
      else
        {
          if (p->rtbst_rtag == RTBST_THREAD)
            return NULL;
          p = p->rtbst_link[1];
        }
    }
}

This code is included in *Note 395: RTBST traversal functions.


File: libavl.info,  Node: RTBST Traverser Advancing,  Next: RTBST Traverser Retreating,  Prev: RTBST Traverser Find Initialization,  Up: Traversing an RTBST

10.6.4 Advancing to the Next Node
---------------------------------

   We use the same algorithm to advance an RTBST traverser as for TBST
traversers.  The only important difference between this code and <*Note
TBST traverser advance function:: 275> is the substitution of
rtbst_rtag for tbst_tag[1].

399. <RTBST traverser advance function 399> =
void *
rtbst_t_next (struct rtbst_traverser *trav)
{
  assert (trav != NULL);

  if (trav->rtbst_node == NULL)
    return rtbst_t_first (trav, trav->rtbst_table);
  else if (trav->rtbst_node->rtbst_rtag == RTBST_THREAD)
    {
      trav->rtbst_node = trav->rtbst_node->rtbst_link[1];
      return trav->rtbst_node != NULL ? trav->rtbst_node->rtbst_data : NULL;
    }
  else
    {
      trav->rtbst_node = trav->rtbst_node->rtbst_link[1];
      while (trav->rtbst_node->rtbst_link[0] != NULL)
        trav->rtbst_node = trav->rtbst_node->rtbst_link[0];
      return trav->rtbst_node->rtbst_data;
    }
}

This code is included in *Note 395: RTBST traversal functions.


File: libavl.info,  Node: RTBST Traverser Retreating,  Prev: RTBST Traverser Advancing,  Up: Traversing an RTBST

10.6.5 Backing Up to the Previous Node
--------------------------------------

   Moving an RTBST traverser backward has the same cases as in the other
ways of finding an inorder predecessor that we've already discussed.
The two main cases are distinguished on whether the current item has a
left child; the third case comes up when there is no current item,
implemented simply by delegation to rtbst_t_last():

400. <RTBST traverser back up function 400> =
void *
rtbst_t_prev (struct rtbst_traverser *trav)
{
  assert (trav != NULL);

  if (trav->rtbst_node == NULL)
    return rtbst_t_last (trav, trav->rtbst_table);
  else if (trav->rtbst_node->rtbst_link[0] == NULL)
    {
      <*Note Find predecessor of RTBST node with no left child:: 401>
    }
  else
    {
      <*Note Find predecessor of RTBST node with left child:: 402>
    }
}

This code is included in *Note 395: RTBST traversal functions.

   The novel case is where the node p whose predecessor we want has no
left child.  In this case, we use a modified version of the algorithm
originally specified for finding a node's successor in an unthreaded
tree (*note Better Iterative Traversal::).  We take the idea of moving
up until we've moved up to the left, and turn it upside down (to avoid
need for a parent stack) and reverse it (to find the predecessor
instead of the successor).

   The idea here is to trace p's entire direct ancestral line.  Starting
from the root of the tree, we repeatedly compare each node's data with
p's and use the result to move downward, until we encounter node p
itself.  Each time we move down from a node x to its right child, we
record x as the potential predecessor of p.  When we finally arrive at
p, the last node so selected is the actual predecessor, or if none was
selected then p is the least node in the tree and we select the null
item as its predecessor.

   Consider this algorithm in the context of the tree shown here:

                               3
                         __..-' `-----......______
                        1                         9
                    _.-' \            ____....---' \
                   0      2          5              []
                    \      \     _.-' `-.__
                     [1]    [3] 4          7
                                 \     _.-' \
                                  [5] 6      8
                                       \      \
                                        [7]    [9]

To find the predecessor of node 8, we trace the path from the root down
to it: 3-9-5-7-8.  The last time we move down to the right is from 7 to
8, so 7 is node 8's predecessor.  To find the predecessor of node 6, we
trace the path 3-9-5-7-6 and notice that we last move down to the right
from 5 to 7, so 5 is node 6's predecessor.  Finally, node 0 has the
null item as its predecessor because path 3-1-0 does not involve any
rightward movement.

   Here is the code to implement this case:

401. <Find predecessor of RTBST node with no left child 401> =
rtbst_comparison_func *cmp = trav->rtbst_table->rtbst_compare;
void *param = trav->rtbst_table->rtbst_param;
struct rtbst_node *node = trav->rtbst_node;
struct rtbst_node *i;

trav->rtbst_node = NULL;
for (i = trav->rtbst_table->rtbst_root; i != node; )
  {
    int dir = cmp (node->rtbst_data, i->rtbst_data, param) > 0;
    if (dir == 1)
      trav->rtbst_node = i;
    i = i->rtbst_link[dir];
  }

return trav->rtbst_node != NULL ? trav->rtbst_node->rtbst_data : NULL;

This code is included in *Note 400: RTBST traverser back up function.

   The other case, where the node whose predecessor we want has a left
child, is nothing new.  We just find the largest node in the node's left
subtree:

402. <Find predecessor of RTBST node with left child 402> =
trav->rtbst_node = trav->rtbst_node->rtbst_link[0];
while (trav->rtbst_node->rtbst_rtag == RTBST_CHILD)
  trav->rtbst_node = trav->rtbst_node->rtbst_link[1];
return trav->rtbst_node->rtbst_data;

This code is included in *Note 400: RTBST traverser back up function.


File: libavl.info,  Node: Copying an RTBST,  Next: Destroying an RTBST,  Prev: Traversing an RTBST,  Up: Right-Threaded Binary Search Trees

10.7 Copying
============

   The algorithm that we used for copying a TBST makes use of threads,
but only right threads, so we can apply this algorithm essentially
unmodified to RTBSTs.

   We will make one change that superficially simplifies and improves
the elegance of the algorithm.  Function tbst_copy() in <*Note TBST
main copy function:: 279> uses a pair of local variables rp and rq to
store pointers to the original and new tree's root, because accessing
the tag field of a cast "pseudo-root" pointer produces undefined
behavior.  However, in an RTBST there is no tag for a node's left
subtree.  During a TBST copy, only the left tags of the root nodes are
accessed, so this means that we can use the pseudo-roots in the RTBST
copy, with no need for rp or rq.

403. <RTBST main copy function 403> =
struct rtbst_table *
rtbst_copy (const struct rtbst_table *org, rtbst_copy_func *copy,
            rtbst_item_func *destroy, struct libavl_allocator *allocator)
{
  struct rtbst_table *new;

  const struct rtbst_node *p;
  struct rtbst_node *q;

  assert (org != NULL);
  new = rtbst_create (org->rtbst_compare, org->rtbst_param,
                     allocator != NULL ? allocator : org->rtbst_alloc);
  if (new == NULL)
    return NULL;

  new->rtbst_count = org->rtbst_count;
  if (new->rtbst_count == 0)
    return new;

  p = (struct rtbst_node *) &org->rtbst_root;
  q = (struct rtbst_node *) &new->rtbst_root;
  for (;;)
    {
      if (p->rtbst_link[0] != NULL)
        {
          if (!copy_node (new, q, 0, p->rtbst_link[0], copy))
            {
              copy_error_recovery (new, destroy);
              return NULL;
            }

          p = p->rtbst_link[0];
          q = q->rtbst_link[0];
        }
      else
        {
          while (p->rtbst_rtag == RTBST_THREAD)
            {
              p = p->rtbst_link[1];
              if (p == NULL)
                {
                  q->rtbst_link[1] = NULL;
                  return new;
                }

              q = q->rtbst_link[1];
            }

          p = p->rtbst_link[1];
          q = q->rtbst_link[1];
        }

      if (p->rtbst_rtag == RTBST_CHILD)
        if (!copy_node (new, q, 1, p->rtbst_link[1], copy))
          {
            copy_error_recovery (new, destroy);
            return NULL;
          }
    }
}

This code is included in *Note 406: RTBST copy function and *Note 447:
RTAVL copy function.

   The code to copy a node must be modified to deal with the
asymmetrical nature of insertion in an RTBST:

404. <RTBST node copy function 404> =
static int
copy_node (struct rtbst_table *tree,
           struct rtbst_node *dst, int dir,
           const struct rtbst_node *src, rtbst_copy_func *copy)
{
  struct rtbst_node *new =
    tree->rtbst_alloc->libavl_malloc (tree->rtbst_alloc, sizeof *new);
  if (new == NULL)
    return 0;

  new->rtbst_link[0] = NULL;
  new->rtbst_rtag = RTBST_THREAD;
  if (dir == 0)
    new->rtbst_link[1] = dst;
  else
    {
      new->rtbst_link[1] = dst->rtbst_link[1];
      dst->rtbst_rtag = RTBST_CHILD;
    }
  dst->rtbst_link[dir] = new;

  if (copy == NULL)
    new->rtbst_data = src->rtbst_data;
  else
    {
      new->rtbst_data = copy (src->rtbst_data, tree->rtbst_param);
      if (new->rtbst_data == NULL)
        return 0;
    }

  return 1;
}

This code is included in *Note 406: RTBST copy function.

   The error recovery function for copying is a bit simpler now, because
the use of the pseudo-root means that no assignment to the new tree's
root need take place, eliminating the need for one of the function's
parameters:

405. <RTBST copy error helper function 405> =
static void
copy_error_recovery (struct rtbst_table *new, rtbst_item_func *destroy)
{
  struct rtbst_node *p = new->rtbst_root;
  if (p != NULL)
    {
      while (p->rtbst_rtag == RTBST_CHILD)
        p = p->rtbst_link[1];
      p->rtbst_link[1] = NULL;
    }
  rtbst_destroy (new, destroy);
}

This code is included in *Note 406: RTBST copy function and *Note 447:
RTAVL copy function.

406. <RTBST copy function 406> =
<*Note RTBST node copy function:: 404>
<*Note RTBST copy error helper function:: 405>
<*Note RTBST main copy function:: 403>

This code is included in *Note 375: RTBST functions.


File: libavl.info,  Node: Destroying an RTBST,  Next: Balancing an RTBST,  Prev: Copying an RTBST,  Up: Right-Threaded Binary Search Trees

10.8 Destruction
================

   The destruction algorithm for TBSTs makes use only of right threads,
so we can easily adapt it for RTBSTs.

407. <RTBST destruction function 407> =
void
rtbst_destroy (struct rtbst_table *tree, rtbst_item_func *destroy)
{
  struct rtbst_node *p; /* Current node. */
  struct rtbst_node *n; /* Next node. */

  p = tree->rtbst_root;
  if (p != NULL)
    while (p->rtbst_link[0] != NULL)
      p = p->rtbst_link[0];

  while (p != NULL)
    {
      n = p->rtbst_link[1];
      if (p->rtbst_rtag == RTBST_CHILD)
        while (n->rtbst_link[0] != NULL)
          n = n->rtbst_link[0];

      if (destroy != NULL && p->rtbst_data != NULL) 
        destroy (p->rtbst_data, tree->rtbst_param);
      tree->rtbst_alloc->libavl_free (tree->rtbst_alloc, p);

      p = n;
    }

  tree->rtbst_alloc->libavl_free (tree->rtbst_alloc, tree);
}

This code is included in *Note 375: RTBST functions, *Note 418: RTAVL
functions, and *Note 455: RTRB functions.


File: libavl.info,  Node: Balancing an RTBST,  Next: Testing RTBSTs,  Prev: Destroying an RTBST,  Up: Right-Threaded Binary Search Trees

10.9 Balance
============

   As for so many other operations, we can reuse most of the TBST
balancing code to rebalance RTBSTs.  Some of the helper functions can be
completely recycled:

408. <RTBST balance function 408> =
<*Note RTBST tree-to-vine function:: 409>
<*Note RTBST vine compression function:: 410>
<*Note TBST vine-to-tree function:: 285>
<*Note TBST main balance function:: 283>

This code is included in *Note 375: RTBST functions.

   The only substantative difference for the remaining two functions is
that there is no need to set nodes' left tags (since they don't have
any):

409. <RTBST tree-to-vine function 409> =
static void
tree_to_vine (struct rtbst_table *tree)
{
  struct rtbst_node *p;

  if (tree->rtbst_root == NULL)
    return;

  p = tree->rtbst_root;
  while (p->rtbst_link[0] != NULL)
    p = p->rtbst_link[0];

  for (;;)
    {
      struct rtbst_node *q = p->rtbst_link[1];
      if (p->rtbst_rtag == RTBST_CHILD)
        {
          while (q->rtbst_link[0] != NULL)
            q = q->rtbst_link[0];
          p->rtbst_rtag = RTBST_THREAD;
          p->rtbst_link[1] = q;
        }

      if (q == NULL)
        break;

      q->rtbst_link[0] = p;
      p = q;
    }

  tree->rtbst_root = p;
}

This code is included in *Note 408: RTBST balance function.

410. <RTBST vine compression function 410> =
/* Performs a compression transformation count times,
   starting at root. */
static void
compress (struct rtbst_node *root,
          unsigned long nonthread, unsigned long thread)
{
  assert (root != NULL);

  while (nonthread--)
    {
      struct rtbst_node *red = root->rtbst_link[0];
      struct rtbst_node *black = red->rtbst_link[0];

      root->rtbst_link[0] = black;
      red->rtbst_link[0] = black->rtbst_link[1];
      black->rtbst_link[1] = red;
      root = black;
    }

  while (thread--)
    {
      struct rtbst_node *red = root->rtbst_link[0];
      struct rtbst_node *black = red->rtbst_link[0];

      root->rtbst_link[0] = black;
      red->rtbst_link[0] = NULL;
      black->rtbst_rtag = RTBST_CHILD;
      root = black;
    }
}

This code is included in *Note 408: RTBST balance function.


File: libavl.info,  Node: Testing RTBSTs,  Prev: Balancing an RTBST,  Up: Right-Threaded Binary Search Trees

10.10 Testing
=============

   There's nothing new or interesting in the test code.

411. <rtbst-test.c 411> =
<*Note License:: 1>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "rtbst.h"
#include "test.h"

<*Note RTBST print function:: 412>
<*Note BST traverser check function:: 104>
<*Note Compare two RTBSTs for structure and content:: 413>
<*Note Recursively verify RTBST structure:: 414>
<*Note BST verify function:: 109>
<*Note TBST test function:: 295>
<*Note BST overflow test function:: 122>

412. <RTBST print function 412> =
void
print_tree_structure (struct rtbst_node *node, int level)
{
  if (level > 16)
    {
      printf ("[...]");
      return;
    }

  if (node == NULL)
    {
      printf ("<nil>");
      return;
    }

  printf ("%d(", node->rtbst_data ? *(int *) node->rtbst_data : -1);

  if (node->rtbst_link[0] != NULL)
    print_tree_structure (node->rtbst_link[0], level + 1);

  fputs (", ", stdout);

  if (node->rtbst_rtag == RTBST_CHILD)
    {
      if (node->rtbst_link[1] == node) 
        printf ("loop");
      else
        print_tree_structure (node->rtbst_link[1], level + 1);
    } 
  else if (node->rtbst_link[1] != NULL)
    printf (">%d",
            (node->rtbst_link[1]->rtbst_data
             ? *(int *) node->rtbst_link[1]->rtbst_data : -1));
  else
    printf (">>");

  putchar (')');
}

void
print_whole_tree (const struct rtbst_table *tree, const char *title)
{
  printf ("%s: ", title);
  print_tree_structure (tree->rtbst_root, 0);
  putchar ('\n');
}

This code is included in *Note 411: rtbst-testc, *Note 449:
rtavl-testc, and *Note 482: rtrb-testc.

413. <Compare two RTBSTs for structure and content 413> =
static int
compare_trees (struct rtbst_node *a, struct rtbst_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      if (a != NULL || b != NULL)
        {
          printf (" a=%d b=%d\n",
                  a ? *(int *) a->rtbst_data : -1, 
                  b ? *(int *) b->rtbst_data : -1);
          assert (0);
        }
      return 1;
    }
  assert (a != b);

  if (*(int *) a->rtbst_data != *(int *) b->rtbst_data
      || a->rtbst_rtag != b->rtbst_rtag)
    {
      printf (" Copied nodes differ: a=%d b=%d a:",
              *(int *) a->rtbst_data, *(int *) b->rtbst_data);

      if (a->rtbst_rtag == RTBST_CHILD)
        printf ("r");

      printf (" b:");
      if (b->rtbst_rtag == RTBST_CHILD)
        printf ("r");

      printf ("\n");
      return 0;
    }

  if (a->rtbst_rtag == RTBST_THREAD)
    assert ((a->rtbst_link[1] == NULL)
            != (a->rtbst_link[1] != b->rtbst_link[1]));

  okay = compare_trees (a->rtbst_link[0], b->rtbst_link[0]);
  if (a->rtbst_rtag == RTBST_CHILD)
    okay &= compare_trees (a->rtbst_link[1], b->rtbst_link[1]);
  return okay;
}

This code is included in *Note 411: rtbst-testc.

414. <Recursively verify RTBST structure 414> =
static void
recurse_verify_tree (struct rtbst_node *node, int *okay, size_t *count, 
                     int min, int max)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */

  if (node == NULL)
    {
      *count = 0;
      return;
    }
  d = *(int *) node->rtbst_data;

  <*Note Verify binary search tree ordering:: 114>

  subcount[0] = subcount[1] = 0;
  recurse_verify_tree (node->rtbst_link[0], okay, &subcount[0], min, d - 1);
  if (node->rtbst_rtag == RTBST_CHILD)
    recurse_verify_tree (node->rtbst_link[1], okay, &subcount[1], d + 1, max);
  *count = 1 + subcount[0] + subcount[1];
}

This code is included in *Note 411: rtbst-testc.


File: libavl.info,  Node: Right-Threaded AVL Trees,  Next: Right-Threaded Red-Black Trees,  Prev: Right-Threaded Binary Search Trees,  Up: Top

11 Right-Threaded AVL Trees
***************************

   In the same way that we can combine threaded trees with AVL trees to
produce threaded AVL trees, we can combine right-threaded trees with
AVL trees to produce right-threaded AVL trees.  This chapter explores
this combination, producing another table implementation.

   Here's the form of the source and header files.  Notice the use of
rtavl_ as the identifier prefix.  Likewise, we will often refer to
right-threaded AVL trees as "RTAVL trees".

415. <rtavl.h 415> =
<*Note License:: 1>
#ifndef RTAVL_H
#define RTAVL_H 1

#include <stddef.h>

<*Note Table types:: 14>
<*Note BST maximum height:: 28>
<*Note TBST table structure:: 250>
<*Note RTAVL node structure:: 417>
<*Note TBST traverser structure:: 267>
<*Note Table function prototypes:: 15>

#endif /* rtavl.h */

416. <rtavl.c 416> =
<*Note License:: 1>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "rtavl.h"

<*Note RTAVL functions:: 418>

* Menu:

* RTAVL Data Types::
* RTAVL Operations::
* RTBST Rotations::
* Inserting into an RTAVL Tree::
* Deleting from an RTAVL tree::
* Copying an RTAVL Tree::
* Testing RTAVL Trees::


File: libavl.info,  Node: RTAVL Data Types,  Next: RTAVL Operations,  Prev: Right-Threaded AVL Trees,  Up: Right-Threaded AVL Trees

11.1 Data Types
===============

   Besides the members needed for any BST, an RTAVL node structure
needs a tag to indicate whether the right link is a child pointer or a
thread, and a balance factor to facilitate AVL balancing.  Here's what
we end up with:

417. <RTAVL node structure 417> =
/* Characterizes a link as a child pointer or a thread. */
enum rtavl_tag
  {
    RTAVL_CHILD,                     /* Child pointer. */
    RTAVL_THREAD                     /* Thread. */
  };

/* A threaded binary search tree node. */
struct rtavl_node
  {
    struct rtavl_node *rtavl_link[2]; /* Subtrees. */
    void *rtavl_data;                 /* Pointer to data. */
    unsigned char rtavl_rtag;         /* Tag field. */
    signed char rtavl_balance;        /* Balance factor. */
  };

This code is included in *Note 415: rtavlh.


File: libavl.info,  Node: RTAVL Operations,  Next: RTBST Rotations,  Prev: RTAVL Data Types,  Up: Right-Threaded AVL Trees

11.2 Operations
===============

   Most of the operations for RTAVL trees can come directly from their
RTBST implementations.  The notable exceptions are, as usual, the
insertion and deletion functions.  The copy function will also need a
small tweak.  Here's the list of operations:

418. <RTAVL functions 418> =
<*Note TBST creation function:: 252>
<*Note RTBST search function:: 376>
<*Note RTAVL item insertion function:: 419>
<*Note Table insertion convenience functions:: 592>
<*Note RTAVL item deletion function:: 429>
<*Note RTBST traversal functions:: 395>
<*Note RTAVL copy function:: 447>
<*Note RTBST destruction function:: 407>
<*Note Default memory allocation functions:: 6>
<*Note Table assertion functions:: 594>

This code is included in *Note 416: rtavlc.


File: libavl.info,  Node: RTBST Rotations,  Next: Inserting into an RTAVL Tree,  Prev: RTAVL Operations,  Up: Right-Threaded AVL Trees

11.3 Rotations
==============

   We will use rotations in right-threaded trees in the same way as for
other kinds of trees that we have already examined.  As always, a
generic rotation looks like this:

                               |        |
                               Y        X
                              / \      / \
                             X   c    a   Y
                             ^            ^
                            a b          b c
 
 On the left side of this diagram, a may be an empty subtree and b and
c may be threads.  On the right side, a and b may be empty subtrees and
c may be a thread.  If none of them in fact represent actual nodes,
then we end up with the following pathological case:

                                |       |
                                Y       X
                            _.-' \       \
                           X      []      Y
                            \              \
                             [Y]            []
 
 Notice the asymmetry here: in a right rotation the right thread from X
to Y becomes a null left child of Y, but in a left rotation this is
reversed and a null subtree b becomes a right thread from X to Y.
Contrast this to the correponding rotation in a threaded tree (*note
TBST Rotations::), where either way the same kind of change occurs: the
thread from X to Y, or vice versa, simply reverses direction.

As with other kinds of rotations we've seen, there is no need to make
any changes in subtrees of a, b, or c, because of rotations' locality
and order-preserving properties (*note BST Rotations::).  In
particular, nodes a and c, if they exist, need no adjustments, as
implied by the diagram above, which shows no changes to these subtrees
on opposite sides.

Exercises:

1. Write functions for right and left rotations in right-threaded BSTs,
analogous to those for unthreaded BSTs developed in Exercise 5.3-2.


File: libavl.info,  Node: Inserting into an RTAVL Tree,  Next: Deleting from an RTAVL tree,  Prev: RTBST Rotations,  Up: Right-Threaded AVL Trees

11.4 Insertion
==============

   Insertion into an RTAVL tree follows the same pattern as insertion
into other kinds of balanced tree.  The outline is straightforward:

419. <RTAVL item insertion function 419> =
void **
rtavl_probe (struct rtavl_table *tree, void *item)
{
  <*Note |avl_probe()| local variables:: 147>

  assert (tree != NULL && item != NULL);

  <*Note Step 1 Search RTAVL tree for insertion point:: 420>
  <*Note Step 2 Insert RTAVL node:: 421>
  <*Note Step 3 Update balance factors after AVL insertion:: 150>
  <*Note Step 4 Rebalance after RTAVL insertion:: 422>
}

This code is included in *Note 418: RTAVL functions.

* Menu:

* Steps 1-1 in RTAVL Insertion::
* Rebalancing RTAVL trees::


File: libavl.info,  Node: Steps 1-1 in RTAVL Insertion,  Next: Rebalancing RTAVL trees,  Prev: Inserting into an RTAVL Tree,  Up: Inserting into an RTAVL Tree

11.4.1 Steps 1-2: Search and Insert
-----------------------------------

   The basic insertion step itself follows the same steps as <*Note
RTBST item insertion function:: 377> does for a plain RTBST.  We do
keep track of the directions moved on stack da[] and the last-seen node
with nonzero balance factor, in the same way as <*Note Step 1 Search
AVL tree for insertion point:: 148> for unthreaded AVL trees.

420. <Step 1: Search RTAVL tree for insertion point 420> =
z = (struct rtavl_node *) &tree->rtavl_root;
y = tree->rtavl_root;
if (tree->rtavl_root != NULL)
  for (q = z, p = y; ; q = p, p = p->rtavl_link[dir])
    {
      int cmp = tree->rtavl_compare (item, p->rtavl_data, tree->rtavl_param);
      if (cmp == 0)
        return &p->rtavl_data;

      if (p->rtavl_balance != 0)
        z = q, y = p, k = 0;
      da[k++] = dir = cmp > 0;

      if (dir == 0)
        {
          if (p->rtavl_link[0] == NULL)
            break;
        }
      else /* dir == 1 */
        {
          if (p->rtavl_rtag == RTAVL_THREAD)
            break;
        }
    }
else
  {
    p = (struct rtavl_node *) &tree->rtavl_root;
    dir = 0;
  }

This code is included in *Note 419: RTAVL item insertion function.

421. <Step 2: Insert RTAVL node 421> =
n = tree->rtavl_alloc->libavl_malloc (tree->rtavl_alloc, sizeof *n);
if (n == NULL)
  return NULL;

tree->rtavl_count++;
n->rtavl_data = item;
n->rtavl_link[0] = NULL;
if (dir == 0)
  n->rtavl_link[1] = p;
else /* dir == 1 */
  {
    p->rtavl_rtag = RTAVL_CHILD;
    n->rtavl_link[1] = p->rtavl_link[1];
  }
n->rtavl_rtag = RTAVL_THREAD;
n->rtavl_balance = 0;
p->rtavl_link[dir] = n;
if (y == NULL)
  {
    n->rtavl_link[1] = NULL;
    return &n->rtavl_data;
  }

This code is included in *Note 419: RTAVL item insertion function.


File: libavl.info,  Node: Rebalancing RTAVL trees,  Prev: Steps 1-1 in RTAVL Insertion,  Up: Inserting into an RTAVL Tree

11.4.2 Step 4: Rebalance
------------------------

   Unlike all of the AVL rebalancing algorithms we've seen so far,
rebalancing of a right-threaded AVL tree is not symmetric.  This means
that we cannot single out left-side rebalancing or right-side
rebalancing as we did before, hand-waving the rest of it as a symmetric
case.  But both cases are very similar, if not exactly symmetric, so we
will present the corresponding cases together.  The theory is exactly
the same as before (*note Rebalancing AVL trees::).  Here is the code
to choose between left-side and right-side rebalancing:

422. <Step 4: Rebalance after RTAVL insertion 422> =
if (y->rtavl_balance == -2)
  {
    <*Note Step 4 Rebalance RTAVL tree after insertion to left:: 423>
  }
else if (y->rtavl_balance == +2)
  {
    <*Note Step 4 Rebalance RTAVL tree after insertion to right:: 424>
  }
else
  return &n->rtavl_data;

z->rtavl_link[y != z->rtavl_link[0]] = w;
return &n->rtavl_data;

This code is included in *Note 419: RTAVL item insertion function.

   The code to choose between the two subcases within the left-side and
right-side rebalancing cases follows below.  As usual during
rebalancing, y is the node at which rebalancing occurs, x is its child
on the same side as the inserted node, and cases are distinguished on
the basis of x's balance factor:

423. <Step 4: Rebalance RTAVL tree after insertion to left 423> =
struct rtavl_node *x = y->rtavl_link[0];
if (x->rtavl_balance == -1)
  {
    <*Note Rebalance for |-| balance factor in RTAVL insertion in left subtree:: 425>
  } 
else
  {
    <*Note Rebalance for |+| balance factor in RTAVL insertion in left subtree:: 427>
  }

This code is included in *Note 422: Step 4 Rebalance after RTAVL
insertion.

424. <Step 4: Rebalance RTAVL tree after insertion to right 424> =
struct rtavl_node *x = y->rtavl_link[1];
if (x->rtavl_balance == +1)
  {
    <*Note Rebalance for |+| balance factor in RTAVL insertion in right subtree:: 426>
  } 
else
  {
    <*Note Rebalance for |-| balance factor in RTAVL insertion in right subtree:: 428>
  }

This code is included in *Note 422: Step 4 Rebalance after RTAVL
insertion.

Case 1: x has taller subtree on side of insertion
.................................................

   If node x's taller subtree is on the same side as the inserted node,
then we perform a rotation at y in the opposite direction.  That is, if
the insertion occurred in the left subtree of y and x has a - balance
factor, we rotate right at y, and if the insertion was to the right and
x has a + balance factor, we rotate left at y.  This changes the
balance of both x and y to zero.  None of this is a change from
unthreaded or fully threaded rebalancing.  The difference is in the
handling of empty subtrees, that is, in the rotation itself (*note
RTBST Rotations::).

   Here is a diagram of left-side rebalancing for the interesting case
where x has a right thread.  Taken along with x's - balance factor,
this means that n, the newly inserted node, must be x's left child.
Therefore, subtree x has height 2, so y has no right child (because it
has a -2 balance factor).  This chain of logic means that we know
exactly what the tree looks like in this particular subcase:

                               |
                               y                |
                             <-->               x
                       __..-'    \             <0>
                       x          []     __..-'   \
                      <->            =>  n          y
                __..-'   \              <0>        <0>
                n         [y]              \          \
               <0>                          [x]        []
                  \
                   [x]
425. <Rebalance for - balance factor in RTAVL insertion in left subtree 425> =
w = x;
if (x->rtavl_rtag == RTAVL_THREAD)
  {
    x->rtavl_rtag = RTAVL_CHILD;
    y->rtavl_link[0] = NULL;
  }
else
  y->rtavl_link[0] = x->rtavl_link[1];
x->rtavl_link[1] = y;
x->rtavl_balance = y->rtavl_balance = 0;

This code is included in *Note 423: Step 4 Rebalance RTAVL tree after
insertion to left.

   Here is the diagram and code for the similar right-side case:

                    |
                    y                        |
                  <++>                       x
                      \                     <0>
                        x             __..-'   \
                       <+>        =>  y          n
                          \          <0>        <0>
                            n           \          \
                           <0>           [x]        []
                              \
                               []
426. <Rebalance for + balance factor in RTAVL insertion in right subtree 426> =
w = x;
if (x->rtavl_link[0] == NULL)
  {
    y->rtavl_rtag = RTAVL_THREAD;
    y->rtavl_link[1] = x;
  }
else
  y->rtavl_link[1] = x->rtavl_link[0];
x->rtavl_link[0] = y;
x->rtavl_balance = y->rtavl_balance = 0;

This code is included in *Note 424: Step 4 Rebalance RTAVL tree after
insertion to right.

Case 2: x has taller subtree on side opposite insertion
.......................................................

   If node x's taller subtree is on the side opposite the newly inserted
node, then we perform a double rotation: first rotate at x in the same
direction as the inserted node, then in the opposite direction at y.
This is the same as in a threaded or unthreaded tree, and indeed we can
reuse much of the code.

   The case where the details differ is, as usual, where threads or null
child pointers are moved around.  In the most extreme case for insertion
to the left, where w is a leaf, we know that x has no left child and s
no right child, and the situation looks like the diagram below before
and after the rebalancing step:

                              |
                              y                |
                            <-->               w
                  ___...---'    \             <0>
                  x              []     __..-'   \
                 <+>                =>  x          y
                    \                  <0>        <0>
                      w                   \          \
                     <0>                   [w]        []
                        \
                         [y]
427. <Rebalance for + balance factor in RTAVL insertion in left subtree 427> =
<*Note Rotate left at |x| then right at |y| in AVL tree:: 156>
if (x->rtavl_link[1] == NULL)
  {
    x->rtavl_rtag = RTAVL_THREAD;
    x->rtavl_link[1] = w;
  }
if (w->rtavl_rtag == RTAVL_THREAD)
  {
    y->rtavl_link[0] = NULL;
    w->rtavl_rtag = RTAVL_CHILD;
  }

This code is included in *Note 423: Step 4 Rebalance RTAVL tree after
insertion to left and *Note 442: Rebalance for |+| balance factor after
right-side RTAVL deletion.

   Here is the code and diagram for right-side insertion rebalancing:

                   |
                   y                          |
                 <++>                         w
                     `--..__                 <0>
                             x         __..-'   \
                            <->    =>  y          x
                      __..-'   \      <0>        <0>
                      w         []       \          \
                     <0>                  [w]        []
                        \
                         [x]
428. <Rebalance for - balance factor in RTAVL insertion in right subtree 428> =
<*Note Rotate right at |x| then left at |y| in AVL tree:: 159>
if (y->rtavl_link[1] == NULL)
  {
    y->rtavl_rtag = RTAVL_THREAD;
    y->rtavl_link[1] = w;
  }
if (w->rtavl_rtag == RTAVL_THREAD)
  {
    x->rtavl_link[0] = NULL;
    w->rtavl_rtag = RTAVL_CHILD;
  }

This code is included in *Note 424: Step 4 Rebalance RTAVL tree after
insertion to right and *Note 441: Rebalance for |-| balance factor
after left-side RTAVL deletion.


File: libavl.info,  Node: Deleting from an RTAVL tree,  Next: Copying an RTAVL Tree,  Prev: Inserting into an RTAVL Tree,  Up: Right-Threaded AVL Trees

11.5 Deletion
=============

   Deletion in an RTAVL tree takes the usual pattern.

429. <RTAVL item deletion function 429> =
void *
rtavl_delete (struct rtavl_table *tree, const void *item)
{
  /* Stack of nodes. */
  struct rtavl_node *pa[RTAVL_MAX_HEIGHT]; /* Nodes. */
  unsigned char da[RTAVL_MAX_HEIGHT];     /* rtavl_link[] indexes. */
  int k;                                  /* Stack pointer. */

  struct rtavl_node *p; /* Traverses tree to find node to delete. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1 Search RTAVL tree for item to delete:: 430>
  <*Note Step 2 Delete RTAVL node:: 431>
  <*Note Steps 3 and 4 Update balance factors and rebalance after RTAVL deletion:: 438>

  return (void *) item;
}

This code is included in *Note 418: RTAVL functions.

* Menu:

* Deleting a RTAVL node step 1 - Search::
* Deleting a RTAVL node step 2 - Delete::
* Deleting a RTAVL node step 3 - Update::
* Deleting a RTAVL node step 4 - Rebalance::


File: libavl.info,  Node: Deleting a RTAVL node step 1 - Search,  Next: Deleting a RTAVL node step 2 - Delete,  Prev: Deleting from an RTAVL tree,  Up: Deleting from an RTAVL tree

11.5.1 Step 1: Search
---------------------

   There's nothing new in searching an RTAVL tree for a node to delete.
We use p to search the tree, and push its chain of parent nodes onto
stack pa[] along with the directions da[] moved down from them,
including the pseudo-root node at the top.

430. <Step 1: Search RTAVL tree for item to delete 430> =
k = 1;
da[0] = 0;
pa[0] = (struct rtavl_node *) &tree->rtavl_root;
p = tree->rtavl_root;
if (p == NULL)
  return NULL;

for (;;)
  {
    int cmp, dir;

    cmp = tree->rtavl_compare (item, p->rtavl_data, tree->rtavl_param);
    if (cmp == 0)
      break;

    dir = cmp > 0;
    if (dir == 0)
      {
        if (p->rtavl_link[0] == NULL)
          return NULL;
      }
    else /* dir == 1 */
      {
        if (p->rtavl_rtag == RTAVL_THREAD)
          return NULL;
      }

    pa[k] = p;
    da[k++] = dir;
    p = p->rtavl_link[dir];
  }
tree->rtavl_count--;
item = p->rtavl_data;

This code is included in *Note 429: RTAVL item deletion function and
*Note 468: RTRB item deletion function.


File: libavl.info,  Node: Deleting a RTAVL node step 2 - Delete,  Next: Deleting a RTAVL node step 3 - Update,  Prev: Deleting a RTAVL node step 1 - Search,  Up: Deleting from an RTAVL tree

11.5.2 Step 2: Delete
---------------------

   As demonstrated in the previous chapter, left-looking deletion,
where we examine the left subtree of the node to be deleted, is more
efficient than right-looking deletion in an RTBST (*note Left-looking
deletion in an RTBST::).  This holds true in an RTAVL tree, too.

431. <Step 2: Delete RTAVL node 431> =
if (p->rtavl_link[0] == NULL)
  {
    if (p->rtavl_rtag == RTAVL_CHILD)
      {
        <*Note Case 1 in RTAVL deletion:: 432>
      }
    else
      {
        <*Note Case 2 in RTAVL deletion:: 433>
      }
  }
else
  {
    struct rtavl_node *r = p->rtavl_link[0];
    if (r->rtavl_rtag == RTAVL_THREAD)
      {
        <*Note Case 3 in RTAVL deletion:: 434>
      }
    else
      {
        <*Note Case 4 in RTAVL deletion:: 435>
      }
  }

tree->rtavl_alloc->libavl_free (tree->rtavl_alloc, p);

This code is included in *Note 429: RTAVL item deletion function.

Case 1: p has a right child but no left child
.............................................

   If the node to be deleted, p, has a right child but not a left child,
then we replace it by its right child.

432. <Case 1 in RTAVL deletion 432> =
pa[k - 1]->rtavl_link[da[k - 1]] = p->rtavl_link[1];

This code is included in *Note 431: Step 2 Delete RTAVL node and *Note
470: Case 1 in RTRB deletion.

Case 2: p has a right thread and no left child
..............................................

   If we are deleting a leaf, then we replace it by a null pointer if
it's a left child, or by a pointer to its own former right thread if
it's a right child.  Refer back to the commentary on <*Note Case 2 in
right-looking RTBST deletion:: 385> for further explanation.

433. <Case 2 in RTAVL deletion 433> =
pa[k - 1]->rtavl_link[da[k - 1]] = p->rtavl_link[da[k - 1]];
if (da[k - 1] == 1)
  pa[k - 1]->rtavl_rtag = RTAVL_THREAD;

This code is included in *Note 431: Step 2 Delete RTAVL node and *Note
471: Case 2 in RTRB deletion.

Case 3: p's left child has a right thread
.........................................

   If p has a left child r, and r has a right thread, then we replace p
by r and transfer p's former right link to r.  Node r also receives p's
balance factor.

434. <Case 3 in RTAVL deletion 434> =
r->rtavl_link[1] = p->rtavl_link[1];
r->rtavl_rtag = p->rtavl_rtag;
r->rtavl_balance = p->rtavl_balance;
pa[k - 1]->rtavl_link[da[k - 1]] = r;
da[k] = 0;
pa[k++] = r;

This code is included in *Note 431: Step 2 Delete RTAVL node.

Case 4: p's left child has a right child
........................................

   The final case, where node p's left child r has a right child, is
also the most complicated.  We find p's predecessor s first:

435. <Case 4 in RTAVL deletion 435> =
struct rtavl_node *s;
int j = k++;

for (;;)
  {
    da[k] = 1;
    pa[k++] = r;
    s = r->rtavl_link[1];
    if (s->rtavl_rtag == RTAVL_THREAD)
      break;

    r = s;
  }

See also *Note 436: Case 4 in RTAVL deletion-2 and *Note 437: Case 4 in
RTAVL deletion-3.
This code is included in *Note 431: Step 2 Delete RTAVL node.

   Then we move s into p's place, not forgetting to update links and
tags as necessary:

436. <Case 4 in RTAVL deletion 435> +=
da[j] = 0;
pa[j] = pa[j - 1]->rtavl_link[da[j - 1]] = s;

if (s->rtavl_link[0] != NULL)
  r->rtavl_link[1] = s->rtavl_link[0];
else
  {
    r->rtavl_rtag = RTAVL_THREAD;
    r->rtavl_link[1] = s;
  }

   Finally, we copy p's old information into s, except for the actual
data:

437. <Case 4 in RTAVL deletion 435> +=
s->rtavl_balance = p->rtavl_balance;
s->rtavl_link[0] = p->rtavl_link[0];
s->rtavl_link[1] = p->rtavl_link[1];
s->rtavl_rtag = p->rtavl_rtag;


File: libavl.info,  Node: Deleting a RTAVL node step 3 - Update,  Next: Deleting a RTAVL node step 4 - Rebalance,  Prev: Deleting a RTAVL node step 2 - Delete,  Up: Deleting from an RTAVL tree

11.5.3 Step 3: Update Balance Factors
-------------------------------------

   Updating balance factors works exactly the same way as in unthreaded
AVL deletion (*note Deleting an AVL node step 3 - Update::).

438. <Steps 3 and 4: Update balance factors and rebalance after RTAVL deletion 438> =
assert (k > 0);
while (--k > 0)
  {
    struct rtavl_node *y = pa[k];

    if (da[k] == 0)
      {
        y->rtavl_balance++;
        if (y->rtavl_balance == +1)
          break;
        else if (y->rtavl_balance == +2)
          {
            <*Note Step 4 Rebalance after RTAVL deletion in left subtree:: 439>
          }
      }
    else
      {
        y->rtavl_balance--;
        if (y->rtavl_balance == -1)
          break;
        else if (y->rtavl_balance == -2)
          {
            <*Note Step 4 Rebalance after RTAVL deletion in right subtree:: 440>
          }
      }
  }

This code is included in *Note 429: RTAVL item deletion function.


File: libavl.info,  Node: Deleting a RTAVL node step 4 - Rebalance,  Prev: Deleting a RTAVL node step 3 - Update,  Up: Deleting from an RTAVL tree

11.5.4 Step 4: Rebalance
------------------------

   Rebalancing in an RTAVL tree after deletion is not completely
symmetric between left-side and right-side rebalancing, but there are
pairs of similar subcases on each side.  The outlines are similar, too.
Either way, rebalancing occurs at node y, and cases are distinguished
based on the balance factor of x, the child of y on the side opposite
the deletion.

439. <Step 4: Rebalance after RTAVL deletion in left subtree 439> =
struct rtavl_node *x = y->rtavl_link[1];

assert (x != NULL);
if (x->rtavl_balance == -1)
  {
    <*Note Rebalance for |-| balance factor after left-side RTAVL deletion:: 441>
  }
else
  {
    pa[k - 1]->rtavl_link[da[k - 1]] = x;
    if (x->rtavl_balance == 0)
      {
        <*Note Rebalance for 0 balance factor after left-side RTAVL deletion:: 443>
        break;
      }
    else /* x->rtavl_balance == +1 */
      {
        <*Note Rebalance for |+| balance factor after left-side RTAVL deletion:: 445>
      }
  }

This code is included in *Note 438: Steps 3 and 4 Update balance
factors and rebalance after RTAVL deletion.

440. <Step 4: Rebalance after RTAVL deletion in right subtree 440> =
struct rtavl_node *x = y->rtavl_link[0];

assert (x != NULL);
if (x->rtavl_balance == +1)
  {
    <*Note Rebalance for |+| balance factor after right-side RTAVL deletion:: 442>
  }
else
  {
    pa[k - 1]->rtavl_link[da[k - 1]] = x;
    if (x->rtavl_balance == 0)
      {
        <*Note Rebalance for 0 balance factor after right-side RTAVL deletion:: 444>
        break;
      }
    else /* x->rtavl_balance == -1 */
      {
        <*Note Rebalance for |-| balance factor after right-side RTAVL deletion:: 446>
      }
  }

This code is included in *Note 438: Steps 3 and 4 Update balance
factors and rebalance after RTAVL deletion.

Case 1: x has taller subtree on same side as deletion
.....................................................

   If the taller subtree of x is on the same side as the deletion, then
we rotate at x in the opposite direction from the deletion, then at y
in the same direction as the deletion. This is the same as case 2 for
RTAVL insertion (*note rtavlinscase2::), which in turn performs the
general transformation described for AVL deletion case 1 (*note
avldelcase1::), and we can reuse the code.

441. <Rebalance for - balance factor after left-side RTAVL deletion 441> =
struct rtavl_node *w;

<*Note Rebalance for |-| balance factor in RTAVL insertion in right subtree:: 428>
pa[k - 1]->rtavl_link[da[k - 1]] = w;

This code is included in *Note 439: Step 4 Rebalance after RTAVL
deletion in left subtree.

442. <Rebalance for + balance factor after right-side RTAVL deletion 442> =
struct rtavl_node *w;

<*Note Rebalance for |+| balance factor in RTAVL insertion in left subtree:: 427>
pa[k - 1]->rtavl_link[da[k - 1]] = w;

This code is included in *Note 440: Step 4 Rebalance after RTAVL
deletion in right subtree.

Case 2: x's subtrees are equal height
.....................................

   If x's two subtrees are of equal height, then we perform a rotation
at y toward the deletion.  This rotation cannot be troublesome, for the
same reason discussed for rebalancing in TAVL trees (*note
tavldelcase2::).  We can even reuse the code:

443. <Rebalance for 0 balance factor after left-side RTAVL deletion 443> =
<*Note Rebalance for 0 balance factor after TAVL deletion in left subtree:: 321>

This code is included in *Note 439: Step 4 Rebalance after RTAVL
deletion in left subtree.

444. <Rebalance for 0 balance factor after right-side RTAVL deletion 444> =
<*Note Rebalance for 0 balance factor after TAVL deletion in right subtree:: 325>

This code is included in *Note 440: Step 4 Rebalance after RTAVL
deletion in right subtree.

Case 3: x has taller subtree on side opposite deletion
......................................................

   When x's taller subtree is on the side opposite the deletion, we
rotate at y toward the deletion, same as case 2.  If the deletion was
on the left side of y, then the general form is the same as for TAVL
deletion (*note tavldelcase3::).  The special case for left-side
deletion, where x lacks a left child, and the general form of the code,
are shown here:

                    |
                    y                        |
                  <++>                       x
                      \                     <0>
                        x             __..-'   \
                       <+>        =>  y          c
                          \          <0>        <0>
                            c           \          \
                           <0>           [x]        []
                              \
                               []
445. <Rebalance for + balance factor after left-side RTAVL deletion 445> =
if (x->rtavl_link[0] != NULL)
  y->rtavl_link[1] = x->rtavl_link[0];
else
  y->rtavl_rtag = RTAVL_THREAD;
x->rtavl_link[0] = y;  
y->rtavl_balance = x->rtavl_balance = 0;

This code is included in *Note 439: Step 4 Rebalance after RTAVL
deletion in left subtree.

   The special case for right-side deletion, where x lacks a right
child, and the general form of the code, are shown here:

                               |
                               y                |
                             <-->               x
                       __..-'    \             <0>
                       x          []     __..-'   \
                      <->            =>  a          y
                __..-'   \              <0>        <0>
                a         [y]              \          \
               <0>                          [x]        []
                  \
                   [x]
446. <Rebalance for - balance factor after right-side RTAVL deletion 446> =
if (x->rtavl_rtag == RTAVL_CHILD)
  y->rtavl_link[0] = x->rtavl_link[1];
else
  {
    y->rtavl_link[0] = NULL;
    x->rtavl_rtag = RTAVL_CHILD;
  }
x->rtavl_link[1] = y;  
y->rtavl_balance = x->rtavl_balance = 0;

This code is included in *Note 440: Step 4 Rebalance after RTAVL
deletion in right subtree.

Exercises:

1. In the chapter about TAVL deletion, we offered two implementations of
deletion: one using a stack (<*Note TAVL item deletion function with
stack:: 659>) and one using an algorithm to find node parents (<*Note
TAVL item deletion function:: 311>).  For RTAVL deletion, we offer only
a stack-based implementation.  Why?

2. The introduction to this section states that left-looking deletion is
more efficient than right-looking deletion in an RTAVL tree.  Confirm
this by writing a right-looking alternate implementation of <*Note Step
2 Delete RTAVL node:: 431> and comparing the two sets of code.

3. Rewrite <*Note Case 4 in RTAVL deletion:: 435> to replace the
deleted node's rtavl_data by its successor, then delete the successor,
instead of shuffling pointers.  (Refer back to Exercise 5.8-3 for an
explanation of why this approach cannot be used in `libavl'.)


File: libavl.info,  Node: Copying an RTAVL Tree,  Next: Testing RTAVL Trees,  Prev: Deleting from an RTAVL tree,  Up: Right-Threaded AVL Trees

11.6 Copying
============

   We can reuse most of the RTBST copying functionality for copying
RTAVL trees, but we must modify the node copy function to copy the
balance factor into the new node as well.

447. <RTAVL copy function 447> =
<*Note RTAVL node copy function:: 448>
<*Note RTBST copy error helper function:: 405>
<*Note RTBST main copy function:: 403>

This code is included in *Note 418: RTAVL functions and *Note 455: RTRB
functions.

448. <RTAVL node copy function 448> =
static int
copy_node (struct rtavl_table *tree,
           struct rtavl_node *dst, int dir,
           const struct rtavl_node *src, rtavl_copy_func *copy)
{
  struct rtavl_node *new = tree->rtavl_alloc->libavl_malloc (tree->rtavl_alloc,
                                                             sizeof *new);
  if (new == NULL)
    return 0;

  new->rtavl_link[0] = NULL;
  new->rtavl_rtag = RTAVL_THREAD;
  if (dir == 0)
    new->rtavl_link[1] = dst;
  else
    {
      new->rtavl_link[1] = dst->rtavl_link[1];
      dst->rtavl_rtag = RTAVL_CHILD;
    }
  dst->rtavl_link[dir] = new;

  new->rtavl_balance = src->rtavl_balance;

  if (copy == NULL)
    new->rtavl_data = src->rtavl_data;
  else
    {
      new->rtavl_data = copy (src->rtavl_data, tree->rtavl_param);
      if (new->rtavl_data == NULL)
        return 0;
    }

  return 1;
}

This code is included in *Note 447: RTAVL copy function.

