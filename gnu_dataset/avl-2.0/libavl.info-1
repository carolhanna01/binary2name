This is libavl.info, produced by makeinfo version 4.0b from libavl.texi.


File: libavl.info,  Node: Top,  Next: Preface,  Prev: (dir),  Up: (dir)

GNU `libavl' 2.0
****************

* Menu:

* Preface::
* Introduction::
* The Table ADT::
* Search Algorithms::
* Binary Search Trees::
* AVL Trees::
* Red-Black Trees::
* Threaded Binary Search Trees::
* Threaded AVL Trees::
* Threaded Red-Black Trees::
* Right-Threaded Binary Search Trees::
* Right-Threaded AVL Trees::
* Right-Threaded Red-Black Trees::
* BSTs with Parent Pointers::
* AVL Trees with Parent Pointers::
* Red-Black Trees with Parent Pointers::
* References::
* Supplementary Code::
* Glossary::
* Answers to All the Exercises::
* Catalogue of Algorithms::
* Index::


File: libavl.info,  Node: Preface,  Next: Introduction,  Prev: Top,  Up: Top

Preface
*******

   Early in 1998, I wanted an AVL tree library for use in writing GNU
PSPP.  At the time, few of these were available on the Internet.  Those
that were had licenses that were not entirely satisfactory for
inclusion in GNU software.  I resolved to write my own.  I sat down
with Knuth's _The Art of Computer Programming_ and did so.  The result
was the earliest version of `libavl'.  As I wrote it, I learned
valuable lessons about implementing algorithms for binary search trees,
and covered many notebook pages with scribbled diagrams.

   Later, I decided that what I really wanted was a similar library for
threaded AVL trees, so I added an implementation to `libavl'.  Along
the way, I ended up having to relearn many of the lessons I'd already
painstakingly uncovered in my earlier work.  Even later, I had much the
same experience in writing code for right-threaded AVL trees and
red-black trees, which was done as much for my own education as any
intention of using the code in real software.

   In late 1999, I contributed a chapter on binary search trees and
balanced trees to a book on programming in C.  This again required a
good deal of duplication of effort as I rediscovered old techniques.
By now I was beginning to see the pattern, so I decided to document
once and for all the algorithms I had chosen and the tradeoffs I had
made.  Along the way, the project expanded in scope several times.

   You are looking at the results.  I hope you find that it is as useful
for reading and reference as I found that writing it was enjoyable for
me.  As I wrote later chapters, I referred less and less to my other
reference books and more and more to my own earlier chapters, so I
already know that it can come in handy for me.  (On the other hand, GNU
PSPP, the program that started off the whole saga, has been long
neglected and development may never resume.  It would need to be
rewritten from the top anyhow.)

   Please feel free to copy and distribute this book, in accordance with
the license agreement.  If you make multiple printed copies, consider
contacting me by email first to check whether there are any
late-breaking corrections or new editions in the pipeline.  Also, if
you are willing to print an extra copy, bind it nicely, and ship it to
me, please drop me an email so that I can provide you with my current
mailing address.  I do not have the kind of resources to print even one
copy of a 400-plus page book for myself.

* Menu:

* Acknowledgements::
* Contacting the Author::


File: libavl.info,  Node: Acknowledgements,  Next: Contacting the Author,  Prev: Preface,  Up: Preface

Acknowledgements
================

   `libavl' has grown into its current state over a period of years.
During that time, many people have contributed advice, bug reports, and
occasional code fragments.  I have attempted to individually
acknowledge all of these people, along with their contributions, in the
`NEWS' and `ChangeLog' files included with the `libavl' source
distribution.  Without their help, `libavl' would not be what it is
today.  If you believe that you should be listed in one of these files,
but are not, please contact me.

   Many people have indirectly contributed by providing computer science
background and software infrastructure, without which `libavl' would
not have been possible at all.  For a partial list, please see `THANKS'
in the `libavl' source distribution.

   Special thanks are due to Erik Goodman of the A. H. Case Center for
Computer-Aided Engineering and Manufacturing at Michigan State
University for making it possible for me to receive MSU honors credit
for rewriting `libavl' as a literate program, and to Dann Corbit for
his invaluable suggestions during development.


File: libavl.info,  Node: Contacting the Author,  Prev: Acknowledgements,  Up: Preface

Contacting the Author
=====================

   `libavl', including this book, the source code, the TexiWEB software,
and related programs, was written by Ben Pfaff, who welcomes your
feedback.  Please send address `libavl'-related correspondence,
including bug reports and suggestions for improvement, to him at
<blp@gnu.org>.

   Ben received his B.S. in electrical engineering from Michigan State
University in May 2001.  He is now studying for a Ph.D. in computer
science at Stanford University as a Stanford Graduate Fellow.

   Ben's personal webpage is at `http://www.msu.edu/~pfaffben', where
you can find a list of his current projects, including the status of
`libavl' test releases.  You can also find him hanging out in the
Internet newsgroup comp.lang.c.


File: libavl.info,  Node: Introduction,  Next: The Table ADT,  Prev: Preface,  Up: Top

1 Introduction
**************

   `libavl' is a library in ANSI C for manipulation of various types of
binary trees.  This book provides an introduction to binary tree
techniques and presents all of `libavl''s source code, along with
annotations and exercises for the reader.  It also includes practical
information on how to use `libavl' in your programs and discussion of
the larger issues of how to choose efficient data structures and
libraries.  The book concludes with suggestions for further reading,
answers to all the exercises, glossary, and index.

* Menu:

* Audience::
* Reading the Code::
* Code Conventions::
* Code License::


File: libavl.info,  Node: Audience,  Next: Reading the Code,  Prev: Introduction,  Up: Introduction

1.1 Audience
============

   This book is intended both for novices interested in finding out
about binary search trees and practicing programmers looking for a
cookbook of algorithms.  It has several features that will be
appreciated by both groups:

   * Tested code: With the exception of code presented as
     counterexamples, which are clearly marked, all code presented has
     been tested.  Most code comes with a working program for testing or
     demonstrating it.

   * No pseudo-code: Pseudo-code can be confusing, so it is not used.

   * Motivation: An important goal is to demonstrate general methods for
     programming, not just the particular algorithms being examined.
     As a result, the rationale for design choices is explained
     carefully.

   * Exercises and answers: To clarify issues raised within the text,
     many sections conclude with exercises.  All exercises come with
     complete answers in an appendix at the back of the book.

     Some exercises are marked with one or more stars (*).  Exercises
     without stars are recommended for all readers, but starred
     exercises deal with particularly obscure topics or make reference
     to topics covered later.

     Experienced programmers should find the exercises particularly
     interesting, because many of them present alternatives to choices
     made in the main text.

   * Asides: Occasionally a section is marked as an "aside".  Like
     exercises, asides often highlight alternatives to techniques in the
     main text, but asides are more extensive than most exercises.
     Asides are not essential to comprehension of the main text, so
     readers not interested may safely skip over them to the following
     section.

   * Minimal C knowledge assumed: Basic familiarity with the C language
     is assumed, but obscure constructions are briefly explained the
     first time they occur.

     Those who wish for a review of C language features before beginning
     should consult *Note Summit 1999::.  This is especially recommended
     for novices who feel uncomfortable with pointer and array concepts.

   * References: When appropriate, other texts that cover the same or
     related material are referenced at the end of sections.

   * Glossary: Terms are "emphasized" and defined the first time they
     are used.  Definitions for these terms and more are collected into
     a glossary at the back of the book.

   * Catalogue of algorithms: *Note Catalogue of Algorithms::, for a
     handy list of all the algorithms implemented in this book.


File: libavl.info,  Node: Reading the Code,  Next: Code Conventions,  Prev: Audience,  Up: Introduction

1.2 Reading the Code
====================

   This book contains all the source code to `libavl'.  Conversely, much
of the source code presented in this book is part of `libavl'.

   `libavl' is written in ANSI/ISO C89 using TexiWEB, a "literate
programming" (*note literate programming::) system.  Literate
programming is a philosophy that regards software as a kind of
literature.  The ideas behind literate programming have been around for
a long time, but the term itself was invented by computer scientist
Donald Knuth in 1984, who wrote two of his most famous programs (TeX
and METAFONT) with a literate programming system of his own design.
That system, called WEB, inspired the form and much of the syntax of
TexiWEB.

   A TexiWEB document is a C program that has been cut into sections,
rearranged, and annotated, with the goal to make the program as a whole
as comprehensible as possible to a reader who starts at the beginning
and reads the entire program in order.  Of course, understanding large,
complex programs cannot be trivial, but TexiWEB tries to make it as
easy as possible.

   Each section of a TexiWEB program is assigned both a number and a
name.  Section numbers are assigned sequentially, starting from 1 with
the first section, and they are used for cross-references between
sections.  Section names are words or phrases assigned by the TexiWEB
program's author to describe the role of the section's code.

   Here's a sample TexiWEB section:

19. <Clear hash table entries 19> =
for (i = 0; i < hash->m; i++)
  hash->entry[i] = NULL;

This code is included in *Note 15: Initialize hash table.

   The first line of a section, as shown here, gives the section's name
and its number within angle brackets.  The section number is also given
at the left margin to make individual sections easy to find.

   Code segments often contain references to other code segments, shown
as a section name and number within angle brackets.  These act something
like macros, in that they stand for the corresponding replacement text.
For instance, consider the following segment:

15. <Initialize hash table 15> =
hash->m = 13;
<*Note Clear hash table entries:: 19>

See also *Note 16: Initialize hash table-2.

   This means that the code for `Clear hash table entries' should be
inserted as part of `Initialize hash table'.  Because the name of a
section explains what it does, it's often unnecessary to know anything
more.  If you do want more detail, the section number 19 in <*Note
Clear hash table entries:: 19> can easily be used to find the full text
and annotations for `Clear hash table entries'.  At the bottom of
section 19 you will find a note reading `This code is included in *Note
15: Initialize hash table.', making it easy to move back to section 15
that includes it.

   There's also a note following the code in the section above: `See
also *Note 16: Initialize hash table-2.'.  This demonstrates how
TexiWEB handles multiple sections that have the same name.  When a name
that corresponds to multiple sections is referenced, code from all the
sections with that name is substituted, in order of appearance.  The
first section with the name ends with a note listing the numbers of all
other same-named sections.  Later sections show their own numbers in
the left margin, but the number of the first section within angle
brackets, to make the first section easy to find.  For example, here's
another line of code for <*Note Clear hash table entries:: 15>:

16. <Initialize hash table 15> +=
hash->n = 0;

   Code segment references have one more feature: the ability to do
special macro replacements within the referenced code.  These
replacements are made on all words within the code segment referenced
and recursively within code segments that the segment references, and
so on.  Word prefixes as well as full words are replaced, as are even
occurrences within comments in the referenced code.  Replacements take
place regardless of case, and the case of the replacement mirrors the
case of the replaced text. This odd feature is useful for adapting a
section of code written for one library having a particular identifier
prefix for use in a different library with another identifier prefix.
For instance, the reference `<BST types; bst => avl>' inserts the
contents of the segment named `BST types', replacing `bst' by `avl'
wherever the former appears at the beginning of a word.

   When a TexiWEB program is converted to C, conversion conceptually
begins from sections named for files; e.g., <`foo.c' 37>.  Within these
sections, all section references are expanded, then references within
those sections are expanded, and so on.  When expansion is complete,
the specified files are written out.

   A final resource in reading a TexiWEB is the index, which contains an
entry for the points of declaration of every section name, function,
type, structure, union, global variable, and macro.  Declarations within
functions are not indexed.

See also:  *Note Knuth 1992::, "How to read a WEB".


File: libavl.info,  Node: Code Conventions,  Next: Code License,  Prev: Reading the Code,  Up: Introduction

1.3 Code Conventions
====================

   Where possible, the `libavl' source code complies to the requirements
imposed by ANSI/ISO C89 and C99.  Features present only in C99 are not
used. In addition, most of the GNU Coding Standards are followed.
Indentation style is an exception to the latter: in print, to conserve
vertical space, K&R indentation style is used instead of GNU style.

See also:  *Note ISO 1990::; *Note ISO 1999::; *Note FSF 2001::,
"Writing C".


File: libavl.info,  Node: Code License,  Prev: Code Conventions,  Up: Introduction

1.4 License
===========

   This book, including the code in it, is subject to the following
license:

1. <License 1> =
/* GNU `libavl' - library for manipulation of binary trees.
   Copyright (C) 1998--2002 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
   See the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.

   The author may be contacted at <blp@gnu.org> on the Internet, or
   as Ben Pfaff, 12167 Airport Rd, DeWitt MI 48820, USA through more 
   mundane means. 
*/

This code is included in *Note 24: bsth, *Note 25: bstc, *Note 97:
testc, *Note 98: bst-testc, *Note 99: testh, *Note 142: avlh, *Note
143: avlc, *Note 186: avl-testc, *Note 192: rbh, *Note 193: rbc, *Note
238: rb-testc, *Note 247: tbsth, *Note 248: tbstc, *Note 290:
tbst-testc, *Note 297: tavlh, *Note 298: tavlc, *Note 330: tavl-testc,
*Note 333: trbh, *Note 334: trbc, *Note 368: trb-testc, *Note 372:
rtbsth, *Note 373: rtbstc, *Note 411: rtbst-testc, *Note 415: rtavlh,
*Note 416: rtavlc, *Note 449: rtavl-testc, *Note 452: rtrbh, *Note 453:
rtrbc, *Note 482: rtrb-testc, *Note 486: pbsth, *Note 487: pbstc, *Note
515: pbst-testc, *Note 519: pavlh, *Note 520: pavlc, *Note 548:
pavl-testc, *Note 551: prbh, *Note 552: prbc, *Note 583: prb-testc,
*Note 595: seq-testc, *Note 599: srch-testc, *Note 617: bin-ary-testc,
and *Note 649: bstsc.


File: libavl.info,  Node: The Table ADT,  Next: Search Algorithms,  Prev: Introduction,  Up: Top

2 The Table ADT
***************

   Most of the chapters in this book implement a table structure as some
kind of binary tree, so it is important to understand what a table is
before we begin.  That is this chapter's purpose.

   This chapter begins with a brief definition of the meaning of "table"
for the purposes of this book, then moves on to describe in a more
formal way the interface of a table used by all of the tables in this
book.  The next chapter motivates the basic idea of a binary tree
starting from simple, everyday concepts.  Experienced programmers may
skip these chapters after skimming through the definitions below.

* Menu:

* Informal Definition::
* Identifiers::
* Comparison Function::
* Item and Copy Functions::
* Memory Allocation::
* Creation and Destruction::
* Count::
* Insertion and Deletion::
* Assertions::
* Traversers::
* Table Headers::
* Additional Exercises for Tables::


File: libavl.info,  Node: Informal Definition,  Next: Identifiers,  Prev: The Table ADT,  Up: The Table ADT

2.1 Informal Definition
=======================

   If you've written even a few programs, you've probably noticed the
necessity for searchable collections of data.  Compilers search their
symbol tables for identifiers and network servers often search tables to
match up data with users.  Many applications with graphical user
interfaces deal with mouse and keyboard activity by searching a table of
possible actions.  In fact, just about every nontrivial program,
regardless of application domain, needs to maintain and search tables of
some kind.

   In this book, the term "table" does not refer to any particular data
structure.  Rather, it is the name for a abstract data structure or ADT,
defined in terms of the operations that can be performed on it.  A table
ADT can be implemented in any number of ways.  Later chapters will show
how to implement tables in terms of various binary tree data structures.

   The purpose of a table is to keep track of a collection of items,
all of the same type.  Items can be inserted into and deleted from a
table, with no arbitrary limit on the number of items in the table.  We
can also search a table for items that match a given item.

   Other operations are supported, too.  Traversal is the most
important of these: all of the items in a table can be visited, in
sorted order from smallest to largest, or from largest to smallest.
Traversals can also start from an item in the middle, or a newly
inserted item, and move in either direction.

   The data in a table may be of any C type, but all the items in a
table must be of the same type.  Structure types are common.  Often,
only part of each data item is used in item lookup, with the rest for
storage of auxiliary information.  A table that contains two-part data
items like this is called a "dictionary" or an "associative array".
The part of table data used for lookup, whether the table is a
dictionary or not, is the "key".  In a dictionary, the remainder is the
"value".

   Our tables cannot contain duplicates.  An attempt to insert an item
into a table that already contains a matching item will fail.

Exercises:

1. Suggest a way to simulate the ability to insert duplicate items in a
table.


File: libavl.info,  Node: Identifiers,  Next: Comparison Function,  Prev: Informal Definition,  Up: The Table ADT

2.2 Identifiers
===============

   In C programming it is necessary to be careful if we expect to avoid
clashes between our own names and those used by others.  Any identifiers
that we pick might also be used by others.  The usual solution is to
adopt a prefix that is applied to the beginning of every identifier that
can be visible in code outside a single source file.  In particular,
most identifiers in a library's public header files must be prefixed.

   `libavl' is a collection of mostly independent modules, each of which
implements the table ADT.  Each module has its own, different identifier
prefix.  Identifiers that begin with this prefix are reserved for any
use in source files that #include the module header file.  Also
reserved (for use as macro names) are identifiers that begin with the
all-uppercase version of the prefix.  Both sets of identifiers are also
reserved as external names(1) throughout any program that uses the
module.

   In addition, all identifiers that begin with libavl_ or LIBAVL_ are
reserved for any use in source files that #include any `libavl' module.
Likewise, these identifiers are reserved as external names in any
program that uses any `libavl' module.  This is primarily to allow for
future expansion, but see *Note Memory Allocation:: and Exercise 3.5-1
for a sample use.

   The prefix used in code samples in this chapter is tbl_, short for
"table".  This can be considered a generic substitute for the prefix
used by any of the table implementation.  All of the statements about
these functions here apply equally to all of the table implementation in
later chapters, except that the tbl_ prefix must be replaced by the
prefix used by the chapter's table implementation.

Exercises:

1. The following kinds of identifiers are among those that might appear
in a header file.  Which of them can be safely appear unprefixed?  Why?

  a. Parameter names within function prototypes.

  b. Macro parameter names.

  c. Structure and union tags.

  d. Structure and union member names.

2. Suppose that we create a module for reporting errors.  Why is err_ a
poorly chosen prefix for the module's identifiers?

   ---------- Footnotes ----------

   (1) External names are identifiers visible outside a single source
file.  These are, mainly, non-static functions and variables declared
outside a function.


File: libavl.info,  Node: Comparison Function,  Next: Item and Copy Functions,  Prev: Identifiers,  Up: The Table ADT

2.3 Comparison Function
=======================

   The C language provides the void * generic pointer for dealing with
data of unknown type.  We will use this type to allow our tables to
contain a wide range of data types.  This flexibility does keep the
table from working directly with its data.  Instead, the table's user
must provide means to operate on data items.  This section describes
the user-provided functions for comparing items, and the next section
describes two other kinds of user-provided functions.

   There is more than one kind of generic algorithm for searching.  We
can search by comparison of keys, by digital properties of the keys, or
by computing a function of the keys.  In this book, we are only
interested in the first possibility, so we need a way to compare data
items.  This is done with a user-provided function compatible with
tbl_comparison_func, declared as follows:

2. <Table function types 2> =
/* Function types. */
typedef int tbl_comparison_func (const void *tbl_a, const void *tbl_b,
                                 void *tbl_param);

See also *Note 4: Table function types-2.
This code is included in *Note 14: Table types.

   A comparison function takes two pointers to data items, here called a
and b, and compares their keys.  It returns a negative value if a < b,
zero if a == b, or a positive value if a > b.  It takes a third
parameter, here called param, which is user-provided.

   A comparison function must work more or less like an arithmetic
comparison within the domain of the data.  This could be alphabetical
ordering for strings, a set of nested sort orders (e.g., sort first by
last name, with duplicates by first name), or any other comparison
function that behaves in a "natural" way.  A comparison function in the
exact class of those acceptable is called a "strict weak ordering", for
which the exact rules are explained in Exercise 5.

   Here's a function that can be used as a comparison function for the
case that the void * pointers point to single ints:

3. <Comparison function for ints 3> =
/* Comparison function for pointers to ints.
   param is not used. */
int
compare_ints (const void *pa, const void *pb, void *param)
{
  const int *a = pa;
  const int *b = pb;

  if (*a < *b)
    return -1;
  else if (*a > *b)
    return +1;
  else
    return 0;
}

This code is included in *Note 134: Test utility functions.

   Here's another comparison function for data items that point to
ordinary C strings:

/* Comparison function for strings.
   param is not used. */
int
compare_strings (const void *pa, const void *pb, void *param)
{
  return strcmp (pa, pb);
}

See also:  *Note FSF 1999::, node "Defining the Comparison Function";
*Note ISO 1998::, section 25.3, "Sorting and related operations"; *Note
SGI 1993::, section "Strict Weak Ordering".

Exercises:

1. In C, integers may be cast to pointers, including void *, and vice
versa.  Explain why it is not a good idea to use an integer cast to
void * as a data item.  When would such a technique would be acceptable?

2. When would the following be an acceptable alternate definition for
compare_ints()?

int
compare_ints (const void *pa, const void *pb, void *param)
{
  return *((int *) pa) - *((int *) pb);
}

3. Could strcmp(), suitably cast, be used in place of compare_strings()?

4. Write a comparison function for data items that, in any particular
table, are character arrays of fixed length.  Among different tables,
the length may differ, so the third parameter to the function points to
a size_t specifying the length for a given table.

*5. For a comparison function f() to be a strict weak ordering, the
following must hold for all possible data items a, b, and c:

   * _Irreflexivity:_ For every a, f(a, a) == 0.

   * _Antisymmetry_: If f(a, b) > 0, then f(b, a) < 0.

   * _Transitivity_: If f(a, b) > 0 and f(b, c) > 0, then f(a, c) > 0.

   * _Transitivity of equivalence_: If f(a, b) == 0 and f(b, c) == 0,
     then f(a, c) == 0.

Consider the following questions that explore the definition of a strict
weak ordering.

  a. Explain how compare_ints() above satisfies each point of the
     definition.

  b. Can the standard C library function strcmp() be used for a strict
     weak ordering?

  c. Propose an irreflexive, antisymmetric, transitive function that
     lacks transitivity of equivalence.

*6. `libavl' uses a ternary comparison function that returns a negative
value for <, zero for ==, positive for >.  Other libraries use binary
comparison functions that return nonzero for < or zero for >=.
Consider these questions about the differences:

  a. Write a C expression, in terms of a binary comparison function f()
     and two items a and b, that is nonzero if and only if a == b as
     defined by f().  Write a similar expression for a > b.

  b. Write a binary comparison function "wrapper" for a `libavl'
     comparison function.

  c. Rewrite bst_find() based on a binary comparison function.  (You can
     use the wrapper from above to simulate a binary comparison
     function.)


File: libavl.info,  Node: Item and Copy Functions,  Next: Memory Allocation,  Prev: Comparison Function,  Up: The Table ADT

2.4 Item and Copy Functions
===========================

   Besides tbl_comparison_func, there are two kinds of functions used in
`libavl' to manipulate item data:

4. <Table function types 2> +=
typedef void tbl_item_func (void *tbl_item, void *tbl_param);
typedef void *tbl_copy_func (void *tbl_item, void *tbl_param);

Both of these function types receive a table item as their first
argument tbl_item and the tbl_param associated with the table as their
second argument.  This tbl_param is the same one passed as the third
argument to tbl_comparison_func.  `libavl' will never pass a null
pointer as tbl_item to either kind of function.

   A tbl_item_func performs some kind of action on tbl_item.  The
particular action that it should perform depends on the context in which
it is used and the needs of the calling program.

   A tbl_copy_func creates and returns a new copy of tbl_item.  If
copying fails, then it returns a null pointer.


File: libavl.info,  Node: Memory Allocation,  Next: Creation and Destruction,  Prev: Item and Copy Functions,  Up: The Table ADT

2.5 Memory Allocation
=====================

   The standard C library functions malloc() and free() are the usual
way to obtain and release memory for dynamic data structures like
tables.  Most users will be satisfied if `libavl' uses these routines
for memory management.  On the other hand, some users will want to
supply their own methods for allocating and freeing memory, perhaps even
different methods from table to table.  For these users' benefit, each
table is associated with a memory allocator, which provides functions
for memory allocation and deallocation.  This allocator has the same
form in each table implementation.  It looks like this:

5. <Memory allocator 5> =
#ifndef LIBAVL_ALLOCATOR
#define LIBAVL_ALLOCATOR
/* Memory allocator. */
struct libavl_allocator
  {
    void *(*libavl_malloc) (struct libavl_allocator *, size_t libavl_size);
    void (*libavl_free) (struct libavl_allocator *, void *libavl_block);
  };
#endif

This code is included in *Note 14: Table types, *Note 99: testh, and
*Note 649: bstsc.

   Members of struct libavl_allocator have the same interfaces as the
like-named standard C library functions, except that they are each
additionally passed a pointer to the struct libavl_allocator * itself
as their first argument.  The table implementations never call
tbl_malloc() with a zero size or tbl_free() with a null pointer block.

   The struct libavl_allocator type is shared between all of `libavl''s
modules, so its name begins with libavl_, not with the specific module
prefix that we've been representing generically here as tbl_.  This
makes it possible for a program to use a single allocator with multiple
`libavl' table modules, without the need to declare instances of
different structures.

   The default allocator is just a wrapper around malloc() and free().
Here it is:

6. <Default memory allocation functions 6> =
/* Allocates size bytes of space using malloc().
   Returns a null pointer if allocation fails. */
void *
tbl_malloc (struct libavl_allocator *allocator, size_t size)
{
  assert (allocator != NULL && size > 0);
  return malloc (size);
}

/* Frees block. */
void
tbl_free (struct libavl_allocator *allocator, void *block)
{
  assert (allocator != NULL && block != NULL);
  free (block);
}

/* Default memory allocator that uses malloc() and free(). */
struct libavl_allocator tbl_allocator_default =
  {
    tbl_malloc,
    tbl_free
  };

This code is included in *Note 29: BST operations, *Note 145: AVL
functions, *Note 196: RB functions, *Note 251: TBST functions, *Note
300: TAVL functions, *Note 336: TRB functions, *Note 375: RTBST
functions, *Note 418: RTAVL functions, *Note 455: RTRB functions, *Note
489: PBST functions, *Note 522: PAVL functions, *Note 554: PRB
functions, and *Note 649: bstsc.

   The default allocator comes along with header file declarations:

7. <Default memory allocator header 7> =
/* Default memory allocator. */
extern struct libavl_allocator tbl_allocator_default;
void *tbl_malloc (struct libavl_allocator *, size_t);
void tbl_free (struct libavl_allocator *, void *);

This code is included in *Note 14: Table types and *Note 649: bstsc.

See also:  *Note FSF 1999::, nodes "Malloc Examples" and "Changing Block
Size".

Exercises:

1. This structure is named with a libavl_ prefix because it is shared
among all of `libavl''s module.  Other types are shared among `libavl'
modules, too, such as tbl_item_func.  Why don't the names of these
other types also begin with libavl_?

2. Supply an alternate allocator, still using malloc() and free(), that
prints an error message to stderr and aborts program execution when
memory allocation fails.

*3. Some kinds of allocators may need additional arguments.  For
instance, if memory for each table is taken from a separate
Apache-style "memory pool", then a pointer to the pool structure is
needed.  Show how this can be done without modifying existing types.


File: libavl.info,  Node: Creation and Destruction,  Next: Count,  Prev: Memory Allocation,  Up: The Table ADT

2.6 Creation and Destruction
============================

   This section describes the functions that create and destroy tables.

8. <Table creation function prototypes 8> =
/* Table functions. */
struct tbl_table *tbl_create (tbl_comparison_func *, void *,
                              struct libavl_allocator *);
struct tbl_table *tbl_copy (const struct tbl_table *, tbl_copy_func *,
                            tbl_item_func *, struct libavl_allocator *);
void tbl_destroy (struct tbl_table *, tbl_item_func *);

This code is included in *Note 15: Table function prototypes.

   * tbl_create(): Creates and returns a new, empty table as a
     struct tbl_table *.  The table is associated with the given
     arguments.  The void * argument is passed as the third argument to
     the comparison function when it is called.  If the allocator is a
     null pointer, then tbl_allocator_default is used.

   * tbl_destroy(): Destroys a table.  During destruction, the
     tbl_item_func provided, if non-null, is called once for every item
     in the table, in no particular order.  The function, if provided,
     must not invoke any table function or macro on the table being
     destroyed.

   * tbl_copy(): Creates and returns a new table with the same contents
     as the existing table passed as its first argument. Its other three
     arguments may all be null pointers.

     If a tbl_copy_func is provided, then it is used to make a copy of
     each table item as it is inserted into the new table, in no
     particular order (a "deep copy" (*note deep copy::)).  Otherwise,
     the void * table items are copied verbatim (a "shallow copy"
     (*note shallow copy::)).

     If the table copy fails, either due to memory allocation failure
     or a null pointer returned by the tbl_copy_func, tbl_copy()
     returns a null pointer.  In this case, any provided tbl_item_func
     is called once for each new item already copied, in no particular
     order.

     By default, the new table uses the same memory allocator as the
     existing one.  If non-null, the struct libavl_allocator * given is
     used instead as the new memory allocator.  To use the
     tbl_allocator_default allocator, specify &tbl_allocator_default
     explicitly.


File: libavl.info,  Node: Count,  Next: Insertion and Deletion,  Prev: Creation and Destruction,  Up: The Table ADT

2.7 Count
=========

   This function returns the number of items currently in a table.

9. <Table count function prototype 9> =
size_t tbl_count (const struct tbl_table *);

The actual tables instead use a macro for implementation.

Exercises:

1. Implement tbl_count() as a macro, on the assumption that struct
tbl_table keeps the number of items in the table in a size_t member
named tbl_count.


File: libavl.info,  Node: Insertion and Deletion,  Next: Assertions,  Prev: Count,  Up: The Table ADT

2.8 Insertion and Deletion
==========================

   These functions insert and delete items in tables.  There is also a
function for searching a table without modifying it.

   The design behind the insertion functions takes into account a
couple of important issues:

   * What should happen if there is a matching item already in the
     tree?  If the items contain only keys and no values, then there's
     no point in doing anything.  If the items do contain values, then
     we might want to leave the existing item or replace it, depending
     on the particular circumstances.  The tbl_insert() and
     tbl_replace() functions are handy in simple cases like these.

   * Occasionally it is convenient to insert one item into a table, then
     immediately replace it by a different item that has identical key
     data.  For instance, if there is a good chance that a data item
     already exists within a table, then it might make sense to insert
     data allocated as a local variable into a table, then replace it
     by a dynamically allocated copy if it turned out that the item
     wasn't already in the table.  That way, we save the time required
     to make an additional copy of the item to insert.  The tbl_probe()
     function allows for this kind of flexibility.

10. <Table insertion and deletion function prototypes 10> =
void **tbl_probe (struct tbl_table *, void *);
void *tbl_insert (struct tbl_table *, void *);
void *tbl_replace (struct tbl_table *, void *);
void *tbl_delete (struct tbl_table *, const void *);
void *tbl_find (const struct tbl_table *, const void *);

This code is included in *Note 15: Table function prototypes.

Each of these functions takes a table to manipulate as its first
argument and a table item as its second argument, here called table and
item, respectively.  Both arguments must be non-null in all cases.  All
but tbl_probe() return a table item or a null pointer.

   * tbl_probe(): Searches in table for an item matching item.  If
     found, a pointer to the void * data item is returned.  Otherwise,
     item is inserted into the table and a pointer to the copy within
     the table is returned.  Memory allocation failure causes a null
     pointer to be returned.

     The pointer returned can be used to replace the item found or
     inserted by a different item.  This must only be done if the
     replacement item has the same position relative to the other items
     in the table as did the original item.  That is, for existing item
     e, replacement item r, and the table's comparison function f(),
     the return values of f(e, x) and f(r, x) must have the same sign
     for every other item x currently in the table.  Calling any other
     table function invalidates the pointer returned and it must not be
     referenced subsequently.

   * tbl_insert(): Inserts item into table, but not if a matching item
     exists.  Returns a null pointer if successful or if a memory
     allocation error occurs.  If a matching item already exists in the
     table, returns that item.

   * tbl_replace(): Inserts item into table, replacing and returning
     any matching item.  Returns a null pointer if the item was
     inserted but there was no matching item to replace, or if a memory
     allocation error occurs.

   * tbl_delete(): Removes from table and returns an item matching
     item.  Returns a null pointer if no matching item exists in the
     table.

   * tbl_find(): Searches table for an item matching item and returns
     any item found.  Returns a null pointer if no matching item exists
     in the table.

Exercises:

1. Functions tbl_insert() and tbl_replace() return NULL in two very
different situations: an error or successful insertion.  Why is this not
necessarily a design mistake?

2. Suggest a reason for disallowing insertion of a null item.

3. Write generic implementations of tbl_insert() and tbl_replace() in
terms of tbl_probe().


File: libavl.info,  Node: Assertions,  Next: Traversers,  Prev: Insertion and Deletion,  Up: The Table ADT

2.9 Assertions
==============

   Sometimes an insertion or deletion must succeed because it is known
in advance that there is no way that it can fail.  For instance, we
might be inserting into a table from a list of items known to be
unique, using a memory allocator that cannot return a null pointer.  In
this case, we want to make sure that the operation succeeded, and abort
if not, because that indicates a program bug.  We also would like to be
able to turn off these tests for success in our production versions,
because we don't want them slowing down the code.

11. <Table assertion function prototypes 11> =
void tbl_assert_insert (struct tbl_table *, void *);
void *tbl_assert_delete (struct tbl_table *, void *);

This code is included in *Note 15: Table function prototypes.

   These functions provide assertions for tbl_insert() and
tbl_delete().  They expand, via macros, directly into calls to those
functions when NDEBUG, the same symbol used to turn off assert()
checks, is declared.  As for the standard C header <assert.h>, header
files for tables may be included multiple times in order to turn these
assertions on or off.

Exercises:

1. Write a set of preprocessor directives for a table header file that
implement the behavior described in the final paragraph above.

2. Write a generic implementation of tbl_assert_insert() and
tbl_assert_delete() in terms of existing table functions.  Consider the
base functions carefully.  Why must we make sure that assertions are
always enabled for these functions?

3. Why must tbl_assert_insert() not be used if the table's memory
allocator can fail?  (See also Exercise 3.8-1.)


File: libavl.info,  Node: Traversers,  Next: Table Headers,  Prev: Assertions,  Up: The Table ADT

2.10 Traversers
===============

   A struct tbl_traverser is a table "traverser" that allows the items
in a table to be examined.  With a traverser, the items within a table
can be enumerated in sorted ascending or descending order, starting from
either end or from somewhere in the middle.

   The user of the traverser declares its own instance of struct
tbl_traverser, typically as a local variable.  One of the traverser
constructor functions described below can be used to initialize it.
Until then, the traverser is invalid.  An invalid traverser must not be
passed to any traverser function other than a constructor.

   Seen from the viewpoint of a table user, a traverser has only one
attribute: the current item.  The current item is either an item in the
table or the "null item", represented by a null pointer and not
associated with any item.

   Traversers continue to work when their tables are modified.  Any
number of insertions and deletions may occur in the table without
affecting the current item selected by a traverser, with only a few
exceptions:

   * Deleting a traverser's current item from its table invalidates the
     traverser (even if the item is later re-inserted).

   * Using the return value of tbl_probe() to replace an item in the
     table invalidates all traversers with that item current, unless the
     replacement item has the same key data as the original item (that
     is, the table's comparison function returns 0 when the two items
     are compared).

   * Similarly, tbl_t_replace() invalidates all _other_ traversers with
     the same item selected, unless the replacement item has the same
     key data.

   * Destroying a table with tbl_destroy() invalidates all of that
     table's traversers.

   There is no need to destroy a traverser that is no longer needed.  An
unneeded traverser can simply be abandoned.

* Menu:

* Constructors::
* Manipulators::


File: libavl.info,  Node: Constructors,  Next: Manipulators,  Prev: Traversers,  Up: Traversers

2.10.1 Constructors
-------------------

   These functions initialize traversers.  A traverser must be
initialized with one of these functions before it is passed to any
other traverser function.

12. <Traverser constructor function prototypes 12> =
/* Table traverser functions. */
void tbl_t_init (struct tbl_traverser *, struct tbl_table *);
void *tbl_t_first (struct tbl_traverser *, struct tbl_table *);
void *tbl_t_last (struct tbl_traverser *, struct tbl_table *);
void *tbl_t_find (struct tbl_traverser *, struct tbl_table *, void *);
void *tbl_t_insert (struct tbl_traverser *, struct tbl_table *, void *);
void *tbl_t_copy (struct tbl_traverser *, const struct tbl_traverser *);

This code is included in *Note 15: Table function prototypes.

All of these functions take a traverser to initialize as their first
argument, and most take a table to associate the traverser with as their
second argument.  These arguments are here called trav and table.  All,
except tbl_t_init(), return the item to which trav is initialized,
using a null pointer to represent the null item.  None of the arguments
to these functions may ever be a null pointer.

   * tbl_t_init(): Initializes trav to the null item in table.

   * tbl_t_first(): Initializes trav to the least-valued item in table.
     If the table is empty, then trav is initialized to the null item.

   * tbl_t_last(): Same as tbl_t_first(), for the greatest-valued item
     in table.

   * tbl_t_find(): Searches table for an item matching the one given.
     If one is found, initializes trav with it.  If none is found,
     initializes trav to the null item.

   * tbl_t_insert(): Attempts to insert the given item into table.  If
     it is inserted succesfully, trav is initialized to its location.
     If it cannot be inserted because of a duplicate, the duplicate
     item is set as trav's current item.  If there is a memory
     allocation error, trav is initialized to the null item.

   * tbl_t_copy(): Initializes trav to the same table and item as a
     second valid traverser.  Both arguments pointing to the same valid
     traverser is valid and causes no change in either.


File: libavl.info,  Node: Manipulators,  Prev: Constructors,  Up: Traversers

2.10.2 Manipulators
-------------------

   These functions manipulate valid traversers.

13. <Traverser manipulator function prototypes 13> =
void *tbl_t_next (struct tbl_traverser *);
void *tbl_t_prev (struct tbl_traverser *);
void *tbl_t_cur (struct tbl_traverser *);
void *tbl_t_replace (struct tbl_traverser *, void *);

This code is included in *Note 15: Table function prototypes.

   Each of these functions takes a valid traverser, here called trav, as
its first argument, and returns a data item.  All but tbl_t_replace()
can also return a null pointer that represents the null item.  All
arguments to these functions must be non-null pointers.

   * tbl_t_next(): Advances trav to the next larger item in its table.
     If trav was at the null item in a nonempty table, then the smallest
     item in the table becomes current. If trav was already at the
     greatest item in its table or the table is empty, the null item
     becomes current.  Returns the new current item.

   * tbl_t_prev(): Advances trav to the next smaller item in its table.
     If trav was at the null item in a nonempty table, then the greatest
     item in the table becomes current. If trav was already at the
     lowest item in the table or the table is empty, the null item
     becomes current.  Returns the new current item.

   * tbl_t_cur(): Returns trav's current item.

   * tbl_t_replace(): Replaces the data item currently selected in trav
     by the one provided.  The replacement item is subject to the same
     restrictions as for the same replacement using tbl_probe().  The
     item replaced is returned.  If the null item is current, the
     behavior is undefined.

   Seen from the outside, the traverser treats the table as a circular
arrangement of items, with the null item at the top of the circle and
the least-valued item just clockwise of it, then the next-lowest-valued
item, and so on until the greatest-valued item is just counterclockwise
of the null item.  Moving clockwise in the circle is equivalent, under
our traverser, to moving to the next item with tbl_t_next().  Moving
counterclockwise is equivalent to moving to the previous item with
tbl_t_prev().

   An equivalent view is that the traverser treats the table as a linear
arrangement of nodes:

	 .-> 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6 <-> 7 <-> 8 <-.
         |                                                |
         `---------------------> NULL <--------------------'
  From this perspective, nodes are arranged from least to greatest in
left to right order, and the null node lies in the middle as a
connection between the least and greatest nodes.  Moving to the next
node is the same as moving to the right and moving to the previous node
is motion to the left, except where the null node is concerned.


File: libavl.info,  Node: Table Headers,  Next: Additional Exercises for Tables,  Prev: Traversers,  Up: The Table ADT

2.11 Table Headers
==================

Here we gather together in one place all of the types and prototypes for
a generic table.

14. <Table types 14> =
<*Note Table function types:: 2>
<*Note Memory allocator:: 5>
<*Note Default memory allocator header:: 7>

This code is included in *Note 24: bsth, *Note 142: avlh, *Note 192:
rbh, *Note 247: tbsth, *Note 297: tavlh, *Note 333: trbh, *Note 372:
rtbsth, *Note 415: rtavlh, *Note 452: rtrbh, *Note 486: pbsth, *Note
519: pavlh, and *Note 551: prbh.

15. <Table function prototypes 15> =
<*Note Table creation function prototypes:: 8>
<*Note Table insertion and deletion function prototypes:: 10>
<*Note Table assertion function prototypes:: 11>
<*Note Table count macro:: 591>
<*Note Traverser constructor function prototypes:: 12>
<*Note Traverser manipulator function prototypes:: 13>

This code is included in *Note 24: bsth, *Note 142: avlh, *Note 192:
rbh, *Note 247: tbsth, *Note 297: tavlh, *Note 333: trbh, *Note 372:
rtbsth, *Note 415: rtavlh, *Note 452: rtrbh, *Note 486: pbsth, *Note
519: pavlh, and *Note 551: prbh.

All of our tables fit the specification given in Exercise 3.7-1, so
<*Note Table count macro:: 591> is directly included above.

