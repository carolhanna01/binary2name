This is libavl.info, produced by makeinfo version 4.0b from libavl.texi.


File: libavl.info,  Node: Deleting from an AVL tree,  Next: Traversal of an AVL tree,  Prev: Inserting into an AVL tree,  Up: AVL Trees

5.5 Deletion
============

   Deletion in an AVL tree is remarkably similar to insertion.  The
steps that we go through are analogous:

  1. *Search* for the item to delete.

  2. *Delete* the item.

  3. *Update* balance factors.

  4. *Rebalance* the tree, if necessary.

  5. *Finish up* and return.

   The main difference is that, after a deletion, we may have to
rebalance at more than one level of a tree, starting from the bottom
up.  This is a bit painful, because it means that we have to keep track
of all the nodes that we visit as we search for the node to delete, so
that we can then move back up the tree.  The actual updating of balance
factors and rebalancing steps are similar to those used for insertion.

   The following sections cover deletion from an AVL tree in detail.
Before we get started, here's an outline of the function.

164. <AVL item deletion function 164> =
void *
avl_delete (struct avl_table *tree, const void *item)
{
  /* Stack of nodes. */
  struct avl_node *pa[AVL_MAX_HEIGHT]; /* Nodes. */
  unsigned char da[AVL_MAX_HEIGHT];    /* avl_link[] indexes. */
  int k;                               /* Stack pointer. */

  struct avl_node *p;   /* Traverses tree to find node to delete. */
  int cmp;              /* Result of comparison between item and p. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1 Search AVL tree for item to delete:: 165>
  <*Note Step 2 Delete item from AVL tree:: 166>
  <*Note Steps 3--4 Update balance factors and rebalance after AVL deletion:: 171>
  <*Note Step 5 Finish up and return after AVL deletion:: 176>
}

This code is included in *Note 145: AVL functions.

See also:  *Note Knuth 1998b::, pages 473-474; *Note Pfaff 1998::.

* Menu:

* Deleting an AVL node step 1 - Search::
* Deleting an AVL node step 2 - Delete::
* Deleting an AVL node step 3 - Update::
* Deleting an AVL node step 4 - Rebalance::
* Deleting an AVL node step 5 - Finish Up::
* AVL deletion symmetric case::


File: libavl.info,  Node: Deleting an AVL node step 1 - Search,  Next: Deleting an AVL node step 2 - Delete,  Prev: Deleting from an AVL tree,  Up: Deleting from an AVL tree

5.5.1 Step 1: Search
--------------------

   The only difference between this search and an ordinary search in a
BST is that we have to keep track of the nodes above the one we're
deleting.  We do this by pushing them onto the stack defined above.
Each iteration through the loop compares item to p's data, pushes the
node onto the stack, moves down in the proper direction.  The first
trip through the loop is something of an exception: we hard-code the
comparison result to -1 so that the pseudo-root node is always the
topmost node on the stack.  When we find a match, we set item to the
actual data item found, so that we can return it later.

165. <Step 1: Search AVL tree for item to delete 165> =
k = 0;
p = (struct avl_node *) &tree->avl_root;
for (cmp = -1; cmp != 0;
     cmp = tree->avl_compare (item, p->avl_data, tree->avl_param))
  {
    int dir = cmp > 0;

    pa[k] = p;
    da[k++] = dir;

    p = p->avl_link[dir];
    if (p == NULL)
      return NULL;
  }
item = p->avl_data;

This code is included in *Note 164: AVL item deletion function and
*Note 220: RB item deletion function.


File: libavl.info,  Node: Deleting an AVL node step 2 - Delete,  Next: Deleting an AVL node step 3 - Update,  Prev: Deleting an AVL node step 1 - Search,  Up: Deleting from an AVL tree

5.5.2 Step 2: Delete
--------------------

   At this point, we've identified p as the node to delete.  The node
on the top of the stack, da[k - 1], is p's parent node.  There are the
same three cases we saw in deletion from an ordinary BST (*note
Deleting from a BST::), with the addition of code to copy balance
factors and update the stack.

   The code for selecting cases is the same as for BSTs:

166. <Step 2: Delete item from AVL tree 166> =
if (p->avl_link[1] == NULL)
  { <*Note Case 1 in AVL deletion:: 168> }
else
  {
    struct avl_node *r = p->avl_link[1];
    if (r->avl_link[0] == NULL)
      {
        <*Note Case 2 in AVL deletion:: 169>
      }
    else
      {
        <*Note Case 3 in AVL deletion:: 170>
      }
  }

See also *Note 167: Step 2 Delete item from AVL tree-2.
This code is included in *Note 164: AVL item deletion function.

   Regardless of the case, we are in the same situation after the
deletion: node p has been removed from the tree and the stack contains
k nodes at which rebalancing may be necessary.  Later code may change p
to point elsewhere, so we free the node immediately.  A pointer to the
item data has already been saved in item (*note avldelsaveitem::):

167. <Step 2: Delete item from AVL tree 166> +=
tree->avl_alloc->libavl_free (tree->avl_alloc, p);

Case 1: p has no right child
............................

   If p has no right child, then we can replace it with its left child,
the same as for BSTs (*note bstdelcase1::).

168. <Case 1 in AVL deletion 168> =
pa[k - 1]->avl_link[da[k - 1]] = p->avl_link[0];

This code is included in *Note 166: Step 2 Delete item from AVL tree.

Case 2: p's right child has no left child
.........................................

   If p has a right child r, which in turn has no left child, then we
replace p by r, attaching p's left child to r, as we would in an
unbalanced BST (*note bstdelcase2::).  In addition, r acquires p's
balance factor, and r must be added to the stack of nodes above the
deleted node.

169. <Case 2 in AVL deletion 169> =
r->avl_link[0] = p->avl_link[0];
r->avl_balance = p->avl_balance;
pa[k - 1]->avl_link[da[k - 1]] = r;
da[k] = 1;
pa[k++] = r;

This code is included in *Note 166: Step 2 Delete item from AVL tree.

Case 3: p's right child has a left child
........................................

   If p's right child has a left child, then this is the third and most
complicated case.  On the other hand, as a modification from the third
case in an ordinary BST deletion (*note bstdelcase3::), it is rather
simple.  We're deleting the inorder successor of p, so we push the
nodes above it onto the stack.  The only trickery is that we do not
know in advance the node that will replace p, so we reserve a spot on
the stack for it (da[j]) and fill it in later:

170. <Case 3 in AVL deletion 170> =
struct avl_node *s;
int j = k++;

for (;;)
  {
    da[k] = 0;
    pa[k++] = r;
    s = r->avl_link[0];
    if (s->avl_link[0] == NULL)
      break;

    r = s;
  }

s->avl_link[0] = p->avl_link[0];
r->avl_link[0] = s->avl_link[1];
s->avl_link[1] = p->avl_link[1];
s->avl_balance = p->avl_balance;

pa[j - 1]->avl_link[da[j - 1]] = s;
da[j] = 1;
pa[j] = s;

This code is included in *Note 166: Step 2 Delete item from AVL tree.

Exercises:

1. Write an alternate version of <*Note Case 3 in AVL deletion:: 170>
that moves data instead of pointers, as in Exercise 5.8-2.

2. Why is it important that the item data was saved earlier?  (Why
couldn't we save it just before freeing the node?)


File: libavl.info,  Node: Deleting an AVL node step 3 - Update,  Next: Deleting an AVL node step 4 - Rebalance,  Prev: Deleting an AVL node step 2 - Delete,  Up: Deleting from an AVL tree

5.5.3 Step 3: Update Balance Factors
------------------------------------

   When we updated balance factors in insertion, we were lucky enough to
know in advance which ones we'd need to update.  Moreover, we never
needed to rebalance at more than one level in the tree for any one
insertion.  These two factors conspired in our favor to let us do all
the updating of balance factors at once from the top down.

   Everything is not quite so simple in AVL deletion.  We don't have any
easy way to figure out during the search process which balance factors
will need to be updated, and for that matter we may need to perform
rebalancing at multiple levels.  Our strategy must change.

   This new approach is not fundamentally different from the previous
one.  We work from the bottom up instead of from the top down.  We
potentially look at each of the nodes along the direct path from the
deleted node to the tree's root, starting at pa[k - 1], the parent of
the deleted node.  For each of these nodes, we adjust its balance
factor and possibly perform rebalancing.  After that, if we're lucky,
this was enough to restore the tree's balancing rule, and we are
finished with updating balance factors and rebalancing.  Otherwise, we
look at the next node, repeating the process.

   Here is the loop itself with the details abstracted out:

171. <Steps 3--4: Update balance factors and rebalance after AVL deletion 171> =
assert (k > 0);
while (--k > 0)
  {
    struct avl_node *y = pa[k];

    if (da[k] == 0)
      {
        <*Note Update |y|s balance factor after left-side AVL deletion:: 172>
      }
    else
      {
        <*Note Update |y|s balance factor after right-side AVL deletion:: 177>
      }
  }

This code is included in *Note 164: AVL item deletion function.

   The reason this works is the loop invariants.  That is, because each
time we look at a node in order to update its balance factor, the
situation is the same.  In particular, if we're looking at a node
pa[k], then we know that it's because the height of its subtree on side
da[k] decreased, so that the balance factor of node pa[k] needs to be
updated.  The rebalancing operations we choose reflect this invariant:
there are sometimes multiple valid ways to rebalance at a given node
and propagate the results up the tree, but only one way to do this
while maintaining the invariant.  (This is especially true in red-black
trees, for which we will develop code for two possible invariants under
insertion and deletion.)

   Updating the balance factor of a node after deletion from its left
side and right side are symmetric, so we'll discuss only the left-side
case here and construct the code for the right-side case later.
Suppose we have a node y whose left subtree has decreased in height.
In general, this increases its balance factor, because the balance
factor of a node is the height of its right subtree minus the height of
its left subtree.  More specifically, there are three cases, treated
individually below.

Case 1: y has - balance factor
..............................

   If y started with a - balance factor, then its left subtree was
taller than its right subtree.  Its left subtree has decreased in
height, so the two subtrees must now be the same height and we set y's
balance factor to 0.  This is between -1 and +1, so there is no need to
rebalance at y.  However, binary tree y has itself decreased in height,
so that means that we must rebalance the AVL tree above y as well, so
we continue to the next iteration of the loop.

   The diagram below may help in visualization.  On the left is shown
the original configuration of a subtree, where subtree a has height h
and subtree b has height h - 1.  The height of a nonempty binary tree
is one plus the larger of its subtrees' heights, so tree y has height h
+ 1.  The diagram on the right shows the situation after a node has
been deleted from a, reducing that subtree's height.  The new height of
tree y is (h - 1) + 1 == h.

                            |             |
                            y             y
                           <->           <0>
                          /   \    =>  _'   \
                         a      b     a*      b
                         h     h-1    h-1    h-1

Case 2: y has 0 balance factor
..............................

If y started with a 0 balance factor, and its left subtree decreased in
height, then the result is that its right subtree is now taller than its
left subtree, so the new balance factor is +.  However, the overall
height of binary tree y has not changed, so no balance factors above y
need to be changed, and we are done, hence we break to exit the loop.

   Here's the corresponding diagram, similar to the one for the previous
case.  The height of tree y on both sides of the diagram is h + 1,
since y's taller subtree in both cases has height h.

                              |           |
                              y           y
                             <0>         <+>
                            /   \  =>  _'   \
                           a     b    a*     b
                           h     h    h-1    h

Case 3: y has + balance factor
..............................

Otherwise, y started with a + balance factor, so the decrease in height
of its left subtree, which was already shorter than its right subtree,
causes a violation of the AVL constraint with a +2 balance factor.  We
need to rebalance.  After rebalancing, we may or may not have to
rebalance further up the tree.

   Here's a diagram of what happens to forcing rebalancing:

                              |            |
                              y            y
                             <+>         <++>
                           _'   \  =>  _'    \
                           a     b    a*      b
                          h-1    h    h-2     h

Implementation
..............

The implementation is straightforward:

172. <Update y's balance factor after left-side AVL deletion 172> =
y->avl_balance++;
if (y->avl_balance == +1)
  break;
else if (y->avl_balance == +2)
  {
    <*Note Step 4 Rebalance after AVL deletion:: 173>
  }

This code is included in *Note 171: Steps 3--4 Update balance factors
and rebalance after AVL deletion.


File: libavl.info,  Node: Deleting an AVL node step 4 - Rebalance,  Next: Deleting an AVL node step 5 - Finish Up,  Prev: Deleting an AVL node step 3 - Update,  Up: Deleting from an AVL tree

5.5.4 Step 4: Rebalance
-----------------------

   Now we have to write code to rebalance when it becomes necessary.
We'll use rotations to do this, as before.  Again, we'll distinguish
the cases on the basis of x's balance factor, where x is y's right
child:

173. <Step 4: Rebalance after AVL deletion 173> =
struct avl_node *x = y->avl_link[1];
if (x->avl_balance == -1)
  {
    <*Note Left-side rebalancing case 1 in AVL deletion:: 174>
  }
else
  {
    <*Note Left-side rebalancing case 2 in AVL deletion:: 175>
  }

This code is included in *Note 172: Update |y|s balance factor after
left-side AVL deletion.

Case 1: x has - balance factor
..............................

   If x has a - balance factor, we handle rebalancing in a manner
analogous to case 2 for insertion.  In fact, we reuse the code.  We
rotate right at x, then left at y.  w is the left child of x.  The two
rotations look like this:

                   |                 |
                   y                 y               |
                 <++>              <++>              w
                /    `._          /    `_           <0>
               a         x       a       w    =>   /   \
                        <->   =>        / \       y     x
                       /   \           b   x      ^     ^
                      w     d              ^     a b   c d
                      ^                   c d
                     b c
174. <Left-side rebalancing case 1 in AVL deletion 174> =
struct avl_node *w;
<*Note Rotate right at |x| then left at |y| in AVL tree:: 159>
pa[k - 1]->avl_link[da[k - 1]] = w;

This code is included in *Note 173: Step 4 Rebalance after AVL deletion.

Case 2: x has + or 0 balance factor
...................................

   When x's balance factor is +, the needed treatment is analogous to
Case 1 for insertion.  We simply rotate left at y and update the
pointer to the subtree, then update balance factors.  The deletion and
rebalancing then look like this:

                 |                |                    |
                 y                y                    x
                <+>             <++>                  <0>
               /   `_          /    `_            _.-'   \
              a       x    => a*       x    =>    y       c
                     <+>              <+>        <0>
                    /   \            /   \      /   \
                   b     c          b     c    a*    b
 
 When x's balance factor is 0, we perform the same rotation, but the
height of the overall subtree does not change, so we're done and can
exit the loop with break.  Here's what the deletion and rebalancing
look like for this subcase:

                 |                |                    |
                 y                y                    x
                <+>             <++>                  <->
               /   `_          /    `_            _.-'   \
              a       x    => a*       x    =>    y       c
                     <0>              <0>        <+>
                    /   \            /   \      /   \
                   b     c          b     c    a*    b
175. <Left-side rebalancing case 2 in AVL deletion 175> =
y->avl_link[1] = x->avl_link[0];
x->avl_link[0] = y;
pa[k - 1]->avl_link[da[k - 1]] = x;
if (x->avl_balance == 0)
  {
    x->avl_balance = -1;
    y->avl_balance = +1;
    break;
  }
else
  x->avl_balance = y->avl_balance = 0;

This code is included in *Note 173: Step 4 Rebalance after AVL deletion.

Exercises:

1. In <*Note Step 4 Rebalance after AVL deletion:: 173>, we refer to
fields in x, the right child of y, without checking that y has a
non-null right child.  Why can we assume that node x is non-null?

2. Describe the shape of a tree that might require rebalancing at every
level above a particular node.  Give an example.


File: libavl.info,  Node: Deleting an AVL node step 5 - Finish Up,  Next: AVL deletion symmetric case,  Prev: Deleting an AVL node step 4 - Rebalance,  Up: Deleting from an AVL tree

5.5.5 Step 5: Finish Up
-----------------------

176. <Step 5: Finish up and return after AVL deletion 176> =
tree->avl_count--;
tree->avl_generation++;
return (void *) item;

This code is included in *Note 164: AVL item deletion function.


File: libavl.info,  Node: AVL deletion symmetric case,  Prev: Deleting an AVL node step 5 - Finish Up,  Up: Deleting from an AVL tree

5.5.6 Symmetric Case
--------------------

   Here's the code for the symmetric case, where the deleted node was
in the right subtree of its parent.

177. <Update y's balance factor after right-side AVL deletion 177> =
y->avl_balance--;
if (y->avl_balance == -1)
  break;
else if (y->avl_balance == -2)
  {
    struct avl_node *x = y->avl_link[0];
    if (x->avl_balance == +1)
      {
        struct avl_node *w;
        <*Note Rotate left at |x| then right at |y| in AVL tree:: 156>
        pa[k - 1]->avl_link[da[k - 1]] = w;
      }
    else
      {
        y->avl_link[0] = x->avl_link[1];
        x->avl_link[1] = y;
        pa[k - 1]->avl_link[da[k - 1]] = x;
        if (x->avl_balance == 0)
          {
            x->avl_balance = +1;
            y->avl_balance = -1;
            break;
          }
        else
          x->avl_balance = y->avl_balance = 0;
      }
  }

This code is included in *Note 171: Steps 3--4 Update balance factors
and rebalance after AVL deletion.


File: libavl.info,  Node: Traversal of an AVL tree,  Next: Copying an AVL tree,  Prev: Deleting from an AVL tree,  Up: AVL Trees

5.6 Traversal
=============

   Traversal is largely unchanged from BSTs.  However, we can be
confident that the tree won't easily exceed the maximum stack height,
because of the AVL balance condition, so we can omit checking for stack
overflow.

178. <AVL traversal functions 178> =
<*Note BST traverser refresher:: 62>
<*Note BST traverser null initializer:: 64>
<*Note AVL traverser least-item initializer:: 180>
<*Note AVL traverser greatest-item initializer:: 181>
<*Note AVL traverser search initializer:: 182>
<*Note AVL traverser insertion initializer:: 179>
<*Note BST traverser copy initializer:: 69>
<*Note AVL traverser advance function:: 183>
<*Note AVL traverser back up function:: 184>
<*Note BST traverser current item function:: 74>
<*Note BST traverser replacement function:: 75>

This code is included in *Note 145: AVL functions and *Note 196: RB
functions.

   We do need to make a new implementation of the insertion traverser
initializer.  Because insertion into an AVL tree is so complicated, we
just write this as a wrapper to avl_probe().  There probably wouldn't
be much of a speed improvement by inlining the code anyhow:

179. <AVL traverser insertion initializer 179> =
void *
avl_t_insert (struct avl_traverser *trav, struct avl_table *tree, void *item)
{
  void **p;

  assert (trav != NULL && tree != NULL && item != NULL);

  p = avl_probe (tree, item);
  if (p != NULL)
    {
      trav->avl_table = tree;
      trav->avl_node =
        ((struct avl_node *)
         ((char *) p - offsetof (struct avl_node, avl_data)));
      trav->avl_generation = tree->avl_generation - 1;
      return *p;
    }
  else
    {
      avl_t_init (trav, tree);
      return NULL;
    }
}

This code is included in *Note 178: AVL traversal functions.

   We will present the rest of the modified functions without further
comment.

180. <AVL traverser least-item initializer 180> =
void *
avl_t_first (struct avl_traverser *trav, struct avl_table *tree)
{
  struct avl_node *x;

  assert (tree != NULL && trav != NULL);

  trav->avl_table = tree;
  trav->avl_height = 0;
  trav->avl_generation = tree->avl_generation;

  x = tree->avl_root;
  if (x != NULL)
    while (x->avl_link[0] != NULL)
      {
        assert (trav->avl_height < AVL_MAX_HEIGHT);
        trav->avl_stack[trav->avl_height++] = x;
        x = x->avl_link[0];
      }
  trav->avl_node = x;

  return x != NULL ? x->avl_data : NULL;
}

This code is included in *Note 178: AVL traversal functions.

181. <AVL traverser greatest-item initializer 181> =
void *
avl_t_last (struct avl_traverser *trav, struct avl_table *tree)
{
  struct avl_node *x;

  assert (tree != NULL && trav != NULL);

  trav->avl_table = tree;
  trav->avl_height = 0;
  trav->avl_generation = tree->avl_generation;

  x = tree->avl_root;
  if (x != NULL)
    while (x->avl_link[1] != NULL)
      {
        assert (trav->avl_height < AVL_MAX_HEIGHT);
        trav->avl_stack[trav->avl_height++] = x;
        x = x->avl_link[1];
      }
  trav->avl_node = x;

  return x != NULL ? x->avl_data : NULL;
}

This code is included in *Note 178: AVL traversal functions.

182. <AVL traverser search initializer 182> =
void *
avl_t_find (struct avl_traverser *trav, struct avl_table *tree, void *item)
{
  struct avl_node *p, *q;

  assert (trav != NULL && tree != NULL && item != NULL);
  trav->avl_table = tree;
  trav->avl_height = 0;
  trav->avl_generation = tree->avl_generation;
  for (p = tree->avl_root; p != NULL; p = q)
    {
      int cmp = tree->avl_compare (item, p->avl_data, tree->avl_param);

      if (cmp < 0)
        q = p->avl_link[0];
      else if (cmp > 0)
        q = p->avl_link[1];
      else /* cmp == 0 */
        {
          trav->avl_node = p;
          return p->avl_data;
        }

      assert (trav->avl_height < AVL_MAX_HEIGHT);
      trav->avl_stack[trav->avl_height++] = p;
    }

  trav->avl_height = 0;
  trav->avl_node = NULL;
  return NULL;
}

This code is included in *Note 178: AVL traversal functions.

183. <AVL traverser advance function 183> =
void *
avl_t_next (struct avl_traverser *trav)
{
  struct avl_node *x;

  assert (trav != NULL);

  if (trav->avl_generation != trav->avl_table->avl_generation)
    trav_refresh (trav);

  x = trav->avl_node;
  if (x == NULL)
    {
      return avl_t_first (trav, trav->avl_table);
    }
  else if (x->avl_link[1] != NULL)
    {
      assert (trav->avl_height < AVL_MAX_HEIGHT);
      trav->avl_stack[trav->avl_height++] = x;
      x = x->avl_link[1];

      while (x->avl_link[0] != NULL)
        {
          assert (trav->avl_height < AVL_MAX_HEIGHT);
          trav->avl_stack[trav->avl_height++] = x;
          x = x->avl_link[0];
        }
    }
  else
    {
      struct avl_node *y;

      do
        {
          if (trav->avl_height == 0)
            {
              trav->avl_node = NULL;
              return NULL;
            }

          y = x;
          x = trav->avl_stack[--trav->avl_height];
        }
      while (y == x->avl_link[1]);
    }
  trav->avl_node = x;

  return x->avl_data;
}

This code is included in *Note 178: AVL traversal functions.

184. <AVL traverser back up function 184> =
void *
avl_t_prev (struct avl_traverser *trav)
{
  struct avl_node *x;

  assert (trav != NULL);

  if (trav->avl_generation != trav->avl_table->avl_generation)
    trav_refresh (trav);

  x = trav->avl_node;
  if (x == NULL)
    {
      return avl_t_last (trav, trav->avl_table);
    }
  else if (x->avl_link[0] != NULL)
    {
      assert (trav->avl_height < AVL_MAX_HEIGHT);
      trav->avl_stack[trav->avl_height++] = x;
      x = x->avl_link[0];

      while (x->avl_link[1] != NULL)
        {
          assert (trav->avl_height < AVL_MAX_HEIGHT);
          trav->avl_stack[trav->avl_height++] = x;
          x = x->avl_link[1];
        }
    }
  else
    {
      struct avl_node *y;

      do
        {
          if (trav->avl_height == 0)
            {
              trav->avl_node = NULL;
              return NULL;
            }

          y = x;
          x = trav->avl_stack[--trav->avl_height];
        }
      while (y == x->avl_link[0]);
    }
  trav->avl_node = x;

  return x->avl_data;
}

This code is included in *Note 178: AVL traversal functions.

Exercises:

1. Explain the meaning of this ugly expression, used in avl_t_insert():

    (struct avl_node *) ((char *) p - offsetof (struct avl_node, avl_data))


File: libavl.info,  Node: Copying an AVL tree,  Next: Testing AVL Trees,  Prev: Traversal of an AVL tree,  Up: AVL Trees

5.7 Copying
===========

   Copying an AVL tree is similar to copying a BST.  The only important
difference is that we have to copy the AVL balance factor between nodes
as well as node data.  We don't check our stack height here, either.

185. <AVL copy function 185> =
<*Note BST copy error helper function:: 82>

struct avl_table *
avl_copy (const struct avl_table *org, avl_copy_func *copy,
          avl_item_func *destroy, struct libavl_allocator *allocator)
{
  struct avl_node *stack[2 * (AVL_MAX_HEIGHT + 1)];
  int height = 0;

  struct avl_table *new;
  const struct avl_node *x;
  struct avl_node *y;

  assert (org != NULL);
  new = avl_create (org->avl_compare, org->avl_param,
                    allocator != NULL ? allocator : org->avl_alloc);
  if (new == NULL)
    return NULL;
  new->avl_count = org->avl_count;
  if (new->avl_count == 0)
    return new;

  x = (const struct avl_node *) &org->avl_root;
  y = (struct avl_node *) &new->avl_root;
  for (;;)
    {
      while (x->avl_link[0] != NULL)
        {
          assert (height < 2 * (AVL_MAX_HEIGHT + 1));

          y->avl_link[0] =
            new->avl_alloc->libavl_malloc (new->avl_alloc,
                                           sizeof *y->avl_link[0]);
          if (y->avl_link[0] == NULL)
            {
              if (y != (struct avl_node *) &new->avl_root)
                {
                  y->avl_data = NULL;
                  y->avl_link[1] = NULL;
                }

              copy_error_recovery (stack, height, new, destroy);
              return NULL;
            }

          stack[height++] = (struct avl_node *) x;
          stack[height++] = y;
          x = x->avl_link[0];
          y = y->avl_link[0];
        }
      y->avl_link[0] = NULL;

      for (;;)
        {
          y->avl_balance = x->avl_balance;
          if (copy == NULL)
            y->avl_data = x->avl_data;
          else
            {
              y->avl_data = copy (x->avl_data, org->avl_param);
              if (y->avl_data == NULL)
                {
                  y->avl_link[1] = NULL;
                  copy_error_recovery (stack, height, new, destroy);
                  return NULL;
                }
            }

          if (x->avl_link[1] != NULL)
            {
              y->avl_link[1] =
                new->avl_alloc->libavl_malloc (new->avl_alloc,
                                               sizeof *y->avl_link[1]);
              if (y->avl_link[1] == NULL)
                {
                  copy_error_recovery (stack, height, new, destroy);
                  return NULL;
                }

              x = x->avl_link[1];
              y = y->avl_link[1];
              break;
            }
          else
            y->avl_link[1] = NULL;

          if (height <= 2)
            return new;

          y = stack[--height];
          x = stack[--height];
        }
    }
}

This code is included in *Note 145: AVL functions and *Note 196: RB
functions.


File: libavl.info,  Node: Testing AVL Trees,  Prev: Copying an AVL tree,  Up: AVL Trees

5.8 Testing
===========

   Our job isn't done until we can demonstrate that our code works.
We'll do this with a test program built using the framework from the
previous chapter (*note Testing our BST functions::).  All we have to
do is produce functions for AVL trees that correspond to each of those
in <*Note bst-testc:: 98>.  This just involves making small changes to
the functions used there.  They are presented below without additional
comment.

186. <avl-test.c 186> =
<*Note License:: 1>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "avl.h"
#include "test.h"

<*Note BST print function:: 119>
<*Note BST traverser check function:: 104>
<*Note Compare two AVL trees for structure and content:: 187>
<*Note Recursively verify AVL tree structure:: 188>
<*Note AVL tree verify function:: 190>
<*Note BST test function:: 100>
<*Note BST overflow test function:: 122>

187. <Compare two AVL trees for structure and content 187> =
static int
compare_trees (struct avl_node *a, struct avl_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      assert (a == NULL && b == NULL);
      return 1;
    }

  if (*(int *) a->avl_data != *(int *) b->avl_data
      || ((a->avl_link[0] != NULL) != (b->avl_link[0] != NULL))
      || ((a->avl_link[1] != NULL) != (b->avl_link[1] != NULL))
      || a->avl_balance != b->avl_balance)
    {
      printf (" Copied nodes differ: a=%d (bal=%d) b=%d (bal=%d) a:",
              *(int *) a->avl_data, a->avl_balance,
              *(int *) b->avl_data, b->avl_balance);

      if (a->avl_link[0] != NULL)
        printf ("l");
      if (a->avl_link[1] != NULL)
        printf ("r");

      printf (" b:");
      if (b->avl_link[0] != NULL)
        printf ("l");
      if (b->avl_link[1] != NULL)
        printf ("r");

      printf ("\n");
      return 0;
    }

  okay = 1;
  if (a->avl_link[0] != NULL)
    okay &= compare_trees (a->avl_link[0], b->avl_link[0]);
  if (a->avl_link[1] != NULL)
    okay &= compare_trees (a->avl_link[1], b->avl_link[1]);
  return okay;
}

This code is included in *Note 186: avl-testc.

188. <Recursively verify AVL tree structure 188> =
/* Examines the binary tree rooted at node.  
   Zeroes *okay if an error occurs.
   Otherwise, does not modify *okay.
   Sets *count to the number of nodes in that tree,
   including node itself if node != NULL.
   Sets *height to the tree's height.
   All the nodes in the tree are verified to be at least min
   but no greater than max. */
static void
recurse_verify_tree (struct avl_node *node, int *okay, size_t *count, 
                     int min, int max, int *height)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */
  int subheight[2];     /* Heights of subtrees. */

  if (node == NULL)
    {
      *count = 0;
      *height = 0;
      return;
    }
  d = *(int *) node->avl_data;

  <*Note Verify binary search tree ordering:: 114>

  recurse_verify_tree (node->avl_link[0], okay, &subcount[0], 
                       min, d -  1, &subheight[0]);
  recurse_verify_tree (node->avl_link[1], okay, &subcount[1], 
                       d + 1, max, &subheight[1]);
  *count = 1 + subcount[0] + subcount[1];
  *height = 1 + (subheight[0] > subheight[1] ? subheight[0] : subheight[1]);

  <*Note Verify AVL node balance factor:: 189>
}

This code is included in *Note 186: avl-testc.

189. <Verify AVL node balance factor 189> =
if (subheight[1] - subheight[0] != node->avl_balance)
  {
    printf (" Balance factor of node %d is %d, but should be %d.\n",
            d, node->avl_balance, subheight[1] - subheight[0]);
    *okay = 0;
  }
else if (node->avl_balance < -1 || node->avl_balance > +1)
  {
    printf (" Balance factor of node %d is %d.\n", d, node->avl_balance);
    *okay = 0;
  }

This code is included in *Note 188: Recursively verify AVL tree
structure, *Note 332: Recursively verify TAVL tree structure, *Note
451: Recursively verify RTAVL tree structure, and *Note 550:
Recursively verify PAVL tree structure.

190. <AVL tree verify function 190> =
static int
verify_tree (struct avl_table *tree, int array[], size_t n)
{
  int okay = 1;

  <*Note Check |tree->bst_count| is correct:: 110>

  if (okay)
    {
      <*Note Check AVL tree structure:: 191>
    }

  if (okay)
    {
      <*Note Check that the tree contains all the elements it should:: 115>
    }

  if (okay)
    {
      <*Note Check that forward traversal works:: 116>
    }

  if (okay)
    {
      <*Note Check that backward traversal works:: 117>
    }

  if (okay)
    {
      <*Note Check that traversal from the null element works:: 118>
    }

  return okay;
}

This code is included in *Note 186: avl-testc, *Note 330: tavl-testc,
*Note 449: rtavl-testc, and *Note 548: pavl-testc.

191. <Check AVL tree structure 191> =
/* Recursively verify tree structure. */
size_t count;
int height;

recurse_verify_tree (tree->avl_root, &okay, &count,
                     0, INT_MAX, &height);
<*Note Check counted nodes:: 112>

This code is included in *Note 190: AVL tree verify function.


File: libavl.info,  Node: Red-Black Trees,  Next: Threaded Binary Search Trees,  Prev: AVL Trees,  Up: Top

6 Red-Black Trees
*****************

   The last chapter saw us implementing a library for one particular
type of balanced trees.  Red-black trees were invented by R. Bayer and
studied at length by L. J. Guibas and R. Sedgewick.  This chapter will
implement a library for another kind of balanced tree, called a
"red-black tree" (*note red-black tree::).  For brevity, we'll often
abbreviate "red-black" to RB.

   Insertion and deletion operations on red-black trees are more complex
to describe or to code than the same operations on AVL trees.
Red-black trees also have a higher maximum height than AVL trees for a
given number of nodes.  The primary advantage of red-black trees is
that, in AVL trees, deleting one node from a tree containing n nodes
may require log2 (n) rotations, but deletion in a red-black tree never
requires more than three rotations.

   The functions for RB trees in this chapter are analogous to those
that we developed for use with AVL trees in the previous chapter.
Here's an outline of the red-black code:

192. <rb.h 192> =
<*Note License:: 1>
#ifndef RB_H
#define RB_H 1

#include <stddef.h>

<*Note Table types:: 14>
<*Note RB maximum height:: 195>
<*Note BST table structure:: 27>
<*Note RB node structure:: 194>
<*Note BST traverser structure:: 61>
<*Note Table function prototypes:: 15>

#endif /* rb.h */

193. <rb.c 193> =
<*Note License:: 1>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "rb.h"

<*Note RB functions:: 196>

See also:  *Note Cormen 1990::, chapter 14, "Chapter notes."

* Menu:

* RB Balancing Rule::
* RB Data Types::
* Operations in an RB Tree::
* Inserting into an RB tree::
* Deleting from an RB tree::
* Testing RB Trees::


File: libavl.info,  Node: RB Balancing Rule,  Next: RB Data Types,  Prev: Red-Black Trees,  Up: Red-Black Trees

6.1 Balancing Rule
==================

   To most clearly express the red-black balancing rule, we need a few
new vocabulary terms.  First, define a "non-branching node" as a node
that does not "branch" the binary tree in different directions, i.e., a
node with exactly zero or one children.

   Second, a "path" is a list of one or more nodes in a binary tree
where every node in the list (except the last node, of course) is
"adjacent" (*note adjacent::) in the tree to the one after it.  Two
nodes in a tree are considered to be adjacent for this purpose if one
is the child of the other.  Furthermore, a "simple path" is a path that
does not contain any given node more than once.

   Finally, a node p is a "descendant" of a second node q if both p and
q are the same node, or if p is located in one of the subtrees of q.

   With these definitions in mind, a red-black tree is a binary search
tree in which every node has been labeled with a "color" (*note
color::), either "red" or "black", with those colors distributed
according to these two simple rules, which are called the "red-black
balancing rules" and often referenced by number:

  1. No red node has a red child.

  2. Every simple path from a given node to one of its non-branching
     node descendants contains the same number of black nodes.

   Any binary search tree that conforms to these rules is a red-black
tree.  Additionally, all red-black trees in `libavl' share a simple
additional property: their roots are black.  This property is not
essential, but it does slightly simplify insertion and deletion
operations.

   To aid in digestion of all these definitions, here are some red-black
trees that might be produced by `libavl':

             4                                        1
            <b>                   4                  <b>
    ___..--'   \                 <b>               _'   `---...___
    1            5         __..-'   `._            0               6
   <r>          <b>        3            6         <b>             <r>
 _'   `._                 <b>          <b>                  __..-'   \
 0        3             _'   \       _'   \                 4          7
<b>      <b>            1      2     5      7              <b>        <b>
       _'              <r>    <r>   <r>    <r>           _'   \
       2                                                 3      5
      <r>                                               <r>    <r>

In this book, black nodes are marked `b' and red nodes marked `r', as
shown here.

The three colored BSTs below are *not* red-black trees.  The one on the
left violates rule 1, because red node 2 is a child of red node 4.  The
one in the middle violates rule 2, because one path from the root has
two black nodes (4-2-3) and the other paths from the root down to a
non-branching node (4-2-1, 4-5, 4-5-6) have only one black node.  The
one on the right violates rule 2, because the path consisting of only
node 1 has only one black node but path 1-2 has two black nodes.

                     4                    4
                    <r>                  <r>             1
              __..-'   \           __..-'   \           <b>
              2          5         2          5            \
             <r>        <b>       <b>        <b>             2
           _'   \               _'   \          \           <b>
           1      3             1      3          6
          <b>    <b>           <r>    <b>        <r>
 
  See also:  *Note Cormen 1990::, section 14.1; *Note Sedgewick 1998::,
definitions 13.3 and 13.4.

Exercises:

*1. A red-black tree contains only black nodes.  Describe the tree's
shape.

2. Suppose that a red-black tree's root is red.  How can it be
transformed into a equivalent red-black tree with a black root?  Does a
similar procedure work for changing a RB's root from black to red?

3. Suppose we have a perfectly balanced red-black tree with exactly pow
(2, n) - 1 nodes and a black root.  Is it possible there is another way
to arrange colors in a tree of the same shape that obeys the red-black
rules while keeping the root black?  Is it possible if we drop the
requirement that the tree be balanced?

* Menu:

* Analysis of Red-Black Balancing Rule::


File: libavl.info,  Node: Analysis of Red-Black Balancing Rule,  Prev: RB Balancing Rule,  Up: RB Balancing Rule

6.1.1 Analysis
--------------

   As we were for AVL trees, we're interested in what the red-black
balancing rule guarantees about performance.  Again, we'll simply state
the results:

     A red-black tree with n nodes has height at least log2 (n + 1) but
     no more than 2 * log2 (n + 1).  A red-black tree with height h has
     at least pow (2, h / 2) - 1 nodes but no more than pow (2, h) - 1.

     For comparison, an optimally balanced BST with n nodes has height
     ceil (log2 (n + 1)).  An optimally balanced BST with height h has
     between pow (2, h - 1) and pow (2, h) - 1 nodes.

See also:  *Note Cormen 1990::, lemma 14.1; *Note Sedgewick 1998::,
property 13.8.


File: libavl.info,  Node: RB Data Types,  Next: Operations in an RB Tree,  Prev: RB Balancing Rule,  Up: Red-Black Trees

6.2 Data Types
==============

   Red-black trees need their own data structure.  Otherwise, there's no
appropriate place to store each node's color.  Here's a C type for a
color and a structure for an RB node, using the rb_ prefix that we've
adopted for this module:

194. <RB node structure 194> =
/* Color of a red-black node. */
enum rb_color
  {
    RB_BLACK,   /* Black. */
    RB_RED      /* Red. */
  };

/* A red-black tree node. */
struct rb_node
  {
    struct rb_node *rb_link[2];   /* Subtrees. */
    void *rb_data;                /* Pointer to data. */
    unsigned char rb_color;       /* Color. */
  };

This code is included in *Note 192: rbh.

   The maximum height for an RB tree is higher than for an AVL tree,
because in the worst case RB trees store nodes less efficiently:

195. <RB maximum height 195> =
/* Maximum RB height. */
#ifndef RB_MAX_HEIGHT
#define RB_MAX_HEIGHT 48
#endif

This code is included in *Note 192: rbh, *Note 333: trbh, *Note 452:
rtrbh, and *Note 551: prbh.

   The other data structures for RB trees are the same as for BSTs or
AVL trees.

Exercises:

1. Why is it okay to have both an enumeration type and a structure
member named rb_color?


File: libavl.info,  Node: Operations in an RB Tree,  Next: Inserting into an RB tree,  Prev: RB Data Types,  Up: Red-Black Trees

6.3 Operations
==============

   Now we'll implement for RB trees all the operations that we did for
BSTs.  Everything but the insertion and deletion function can be
borrowed either from our BST or AVL tree functions.  The copy function
is an unusual case: we need it to copy colors, instead of balance
factors, between nodes, so we replace avl_balance by rb_color in the
macro expansion.

196. <RB functions 196> =
<*Note BST creation function:: 30>
<*Note BST search function:: 31>
<*Note RB item insertion function:: 197>
<*Note Table insertion convenience functions:: 592>
<*Note RB item deletion function:: 220>
<*Note AVL traversal functions:: 178>
<*Note AVL copy function:: 185>
<*Note BST destruction function:: 84>
<*Note Default memory allocation functions:: 6>
<*Note Table assertion functions:: 594>

This code is included in *Note 193: rbc.


File: libavl.info,  Node: Inserting into an RB tree,  Next: Deleting from an RB tree,  Prev: Operations in an RB Tree,  Up: Red-Black Trees

6.4 Insertion
=============

   The steps for insertion into a red-black tree are similar to those
for insertion into an AVL tree:

  1. *Search* for the location to insert the new item.

  2. *Insert* the item.

  3. *Rebalance* the tree as necessary to satisfy the red-black balance
     condition.

   Red-black node colors don't need to be updated in the way that AVL
balance factors do, so there is no separate step for updating colors.

   Here's the outline of the function, expressed as code:

197. <RB item insertion function 197> =
void **
rb_probe (struct rb_table *tree, void *item)
{
  <*Note |rb_probe()| local variables:: 198>

  <*Note Step 1 Search RB tree for insertion point:: 199>
  <*Note Step 2 Insert RB node:: 200>
  <*Note Step 3 Rebalance after RB insertion:: 201>

  return &n->rb_data;
}

This code is included in *Note 196: RB functions.

198. <rb_probe() local variables 198> =
struct rb_node *pa[RB_MAX_HEIGHT]; /* Nodes on stack. */
unsigned char da[RB_MAX_HEIGHT];   /* Directions moved from stack nodes. */
int k;                             /* Stack height. */

struct rb_node *p; /* Traverses tree looking for insertion point. */
struct rb_node *n; /* Newly inserted node. */

assert (tree != NULL && item != NULL);

This code is included in *Note 33: BST item insertion function root
insertion version, *Note 197: RB item insertion function, and *Note
210: RB item insertion function initial black.

See also:  *Note Cormen 1990::, section 14.3; *Note Sedgewick 1998::,
program 13.6.

* Menu:

* Inserting an RB node step 1 - Search::
* Inserting an RB node step 2 - Insert::
* Inserting an RB node step 3 - Rebalance::
* RB insertion symmetric case::
* Initial Black Insertion in an RB Tree::


File: libavl.info,  Node: Inserting an RB node step 1 - Search,  Next: Inserting an RB node step 2 - Insert,  Prev: Inserting into an RB tree,  Up: Inserting into an RB tree

6.4.1 Step 1: Search
--------------------

   The first thing to do is to search for the point to insert the new
node.  In a manner similar to AVL deletion, we keep a stack of nodes
tracking the path followed to arrive at the insertion point, so that
later we can move up the tree in rebalancing.

199. <Step 1: Search RB tree for insertion point 199> =
pa[0] = (struct rb_node *) &tree->rb_root;
da[0] = 0;
k = 1;
for (p = tree->rb_root; p != NULL; p = p->rb_link[da[k - 1]])
  {
    int cmp = tree->rb_compare (item, p->rb_data, tree->rb_param);
    if (cmp == 0)
      return &p->rb_data;

    pa[k] = p;
    da[k++] = cmp > 0;
  }

This code is included in *Note 197: RB item insertion function and
*Note 210: RB item insertion function initial black.


File: libavl.info,  Node: Inserting an RB node step 2 - Insert,  Next: Inserting an RB node step 3 - Rebalance,  Prev: Inserting an RB node step 1 - Search,  Up: Inserting into an RB tree

6.4.2 Step 2: Insert
--------------------

200. <Step 2: Insert RB node 200> =
n = pa[k - 1]->rb_link[da[k - 1]] =
  tree->rb_alloc->libavl_malloc (tree->rb_alloc, sizeof *n);
if (n == NULL)
  return NULL;

n->rb_data = item;
n->rb_link[0] = n->rb_link[1] = NULL;
n->rb_color = RB_RED;
tree->rb_count++;
tree->rb_generation++;

This code is included in *Note 197: RB item insertion function and
*Note 210: RB item insertion function initial black.

Exercises:

1. Why are new nodes colored red, instead of black?


File: libavl.info,  Node: Inserting an RB node step 3 - Rebalance,  Next: RB insertion symmetric case,  Prev: Inserting an RB node step 2 - Insert,  Up: Inserting into an RB tree

6.4.3 Step 3: Rebalance
-----------------------

   The code in step 2 that inserts a node always colors the new node
red.  This means that rule 2 is always satisfied afterward (as long as
it was satisfied before we began).  On the other hand, rule 1 is broken
if the newly inserted node's parent was red.  In this latter case we
must rearrange or recolor the BST so that it is again an RB tree.

   This is what rebalancing does.  At each step in rebalancing, we have
the invariant that we just colored a node p red and that p's parent,
the node at the top of the stack, is also red, a rule 1 violation.  The
rebalancing step may either clear up the violation entirely, without
introducing any other violations, in which case we are done, or, if
that is not possible, it reduces the violation to a similar violation
of rule 1 higher up in the tree, in which case we go around again.

   In no case can we allow the rebalancing step to introduce a rule 2
violation, because the loop is not prepared to repair that kind of
problem: it does not fit the invariant.  If we allowed rule 2
violations to be introduced, we would have to write additional code to
recognize and repair those violations.  This extra code would be a
waste of space, because we can do just fine without it.  (Incidentally,
there is nothing magical about using a rule 1 violation as our
rebalancing invariant.  We could use a rule 2 violation as our
invariant instead, and in fact we will later write an alternate
implementation that does that, in order to show how it would be done.)

   Here is the rebalancing loop.  At each rebalancing step, it checks
that we have a rule 1 violation by checking the color of pa[k - 1], the
node on the top of the stack, and then divides into two cases, one for
rebalancing an insertion in pa[k - 1]'s left subtree and a symmetric
case for the right subtree.  After rebalancing it recolors the root of
the tree black just in case the loop changed it to red:

201. <Step 3: Rebalance after RB insertion 201> =
while (k >= 3 && pa[k - 1]->rb_color == RB_RED)
  {
    if (da[k - 2] == 0)
      {
        <*Note Left-side rebalancing after RB insertion:: 202>
      }
    else
      {
        <*Note Right-side rebalancing after RB insertion:: 206>
      }
  }
tree->rb_root->rb_color = RB_BLACK;

This code is included in *Note 197: RB item insertion function.

   Now for the real work.  We'll look at the left-side insertion case
only.  Consider the node that was just recolored red in the last
rebalancing step, or if this is the first rebalancing step, the newly
inserted node n.  The code does not name this node, but we will refer
to it here as q.  We know that q is red and, because the loop condition
was met, that its parent pa[k - 1] is red.  Therefore, due to rule 1,
q's grandparent, pa[k - 2], must be black.  After this, we have three
cases, distinguished by the following code:

202. <Left-side rebalancing after RB insertion 202> =
struct rb_node *y = pa[k - 2]->rb_link[1];
if (y != NULL && y->rb_color == RB_RED)
  {
    <*Note Case 1 in left-side RB insertion rebalancing:: 203>
  }
else
  {
    struct rb_node *x;

    if (da[k - 1] == 0)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in left-side RB insertion rebalancing:: 205>
      }

    <*Note Case 2 in left-side RB insertion rebalancing:: 204>
    break;
  }

This code is included in *Note 201: Step 3 Rebalance after RB insertion.

Case 1: q's uncle is red
........................

   If q has an "uncle" y, that is, its grandparent has a child on the
side opposite q, and y is red, then rearranging the tree's color scheme
is all that needs to be done, like this:

                       |                                 |
                    pa[k-2]                           pa[k-2]
                      <b>                               <r>
            ___..--'       `_                 ___..--'       `_
           pa[k-1]            y              pa[k-1]            y
             <r>             <r>   =>          <b>             <b>
       _.-'       \         /   \        _.-'       \         /   \
       q           c       d     e       q           c       d     e
      <r>                               <r>
     /   \                             /   \
    a     b                           a     b
 
 Notice the neat way that this preserves the "black-height" (*note
black-height::), or the number of black nodes in any simple path from a
given node down to a node with 0 or 1 children, at pa[k - 2].  This
ensures that rule 2 is not violated.

After the transformation, if node pa[k - 2]'s parent exists and is red,
then we have to move up the tree and try again.  The while loop
condition takes care of this test, so adjusting the stack is all that
has to be done in this code segment:

203. <Case 1 in left-side RB insertion rebalancing 203> =
pa[k - 1]->rb_color = y->rb_color = RB_BLACK;
pa[k - 2]->rb_color = RB_RED;
k -= 2;

This code is included in *Note 202: Left-side rebalancing after RB
insertion, *Note 207: Case 1 in right-side RB insertion rebalancing,
*Note 342: Case 1 in left-side TRB insertion rebalancing, and *Note
462: Case 1 in left-side RTRB insertion rebalancing.

Case 2: q is the left child of pa[k - 1]
........................................

   If q is the left child of its parent, then we can perform a right
rotation at q's grandparent, which we'll call x, and recolor a couple
of nodes.  Then we're all done, because we've satisfied both rules.
Here's a diagram of what's happened:

                                 |
                             pa[k-2],x              |
                                <b>                 y
                   ___...---'         \            <b>
                  pa[k-1],y            d       _.-'   `_
                     <r>                 =>    q         x
              _.-'         \                  <r>       <r>
              q             c                /   \     /   \
             <r>                            a     b   c     d
            /   \
           a     b
 
 There's no need to progress farther up the tree, because neither the
subtree's black-height nor its root's color have changed.  Here's the
corresponding code.  Bear in mind that the break statement is in the
enclosing code segment:

204. <Case 2 in left-side RB insertion rebalancing 204> =
x = pa[k - 2];
x->rb_color = RB_RED;
y->rb_color = RB_BLACK;

x->rb_link[0] = y->rb_link[1];
y->rb_link[1] = x;
pa[k - 3]->rb_link[da[k - 3]] = y;

This code is included in *Note 202: Left-side rebalancing after RB
insertion, *Note 343: Case 2 in left-side TRB insertion rebalancing,
and *Note 464: Case 2 in left-side RTRB insertion rebalancing.

Case 3: q is the right child of pa[k - 1]
.........................................

   The final case, where q is a right child, is really just a small
variant of case 2, so we can handle it by transforming it into case 2
and sharing code for that case.  To transform case 2 to case 3, we just
rotate left at q's parent, which is then treated as q.

   The diagram below shows the transformation from case 3 into case 2.
After this transformation, x is relabeled q and y's parent is labeled
x, then rebalancing continues as shown in the diagram for case 2, with
the exception that pa[k - 1] is not updated to correspond to y as shown
in that diagram.  That's okay because variable y has already been set
to point to the proper node.

                                 |                      |
                              pa[k-2]                  <b>
                                <b>                _.-'   \
               _____.....----'       \             y       d
              pa[k-1],x               d           <r>
                 <r>                    =>    _.-'   \
             /         `_                     x       c
            a            q,y                 <r>
                         <r>                /   \
                        /   \              a     b
                       b     c
205. <Case 3 in left-side RB insertion rebalancing 205> =
x = pa[k - 1];
y = x->rb_link[1];
x->rb_link[1] = y->rb_link[0];
y->rb_link[0] = x;
pa[k - 2]->rb_link[0] = y;

This code is included in *Note 202: Left-side rebalancing after RB
insertion, *Note 344: Case 3 in left-side TRB insertion rebalancing,
and *Note 466: Case 3 in left-side RTRB insertion rebalancing.

Exercises:

1. Why is the test k >= 3 on the while loop valid?  (Hint: read the
code for step 4, below, first.)

2. Consider rebalancing case 2 and, in particular, what would happen if
the root of subtree d were red.  Wouldn't the rebalancing
transformation recolor x as red and thus cause a rule 1 violation?

