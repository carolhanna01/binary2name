This is libavl.info, produced by makeinfo version 4.0b from libavl.texi.


File: libavl.info,  Node: RB insertion symmetric case,  Next: Initial Black Insertion in an RB Tree,  Prev: Inserting an RB node step 3 - Rebalance,  Up: Inserting into an RB tree

6.4.4 Symmetric Case
--------------------

206. <Right-side rebalancing after RB insertion 206> =
struct rb_node *y = pa[k - 2]->rb_link[0];
if (y != NULL && y->rb_color == RB_RED)
  {
    <*Note Case 1 in right-side RB insertion rebalancing:: 207>
  }
else
  {
    struct rb_node *x;

    if (da[k - 1] == 1)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in right-side RB insertion rebalancing:: 209>
      }

    <*Note Case 2 in right-side RB insertion rebalancing:: 208>
    break;
  }

This code is included in *Note 201: Step 3 Rebalance after RB insertion.

207. <Case 1 in right-side RB insertion rebalancing 207> =
<*Note Case 1 in left-side RB insertion rebalancing:: 203>

This code is included in *Note 206: Right-side rebalancing after RB
insertion, *Note 346: Case 1 in right-side TRB insertion rebalancing,
and *Note 463: Case 1 in right-side RTRB insertion rebalancing.

208. <Case 2 in right-side RB insertion rebalancing 208> =
x = pa[k - 2];
x->rb_color = RB_RED;
y->rb_color = RB_BLACK;

x->rb_link[1] = y->rb_link[0];
y->rb_link[0] = x;
pa[k - 3]->rb_link[da[k - 3]] = y;

This code is included in *Note 206: Right-side rebalancing after RB
insertion, *Note 347: Case 2 in right-side TRB insertion rebalancing,
and *Note 465: Case 2 in right-side RTRB insertion rebalancing.

209. <Case 3 in right-side RB insertion rebalancing 209> =
x = pa[k - 1];
y = x->rb_link[0];
x->rb_link[0] = y->rb_link[1];
y->rb_link[1] = x;
pa[k - 2]->rb_link[1] = y;

This code is included in *Note 206: Right-side rebalancing after RB
insertion, *Note 348: Case 3 in right-side TRB insertion rebalancing,
and *Note 467: Case 3 in right-side RTRB insertion rebalancing.


File: libavl.info,  Node: Initial Black Insertion in an RB Tree,  Prev: RB insertion symmetric case,  Up: Inserting into an RB tree

6.4.5 Aside: Initial Black Insertion
------------------------------------

   The traditional algorithm for insertion in an RB tree colors new
nodes red.  This is a good choice, because it often means that no
rebalancing is necessary, but it is not the only possible choice.  This
section implements an alternate algorithm for insertion into an RB tree
that colors new nodes black.

   The outline is the same as for initial-red insertion.  We change the
newly inserted node from red to black and replace the rebalancing
algorithm:

210. <RB item insertion function, initial black 210> =
void **
rb_probe (struct rb_table *tree, void *item)
{
  <*Note |rb_probe()| local variables:: 198>

  <*Note Step 1 Search RB tree for insertion point:: 199>
  <*Note Step 2 Insert RB node:: 200>
  <*Note Step 3 Rebalance after initial-black RB insertion:: 211>

  return &n->rb_data;
}

   The remaining task is to devise the rebalancing algorithm.
Rebalancing is always necessary, unless the tree was empty before
insertion, because insertion of a black node into a nonempty tree
always violates rule 2.  Thus, our invariant is that we have a rule 2
violation to fix.

   More specifically, the invariant, as implemented, is that at the top
of each trip through the loop, stack pa[] contains the chain of
ancestors of a node that is the black root of a subtree whose
black-height is 1 more than it should be.  We give that node the name
q.  There is one easy rebalancing special case: if node q has a black
parent, we can just recolor q as red, and we're done.  Here's the loop:

211. <Step 3: Rebalance after initial-black RB insertion 211> =
while (k >= 2)
  {
    struct rb_node *q = pa[k - 1]->rb_link[da[k - 1]];

    if (pa[k - 1]->rb_color == RB_BLACK)
      {
        q->rb_color = RB_RED;
        break;
      }

    if (da[k - 2] == 0)
      {
        <*Note Left-side rebalancing after initial-black RB insertion:: 212>
      }
    else
      {
        <*Note Right-side rebalancing after initial-black RB insertion:: 216>
      }
  }

This code is included in *Note 210: RB item insertion function initial
black.

   Consider rebalancing where insertion was on the left side of q's
grandparent.  We know that q is black and its parent pa[k - 1] is red.
Then, we can divide rebalancing into three cases, described below in
detail.  (For additional insight, compare these cases to the
corresponding cases for initial-red insertion.)

212. <Left-side rebalancing after initial-black RB insertion 212> =
struct rb_node *y = pa[k - 2]->rb_link[1];

if (y != NULL && y->rb_color == RB_RED)
  {
    <*Note Case 1 in left-side initial-black RB insertion rebalancing:: 213>
  }
else
  {
    struct rb_node *x;

    if (da[k - 1] == 0)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in left-side initial-black RB insertion rebalancing:: 215>
      }

    <*Note Case 2 in left-side initial-black RB insertion rebalancing:: 214>
  }

This code is included in *Note 211: Step 3 Rebalance after
initial-black RB insertion.

Case 1: q's uncle is red
........................

   If q has an red "uncle" y, then we recolor q red and pa[k - 1] and y
black.  This fixes the immediate problem, making the black-height of q
equal to its sibling's, but increases the black-height of pa[k - 2], so
we must repeat the rebalancing process farther up the tree:

                       |                                 |
                    pa[k-2]                           pa[k-2]
                      <b>                               <b>
            ___..--'       `_                 ___..--'       `_
           pa[k-1]            y              pa[k-1]            y
             <r>             <r>   =>          <b>             <b>
       _.-'       \         /   \        _.-'       \         /   \
       q           c       d     e       q           c       d     e
      <b>                               <r>
     /   \                             /   \
    a     b                           a     b
213. <Case 1 in left-side initial-black RB insertion rebalancing 213> =
pa[k - 1]->rb_color = y->rb_color = RB_BLACK;
q->rb_color = RB_RED;
k -= 2;

This code is included in *Note 212: Left-side rebalancing after
initial-black RB insertion and *Note 217: Case 1 in right-side
initial-black RB insertion rebalancing.

Case 2: q is the left child of pa[k - 1]
........................................

   If q is a left child, then call q's parent y and its grandparent x,
rotate right at x, and recolor q, y, and x.  The effect is that the
black-heights of all three subtrees is the same as before q was
inserted, so we're done, and break out of the loop.

                                 |
                             pa[k-2],x              |
                                <b>                 y
                   ___...---'         \            <b>
                  pa[k-1],y            d       _.-'   `_
                     <r>                 =>    q         x
              _.-'         \                  <r>       <r>
              q             c                /   \     /   \
             <b>                            a     b   c     d
            /   \
           a     b
214. <Case 2 in left-side initial-black RB insertion rebalancing 214> =
x = pa[k - 2];
x->rb_color = q->rb_color = RB_RED;
y->rb_color = RB_BLACK;

x->rb_link[0] = y->rb_link[1];
y->rb_link[1] = x;
pa[k - 3]->rb_link[da[k - 3]] = y;
break;

This code is included in *Note 212: Left-side rebalancing after
initial-black RB insertion.

Case 3: q is the right child of pa[k - 1]
.........................................

   If q is a right child, then we rotate left at its parent, which we
here call x.  The result is in the form for application of case 2, so
after the rotation, we relabel the nodes to be consistent with that
case.

                               |                        |
                            pa[k-2]                  pa[k-2]
                              <b>                      <b>
             _____.....----'       \             _.-'       \
            pa[k-1],x               d            q           d
               <r>                    =>        <b>
           /         `_                     _.-'   \
          a             q                   x       c
                       <b>                 <r>
                      /   \               /   \
                     b     c             a     b
215. <Case 3 in left-side initial-black RB insertion rebalancing 215> =
x = pa[k - 1];
y = pa[k - 2]->rb_link[0] = q;
x->rb_link[1] = y->rb_link[0];
q = y->rb_link[0] = x;

This code is included in *Note 212: Left-side rebalancing after
initial-black RB insertion.

6.4.5.1 Symmetric Case
......................

216. <Right-side rebalancing after initial-black RB insertion 216> =
struct rb_node *y = pa[k - 2]->rb_link[0];

if (y != NULL && y->rb_color == RB_RED)
  {
    <*Note Case 1 in right-side initial-black RB insertion rebalancing:: 217>
  }
else
  {
    struct rb_node *x;

    if (da[k - 1] == 1)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in right-side initial-black RB insertion rebalancing:: 219>
      }

    <*Note Case 2 in right-side initial-black RB insertion rebalancing:: 218>
  }

This code is included in *Note 211: Step 3 Rebalance after
initial-black RB insertion.

217. <Case 1 in right-side initial-black RB insertion rebalancing 217> =
<*Note Case 1 in left-side initial-black RB insertion rebalancing:: 213>

This code is included in *Note 216: Right-side rebalancing after
initial-black RB insertion.

218. <Case 2 in right-side initial-black RB insertion rebalancing 218> =
x = pa[k - 2];
x->rb_color = q->rb_color = RB_RED;
y->rb_color = RB_BLACK;

x->rb_link[1] = y->rb_link[0];
y->rb_link[0] = x;
pa[k - 3]->rb_link[da[k - 3]] = y;
break;

This code is included in *Note 216: Right-side rebalancing after
initial-black RB insertion.

219. <Case 3 in right-side initial-black RB insertion rebalancing 219> =
x = pa[k - 1];
y = pa[k - 2]->rb_link[1] = q;
x->rb_link[0] = y->rb_link[1];
q = y->rb_link[1] = x;

This code is included in *Note 216: Right-side rebalancing after
initial-black RB insertion.


File: libavl.info,  Node: Deleting from an RB tree,  Next: Testing RB Trees,  Prev: Inserting into an RB tree,  Up: Red-Black Trees

6.5 Deletion
============

   The process of deletion from an RB tree is very much in line with the
other algorithms for balanced trees that we've looked at already.  This
time, the steps are:

  1. *Search* for the item to delete.

  2. *Delete* the item.

  3. *Rebalance* the tree as necessary.

  4. *Finish up* and return.

   Here's an outline of the code.  Step 1 is already done for us,
because we can reuse the search code from AVL deletion.

220. <RB item deletion function 220> =
void *
rb_delete (struct rb_table *tree, const void *item)
{
  struct rb_node *pa[RB_MAX_HEIGHT]; /* Nodes on stack. */
  unsigned char da[RB_MAX_HEIGHT];   /* Directions moved from stack nodes. */
  int k;                             /* Stack height. */

  struct rb_node *p;    /* The node to delete, or a node part way to it. */
  int cmp;              /* Result of comparison between item and p. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1 Search AVL tree for item to delete:: 165>
  <*Note Step 2 Delete item from RB tree:: 221>
  <*Note Step 3 Rebalance tree after RB deletion:: 225>
  <*Note Step 4 Finish up after RB deletion:: 232>
}

This code is included in *Note 196: RB functions.

See also:  *Note Cormen 1990::, section 14.4.

* Menu:

* Deleting an RB node step 2 - Delete::
* Deleting an RB node step 3 - Rebalance::
* Deleting an RB node step 4 - Finish up::
* RB deletion symmetric case::


File: libavl.info,  Node: Deleting an RB node step 2 - Delete,  Next: Deleting an RB node step 3 - Rebalance,  Prev: Deleting from an RB tree,  Up: Deleting from an RB tree

6.5.1 Step 2: Delete
--------------------

   At this point, p is the node to be deleted and the stack contains
all of the nodes on the simple path from the tree's root down to p.
The immediate task is to delete p.  We break deletion down into the
familiar three cases (*note Deleting from a BST::), but before we dive
into the code, let's think about the situation.

   In red-black insertion, we were able to limit the kinds of violation
that could occur to rule 1 or rule 2, at our option, by choosing the
new node's color.  No such luxury is available in deletion, because
colors have already been assigned to all of the nodes.  In fact, a
naive approach to deletion can lead to multiple violations in widely
separated parts of a tree.  Consider the effects of deletion of node 3
from the following red-black tree tree, supposing that it is a subtree
of some larger tree:

                              |
                              3
                             <r>
                       __..-'   `----...._____
                       1                       8
                      <b>                     <b>
                    _'   \              __..-'   \
                    0      2            6          9
                   <b>    <b>          <r>        <b>
                                 __..-'   \
                                 4          7
                                <b>        <b>
                                   \
                                     5
                                    <r>
 
 If we performed this deletion in a literal-minded fashion, we would
end up with the tree below, with the following violations: rule 1,
between node 6 and its child; rule 2, at node 6; rule 2, at node 4,
because the black-height of the subtree as a whole has increased
(ignoring the rule 2 violation at node 6); and rule 1, at node 4, only
if the subtree's parent is red.  The result is difficult to rebalance in
general because we have two problem areas to deal with, one at node 4,
one at node 6.

                                |
                                4
                               <b>
                         __..-'   `---...___
                         1                   8
                        <b>                 <b>
                      _'   \          __..-'   \
                      0      2        6          9
                     <b>    <b>      <r>        <b>
                                   _'   \
                                   5      7
                                  <r>    <b>
 
 Fortunately, we can make things easier for ourselves.  We can
eliminate the problem area at node 4 simply by recoloring it red, the
same color as the node it replaced, as shown below.  Then all we have
to deal with are the violations at node 6:

                                |
                                4
                               <r>
                         __..-'   `---...___
                         1                   8
                        <b>                 <b>
                      _'   \          __..-'   \
                      0      2        6          9
                     <b>    <b>      <r>        <b>
                                   _'   \
                                   5      7
                                  <r>    <b>

This idea holds in general.  So, when we replace the deleted node p by
a different node q, we set q's color to p's.  Besides that, as an
implementation detail, we need to keep track of the color of the node
that was moved, i.e., node q's former color.  We do this here by saving
it temporarily in p.  In other words, when we replace one node by
another during deletion, we swap their colors.

   Now we know enough to begin the implementation.  While reading this
code, keep in mind that after deletion, regardless of the case
selected, the stack contains a list of the nodes where rebalancing may
be required, and da[k - 1] indicates the side of pa[k - 1] from which a
node of color p->rb_color was deleted.  Here's an outline of the meat
of the code:

221. <Step 2: Delete item from RB tree 221> =
if (p->rb_link[1] == NULL)
  { <*Note Case 1 in RB deletion:: 222> }
else
  {
    enum rb_color t;
    struct rb_node *r = p->rb_link[1];

    if (r->rb_link[0] == NULL)
      {
        <*Note Case 2 in RB deletion:: 223>
      }
    else
      {
        <*Note Case 3 in RB deletion:: 224>
      }
  }

This code is included in *Note 220: RB item deletion function.

Case 1: p has no right child
............................

   In case 1, p has no right child, so we replace it by its left
subtree.  As a very special case, there is no need to do any swapping
of colors (see Exercise 1 for details).

222. <Case 1 in RB deletion 222> =
pa[k - 1]->rb_link[da[k - 1]] = p->rb_link[0];

This code is included in *Note 221: Step 2 Delete item from RB tree.

Case 2: p's right child has no left child
.........................................

   In this case, p has a right child r, which in turn has no left
child.  We replace p by r, swap the colors of nodes p and r, and add r
to the stack because we may need to rebalance there.  Here's a pre- and
post-deletion diagram that shows one possible set of colors out of the
possibilities.  Node p is shown detached after deletion to make it
clear that the colors are swapped:

                         |              |
                         p              r        p
                        <r>            <r>      <b>
                       /   \          /   \
                      a      r    => a     x
                            <b>
                               \
                                x
223. <Case 2 in RB deletion 223> =
r->rb_link[0] = p->rb_link[0];
t = r->rb_color;
r->rb_color = p->rb_color;
p->rb_color = t;
pa[k - 1]->rb_link[da[k - 1]] = r;
da[k] = 1;
pa[k++] = r;

This code is included in *Note 221: Step 2 Delete item from RB tree.

Case 3: p's right child has a left child
........................................

   In this case, p's right child has a left child.  The code here is
basically the same as for AVL deletion.  We replace p by its inorder
successor s and swap their node colors.  Because they may require
rebalancing, we also add all of the nodes we visit to the stack.
Here's a diagram to clear up matters, again with arbitrary colors:

            |                          |
            p                          s
           <b>                        <b>
          /   `----....____          /   `---...___
         a                 <r>      a              <r>
                         _'   \                  _'   \      p
                        ...    c                ...    c    <r>
                    _.-'         =>         _.-'
                    r                       r
                   <r>                     <r>
               _.-'   \                   /   \
               s       b                 x     b
              <b>
                 \
                  x
224. <Case 3 in RB deletion 224> =
struct rb_node *s;
int j = k++;

for (;;)
  {
    da[k] = 0;
    pa[k++] = r;
    s = r->rb_link[0];
    if (s->rb_link[0] == NULL)
      break;

    r = s;
  }

da[j] = 1;
pa[j] = s;
pa[j - 1]->rb_link[da[j - 1]] = s;

s->rb_link[0] = p->rb_link[0];
r->rb_link[0] = s->rb_link[1];
s->rb_link[1] = p->rb_link[1];

t = s->rb_color;
s->rb_color = p->rb_color;
p->rb_color = t;

This code is included in *Note 221: Step 2 Delete item from RB tree.

Exercises:

*1. In case 1, why is it unnecessary to swap the colors of p and the
node that replaces it?

2. Rewrite <*Note Step 2 Delete item from RB tree:: 221> to replace the
deleted node's rb_data by its successor, then delete the successor,
instead of shuffling pointers.  (Refer back to Exercise 5.8-3 for an
explanation of why this approach cannot be used in `libavl'.)


File: libavl.info,  Node: Deleting an RB node step 3 - Rebalance,  Next: Deleting an RB node step 4 - Finish up,  Prev: Deleting an RB node step 2 - Delete,  Up: Deleting from an RB tree

6.5.2 Step 3: Rebalance
-----------------------

   At this point, node p has been removed from tree and p->rb_color
indicates the color of the node that was removed from the tree.  Our
first step is to handle one common special case: if we deleted a red
node, no rebalancing is necessary, because deletion of a red node
cannot violate either rule.  Here is the code to avoid rebalancing in
this special case:

225. <Step 3: Rebalance tree after RB deletion 225> =
if (p->rb_color == RB_BLACK)
  {
    <*Note Rebalance after RB deletion:: 226>
  }

This code is included in *Note 220: RB item deletion function.

   On the other hand, if a black node was deleted, then we have more
work to do.  At the least, we have a violation of rule 2.  If the
deletion brought together two red nodes, as happened in the example in
the previous section, there is also a violation of rule 1.

   We must now fix both of these problems by rebalancing.  This time,
the rebalancing loop invariant is that the black-height of pa[k - 1]'s
subtree on side da[k - 1] is 1 less than the black-height of its other
subtree, a rule 2 violation.

   There may also be a rule 2 violation, such pa[k - 1] and its child
on side da[k - 1], which we will call x, are both red.  (In the first
iteration of the rebalancing loop, node x is the node labeled as such
in the diagrams in the previous section.)  If this is the case, then
the fix for rule 2 is simple: just recolor x black.  This increases the
black-height and fixes any rule 1 violation as well.  If we can do
this, we're all done.  Otherwise, we have more work to do.

   Here's the rebalancing loop:

226. <Rebalance after RB deletion 226> =
for (;;)
  {
    struct rb_node *x = pa[k - 1]->rb_link[da[k - 1]];
    if (x != NULL && x->rb_color == RB_RED)
      {
        x->rb_color = RB_BLACK;
        break;
      }
    if (k < 2)
      break;

    if (da[k - 1] == 0)
      {
        <*Note Left-side rebalancing after RB deletion:: 227>
      }
    else
      {
        <*Note Right-side rebalancing after RB deletion:: 233>
      }

    k--;
  }

This code is included in *Note 225: Step 3 Rebalance tree after RB
deletion.

   Now we'll take a detailed look at the rebalancing algorithm.  As
before, we'll only examine the case where the deleted node was in its
parent's left subtree, that is, where da[k - 1] is 0.  The other case
is similar.

   Recall that x is pa[k - 1]->rb_link[da[k - 1]] and that it may be a
null pointer.  In the left-side deletion case, x is pa[k - 1]'s left
child.  We now designate x's "sibling", the right child of pa[k - 1],
as w.  Jumping right in, here's an outline of the rebalancing code:

227. <Left-side rebalancing after RB deletion 227> =
struct rb_node *w = pa[k - 1]->rb_link[1];

if (w->rb_color == RB_RED)
  {
    <*Note Ensure |w| is black in left-side RB deletion rebalancing:: 228>
  }

if ((w->rb_link[0] == NULL
     || w->rb_link[0]->rb_color == RB_BLACK)
    && (w->rb_link[1] == NULL
        || w->rb_link[1]->rb_color == RB_BLACK))
  { <*Note Case 1 in left-side RB deletion rebalancing:: 229> }
else
  {
    if (w->rb_link[1] == NULL
        || w->rb_link[1]->rb_color == RB_BLACK)
      {
        <*Note Transform left-side RB deletion rebalancing case 3 into case 2:: 231>
      }

    <*Note Case 2 in left-side RB deletion rebalancing:: 230>
    break;
  }

This code is included in *Note 226: Rebalance after RB deletion.

Case Reduction: Ensure w is black
.................................

   We know, at this point, that x is a black node or an empty tree.
Node w may be red or black.  If w is red, we perform a left rotation at
the common parent of x and w, labeled A in the diagram below, and
recolor A and its own newly acquired parent C.  Then we reassign w as
the new sibling of x.  The effect is to ensure that w is also black, in
order to reduce the number of cases:

         |                                               |
     A,pa[k-1]                                       C,pa[k-2]
        <b>                                             <b>
    /         `--..__                 _____.....----'         `_
   x                 C,w             A,pa[k-1]                   D
                     <r>        =>      <r>                     <b>
                 _.-'   `_          /         `_               /   \
                 B         D       x            B,w           c     d
                <b>       <b>                   <b>
               /   \     /   \                 /   \
              a     b   c     d               a     b

Node w must have children because x is black, in order to satisfy rule
2, and w's children must be black because of rule 1.

   Here is the code corresponding to this transformation.  Because the
ancestors of node x change, pa[] and da[] are updated as well as w.

228. <Ensure w is black in left-side RB deletion rebalancing 228> =
w->rb_color = RB_BLACK;
pa[k - 1]->rb_color = RB_RED;

pa[k - 1]->rb_link[1] = w->rb_link[0];
w->rb_link[0] = pa[k - 1];
pa[k - 2]->rb_link[da[k - 2]] = w;

pa[k] = pa[k - 1];
da[k] = 0;
pa[k - 1] = w;
k++;

w = pa[k - 1]->rb_link[1];

This code is included in *Note 227: Left-side rebalancing after RB
deletion, *Note 358: Ensure |w| is black in left-side TRB deletion
rebalancing, and *Note 475: Left-side rebalancing after RTRB deletion.

   Now we can take care of the three rebalancing cases one by one.
Remember that the situation is a deleted black node in the subtree
designated x and the goal is to correct a rule 2 violation.  Although
subtree x may be an empty tree, the diagrams below show it as a black
node.  That's okay because the code itself never refers to x.  The
label is supplied for the reader's benefit only.

Case 1: w has no red children
.............................

   If w doesn't have any red children, then it can be recolored red.
When we do that, the black-height of the subtree rooted at w has
decreased, so we must move up the tree, with pa[k - 1] becoming the new
x, to rebalance at w and x's parent.

   The parent, labeled B in the diagram below, may be red or black.
Its color is not changed within the code for this case.  If it is red,
then the next iteration of the rebalancing loop will recolor it as red
immediately and exit.  In particular, B will be red if the
transformation to make x black was performed earlier.  If, on the other
hand, B is black, the loop will continue as usual.

                         |                       |
                     B,pa[k-1]                  B,x
                        <g>                     <g>
                 _.-'         `_            _.-'   `_
                A,x             C,w   =>    A         C
                <b>             <b>        <b>       <r>
               /   \           /   \      /   \     /   \
              a     b         c     d    a     b   c     d
229. <Case 1 in left-side RB deletion rebalancing 229> =
w->rb_color = RB_RED;

This code is included in *Note 227: Left-side rebalancing after RB
deletion, *Note 359: Case 1 in left-side TRB deletion rebalancing,
*Note 475: Left-side rebalancing after RTRB deletion, and *Note 574:
Case 1 in left-side PRB deletion rebalancing.

Case 2: w's right child is red
..............................

   If w's right child is red, we can perform a left rotation at pa[k -
1] and recolor some nodes, and thereby satisfy both of the red-black
rules.  The loop is then complete.  The transformation looks like this:

                    |                                 |
                B,pa[x-1]                             C
                   <g>                               <g>
            _.-'         `_                      _.-'   `_
           A,x             C,w                   B         D
           <b>             <b>        =>        <b>       <b>
          /   \           /   `_            _.-'   \     /   \
         a     b         c       D          A       c   d     e
                                <r>        <b>
                               /   \      /   \
                              d     e    a     b
 
 The corresponding code is below.  The break is supplied by the
enclosing code segment <*Note Left-side rebalancing after RB deletion::
227>:

230. <Case 2 in left-side RB deletion rebalancing 230> =
w->rb_color = pa[k - 1]->rb_color;
pa[k - 1]->rb_color = RB_BLACK;
w->rb_link[1]->rb_color = RB_BLACK;

pa[k - 1]->rb_link[1] = w->rb_link[0];
w->rb_link[0] = pa[k - 1];
pa[k - 2]->rb_link[da[k - 2]] = w;

This code is included in *Note 227: Left-side rebalancing after RB
deletion, *Note 360: Case 2 in left-side TRB deletion rebalancing, and
*Note 477: Case 2 in left-side RTRB deletion rebalancing.

Case 3: w's left child is red
.............................

   Because the conditions for neither case 1 nor case 2 apply, the only
remaining possibility is that w has a red left child.  When this is the
case, we can transform it into case 2 by rotating right at w.  This
causes w to move to the node that was previously w's left child, in
this way:

                 |                               |
             B,pa[k-1]                       B,pa[k-1]
                <g>                             <g>
         _.-'         `--..__            _.-'         `_
        A,x                  D,w        A,x             C,w
        <b>                  <b>   =>   <b>             <b>
       /   \             _.-'   \      /   \           /   `_
      a     b            C       e    a     b         c       D
                        <r>                                  <r>
                       /   \                                /   \
                      c     d                              d     e
231. <Transform left-side RB deletion rebalancing case 3 into case 2 231> =
struct rb_node *y = w->rb_link[0];
y->rb_color = RB_BLACK;
w->rb_color = RB_RED;
w->rb_link[0] = y->rb_link[1];
y->rb_link[1] = w;
w = pa[k - 1]->rb_link[1] = y;

This code is included in *Note 227: Left-side rebalancing after RB
deletion, *Note 361: Transform left-side TRB deletion rebalancing case
3 into case 2, and *Note 479: Transform left-side RTRB deletion
rebalancing case 3 into case 2.


File: libavl.info,  Node: Deleting an RB node step 4 - Finish up,  Next: RB deletion symmetric case,  Prev: Deleting an RB node step 3 - Rebalance,  Up: Deleting from an RB tree

6.5.3 Step 4: Finish Up
-----------------------

   All that's left to do is free the node, update counters, and return
the deleted item:

232. <Step 4: Finish up after RB deletion 232> =
tree->rb_alloc->libavl_free (tree->rb_alloc, p);
tree->rb_count--;
tree->rb_generation++;
return (void *) item;

This code is included in *Note 220: RB item deletion function.


File: libavl.info,  Node: RB deletion symmetric case,  Prev: Deleting an RB node step 4 - Finish up,  Up: Deleting from an RB tree

6.5.4 Symmetric Case
--------------------

233. <Right-side rebalancing after RB deletion 233> =
struct rb_node *w = pa[k - 1]->rb_link[0];

if (w->rb_color == RB_RED)
  {
    <*Note Ensure |w| is black in right-side RB deletion rebalancing:: 234>
  }

if ((w->rb_link[0] == NULL
     || w->rb_link[0]->rb_color == RB_BLACK)
    && (w->rb_link[1] == NULL
        || w->rb_link[1]->rb_color == RB_BLACK))
  { <*Note Case 1 in right-side RB deletion rebalancing:: 235> }
else
  {
    if (w->rb_link[0] == NULL
        || w->rb_link[0]->rb_color == RB_BLACK)
      {
        <*Note Transform right-side RB deletion rebalancing case 3 into case 2:: 236>
      }

    <*Note Case 2 in right-side RB deletion rebalancing:: 237>
    break;
  }

This code is included in *Note 226: Rebalance after RB deletion.

234. <Ensure w is black in right-side RB deletion rebalancing 234> =
w->rb_color = RB_BLACK;
pa[k - 1]->rb_color = RB_RED;

pa[k - 1]->rb_link[0] = w->rb_link[1];
w->rb_link[1] = pa[k - 1];
pa[k - 2]->rb_link[da[k - 2]] = w;

pa[k] = pa[k - 1];
da[k] = 1;
pa[k - 1] = w;
k++;

w = pa[k - 1]->rb_link[0];

This code is included in *Note 233: Right-side rebalancing after RB
deletion, *Note 364: Ensure |w| is black in right-side TRB deletion
rebalancing, and *Note 476: Right-side rebalancing after RTRB deletion.

235. <Case 1 in right-side RB deletion rebalancing 235> =
w->rb_color = RB_RED;

This code is included in *Note 233: Right-side rebalancing after RB
deletion, *Note 365: Case 1 in right-side TRB deletion rebalancing, and
*Note 476: Right-side rebalancing after RTRB deletion.

236. <Transform right-side RB deletion rebalancing case 3 into case 2 236> =
struct rb_node *y = w->rb_link[1];
y->rb_color = RB_BLACK;
w->rb_color = RB_RED;
w->rb_link[1] = y->rb_link[0];
y->rb_link[0] = w;
w = pa[k - 1]->rb_link[0] = y;

This code is included in *Note 233: Right-side rebalancing after RB
deletion, *Note 367: Transform right-side TRB deletion rebalancing case
3 into case 2, and *Note 480: Transform right-side RTRB deletion
rebalancing case 3 into case 2.

237. <Case 2 in right-side RB deletion rebalancing 237> =
w->rb_color = pa[k - 1]->rb_color;
pa[k - 1]->rb_color = RB_BLACK;
w->rb_link[0]->rb_color = RB_BLACK;

pa[k - 1]->rb_link[0] = w->rb_link[1];
w->rb_link[1] = pa[k - 1];
pa[k - 2]->rb_link[da[k - 2]] = w;

This code is included in *Note 233: Right-side rebalancing after RB
deletion, *Note 366: Case 2 in right-side TRB deletion rebalancing, and
*Note 478: Case 2 in right-side RTRB deletion rebalancing.


File: libavl.info,  Node: Testing RB Trees,  Prev: Deleting from an RB tree,  Up: Red-Black Trees

6.6 Testing
===========

   Now we'll present a test program to demonstrate that our code works,
using the same framework that has been used in past chapters.  The
additional code needed is straightforward:

238. <rb-test.c 238> =
<*Note License:: 1>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "rb.h"
#include "test.h"

<*Note BST print function:: 119>
<*Note BST traverser check function:: 104>
<*Note Compare two RB trees for structure and content:: 239>
<*Note Recursively verify RB tree structure:: 240>
<*Note RB tree verify function:: 244>
<*Note BST test function:: 100>
<*Note BST overflow test function:: 122>

239. <Compare two RB trees for structure and content 239> =
static int
compare_trees (struct rb_node *a, struct rb_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      assert (a == NULL && b == NULL);
      return 1;
    }

  if (*(int *) a->rb_data != *(int *) b->rb_data
      || ((a->rb_link[0] != NULL) != (b->rb_link[0] != NULL))
      || ((a->rb_link[1] != NULL) != (b->rb_link[1] != NULL))
      || a->rb_color != b->rb_color)
    {
      printf (" Copied nodes differ: a=%d%c b=%d%c a:",
              *(int *) a->rb_data, a->rb_color == RB_RED ? 'r' : 'b',
              *(int *) b->rb_data, b->rb_color == RB_RED ? 'r' : 'b');

      if (a->rb_link[0] != NULL)
        printf ("l");
      if (a->rb_link[1] != NULL)
        printf ("r");

      printf (" b:");
      if (b->rb_link[0] != NULL)
        printf ("l");
      if (b->rb_link[1] != NULL)
        printf ("r");

      printf ("\n");
      return 0;
    }

  okay = 1;
  if (a->rb_link[0] != NULL)
    okay &= compare_trees (a->rb_link[0], b->rb_link[0]);
  if (a->rb_link[1] != NULL)
    okay &= compare_trees (a->rb_link[1], b->rb_link[1]);
  return okay;
}

This code is included in *Note 238: rb-testc.

240. <Recursively verify RB tree structure 240> =
/* Examines the binary tree rooted at node.  
   Zeroes *okay if an error occurs.
   Otherwise, does not modify *okay.
   Sets *count to the number of nodes in that tree,
   including node itself if node != NULL.
   Sets *bh to the tree's black-height.
   All the nodes in the tree are verified to be at least min
   but no greater than max. */
static void
recurse_verify_tree (struct rb_node *node, int *okay, size_t *count, 
                     int min, int max, int *bh)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */
  int subbh[2];         /* Black-heights of subtrees. */

  if (node == NULL)
    {
      *count = 0;
      *bh = 0;
      return;
    }
  d = *(int *) node->rb_data;

  <*Note Verify binary search tree ordering:: 114>

  recurse_verify_tree (node->rb_link[0], okay, &subcount[0], 
                       min, d - 1, &subbh[0]);
  recurse_verify_tree (node->rb_link[1], okay, &subcount[1], 
                       d + 1, max, &subbh[1]);
  *count = 1 + subcount[0] + subcount[1];
  *bh = (node->rb_color == RB_BLACK) + subbh[0];

  <*Note Verify RB node color:: 241>
  <*Note Verify RB node rule 1 compliance:: 242>
  <*Note Verify RB node rule 2 compliance:: 243>
}

This code is included in *Note 238: rb-testc.

241. <Verify RB node color 241> =
if (node->rb_color != RB_RED && node->rb_color != RB_BLACK)
  {
    printf (" Node %d is neither red nor black (%d).\n",
            d, node->rb_color);
    *okay = 0;
  }

This code is included in *Note 240: Recursively verify RB tree
structure, *Note 370: Recursively verify TRB tree structure, *Note 484:
Recursively verify RTRB tree structure, and *Note 585: Recursively
verify PRB tree structure.

242. <Verify RB node rule 1 compliance 242> =
/* Verify compliance with rule 1. */
if (node->rb_color == RB_RED)
  {
    if (node->rb_link[0] != NULL && node->rb_link[0]->rb_color == RB_RED)
      {
        printf (" Red node %d has red left child %d\n",
                d, *(int *) node->rb_link[0]->rb_data);
        *okay = 0;
      }

    if (node->rb_link[1] != NULL && node->rb_link[1]->rb_color == RB_RED)
      {
        printf (" Red node %d has red right child %d\n",
                d, *(int *) node->rb_link[1]->rb_data);
        *okay = 0;
      }
  }

This code is included in *Note 240: Recursively verify RB tree
structure and *Note 585: Recursively verify PRB tree structure.

243. <Verify RB node rule 2 compliance 243> =
/* Verify compliance with rule 2. */
if (subbh[0] != subbh[1])
  {
    printf (" Node %d has two different black-heights: left bh=%d, "
            "right bh=%d\n", d, subbh[0], subbh[1]);
    *okay = 0;
  }

This code is included in *Note 240: Recursively verify RB tree
structure, *Note 370: Recursively verify TRB tree structure, *Note 484:
Recursively verify RTRB tree structure, and *Note 585: Recursively
verify PRB tree structure.

244. <RB tree verify function 244> =
static int
verify_tree (struct rb_table *tree, int array[], size_t n)
{
  int okay = 1;

  <*Note Check |tree->bst_count| is correct:: 110>

  if (okay)
    {
      <*Note Check root is black:: 245>
    }

  if (okay)
    {
      <*Note Check RB tree structure:: 246>
    }

  if (okay)
    {
      <*Note Check that the tree contains all the elements it should:: 115>
    }

  if (okay)
    {
      <*Note Check that forward traversal works:: 116>
    }

  if (okay)
    {
      <*Note Check that backward traversal works:: 117>
    }

  if (okay)
    {
      <*Note Check that traversal from the null element works:: 118>
    }

  return okay;
}

This code is included in *Note 238: rb-testc, *Note 368: trb-testc,
*Note 482: rtrb-testc, and *Note 583: prb-testc.

245. <Check root is black 245> =
if (tree->rb_root != NULL && tree->rb_root->rb_color != RB_BLACK)
  {
    printf (" Tree's root is not black.\n");
    okay = 0;
  }

This code is included in *Note 244: RB tree verify function.

246. <Check RB tree structure 246> =
/* Recursively verify tree structure. */
size_t count;
int bh;

recurse_verify_tree (tree->rb_root, &okay, &count, 0, INT_MAX, &bh);
<*Note Check counted nodes:: 112>

This code is included in *Note 244: RB tree verify function.


File: libavl.info,  Node: Threaded Binary Search Trees,  Next: Threaded AVL Trees,  Prev: Red-Black Trees,  Up: Top

7 Threaded Binary Search Trees
******************************

   Traversal in inorder, as done by `libavl' traversers, is a common
operation in a binary tree.  To do this efficiently in an ordinary
binary search tree or balanced tree, we need to maintain a list of the
nodes above the current node, or at least a list of nodes still to be
visited.  This need leads to the stack used in struct bst_traverser and
friends.

   It's really too bad that we need such stacks for traversal.  First,
they take up space.  Second, they're fragile: if an item is inserted
into or deleted from the tree during traversal, or if the tree is
balanced, we have to rebuild the traverser's stack.  In addition, it
can sometimes be difficult to know in advance how tall the stack will
need to be, as demonstrated by the code that we wrote to handle stack
overflow.

   These problems are important enough that, in this book, we'll look at
two different solutions.  This chapter looks at the first of these,
which adds special pointers, each called a "thread" (*note thread::),
to nodes, producing what is called a threaded binary search tree,
"threaded tree" (*note threaded tree::), or simply a TBST.(1)  Later in
the book, we'll examine an alternate and more general solution using a
"parent pointer" (*note parent pointer::) in each node.

   Here's the outline of the TBST code.  We're using the prefix tbst_
this time:

247. <tbst.h 247> =
<*Note License:: 1>
#ifndef TBST_H
#define TBST_H 1

#include <stddef.h>

<*Note Table types:: 14>
<*Note TBST table structure:: 250>
<*Note TBST node structure:: 249>
<*Note TBST traverser structure:: 267>
<*Note Table function prototypes:: 15>
<*Note BST extra function prototypes:: 88>

#endif /* tbst.h */

248. <tbst.c 248> =
<*Note License:: 1>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "tbst.h"

<*Note TBST functions:: 251>

* Menu:

* Threads::
* TBST Data Types::
* TBST Operations::
* Creating a TBST::
* Searching a TBST::
* Inserting into a TBST::
* Deleting from a TBST::
* Traversing a TBST::
* Copying a TBST::
* Destroying a TBST::
* Balancing a TBST::
* Testing TBSTs::

   ---------- Footnotes ----------

   (1) This usage of "thread" has nothing to do with the idea of a
program with multiple "threads of excecution", a form of multitasking
within a single program.


File: libavl.info,  Node: Threads,  Next: TBST Data Types,  Prev: Threaded Binary Search Trees,  Up: Threaded Binary Search Trees

7.1 Threads
===========

   In an ordinary binary search tree or balanced tree, a lot of the
pointer fields go more-or-less unused.  Instead of pointing to
somewhere useful, they are used to store null pointers.  In a sense,
they're wasted.  What if we were to instead use these fields to point
elsewhere in the tree?

   This is the idea behind a threaded tree.  In a threaded tree, a
node's left child pointer field, if it would otherwise be a null
pointer, is used to point to the node's inorder predecessor.  An
otherwise-null right child pointer field points to the node's
successor.  The least-valued node in a threaded tree has a null pointer
for its left thread, and the greatest-valued node similarly has a null
right thread.  These two are the only null pointers in a threaded tree.

   Here's a sample threaded tree:

                           3
                       _.-' `---....____
                      2                 6
                  _.-' \        ___..--' `--..___
                 1      [3]    4                 8
                / \          _' `._          _.-' `._
               []  [2]      [3]    5        7        9
                                 _' \     _' \     _' \
                                [4]  [6] [6]  [8] [8]  []
 
  This diagram illustrates the convention used for threads in text:
thread links are designated by surrounding the node name or value with
square brackets.  Null threads in the least and greatest nodes are
shown as `[0]', which is also used to show threads up to nodes not
shown in the diagram.  This notation is unfortunate, but less visually
confusing than trying to include additional arrows in text art tree
diagrams.

There are some disadvantages to threaded trees.  Each node in an
unthreaded tree has only one pointer that leads to it, either from the
tree structure or its parent node, but in a threaded tree some nodes
have as many as three pointers leading to them: one from the root or
parent, one from its predecessor's right thread, and one from its
successor's left thread.  This means that, although traversing a
threaded tree is simpler, building and maintaining a threaded tree is
more complicated.

   As we learned earlier, any node that has a right child has a
successor in its right subtree, and that successor has no left child.
So, a node in an threaded tree has a left thread pointing back to it if
and only if the node has a right child.  Similarly, a node has a right
thread pointing to it if and only if the node has a left child.  Take a
look at the sample tree above and check these statements for yourself
for some of its nodes.

See also:  *Note Knuth 1997::, section 2.3.1.


File: libavl.info,  Node: TBST Data Types,  Next: TBST Operations,  Prev: Threads,  Up: Threaded Binary Search Trees

7.2 Data Types
==============

   We need two extra fields in the node structure to keep track of
whether each link is a child pointer or a thread.  Each of these fields
is called a "tag" (*note tag::).  The revised struct tbst_node, along
with enum tbst_tag for tags, looks like this:

249. <TBST node structure 249> =
/* Characterizes a link as a child pointer or a thread. */
enum tbst_tag
  {
    TBST_CHILD,                     /* Child pointer. */
    TBST_THREAD                     /* Thread. */
  };

/* A threaded binary search tree node. */
struct tbst_node
  {
    struct tbst_node *tbst_link[2]; /* Subtrees. */
    void *tbst_data;                /* Pointer to data. */
    unsigned char tbst_tag[2];      /* Tag fields. */
  };

This code is included in *Note 247: tbsth.

Each element of tbst_tag[] is set to TBST_CHILD if the corresponding
tbst_link[] element is a child pointer, or to TBST_THREAD if it is a
thread.  The other members of struct tbst_node should be familiar.

   We also want a revised table structure, because traversers in
threaded trees do not need a generation number:

250. <TBST table structure 250> =
/* Tree data structure. */
struct tbst_table
  {
    struct tbst_node *tbst_root;        /* Tree's root. */
    tbst_comparison_func *tbst_compare; /* Comparison function. */
    void *tbst_param;                   /* Extra argument to tbst_compare. */
    struct libavl_allocator *tbst_alloc; /* Memory allocator. */
    size_t tbst_count;                  /* Number of items in tree. */
  };

This code is included in *Note 247: tbsth, *Note 297: tavlh, *Note 333:
trbh, *Note 372: rtbsth, *Note 415: rtavlh, *Note 452: rtrbh, *Note
486: pbsth, *Note 519: pavlh, and *Note 551: prbh.

   There is no need to define a maximum height for TBST trees because
none of the TBST functions use a stack.

Exercises:

1. We defined enum tbst_tag for distinguishing threads from child
pointers, but declared the actual tag members as unsigned char instead.
Why?


File: libavl.info,  Node: TBST Operations,  Next: Creating a TBST,  Prev: TBST Data Types,  Up: Threaded Binary Search Trees

7.3 Operations
==============

   Now that we've changed the basic form of our binary trees, we have to
rewrite most of the tree functions.  A function designed for use with
unthreaded trees will get hopelessly lost in a threaded tree, because
it will follow threads that it thinks are child pointers.  The only
functions we can keep are the totally generic functions defined in
terms of other table functions.

251. <TBST functions 251> =
<*Note TBST creation function:: 252>
<*Note TBST search function:: 253>
<*Note TBST item insertion function:: 254>
<*Note Table insertion convenience functions:: 592>
<*Note TBST item deletion function:: 257>
<*Note TBST traversal functions:: 268>
<*Note TBST copy function:: 278>
<*Note TBST destruction function:: 281>
<*Note TBST balance function:: 282>
<*Note Default memory allocation functions:: 6>
<*Note Table assertion functions:: 594>

This code is included in *Note 248: tbstc.


File: libavl.info,  Node: Creating a TBST,  Next: Searching a TBST,  Prev: TBST Operations,  Up: Threaded Binary Search Trees

7.4 Creation
============

   Function tbst_create() is the same as bst_create() except that a
struct tbst_table has no generation number to fill in.

252. <TBST creation function 252> =
struct tbst_table *
tbst_create (tbst_comparison_func *compare, void *param,
            struct libavl_allocator *allocator)
{
  struct tbst_table *tree;

  assert (compare != NULL);

  if (allocator == NULL)
    allocator = &tbst_allocator_default;

  tree = allocator->libavl_malloc (allocator, sizeof *tree);
  if (tree == NULL)
    return NULL;

  tree->tbst_root = NULL;
  tree->tbst_compare = compare;
  tree->tbst_param = param;
  tree->tbst_alloc = allocator;
  tree->tbst_count = 0;

  return tree;
}

This code is included in *Note 251: TBST functions, *Note 300: TAVL
functions, *Note 336: TRB functions, *Note 375: RTBST functions, *Note
418: RTAVL functions, *Note 455: RTRB functions, *Note 489: PBST
functions, *Note 522: PAVL functions, and *Note 554: PRB functions.


File: libavl.info,  Node: Searching a TBST,  Next: Inserting into a TBST,  Prev: Creating a TBST,  Up: Threaded Binary Search Trees

7.5 Search
==========

   In searching a TBST we just have to be careful to distinguish threads
from child pointers.  If we hit a thread link, then we've run off the
bottom of the tree and the search is unsuccessful.  Other that that, a
search in a TBST works the same as in any other binary search tree.

253. <TBST search function 253> =
void *
tbst_find (const struct tbst_table *tree, const void *item)
{
  const struct tbst_node *p;

  assert (tree != NULL && item != NULL);

  p = tree->tbst_root;
  if (p == NULL)
    return NULL;

  for (;;)
    {
      int cmp, dir;

      cmp = tree->tbst_compare (item, p->tbst_data, tree->tbst_param);
      if (cmp == 0)
        return p->tbst_data;

      dir = cmp > 0;
      if (p->tbst_tag[dir] == TBST_CHILD)
        p = p->tbst_link[dir];
      else
        return NULL;
    }
}

This code is included in *Note 251: TBST functions, *Note 300: TAVL
functions, and *Note 336: TRB functions.

