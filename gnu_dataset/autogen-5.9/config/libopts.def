
autogen definitions conftest.tpl;

/*
 */ author =           "Bruce Korb <bkorb@gnu.org>";
/*  Created:           Tue Nov 24 01:07:30 1998
 *  Last Modified:     $Date: 2007/01/18 05:32:13 $
 *  Time-stamp:        "2007-01-12 12:10:55 bkorb"
 *             by: bkorb
 *  -------------------------------------------------------------------
 *  $Id: libopts.def,v 4.16 2007/01/18 05:32:13 bkorb Exp $
 *  -------------------------------------------------------------------
 */

group       = libopts;
version     = "$Revision: 4.16 $";
output-file = libopts.m4;

test   = {
  name     = "regex_header";
  type     = "with";
  check    = "a reg expr header is specified";

  action   = { yes; act-type = script; asis;
        act-text = 'AC_DEFINE_UNQUOTED([REGEX_HEADER],'
                   '[<${libopts_cv_with_regex_header}>])';
  };

  action   = { no; act-type = script; asis;
        act-text = 'AC_DEFINE([REGEX_HEADER],[<regex.h>],'
                              '[name of regex header file])'; };

  doc = "When using alternative libraries, sometimes you must use\n"
        "alternative header file names, too.";
};

test   = {
  name     = regex;
  type     = withlib;
  check    = "a working libregex can be found";
  libname  = "";
  code     = <<- _END_OF_CODE_
	#include <stdio.h>
	#include <stdlib.h>
	#include <sys/types.h>
	#include REGEX_HEADER
	static regex_t re;
	void comp_re( char const* pzPat ) {
	  int res = regcomp( &re, pzPat, REG_EXTENDED|REG_ICASE|REG_NEWLINE );
	  if (res == 0) return;
	  exit( res ); }
	int main() {
	  regmatch_t m[2];
	  comp_re( "^.*\$"   );
	  comp_re( "()|no.*" );
	  comp_re( "."       );
	  if (regexec( &re, "X", 2, m, 0 ) != 0)  return 1;
	  if ((m[0].rm_so != 0) || (m[0].rm_eo != 1)) {
	    fputs( "error: regex -->.<-- did not match\n", stderr );
	    return 1;
	  }
	  return 0; }
	_END_OF_CODE_;
  run-mode   =  "run";
  code-mode  =  "all";
  action = { act-type = define; };

  doc =
  "AutoGen won't work without a POSIX compliant regular expression library.";
};

test = {
    name   = pathfind;
    type   = run;
    check  = "pathfind(3) works";
    action = { act-type = define; };

    code   = <<-  _EOF_
	#include <string.h>
	#include <stdlib.h>
	int main (int argc, char** argv) {
	   char* pz = pathfind( getenv( "PATH" ), "sh", "x" );
	   return (pz == 0) ? 1 : 0;
	}
	_EOF_;

    doc =
    "Not all systems have pathfind(3).  See if we need to substitute.\n"
    "To make this work, you have to do horrible things.  See the doc\n"
    "for AG_CHECK_STRCSPN.";
};

test = {
    name   = dev_zero;
    type   = test;
    check  = "/dev/zero is readable device";
    action = { act-type = define; };

    code   = <<-  _EOF_
	dzero=`ls -lL /dev/zero | egrep ^c......r`
	test -z "${dzero}" && exit 1
	echo ${dzero}
	_EOF_;

    doc =
    "Not all systems have pathfind(3).  See if we need to substitute.\n"
    "To make this work, you have to do horrible things.  See the doc\n"
    "for AG_CHECK_STRCSPN.";
};

test = {
    name   = realpath;
    type   = run;
    check  = "we have a functional realpath(3C)";
    action = { act-type = define; };

    code   = <<-  _EOF_
	#include <limits.h>
	#include <stdlib.h>
	int main (int argc, char** argv) {
	#ifndef PATH_MAX
	choke me!!
	#else
	   char zPath[PATH_MAX+1];
	#endif
	   char *pz = realpath(argv[0], zPath);
	   return (pz == zPath) ? 0 : 1;
	}
	_EOF_;


    doc = <<- _EODoc_
	realpath only really works if PATH_MAX is defined.  If it is not defined,
	the value may be obtained from pathconf(3C), but that value might be
	unallocatable.  So, without a sane PATH_MAX, we won't be able to use
	realpath(3C).
	_EODoc_;
};

test = {
    name  = strftime;
    type  = run;
    check = "strftime() works";
    action = { act-type = define; };
    code  = <<-  _EOF_
	#include <time.h>
	#include <string.h>
	char t_buf[ 64 ];
	int main() {
	  static char const z[] = "Thursday Aug 28 240";
	  struct tm tm;
	  tm.tm_sec   = 36;  /* seconds after the minute [0, 61]  */
	  tm.tm_min   = 44;  /* minutes after the hour [0, 59] */
	  tm.tm_hour  = 12;  /* hour since midnight [0, 23] */
	  tm.tm_mday  = 28;  /* day of the month [1, 31] */
	  tm.tm_mon   =  7;  /* months since January [0, 11] */
	  tm.tm_year  = 86;  /* years since 1900 */
	  tm.tm_wday  =  4;  /* days since Sunday [0, 6] */
	  tm.tm_yday  = 239; /* days since January 1 [0, 365] */
	  tm.tm_isdst =  1;  /* flag for daylight savings time */
	  strftime( t_buf, sizeof( t_buf ), "%A %b %d %j", &tm );
	  return (strcmp( t_buf, z ) != 0); }
	_EOF_;

    doc =
    "Check for existence and functioning of strftime routine.";
};

test = {
    name   = fopen_binary;
    type   = run;
    check  = 'fopen accepts "b" mode';
    action = { act-type = script; asis;
      act-text = "AC_DEFINE([FOPEN_BINARY_FLAG],\"b\",\n\t"
                 "[fopen(3) accepts a 'b' in the mode flag])"; };
    action = { act-type = script; asis; no;
      act-text = "AC_DEFINE([FOPEN_BINARY_FLAG],\"\",\n\t"
                 "[fopen(3) accepts a 'b' in the mode flag])"; };
    code   = <<- _EOF_
	#include <stdio.h>
	int main (int argc, char** argv) {
	FILE* fp = fopen("conftest.$ac_ext", "rb");
	return (fp == NULL) ? 1 : fclose(fp); }
	_EOF_;
    doc = <<- _END_OF_DOC_
	Test whether fopen accepts a "b" in the mode string for binary file
	opening.  This makes no difference on most unices, but some OSes
	convert every newline written to a file to two bytes (CR LF), and
	every CR LF read from a file is silently converted to a newline.
	_END_OF_DOC_;
};

test = {
    name   = fopen_text;
    type   = run;
    check  = 'fopen accepts "t" mode';
    action = { act-type = script; asis;
      act-text = "AC_DEFINE([FOPEN_TEXT_FLAG],\"t\",\n\t"
                 "[fopen(3) accepts a 't' in the mode flag])"; };
    action = { act-type = script; asis; no;
      act-text = "AC_DEFINE([FOPEN_TEXT_FLAG],\"\",\n\t"
                 "[fopen(3) accepts a 't' in the mode flag])"; };
    code   = <<- _EOF_
	#include <stdio.h>
	int main (int argc, char** argv) {
	FILE* fp = fopen("conftest.$ac_ext", "rt");
	return (fp == NULL) ? 1 : fclose(fp); }
	_EOF_;
    doc = <<- _END_OF_DOC_
	Test whether fopen accepts a "t" in the mode string for text file
	opening.  This makes no difference on most unices, but some OSes
	convert every newline written to a file to two bytes (CR LF), and
	every CR LF read from a file is silently converted to a newline.
	_END_OF_DOC_;
};

do-first = <<-_EOF_
	# =================
	# AC_HEADER_STDC
	# =================
	AC_HEADER_STDC
	# =================
	# AC_HEADER_DIRENT
	# =================
	AC_HEADER_DIRENT

	# =================
	# AC_CHECK_HEADERS
	# =================
	AC_CHECK_HEADERS(dlfcn.h errno.h fcntl.h libgen.h memory.h netinet/in.h \
	  setjmp.h sys/mman.h sys/param.h sys/poll.h sys/procset.h sys/select.h \
	  sys/socket.h sys/stropts.h sys/time.h sys/un.h sys/wait.h unistd.h    \
	  utime.h )

	# --------------------------------------------
	# Verify certain entries from AC_CHECK_HEADERS
	# --------------------------------------------
	[for f in sys_types sys_mman sys_param sys_stat sys_wait \
	         string errno stdlib memory setjmp
	do eval as_ac_var=\${ac_cv_header_${f}_h+set}
	   test "${as_ac_var}" = set] || \
	     AC_MSG_ERROR([You must have ${f}.h on your system])
	done

	# ================================================
	# AC_CHECK_HEADERS: stdarg.h is present define HAVE_STDARG_H, otherwise
	# if varargs.h is present define HAVE_VARARGS_H.
	# ================================================
	AC_CHECK_HEADERS(stdarg.h varargs.h, break)
	[if test `eval echo '${'$as_ac_Header'}'` != yes; then]
	  AC_MSG_ERROR([You must have stdarg.h or varargs.h on your system])
	fi

	# ================================================
	# Similarly for the string.h and strings.h headers
	# ================================================
	AC_CHECK_HEADERS(string.h strings.h, break)
	[if test `eval echo '${'$as_ac_Header'}'` != yes; then]
	  AC_MSG_ERROR([You must have string.h or strings.h on your system])
	fi

	# =====================
	# ...and limits headers
	# =====================
	AC_CHECK_HEADERS(limits.h sys/limits.h values.h, break)
	[if test `eval echo '${'$as_ac_Header'}'` != yes; then]
	  AC_MSG_ERROR([You must have one of limits.h, sys/limits.h or values.h])
	fi

	# ========================
	# ...and int types headers
	# ========================
	AC_CHECK_HEADERS(stdint.h inttypes.h, break)
	AC_CHECK_TYPES([int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t,
	   intptr_t, uint_t])

	# ====================
	# uintptr type & sizes
	# ====================
	AC_CHECK_TYPES([uintptr_t], ,
	       [AC_DEFINE([uintptr_t], unsigned long,
	                  [Alternate uintptr_t for systems without it.])])
	AC_CHECK_SIZEOF(char*, 4)
	AC_CHECK_SIZEOF(int,   4)
	AC_CHECK_SIZEOF(long,  4)
	AC_CHECK_SIZEOF(short, 2)

	# ----------------------------------------------------------------------
	# AC_CHECK_LIB for SVR4 libgen, and use it if it defines pathfind.
	# ----------------------------------------------------------------------
	AC_CHECK_LIB(gen, pathfind)
	AC_FUNC_VPRINTF
	AC_CHECK_FUNCS([mmap canonicalize_file_name snprintf strdup strchr strrchr])
	_EOF_;
