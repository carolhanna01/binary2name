/*   -*- buffer-read-only: t -*- vi: set ro:
 *  
 *  DO NOT EDIT THIS FILE   (xmlopts.c)
 *  
 *  It has been AutoGen-ed  Saturday February 17, 2007 at 12:51:03 PM PST
 *  From the definitions    ./xmlopts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 28:0:3 templates.
 */

/*
 *  This file was produced by an AutoOpts template.  AutoOpts is a
 *  copyrighted work.  This source file is not encumbered by AutoOpts
 *  licensing, but is provided under the licensing terms chosen by the
 *  xml2ag author or copyright holder.  AutoOpts is licensed under
 *  the terms of the LGPL.  The redistributable library (``libopts'') is
 *  licensed under the terms of either the LGPL or, at the users discretion,
 *  the BSD license.  See the AutoOpts and/or libopts sources for details.
 *
 * This source file is copyrighted and licensed under the following terms:
 *
 * xml2ag copyright 1992-2006 Bruce Korb - all rights reserved
 *
 * xml2ag is free software.
 * 
 * You may redistribute it and/or modify it under the terms of the
 * GNU General Public License, as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * xml2ag is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with xml2ag.  If not, write to:
 * 	The Free Software Foundation, Inc.,
 * 	51 Franklin Street, Fifth Floor
 * 	Boston, MA  02110-1301, USA.
 */


#include <limits.h>
#include <stdio.h>
#define OPTION_CODE_COMPILE 1
#include "xmlopts.h"

#ifdef  __cplusplus
extern "C" {
#endif
tSCC zCopyright[] =
       "xml2ag copyright (c) 1992-2006 Bruce Korb, all rights reserved";
tSCC zCopyrightNotice[] =
       "xml2ag is free software.\n\n\
You may redistribute it and/or modify it under the terms of the\n\
GNU General Public License, as published by the Free Software\n\
Foundation; either version 2 of the License, or (at your option)\n\
any later version.\n\n\
xml2ag is distributed in the hope that it will be useful,\n\
but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\
See the GNU General Public License for more details.\n\n\
You should have received a copy of the GNU General Public License\n\
along with xml2ag.  If not, write to:\n\
\tThe Free Software Foundation, Inc.,\n\
\t51 Franklin Street, Fifth Floor\n\
\tBoston, MA  02110-1301, USA.";
extern tUsageProc optionUsage;

#ifndef NULL
#  define NULL 0
#endif
#ifndef EXIT_SUCCESS
#  define  EXIT_SUCCESS 0
#endif
#ifndef EXIT_FAILURE
#  define  EXIT_FAILURE 1
#endif
/*
 *  Output option description:
 */
tSCC    zOutputText[] =
        "Output file in lieu of AutoGen processing";
tSCC    zOutput_NAME[]             = "OUTPUT";
tSCC    zOutput_Name[]             = "output";
#define OUTPUT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Templ_Dirs option description:
 */
tSCC    zTempl_DirsText[] =
        "Template search directory list";
tSCC    zTempl_Dirs_NAME[]         = "TEMPL_DIRS";
tSCC    zTempl_Dirs_Name[]         = "templ-dirs";
#define TEMPL_DIRS_FLAGS       (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Override_Tpl option description:
 */
tSCC    zOverride_TplText[] =
        "Override template file";
tSCC    zOverride_Tpl_NAME[]       = "OVERRIDE_TPL";
tSCC    zOverride_Tpl_Name[]       = "override-tpl";
#define OVERRIDE_TPL_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Lib_Template option description:
 */
tSCC    zLib_TemplateText[] =
        "Library template file";
tSCC    zLib_Template_NAME[]       = "LIB_TEMPLATE";
tSCC    zLib_Template_Name[]       = "lib-template";
#define LIB_TEMPLATE_FLAGS       (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Base_Name option description:
 */
tSCC    zBase_NameText[] =
        "Base name for output file(s)";
tSCC    zBase_Name_NAME[]          = "BASE_NAME";
tSCC    zBase_Name_Name[]          = "base-name";
#define BASE_NAME_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Definitions option description:
 */
tSCC    zDefinitionsText[] =
        "Definitions input file";
tSCC    zDefinitions_NAME[]        = "DEFINITIONS";
tSCC    zDefinitions_Name[]        = "definitions";
#define DEFINITIONS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Load_Scheme option description:
 */
tSCC    zLoad_SchemeText[] =
        "Scheme code file to load";
tSCC    zLoad_Scheme_NAME[]        = "LOAD_SCHEME";
tSCC    zLoad_Scheme_Name[]        = "load-scheme";
#define LOAD_SCHEME_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Load_Functions option description:
 */
#ifdef HAVE_DLOPEN
tSCC    zLoad_FunctionsText[] =
        "Load scheme function library";
tSCC    zLoad_Functions_NAME[]     = "LOAD_FUNCTIONS";
tSCC    zLoad_Functions_Name[]     = "load-functions";
#define LOAD_FUNCTIONS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable Load_Functions */
#define VALUE_OPT_LOAD_FUNCTIONS NO_EQUIVALENT
#define LOAD_FUNCTIONS_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zLoad_FunctionsText       NULL
#define zLoad_Functions_NAME      NULL
#define zLoad_Functions_Name      NULL
#endif  /* HAVE_DLOPEN */

/*
 *  Skip_Suffix option description:
 */
tSCC    zSkip_SuffixText[] =
        "Omit the file with this suffix";
tSCC    zSkip_Suffix_NAME[]        = "SKIP_SUFFIX";
tSCC    zSkip_Suffix_Name[]        = "skip-suffix";
#define SKIP_SUFFIX_FLAGS       (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Select_Suffix option description:
 */
tSCC    zSelect_SuffixText[] =
        "specify this output suffix";
tSCC    zSelect_Suffix_NAME[]      = "SELECT_SUFFIX";
tSCC    zSelect_Suffix_Name[]      = "select-suffix";
#define SELECT_SUFFIX_FLAGS       (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING) | OPTST_ARG_OPTIONAL)

/*
 *  Source_Time option description:
 */
tSCC    zSource_TimeText[] =
        "set mod times to latest source";
tSCC    zSource_Time_NAME[]        = "SOURCE_TIME";
tSCC    zSource_Time_Name[]        = "source-time";
#define SOURCE_TIME_FLAGS       (OPTST_DISABLED)

/*
 *  No_Fmemopen option description:
 */
#ifdef ENABLE_FMEMOPEN
tSCC    zNo_FmemopenText[] =
        "Do not use in-mem streams";
tSCC    zNo_Fmemopen_NAME[]        = "NO_FMEMOPEN";
tSCC    zNo_Fmemopen_Name[]        = "no-fmemopen";
#define NO_FMEMOPEN_FLAGS       (OPTST_DISABLED)

#else   /* disable No_Fmemopen */
#define VALUE_OPT_NO_FMEMOPEN NO_EQUIVALENT
#define NO_FMEMOPEN_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zNo_FmemopenText       NULL
#define zNo_Fmemopen_NAME      NULL
#define zNo_Fmemopen_Name      NULL
#endif  /* ENABLE_FMEMOPEN */

/*
 *  Equate option description:
 */
tSCC    zEquateText[] =
        "characters considered equivalent";
tSCC    zEquate_NAME[]             = "EQUATE";
tSCC    zEquate_Name[]             = "equate";
#define EQUATE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Writable option description:
 */
tSCC    zWritableText[] =
        "Allow output files to be writable";
tSCC    zWritable_NAME[]           = "WRITABLE";
tSCC    zNotWritable_Name[]        = "not-writable";
tSCC    zNotWritable_Pfx[]         = "not";
#define zWritable_Name               (zNotWritable_Name + 4)
#define WRITABLE_FLAGS       (OPTST_DISABLED)

/*
 *  Loop_Limit option description:
 */
tSCC    zLoop_LimitText[] =
        "Limit on increment loops";
tSCC    zLoop_Limit_NAME[]         = "LOOP_LIMIT";
tSCC    zLoop_Limit_Name[]         = "loop-limit";
#define zLoop_LimitDefaultArg        ((char const*)256)
#define LOOP_LIMIT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Timeout option description:
 */
tSCC    zTimeoutText[] =
        "Time limit for servers";
tSCC    zTimeout_NAME[]            = "TIMEOUT";
tSCC    zTimeout_Name[]            = "timeout";
#define TIMEOUT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Trace option description:
 */
tSCC    zTraceText[] =
        "tracing level of detail";
tSCC    zTrace_NAME[]              = "TRACE";
tSCC    zTrace_Name[]              = "trace";
#define zTraceDefaultArg             ((char const*)TRACE_NOTHING)
#define TRACE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_ENUMERATION))

/*
 *  Trace_Out option description:
 */
tSCC    zTrace_OutText[] =
        "tracing output file or filter";
tSCC    zTrace_Out_NAME[]          = "TRACE_OUT";
tSCC    zTrace_Out_Name[]          = "trace-out";
#define TRACE_OUT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Show_Defs option description:
 */
tSCC    zShow_DefsText[] =
        "Show the definition tree";
tSCC    zShow_Defs_NAME[]          = "SHOW_DEFS";
tSCC    zShow_Defs_Name[]          = "show-defs";
#define SHOW_DEFS_FLAGS       (OPTST_DISABLED)

/*
 *  Define option description:
 */
tSCC    zDefineText[] =
        "name to add to definition list";
tSCC    zDefine_NAME[]             = "DEFINE";
tSCC    zDefine_Name[]             = "define";
#define DEFINE_FLAGS       (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Undefine option description:
 */
tSCC    zUndefineText[] =
        "definition list removal pattern";
tSCC    zUndefine_NAME[]           = "UNDEFINE";
tSCC    zUndefine_Name[]           = "undefine";
#define UNDEFINE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Help/More_Help/Version option descriptions:
 */
tSCC zHelpText[]       = "Display usage information and exit";
tSCC zHelp_Name[]      = "help";

tSCC zMore_HelpText[]  = "Extended usage information passed thru pager";
tSCC zMore_Help_Name[] = "more-help";

tSCC zVersionText[]    = "Output version information and exit";
tSCC zVersion_Name[]   = "version";
/*
 *  Declare option callback procedures
 */
extern tOptProc
    optionPagedUsage, optionPrintVersion, optionStackArg, optionUnstackArg;
static tOptProc
    doOptLoop_Limit, doOptOutput, doOptTimeout, doOptTrace, doUsageOpt;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Xml2ag Option Descriptions.
 */
static tOptDesc optDesc[ OPTION_CT ] = {
  {  /* entry idx, value */ 0, VALUE_OPT_OUTPUT,
     /* equiv idx, value */ 0, VALUE_OPT_OUTPUT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OUTPUT_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptOutput,
     /* desc, NAME, name */ zOutputText, zOutput_NAME, zOutput_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 1, VALUE_OPT_TEMPL_DIRS,
     /* equiv idx, value */ 1, VALUE_OPT_TEMPL_DIRS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ TEMPL_DIRS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zTempl_DirsText, zTempl_Dirs_NAME, zTempl_Dirs_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 2, VALUE_OPT_OVERRIDE_TPL,
     /* equiv idx, value */ 2, VALUE_OPT_OVERRIDE_TPL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OVERRIDE_TPL_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zOverride_TplText, zOverride_Tpl_NAME, zOverride_Tpl_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 3, VALUE_OPT_LIB_TEMPLATE,
     /* equiv idx, value */ 3, VALUE_OPT_LIB_TEMPLATE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ LIB_TEMPLATE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zLib_TemplateText, zLib_Template_NAME, zLib_Template_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 4, VALUE_OPT_BASE_NAME,
     /* equiv idx, value */ 4, VALUE_OPT_BASE_NAME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ BASE_NAME_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zBase_NameText, zBase_Name_NAME, zBase_Name_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 5, VALUE_OPT_DEFINITIONS,
     /* equiv idx, value */ 5, VALUE_OPT_DEFINITIONS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DEFINITIONS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDefinitionsText, zDefinitions_NAME, zDefinitions_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 6, VALUE_OPT_LOAD_SCHEME,
     /* equiv idx, value */ 6, VALUE_OPT_LOAD_SCHEME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOAD_SCHEME_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zLoad_SchemeText, zLoad_Scheme_NAME, zLoad_Scheme_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 7, VALUE_OPT_LOAD_FUNCTIONS,
     /* equiv idx, value */ 7, VALUE_OPT_LOAD_FUNCTIONS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOAD_FUNCTIONS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zLoad_FunctionsText, zLoad_Functions_NAME, zLoad_Functions_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 8, VALUE_OPT_SKIP_SUFFIX,
     /* equiv idx, value */ 8, VALUE_OPT_SKIP_SUFFIX,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ SKIP_SUFFIX_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zSkip_SuffixText, zSkip_Suffix_NAME, zSkip_Suffix_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 9, VALUE_OPT_SELECT_SUFFIX,
     /* equiv idx, value */ 9, VALUE_OPT_SELECT_SUFFIX,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ SELECT_SUFFIX_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zSelect_SuffixText, zSelect_Suffix_NAME, zSelect_Suffix_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 10, VALUE_OPT_SOURCE_TIME,
     /* equiv idx, value */ 10, VALUE_OPT_SOURCE_TIME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SOURCE_TIME_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zSource_TimeText, zSource_Time_NAME, zSource_Time_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 11, VALUE_OPT_NO_FMEMOPEN,
     /* equiv idx, value */ 11, VALUE_OPT_NO_FMEMOPEN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NO_FMEMOPEN_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zNo_FmemopenText, zNo_Fmemopen_NAME, zNo_Fmemopen_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 12, VALUE_OPT_EQUATE,
     /* equiv idx, value */ 12, VALUE_OPT_EQUATE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ EQUATE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zEquateText, zEquate_NAME, zEquate_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 13, VALUE_OPT_WRITABLE,
     /* equiv idx, value */ 13, VALUE_OPT_WRITABLE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ WRITABLE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zWritableText, zWritable_NAME, zWritable_Name,
     /* disablement strs */ zNotWritable_Name, zNotWritable_Pfx },

  {  /* entry idx, value */ 14, VALUE_OPT_LOOP_LIMIT,
     /* equiv idx, value */ 14, VALUE_OPT_LOOP_LIMIT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOOP_LIMIT_FLAGS, 0,
     /* last opt argumnt */ { zLoop_LimitDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLoop_Limit,
     /* desc, NAME, name */ zLoop_LimitText, zLoop_Limit_NAME, zLoop_Limit_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 15, VALUE_OPT_TIMEOUT,
     /* equiv idx, value */ 15, VALUE_OPT_TIMEOUT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TIMEOUT_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptTimeout,
     /* desc, NAME, name */ zTimeoutText, zTimeout_NAME, zTimeout_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 16, VALUE_OPT_TRACE,
     /* equiv idx, value */ 16, VALUE_OPT_TRACE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TRACE_FLAGS, 0,
     /* last opt argumnt */ { zTraceDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptTrace,
     /* desc, NAME, name */ zTraceText, zTrace_NAME, zTrace_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 17, VALUE_OPT_TRACE_OUT,
     /* equiv idx, value */ 17, VALUE_OPT_TRACE_OUT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TRACE_OUT_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zTrace_OutText, zTrace_Out_NAME, zTrace_Out_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 18, VALUE_OPT_SHOW_DEFS,
     /* equiv idx, value */ 18, VALUE_OPT_SHOW_DEFS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SHOW_DEFS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zShow_DefsText, zShow_Defs_NAME, zShow_Defs_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 19, VALUE_OPT_DEFINE,
     /* equiv idx, value */ 19, VALUE_OPT_DEFINE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ DEFINE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zDefineText, zDefine_NAME, zDefine_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 20, VALUE_OPT_UNDEFINE,
     /* equiv idx, value */ NOLIMIT, NOLIMIT,
     /* equivalenced to  */ INDEX_OPT_DEFINE,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ UNDEFINE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionUnstackArg,
     /* desc, NAME, name */ zUndefineText, zUndefine_NAME, zUndefine_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_VERSION, VALUE_OPT_VERSION,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                          | OPTST_ARG_OPTIONAL | OPTST_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionPrintVersion,
     /* desc, NAME, name */ zVersionText, NULL, zVersion_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ zHelpText, NULL, zHelp_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ optionPagedUsage,
     /* desc, NAME, name */ zMore_HelpText, NULL, zMore_Help_Name,
     /* disablement strs */ NULL, NULL }
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Xml2ag Option Environment
 */
tSCC   zPROGNAME[]   = "XML2AG";
tSCC   zUsageTitle[] =
"xml2ag (GNU AutoGen) - XML to AutoGen Definiton Converter - Ver. 5.9\n\
USAGE:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [ <def-file> ]\n";
#define zRcName     NULL
#define apzHomeList NULL

tSCC   zBugsAddr[]    = "autogen-users@lists.sourceforge.net";
tSCC   zExplain[]     = "\n\
This program will convert any arbitrary XML file into equivalent\n\
AutoGen definitions, and invoke AutoGen.\n";
tSCC    zDetail[]     = "\n\
The template will be derived from either:\n\
*  the ``--override-tpl'' command line option\n\
*  a top level XML attribute named, \"template\"\n\n\
The ``base-name'' for the output will similarly be either:\n\
*  the ``--base-name'' command line option\n\
*  the base name of the .xml file\n";
tSCC    zFullVersion[] = XML2AG_FULL_VERSION;
/* extracted from /home/bkorb/ag/ag/autoopts/optcode.tpl near line 378 */

#if defined(ENABLE_NLS)
# define OPTPROC_BASE OPTPROC_TRANSLATE
  static tOptionXlateProc translate_option_strings;
#else
# define OPTPROC_BASE OPTPROC_NONE
# define translate_option_strings NULL
#endif /* ENABLE_NLS */

tOptions xml2agOptions = {
    OPTIONS_STRUCT_VERSION,
    0, NULL,                    /* original argc + argv    */
    ( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_NEGATIONS ),
    0, NULL,                    /* current option index, current option */
    NULL,         NULL,         zPROGNAME,
    zRcName,      zCopyright,   zCopyrightNotice,
    zFullVersion, apzHomeList,  zUsageTitle,
    zExplain,     zDetail,      optDesc,
    zBugsAddr,                  /* address to send bugs to */
    NULL, NULL,                 /* extensions/saved state  */
    optionUsage,       /* usage procedure */
    translate_option_strings,   /* translation procedure */
    /*
     *  Indexes to special options
     */
    { INDEX_OPT_MORE_HELP,
       0 /* no option state saving */,
      NO_EQUIVALENT /* index of '-#' option */,
      NO_EQUIVALENT /* index of default opt */
    },
    OPTION_CT, 21 /* user option count */
};

/*
 *  Create the static procedure(s) declared above.
 */
static void
doUsageOpt(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    USAGE( EXIT_SUCCESS );
}

/* * * * * * *
 *
 *   For the output option.
 */
static void
doOptOutput(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    /* extracted from ./xmlopts.def, line 47 */
    if (strcmp( pOptDesc->pzLastArg, "-" ) == 0)
        return;

    if (freopen( pOptDesc->pzLastArg, "w", stdout ) == NULL) {
        fprintf( stderr, "Error %d (%s) opening `%s' for output",
                 errno, strerror( errno ), pOptDesc->pzLastArg );
        exit( EXIT_FAILURE );
    }
}

/* * * * * * *
 *
 *   For the loop-limit option.
 */
static void
doOptLoop_Limit(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    static const struct {const int rmin, rmax;} rng[ 2 ] = {
        { -1, INT_MIN },  { 1, 0x1000000 } };
    int val;
    int ix;
    char const* pzIndent = "\t\t\t\t  ";
    extern FILE* option_usage_fp;

    if (pOptDesc == NULL) /* usage is requesting range list
                             option_usage_fp has already been set */
        goto emit_ranges;

    val = atoi( pOptDesc->optArg.argString );
    for (ix = 0; ix < 2; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == INT_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

    option_usage_fp = stderr;
    fprintf(stderr, _("%s error:  %s option value ``%s''is out of range.\n"),
            pOptions->pzProgName, pOptDesc->pz_Name, pOptDesc->optArg.argString);
    pzIndent = "\t";

  emit_ranges:
    fprintf( option_usage_fp, _("%sit must lie in one of the ranges:\n"),
             pzIndent );
    for ( ix=0;; ) {
        if (rng[ix].rmax == INT_MIN)
             fprintf(option_usage_fp, _("%s%d exactly"), pzIndent,
                     rng[ix].rmin);
        else fprintf(option_usage_fp, _("%s%d to %d"), pzIndent,
                      rng[ix].rmin, rng[ix].rmax );
        if (++ix >= 2)
            break;
        fputs( _(", or\n"), option_usage_fp );
    }

    fputc( '\n', option_usage_fp );
    if (pOptDesc == NULL)
        return;

    USAGE( EXIT_FAILURE );
    /* NOTREACHED */
    return;

  valid_return:
    pOptDesc->optArg.argInt = val;
}

/* * * * * * *
 *
 *   For the timeout option.
 */
static void
doOptTimeout(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    static const struct {const int rmin, rmax;} rng[ 1 ] = {
        { 0, 3600 } };
    int val;
    int ix;
    char const* pzIndent = "\t\t\t\t  ";
    extern FILE* option_usage_fp;

    if (pOptDesc == NULL) /* usage is requesting range list
                             option_usage_fp has already been set */
        goto emit_ranges;

    val = atoi( pOptDesc->optArg.argString );
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == INT_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

    option_usage_fp = stderr;
    fprintf(stderr, _("%s error:  %s option value ``%s''is out of range.\n"),
            pOptions->pzProgName, pOptDesc->pz_Name, pOptDesc->optArg.argString);
    pzIndent = "\t";

  emit_ranges:
    fprintf( option_usage_fp, _("%sit must lie in the range: %d to %d\n"),
             pzIndent, rng[0].rmin, rng[0].rmax );
    if (pOptDesc == NULL)
        return;

    USAGE( EXIT_FAILURE );
    /* NOTREACHED */
    return;

  valid_return:
    pOptDesc->optArg.argInt = val;
}

/* * * * * * *
 *
 *   For the trace option.
 */
static void
doOptTrace(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{

/* extracted from /home/bkorb/ag/ag/autoopts/optmain.tpl near line 833 */
    static char const * const azNames[6] = {
        "nothing",       "server-shell",  "templates",     "block-macros",
        "expressions",   "everything"
    };

    pOptDesc->optArg.argEnum =
        optionEnumerationVal( pOptions, pOptDesc, azNames, 6 );
}

/* extracted from /home/bkorb/ag/ag/autoopts/optcode.tpl near line 475 */

#if ENABLE_NLS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <autoopts/usage-txt.h>

static char* AO_gettext( char const* pz );
static void  coerce_it(void** s);

static char*
AO_gettext( char const* pz )
{
    char* pzRes;
    if (pz == NULL)
        return NULL;
    pzRes = _(pz);
    if (pzRes == pz)
        return pzRes;
    pzRes = strdup( pzRes );
    if (pzRes == NULL) {
        fputs( _("No memory for duping translated strings\n"), stderr );
        exit( EXIT_FAILURE );
    }
    return pzRes;
}

static void coerce_it(void** s) { *s = AO_gettext(*s); }
#define COERSION(_f) \
  coerce_it((void*)&(xml2agOptions._f))

/*
 *  This invokes the translation code (e.g. gettext(3)).
 */
static void
translate_option_strings( void )
{
    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_usage_text.field_ct == 0)
        return;
    /*
     *  Do the translations.  The first pointer follows the field count field.
     *  The field count field is the size of a pointer.
     */
    {
        char** ppz = (char**)(void*)&(option_usage_text);
        int    ix  = option_usage_text.field_ct;

        do {
            ppz++;
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);
    }
    option_usage_text.field_ct = 0;

    {
        tOptDesc* pOD = xml2agOptions.pOptDesc;
        int       ix  = xml2agOptions.optCt;

        for (;;) {
            pOD->pzText           = AO_gettext(pOD->pzText);
            pOD->pz_NAME          = AO_gettext(pOD->pz_NAME);
            pOD->pz_Name          = AO_gettext(pOD->pz_Name);
            pOD->pz_DisableName   = AO_gettext(pOD->pz_DisableName);
            pOD->pz_DisablePfx    = AO_gettext(pOD->pz_DisablePfx);
            if (--ix <= 0)
                break;
            pOD++;
        }
    }
    COERSION(pzCopyright);
    COERSION(pzCopyNotice);
    COERSION(pzFullVersion);
    COERSION(pzUsageTitle);
    COERSION(pzExplain);
    COERSION(pzDetail);
}

#endif /* ENABLE_NLS */

#ifdef  __cplusplus
}
#endif
/* xmlopts.c ends here */
