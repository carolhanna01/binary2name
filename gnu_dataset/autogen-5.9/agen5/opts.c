/*   -*- buffer-read-only: t -*- vi: set ro:
 *  
 *  DO NOT EDIT THIS FILE   (opts.c)
 *  
 *  It has been AutoGen-ed  Saturday February 17, 2007 at 12:50:03 PM PST
 *  From the definitions    /home/bkorb/ag/ag/agen5/opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 28:0:3 templates.
 */

/*
 *  This file was produced by an AutoOpts template.  AutoOpts is a
 *  copyrighted work.  This source file is not encumbered by AutoOpts
 *  licensing, but is provided under the licensing terms chosen by the
 *  autogen author or copyright holder.  AutoOpts is licensed under
 *  the terms of the LGPL.  The redistributable library (``libopts'') is
 *  licensed under the terms of either the LGPL or, at the users discretion,
 *  the BSD license.  See the AutoOpts and/or libopts sources for details.
 *
 * This source file is copyrighted and licensed under the following terms:
 *
 * autogen copyright 1992-2006 Bruce Korb - all rights reserved
 *
 * autogen is free software.
 * 
 * You may redistribute it and/or modify it under the terms of the
 * GNU General Public License, as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * autogen is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with autogen.  If not, write to:
 * 	The Free Software Foundation, Inc.,
 * 	51 Franklin Street, Fifth Floor
 * 	Boston, MA  02110-1301, USA.
 */


#include <limits.h>
#include <stdio.h>
#define OPTION_CODE_COMPILE 1
#include "opts.h"

#ifdef  __cplusplus
extern "C" {
#endif
tSCC zCopyright[] =
       "autogen copyright (c) 1992-2006 Bruce Korb, all rights reserved";
tSCC zCopyrightNotice[] =
       "autogen is free software.\n\n\
You may redistribute it and/or modify it under the terms of the\n\
GNU General Public License, as published by the Free Software\n\
Foundation; either version 2 of the License, or (at your option)\n\
any later version.\n\n\
autogen is distributed in the hope that it will be useful,\n\
but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\
See the GNU General Public License for more details.\n\n\
You should have received a copy of the GNU General Public License\n\
along with autogen.  If not, write to:\n\
\tThe Free Software Foundation, Inc.,\n\
\t51 Franklin Street, Fifth Floor\n\
\tBoston, MA  02110-1301, USA.";
extern tUsageProc optionUsage;

/*
 *  global included definitions
 */
#include "autogen.h"
#ifdef HAVE_DLOPEN
# ifdef HAVE_DLFCN_H
#  include <dlfcn.h>
# else
   extern void* dlopen(char const*,int);
# endif

# ifndef  RTLD_GLOBAL
#  define RTLD_GLOBAL 0
# endif

# ifndef  RTLD_NOW
#  ifdef  RTLD_LAZY
#   define RTLD_NOW DL_LAZY
#  else
#   define RTLD_NOW 0
#  endif
# endif
#endif
typedef void (init_proc_t)( void );
tCC* pzTemplFileName = NULL;
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

#ifndef NULL
#  define NULL 0
#endif
#ifndef EXIT_SUCCESS
#  define  EXIT_SUCCESS 0
#endif
#ifndef EXIT_FAILURE
#  define  EXIT_FAILURE 1
#endif
/*
 *  Templ_Dirs option description:
 */
tSCC    zTempl_DirsText[] =
        "Template search directory list";
tSCC    zTempl_Dirs_NAME[]         = "TEMPL_DIRS";
tSCC    zTempl_Dirs_Name[]         = "templ-dirs";
#define TEMPL_DIRS_FLAGS       (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Override_Tpl option description:
 */
tSCC    zOverride_TplText[] =
        "Override template file";
tSCC    zOverride_Tpl_NAME[]       = "OVERRIDE_TPL";
tSCC    zOverride_Tpl_Name[]       = "override-tpl";
#define OVERRIDE_TPL_FLAGS       (OPTST_DISABLED | OPTST_NO_INIT \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Lib_Template option description:
 */
tSCC    zLib_TemplateText[] =
        "Library template file";
tSCC    zLib_Template_NAME[]       = "LIB_TEMPLATE";
tSCC    zLib_Template_Name[]       = "lib-template";
#define LIB_TEMPLATE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Base_Name option description:
 */
tSCC    zBase_NameText[] =
        "Base name for output file(s)";
tSCC    zBase_Name_NAME[]          = "BASE_NAME";
tSCC    zBase_Name_Name[]          = "base-name";
#define BASE_NAME_FLAGS       (OPTST_DISABLED | OPTST_NO_INIT \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Definitions option description:
 */
tSCC    zDefinitionsText[] =
        "Definitions input file";
tSCC    zDefinitions_NAME[]        = "DEFINITIONS";
tSCC    zNotDefinitions_Name[]     = "no-definitions";
tSCC    zNotDefinitions_Pfx[]      = "no";
#define zDefinitions_Name            (zNotDefinitions_Name + 3)
#define DEFINITIONS_FLAGS       (OPTST_INITENABLED | OPTST_NO_INIT \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Load_Scheme option description:
 */
tSCC    zLoad_SchemeText[] =
        "Scheme code file to load";
tSCC    zLoad_Scheme_NAME[]        = "LOAD_SCHEME";
tSCC    zLoad_Scheme_Name[]        = "load-scheme";
#define LOAD_SCHEME_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Load_Functions option description:
 */
#ifdef HAVE_DLOPEN
tSCC    zLoad_FunctionsText[] =
        "Load scheme function library";
tSCC    zLoad_Functions_NAME[]     = "LOAD_FUNCTIONS";
tSCC    zLoad_Functions_Name[]     = "load-functions";
#define LOAD_FUNCTIONS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable Load_Functions */
#define VALUE_OPT_LOAD_FUNCTIONS NO_EQUIVALENT
#define LOAD_FUNCTIONS_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zLoad_FunctionsText       NULL
#define zLoad_Functions_NAME      NULL
#define zLoad_Functions_Name      NULL
#endif  /* HAVE_DLOPEN */

/*
 *  Skip_Suffix option description:
 */
tSCC    zSkip_SuffixText[] =
        "Omit the file with this suffix";
tSCC    zSkip_Suffix_NAME[]        = "SKIP_SUFFIX";
tSCC    zSkip_Suffix_Name[]        = "skip-suffix";
#define SKIP_SUFFIX_FLAGS       (OPTST_DISABLED | OPTST_STACKED | OPTST_NO_INIT \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Select_Suffix option description:
 */
tSCC    zSelect_SuffixText[] =
        "specify this output suffix";
tSCC    zSelect_Suffix_NAME[]      = "SELECT_SUFFIX";
tSCC    zSelect_Suffix_Name[]      = "select-suffix";
#define SELECT_SUFFIX_FLAGS       (OPTST_DISABLED | OPTST_NO_INIT \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING) | OPTST_ARG_OPTIONAL)

/*
 *  Source_Time option description:
 */
tSCC    zSource_TimeText[] =
        "set mod times to latest source";
tSCC    zSource_Time_NAME[]        = "SOURCE_TIME";
tSCC    zNotSource_Time_Name[]     = "no-source-time";
tSCC    zNotSource_Time_Pfx[]      = "no";
#define zSource_Time_Name            (zNotSource_Time_Name + 3)
#define SOURCE_TIME_FLAGS       (OPTST_DISABLED)

/*
 *  No_Fmemopen option description:
 */
#ifdef ENABLE_FMEMOPEN
tSCC    zNo_FmemopenText[] =
        "Do not use in-mem streams";
tSCC    zNo_Fmemopen_NAME[]        = "NO_FMEMOPEN";
tSCC    zNo_Fmemopen_Name[]        = "no-fmemopen";
#define NO_FMEMOPEN_FLAGS       (OPTST_DISABLED)

#else   /* disable No_Fmemopen */
#define VALUE_OPT_NO_FMEMOPEN NO_EQUIVALENT
#define NO_FMEMOPEN_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zNo_FmemopenText       NULL
#define zNo_Fmemopen_NAME      NULL
#define zNo_Fmemopen_Name      NULL
#endif  /* ENABLE_FMEMOPEN */

/*
 *  Equate option description:
 */
tSCC    zEquateText[] =
        "characters considered equivalent";
tSCC    zEquate_NAME[]             = "EQUATE";
tSCC    zEquate_Name[]             = "equate";
tSCC    zEquateDefaultArg[]          = "_-^";
#define EQUATE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Writable option description:
 */
tSCC    zWritableText[] =
        "Allow output files to be writable";
tSCC    zWritable_NAME[]           = "WRITABLE";
tSCC    zNotWritable_Name[]        = "not-writable";
tSCC    zNotWritable_Pfx[]         = "not";
#define zWritable_Name               (zNotWritable_Name + 4)
#define WRITABLE_FLAGS       (OPTST_DISABLED | OPTST_NO_INIT)

/*
 *  Doc_Debug option description:
 */
tSCC    zDoc_DebugText[] =
        "The following options are often useful while debugging new templates:";
#define DOC_DEBUG_FLAGS       (OPTST_DOCUMENT | OPTST_NO_INIT)

/*
 *  Loop_Limit option description:
 */
tSCC    zLoop_LimitText[] =
        "Limit on increment loops";
tSCC    zLoop_Limit_NAME[]         = "LOOP_LIMIT";
tSCC    zLoop_Limit_Name[]         = "loop-limit";
#define zLoop_LimitDefaultArg        ((char const*)256)
#define LOOP_LIMIT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Timeout option description:
 */
#ifdef SHELL_ENABLED
tSCC    zTimeoutText[] =
        "Time limit for servers";
tSCC    zTimeout_NAME[]            = "TIMEOUT";
tSCC    zTimeout_Name[]            = "timeout";
#define TIMEOUT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

#else   /* disable Timeout */
#define VALUE_OPT_TIMEOUT NO_EQUIVALENT
#define TIMEOUT_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zTimeoutText       NULL
#define zTimeout_NAME      NULL
#define zTimeout_Name      NULL
#endif  /* SHELL_ENABLED */

/*
 *  Trace option description:
 */
tSCC    zTraceText[] =
        "tracing level of detail";
tSCC    zTrace_NAME[]              = "TRACE";
tSCC    zTrace_Name[]              = "trace";
#define zTraceDefaultArg             ((char const*)TRACE_NOTHING)
#define TRACE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_ENUMERATION))

/*
 *  Trace_Out option description:
 */
tSCC    zTrace_OutText[] =
        "tracing output file or filter";
tSCC    zTrace_Out_NAME[]          = "TRACE_OUT";
tSCC    zTrace_Out_Name[]          = "trace-out";
#define TRACE_OUT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Show_Defs option description:
 */
#ifdef DEBUG_ENABLED
tSCC    zShow_DefsText[] =
        "Show the definition tree";
tSCC    zShow_Defs_NAME[]          = "SHOW_DEFS";
tSCC    zShow_Defs_Name[]          = "show-defs";
#define SHOW_DEFS_FLAGS       (OPTST_DISABLED | OPTST_NO_INIT)

#else   /* disable Show_Defs */
#define VALUE_OPT_SHOW_DEFS NO_EQUIVALENT
#define SHOW_DEFS_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zShow_DefsText       NULL
#define zShow_Defs_NAME      NULL
#define zShow_Defs_Name      NULL
#endif  /* DEBUG_ENABLED */

/*
 *  Doc_Control option description:
 */
tSCC    zDoc_ControlText[] =
        "These options can be used to control what gets processed\n\
in the definitions files and template files.";
#define DOC_CONTROL_FLAGS       (OPTST_DOCUMENT | OPTST_NO_INIT)

/*
 *  Define option description:
 */
tSCC    zDefineText[] =
        "name to add to definition list";
tSCC    zDefine_NAME[]             = "DEFINE";
tSCC    zDefine_Name[]             = "define";
#define DEFINE_FLAGS       (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Undefine option description:
 */
tSCC    zUndefineText[] =
        "definition list removal pattern";
tSCC    zUndefine_NAME[]           = "UNDEFINE";
tSCC    zUndefine_Name[]           = "undefine";
#define UNDEFINE_FLAGS       (OPTST_DISABLED | OPTST_NO_INIT \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Autoopts_Std_Options option description:
 */
tSCC    zAutoopts_Std_OptionsText[] =
        "The following options are commonly used and are provided and supported\n\
by AutoOpts:";
#define AUTOOPTS_STD_OPTIONS_FLAGS       (OPTST_DOCUMENT | OPTST_NO_INIT)

/*
 *  Short_Help option description:
 */
tSCC    zShort_HelpText[] =
        "Get short help text without an error exit";
tSCC    zShort_Help_NAME[]         = "SHORT_HELP";
tSCC    zShort_Help_Name[]         = "short-help";
#define SHORT_HELP_FLAGS       (OPTST_DISABLED | OPTST_NO_INIT | OPTST_IMM)

/*
 *  Help/More_Help/Version option descriptions:
 */
tSCC zHelpText[]       = "Display usage information and exit";
tSCC zHelp_Name[]      = "help";

tSCC zMore_HelpText[]  = "Extended usage information passed thru pager";
tSCC zMore_Help_Name[] = "more-help";

tSCC zVersionText[]    = "Output version information and exit";
tSCC zVersion_Name[]   = "version";

/*
 *  Save/Load_Opts option description:
 */
tSCC zSave_OptsText[]     = "Save the option state to a config file";
tSCC zSave_Opts_Name[]    = "save-opts";

tSCC zLoad_OptsText[]     = "Load options from a config file";
tSCC zLoad_Opts_NAME[]    = "LOAD_OPTS";

tSCC zNotLoad_Opts_Name[] = "no-load-opts";
tSCC zNotLoad_Opts_Pfx[]  = "no";
#define zLoad_Opts_Name   (zNotLoad_Opts_Name + 3)
/*
 *  Declare option callback procedures
 */
#ifdef HAVE_DLOPEN
  static tOptProc doOptLoad_Functions;
#else /* not HAVE_DLOPEN */
# define doOptLoad_Functions NULL
#endif /* def/not HAVE_DLOPEN */
#ifdef SHELL_ENABLED
  static tOptProc doOptTimeout;
#else /* not SHELL_ENABLED */
# define doOptTimeout NULL
#endif /* def/not SHELL_ENABLED */
extern tOptProc
    optionPagedUsage, optionPrintVersion, optionStackArg, optionUnstackArg;
static tOptProc
    doOptLib_Template,  doOptLoad_Scheme,   doOptLoop_Limit,
    doOptOverride_Tpl,  doOptSelect_Suffix, doOptShort_Help,
    doOptTrace,         doOptTrace_Out,     doUsageOpt;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Autogen Option Descriptions.
 */
static tOptDesc optDesc[ OPTION_CT ] = {
  {  /* entry idx, value */ 0, VALUE_OPT_TEMPL_DIRS,
     /* equiv idx, value */ 0, VALUE_OPT_TEMPL_DIRS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ TEMPL_DIRS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zTempl_DirsText, zTempl_Dirs_NAME, zTempl_Dirs_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 1, VALUE_OPT_OVERRIDE_TPL,
     /* equiv idx, value */ 1, VALUE_OPT_OVERRIDE_TPL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OVERRIDE_TPL_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptOverride_Tpl,
     /* desc, NAME, name */ zOverride_TplText, zOverride_Tpl_NAME, zOverride_Tpl_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 2, VALUE_OPT_LIB_TEMPLATE,
     /* equiv idx, value */ 2, VALUE_OPT_LIB_TEMPLATE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ LIB_TEMPLATE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLib_Template,
     /* desc, NAME, name */ zLib_TemplateText, zLib_Template_NAME, zLib_Template_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 3, VALUE_OPT_BASE_NAME,
     /* equiv idx, value */ 3, VALUE_OPT_BASE_NAME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ BASE_NAME_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zBase_NameText, zBase_Name_NAME, zBase_Name_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 4, VALUE_OPT_DEFINITIONS,
     /* equiv idx, value */ 4, VALUE_OPT_DEFINITIONS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DEFINITIONS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDefinitionsText, zDefinitions_NAME, zDefinitions_Name,
     /* disablement strs */ zNotDefinitions_Name, zNotDefinitions_Pfx },

  {  /* entry idx, value */ 5, VALUE_OPT_LOAD_SCHEME,
     /* equiv idx, value */ 5, VALUE_OPT_LOAD_SCHEME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOAD_SCHEME_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLoad_Scheme,
     /* desc, NAME, name */ zLoad_SchemeText, zLoad_Scheme_NAME, zLoad_Scheme_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 6, VALUE_OPT_LOAD_FUNCTIONS,
     /* equiv idx, value */ 6, VALUE_OPT_LOAD_FUNCTIONS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOAD_FUNCTIONS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLoad_Functions,
     /* desc, NAME, name */ zLoad_FunctionsText, zLoad_Functions_NAME, zLoad_Functions_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 7, VALUE_OPT_SKIP_SUFFIX,
     /* equiv idx, value */ 7, VALUE_OPT_SKIP_SUFFIX,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ SKIP_SUFFIX_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zSkip_SuffixText, zSkip_Suffix_NAME, zSkip_Suffix_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 8, VALUE_OPT_SELECT_SUFFIX,
     /* equiv idx, value */ 8, VALUE_OPT_SELECT_SUFFIX,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ SELECT_SUFFIX_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptSelect_Suffix,
     /* desc, NAME, name */ zSelect_SuffixText, zSelect_Suffix_NAME, zSelect_Suffix_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 9, VALUE_OPT_SOURCE_TIME,
     /* equiv idx, value */ 9, VALUE_OPT_SOURCE_TIME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SOURCE_TIME_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zSource_TimeText, zSource_Time_NAME, zSource_Time_Name,
     /* disablement strs */ zNotSource_Time_Name, zNotSource_Time_Pfx },

  {  /* entry idx, value */ 10, VALUE_OPT_NO_FMEMOPEN,
     /* equiv idx, value */ 10, VALUE_OPT_NO_FMEMOPEN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NO_FMEMOPEN_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zNo_FmemopenText, zNo_Fmemopen_NAME, zNo_Fmemopen_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 11, VALUE_OPT_EQUATE,
     /* equiv idx, value */ 11, VALUE_OPT_EQUATE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ EQUATE_FLAGS, 0,
     /* last opt argumnt */ { zEquateDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zEquateText, zEquate_NAME, zEquate_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 12, VALUE_OPT_WRITABLE,
     /* equiv idx, value */ 12, VALUE_OPT_WRITABLE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ WRITABLE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zWritableText, zWritable_NAME, zWritable_Name,
     /* disablement strs */ zNotWritable_Name, zNotWritable_Pfx },

  {  /* entry idx, value */ 0, 0,
     /* equiv idx, value */ 0, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 0, 0,
     /* opt state flags  */ DOC_DEBUG_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDoc_DebugText, NULL, NULL,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 14, VALUE_OPT_LOOP_LIMIT,
     /* equiv idx, value */ 14, VALUE_OPT_LOOP_LIMIT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOOP_LIMIT_FLAGS, 0,
     /* last opt argumnt */ { zLoop_LimitDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLoop_Limit,
     /* desc, NAME, name */ zLoop_LimitText, zLoop_Limit_NAME, zLoop_Limit_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 15, VALUE_OPT_TIMEOUT,
     /* equiv idx, value */ 15, VALUE_OPT_TIMEOUT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TIMEOUT_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptTimeout,
     /* desc, NAME, name */ zTimeoutText, zTimeout_NAME, zTimeout_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 16, VALUE_OPT_TRACE,
     /* equiv idx, value */ 16, VALUE_OPT_TRACE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TRACE_FLAGS, 0,
     /* last opt argumnt */ { zTraceDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptTrace,
     /* desc, NAME, name */ zTraceText, zTrace_NAME, zTrace_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 17, VALUE_OPT_TRACE_OUT,
     /* equiv idx, value */ 17, VALUE_OPT_TRACE_OUT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TRACE_OUT_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptTrace_Out,
     /* desc, NAME, name */ zTrace_OutText, zTrace_Out_NAME, zTrace_Out_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 18, VALUE_OPT_SHOW_DEFS,
     /* equiv idx, value */ 18, VALUE_OPT_SHOW_DEFS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SHOW_DEFS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zShow_DefsText, zShow_Defs_NAME, zShow_Defs_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 0, 0,
     /* equiv idx, value */ 0, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 0, 0,
     /* opt state flags  */ DOC_CONTROL_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDoc_ControlText, NULL, NULL,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 20, VALUE_OPT_DEFINE,
     /* equiv idx, value */ 20, VALUE_OPT_DEFINE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ DEFINE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zDefineText, zDefine_NAME, zDefine_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 21, VALUE_OPT_UNDEFINE,
     /* equiv idx, value */ NOLIMIT, NOLIMIT,
     /* equivalenced to  */ INDEX_OPT_DEFINE,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ UNDEFINE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionUnstackArg,
     /* desc, NAME, name */ zUndefineText, zUndefine_NAME, zUndefine_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 0, 0,
     /* equiv idx, value */ 0, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 0, 0,
     /* opt state flags  */ AUTOOPTS_STD_OPTIONS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zAutoopts_Std_OptionsText, NULL, NULL,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 23, VALUE_OPT_SHORT_HELP,
     /* equiv idx, value */ 23, VALUE_OPT_SHORT_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SHORT_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptShort_Help,
     /* desc, NAME, name */ zShort_HelpText, zShort_Help_NAME, zShort_Help_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_VERSION, VALUE_OPT_VERSION,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                          | OPTST_ARG_OPTIONAL | OPTST_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionPrintVersion,
     /* desc, NAME, name */ zVersionText, NULL, zVersion_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ zHelpText, NULL, zHelp_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ optionPagedUsage,
     /* desc, NAME, name */ zMore_HelpText, NULL, zMore_Help_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_SAVE_OPTS, VALUE_OPT_SAVE_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                          | OPTST_ARG_OPTIONAL, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zSave_OptsText, NULL, zSave_Opts_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_LOAD_OPTS, VALUE_OPT_LOAD_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ OPTST_DISABLE_IMM | \
			OPTST_SET_ARGTYPE(OPARG_TYPE_STRING), 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionLoadOpt,
     /* desc, NAME, name */ zLoad_OptsText, zLoad_Opts_NAME, zLoad_Opts_Name,
     /* disablement strs */ zNotLoad_Opts_Name, zNotLoad_Opts_Pfx }
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Autogen Option Environment
 */
tSCC   zPROGNAME[]   = "AUTOGEN";
tSCC   zUsageTitle[] =
"autogen (GNU AutoGen) - The Automated Program Generator - Ver. 5.9\n\
USAGE:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [ <def-file> ]\n";
tSCC   zRcName[]     = ".autogenrc";
tSCC*  apzHomeList[] = {
       "$HOME",
       ".",
       NULL };

tSCC   zBugsAddr[]    = "autogen-users@lists.sourceforge.net";
tSCC   zExplain[]     = "\n\
AutoGen creates text files from templates using external definitions.\n";
tSCC    zDetail[]     = "\n\
The definitions file (`<def-file>') can be specified with the\n\
`definitions' option or as the command argument, but not both.\n\
Omitting it or specifying `-' will result in reading definitions from\n\
standard input.\n\n\
The output file names are based on the template, but generally use the\n\
base name of the definition file.  If standard in is read for the\n\
definitions, then `stdin' will be used for that base name.  The\n\
suffixes to the base name are gotten from the template.  However, the\n\
template file may specify the entire output file name.  The generated\n\
files are always created in the current directory.  If you need to\n\
place output in an alternate directory, `cd' to that directory and use\n\
the `--templ_dirs' option to search the original directory.\n\n\
`loop-limit' is used in debugging to stop runaway expansions.\n";
tSCC    zFullVersion[] = AUTOGEN_FULL_VERSION;
/* extracted from /home/bkorb/ag/ag/autoopts/optcode.tpl near line 378 */

#if defined(ENABLE_NLS)
# define OPTPROC_BASE OPTPROC_TRANSLATE
  static tOptionXlateProc translate_option_strings;
#else
# define OPTPROC_BASE OPTPROC_NONE
# define translate_option_strings NULL
#endif /* ENABLE_NLS */

tOptions autogenOptions = {
    OPTIONS_STRUCT_VERSION,
    0, NULL,                    /* original argc + argv    */
    ( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_NEGATIONS
    + OPTPROC_ENVIRON
    + OPTPROC_HAS_IMMED ),
    0, NULL,                    /* current option index, current option */
    NULL,         NULL,         zPROGNAME,
    zRcName,      zCopyright,   zCopyrightNotice,
    zFullVersion, apzHomeList,  zUsageTitle,
    zExplain,     zDetail,      optDesc,
    zBugsAddr,                  /* address to send bugs to */
    NULL, NULL,                 /* extensions/saved state  */
    optionUsage,       /* usage procedure */
    translate_option_strings,   /* translation procedure */
    /*
     *  Indexes to special options
     */
    { INDEX_OPT_MORE_HELP,
      INDEX_OPT_SAVE_OPTS,
      NO_EQUIVALENT /* index of '-#' option */,
      NO_EQUIVALENT /* index of default opt */
    },
    OPTION_CT, 24 /* user option count */
};

/*
 *  Create the static procedure(s) declared above.
 */
static void
doUsageOpt(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    USAGE( EXIT_SUCCESS );
}

/* * * * * * *
 *
 *   For the override-tpl option.
 */
static void
doOptOverride_Tpl(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    /* extracted from /home/bkorb/ag/ag/agen5/opts.def, line 150 */
    pzTemplFileName = pOptDesc->pzLastArg;
}

/* * * * * * *
 *
 *   For the lib-template option.
 */
static void
doOptLib_Template(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    /* extracted from /home/bkorb/ag/ag/agen5/opts.def, line 171 */
    tTemplate* pT;
    procState = PROC_STATE_LIB_LOAD;
    pT = loadTemplate(pOptDesc->pzLastArg, NULL);
    unloadTemplate( pT );
    procState = PROC_STATE_OPTIONS;
}

/* * * * * * *
 *
 *   For the load-scheme option.
 */
static void
doOptLoad_Scheme(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    /* extracted from /home/bkorb/ag/ag/agen5/opts.def, line 251 */
    teProcState saveState = procState;
    char* pz;
    char  zPath[ MAXPATHLEN ];
    tSCC* apzSfx[] = { "scm", NULL };

    if (! SUCCESSFUL(
            findFile( pOptDesc->pzLastArg, zPath, apzSfx, NULL))) {
        fprintf( stderr, "Cannot locate scheme file `%s'\n",
                 pOptDesc->pzLastArg );
        USAGE( EXIT_FAILURE );
    }

    pz = aprf( "(load \"%s\")", zPath );
    procState = PROC_STATE_GUILE_PRELOAD;
    (void)ag_scm_c_eval_string_from_file_line(
                   pz, __FILE__, __LINE__);
    free( pz );
    procState = saveState;
}

/* * * * * * *
 *
 *   For the load-functions option, when HAVE_DLOPEN is #define-d.
 */
#ifdef HAVE_DLOPEN
static void
doOptLoad_Functions(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    /* extracted from /home/bkorb/ag/ag/agen5/opts.def, line 319 */
    void* hdl = dlopen( pOptDesc->pzLastArg, RTLD_NOW|RTLD_GLOBAL );
    init_proc_t* proc;

    if (hdl == NULL) {
        char const* pzErr = dlerror();
        fprintf( stderr, "dlopen(%s) error %d\n%s\n",
                 pOptDesc->pzLastArg, errno, pzErr );
        exit( EXIT_FAILURE );
    }
    proc = (init_proc_t*)dlsym( hdl, "scm_init" );
    if (proc == NULL) {
        fprintf( stderr, "dlsym(scm_init) not found in %s\n"
                 "\tyou must initialize the library yourself\n",
                 pOptDesc->pzLastArg );
    }
    else (*proc)();
}
#endif /* defined HAVE_DLOPEN */

/* * * * * * *
 *
 *   For the select-suffix option.
 */
static void
doOptSelect_Suffix(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    /* extracted from /home/bkorb/ag/ag/agen5/opts.def, line 378 */
    if (  (pOptDesc->pzLastArg != NULL)
       && (*(pOptDesc->pzLastArg) != NUL))
        (void)doSuffixSpec( pOptDesc->pzLastArg, NULL, -1 );
}

/* * * * * * *
 *
 *   For the loop-limit option.
 */
static void
doOptLoop_Limit(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    static const struct {const int rmin, rmax;} rng[ 2 ] = {
        { -1, INT_MIN },  { 1, 0x1000000 } };
    int val;
    int ix;
    char const* pzIndent = "\t\t\t\t  ";
    extern FILE* option_usage_fp;

    if (pOptDesc == NULL) /* usage is requesting range list
                             option_usage_fp has already been set */
        goto emit_ranges;

    val = atoi( pOptDesc->optArg.argString );
    for (ix = 0; ix < 2; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == INT_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

    option_usage_fp = stderr;
    fprintf(stderr, _("%s error:  %s option value ``%s''is out of range.\n"),
            pOptions->pzProgName, pOptDesc->pz_Name, pOptDesc->optArg.argString);
    pzIndent = "\t";

  emit_ranges:
    fprintf( option_usage_fp, _("%sit must lie in one of the ranges:\n"),
             pzIndent );
    for ( ix=0;; ) {
        if (rng[ix].rmax == INT_MIN)
             fprintf(option_usage_fp, _("%s%d exactly"), pzIndent,
                     rng[ix].rmin);
        else fprintf(option_usage_fp, _("%s%d to %d"), pzIndent,
                      rng[ix].rmin, rng[ix].rmax );
        if (++ix >= 2)
            break;
        fputs( _(", or\n"), option_usage_fp );
    }

    fputc( '\n', option_usage_fp );
    if (pOptDesc == NULL)
        return;

    USAGE( EXIT_FAILURE );
    /* NOTREACHED */
    return;

  valid_return:
    pOptDesc->optArg.argInt = val;
}

/* * * * * * *
 *
 *   For the timeout option, when SHELL_ENABLED is #define-d.
 */
#ifdef SHELL_ENABLED
static void
doOptTimeout(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    static const struct {const int rmin, rmax;} rng[ 1 ] = {
        { 0, 3600 } };
    int val;
    int ix;
    char const* pzIndent = "\t\t\t\t  ";
    extern FILE* option_usage_fp;

    if (pOptDesc == NULL) /* usage is requesting range list
                             option_usage_fp has already been set */
        goto emit_ranges;

    val = atoi( pOptDesc->optArg.argString );
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == INT_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

    option_usage_fp = stderr;
    fprintf(stderr, _("%s error:  %s option value ``%s''is out of range.\n"),
            pOptions->pzProgName, pOptDesc->pz_Name, pOptDesc->optArg.argString);
    pzIndent = "\t";

  emit_ranges:
    fprintf( option_usage_fp, _("%sit must lie in the range: %d to %d\n"),
             pzIndent, rng[0].rmin, rng[0].rmax );
    if (pOptDesc == NULL)
        return;

    USAGE( EXIT_FAILURE );
    /* NOTREACHED */
    return;

  valid_return:
    pOptDesc->optArg.argInt = val;
}
#endif /* defined SHELL_ENABLED */

/* * * * * * *
 *
 *   For the trace option.
 */
static void
doOptTrace(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{

/* extracted from /home/bkorb/ag/ag/autoopts/optmain.tpl near line 833 */
    static char const * const azNames[6] = {
        "nothing",       "server-shell",  "templates",     "block-macros",
        "expressions",   "everything"
    };

    pOptDesc->optArg.argEnum =
        optionEnumerationVal( pOptions, pOptDesc, azNames, 6 );
}

/* * * * * * *
 *
 *   For the trace-out option.
 */
static void
doOptTrace_Out(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    /* extracted from /home/bkorb/ag/ag/agen5/opts.def, line 569 */
    if (*(pOptDesc->pzLastArg) == '|')
        pfTrace = popen( pOptDesc->pzLastArg + 1, "w" );
    else
        pfTrace = fopen( pOptDesc->pzLastArg, "w" );

    if (pfTrace == NULL) {
        fprintf( stderr, "Error %d (%s) opening `%s' for output",
                 errno, strerror( errno ), pOptDesc->pzLastArg );
        exit( EXIT_FAILURE );
    }
}

/* * * * * * *
 *
 *   For the short_help option.
 */
static void
doOptShort_Help(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    /* extracted from /home/bkorb/ag/ag/autoopts/stdoptions.def, line 457 */
    pid_t chid;
#   ifndef SIGCHLD
#     define SIGCHLD SIGCLD
#   endif
    signal(SIGCHLD, SIG_DFL); /* make sure we can wait for child */
    chid = fork();
    if (chid > 0) {
        int sts;
        waitpid(chid, &sts, 0);
        exit( 0 );
    }
    (*(pOptions->pUsageProc))(pOptions, EXIT_FAILURE);
    /*NOTREACHED*/
}

/* extracted from /home/bkorb/ag/ag/autoopts/optcode.tpl near line 475 */

#if ENABLE_NLS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <autoopts/usage-txt.h>

static char* AO_gettext( char const* pz );
static void  coerce_it(void** s);

static char*
AO_gettext( char const* pz )
{
    char* pzRes;
    if (pz == NULL)
        return NULL;
    pzRes = _(pz);
    if (pzRes == pz)
        return pzRes;
    pzRes = strdup( pzRes );
    if (pzRes == NULL) {
        fputs( _("No memory for duping translated strings\n"), stderr );
        exit( EXIT_FAILURE );
    }
    return pzRes;
}

static void coerce_it(void** s) { *s = AO_gettext(*s); }
#define COERSION(_f) \
  coerce_it((void*)&(autogenOptions._f))

/*
 *  This invokes the translation code (e.g. gettext(3)).
 */
static void
translate_option_strings( void )
{
    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_usage_text.field_ct == 0)
        return;
    /*
     *  Do the translations.  The first pointer follows the field count field.
     *  The field count field is the size of a pointer.
     */
    {
        char** ppz = (char**)(void*)&(option_usage_text);
        int    ix  = option_usage_text.field_ct;

        do {
            ppz++;
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);
    }
    option_usage_text.field_ct = 0;

    {
        tOptDesc* pOD = autogenOptions.pOptDesc;
        int       ix  = autogenOptions.optCt;

        for (;;) {
            pOD->pzText           = AO_gettext(pOD->pzText);
            pOD->pz_NAME          = AO_gettext(pOD->pz_NAME);
            pOD->pz_Name          = AO_gettext(pOD->pz_Name);
            pOD->pz_DisableName   = AO_gettext(pOD->pz_DisableName);
            pOD->pz_DisablePfx    = AO_gettext(pOD->pz_DisablePfx);
            if (--ix <= 0)
                break;
            pOD++;
        }
    }
    COERSION(pzCopyright);
    COERSION(pzCopyNotice);
    COERSION(pzFullVersion);
    COERSION(pzUsageTitle);
    COERSION(pzExplain);
    COERSION(pzDetail);
}

#endif /* ENABLE_NLS */

#ifdef  __cplusplus
}
#endif
/* opts.c ends here */
