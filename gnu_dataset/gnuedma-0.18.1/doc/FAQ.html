<html><head><!-- saved from url=(0022)http://internet.e-mail -->
   
<title>GNU EDMA - GNU Project - Free Software Foundation (FSF)</title><meta name="keywords" content="edma"></head>

<body>

<h1>GNU EDMA FAQ</h1>
<h3>General Questions</h3>
<ul>
  <li>
    <b>What's GNU EDMA?</b><br> 
		GNU EDMA is an Object Oriented and Component Based environment for application development. What makes GNU EDMA different from other systems is that GNU EDMA does most of the processing dynamically, that is, at run-time. We call these systems, generically, Loosely Coupled Object Oriented Systems (LOOCOS).<p>
		
		So, you can establish inheritance relationships among objects or even, you can dynamically override virtual methods, while the applications is running. Working this way you can build more real_life-like models and simplify a lot of common operations which, in most cases, needs complex patterns. Design patterns like Factories, Facades, Proxies, etc... are implicit in the GNU EDMA programming model.<p>

		In addition to all this, the programming interface provided by GNU EDMA is mostly based on strings so, concepts like automation or component interactive managing are directly supported by the system in a very easy way.<p>

	As a final word, GNU/EDMA was developed using C language, and this is the full supported programming language by the system, so you can build your applications in an OO basis using C language.<p>
  </li>
	<li>
		<b>What's CORIE?</b><br>
		CORIE is the GNU EDMA core, that is, the library that provides the main functionalities of the system, as well as, a basic set of classes/components to begin working with GNU EDMA.<p>

		The classes library is still barely populated, but we are working to add the basic components needed by most applications.<p>
	</li>
	<li>
		<b>What does stand EDMA for?</b><br>
		EDMA stands for the spanish acronim Entorno de Desarrollo Modular y Abierto, or in english Modular and Open Development Environment. It was first developed at Image Processing Group (GPI) at Vigo University in Spain.<p>
	</li>
	<li>
		<b>What systems are supported?</b><br>
		At the moment GNU EDMA runs on GNU Linux systems. A quick test was done succesfully on FreeBSD with the GNU Linux compatibility packages installed, but current release won't work directly on such systems.<p>

		The use on autotools in this new release'll simplify the port to other paltforms.<p>
		
	</li>
	<li>
	<b>What's the diference with other component-based projects?</b></br>
	GNU EDMA was developed as a low-level development tool with reuse in mind, so the main diference with other component-based system is that GNU EDMA can be seen as an easy way to work with libraries, or more generally, an easier way to reuse code.<p>

	On the other hand, there is no relationship with graphical components (JavaBeans, ActiveX) or distributed components (DCOM, CORBA-CCM). Any of this special kinds of components can be built using GNU EDMA, but GNU EDMA is a more general system. Actually, any of this system can be built in a easy way using GNU EDMA as its lower layer.<p>

	The other big diferences with other componet-based environments is that GNU EDMA does all the work at run-time, and allows to use OO programming on components, that is, you can, for example, use inheritance on components instead of complex aggregation/delegation systems.<p>
	
	</li>
	<li>
		<b>What do you mean with "doing all the work at run-time"?</b></br>
		Let's see some examples:<p>
		<ul>
		<li>
		Interface compilation: Most component-based systems need a interface compilation to generate code from a Interface Definition file like IDL for CORBA-based systems for example. GNU EDMA does this compilation at run-time providen a higher level of flexibility.<p>
		</li>
		<li>
		Dynamical OO: GNU EDMA does most of the typical OO operations at run-time. That is you can modify inheritance hierarchies dynamically, or even override any virtual method while your application is running. What this means is that you have very powerfull reuse mechanisms, and your OO designs get dramatically reduced, because you can afford a lot of classes in your class hierarchies.<p>
		</li>
		<li>
		Lossely Coupled: Practically, any GNU EDMA internal component (properies, methods, classes,...) are referenced through strings, so you can modify your program behavior, in a very easy way, even when it is running.<p>
		</li>
		<li>
		Highly Extensible: GNU EDMA allows you to provide new formats for your Interface definition files through its IngrIDF subsystems, and interface GNU EDMA with any other system using the SIU subsystem.<p>
		</li>
	</li>
	</ul>
	<p>
	<li>
		<b>What exactly does IngrIDF subsystem?</b><br>
		IngrIDF subsystem allows you to define GNU EDMA classes to parse IDF files. This special classes are called IDF Parser. So, you can write a GNU EDMA class to parse any kind of Interface Definition File and convert it to the GNU EDMA internal representation.<p>

		For doing such a thing, GNU EDMA provides a set of primitives to add the information retrived by your parser in the system.<p>

		You can see an example on how to build such classes in: <i>classes/systems/IngrIDF</i><p>
	</li>
	<li>
		<b>What exactly does SIU subsystem?</b><br>
	SIU subsystem, allows you to override the basic GNU EDMA primitives that deals with objects, that are, edma_new_obj, edma_free_obj, edma_wprop3, edma_rprop3 and edma_met3.<p>

	So you can write new GNU EDMA classes that translates those GNU EDMA primitives in external calls to other system. For example, you can write a SIU Proxy (that is how this special classes are called), to interface GNU EDMA with any interpreted language like Java, Perl or Python, or even with other componet-based systems like CORBA-based ones.<p>

  In the section <i>GNU/EDMA friends</i> bellow you can check out some projects using <b>GNU/EDMA</b> SIU subsystem.<p>

	You can see a SIU Proxy example in: <i>classes/systems/runnable</i><p>
	</li>
</ul>

<h3>GNU EDMA Applications</h3>
<ul>
  <li>
    <b>How does a GNU/EDMA application look like?</b><br>
		Here, is the minimal <b>GNU/EDMA</b> application:
				<pre>
#include <edma.h>

main () {
  EDMAInit();
  edma_printf ("Hello World from GNU/EDMA!\n");
  EDMAEnd();
}
				</pre>
	</li>
	<li>
		<b>How do I compile this application?</b><br>
		You can use this simple <i>Makefile</i> as skeleton for your applications. Do not forget TABS in the file.
		<pre>
CC=gcc
CFLAGS=`edma-config --cflags-exe`
LIBS=`edma-config --libs-exe`

all: your_application
your_application: your_application.c
	$(CC) $(CFLAGS) $< -o $@ $(LIBS)
clean:
	rm -f core *.o *~ your_application
			
		</pre>
	</li>
	<li>
		<b> My application doesn't run. I get this error</b><br>
		<pre>myapp: error while loading shared libraries: libEDMA.so.0: cannot open shared object file: No such file or directory</pre> <p>
	This means that the dynamic linker can find GNU/EDMA lib. By default GNU/EDMA gets intalled
	in /usr/local/lib which isn't in the linker	search path. Just add this path to your
	LD_LIBRARY_PATH environment variable or update your /etc/ld.so.conf file to include this
	directory, and then run ldconfig.
	</li>
	<li>
		<b>How do I use exceptions?</b><br>
		The exception support was added in release 0.9.3, and it still is in its early
		development stage. At the moment only the <b>GNU/EDMA</b> core generate exceptions
		and only a generic one is defined.<p>
		The code bellow shows an example on how to catch exceptions in your applications:<p>
	<pre>
	EDMA_TRY
	  {
	    id = edma_new_obj ("NON_EXISTING_CLASS");
	  }
	EDMA_CATCH (the_exception)
	  {
	    edma_met3 (the_exception, "print");
	  }
	EDMA_TRY_END;
	</pre>
	Current implementation uses preprocesor macros and longjmp calls to simulate exceptions.
	A better implementations will be provided in future versions.<p>
	</li>
	<li>
		<b>What is the script cleanup_after_crash.sh for?</b><br>
		<b>GNU/EDMA</b> stores global variables in a shared memory chunck so this
		information can be access by any <b>GNU/EDMA</b> application in the system.
		Sometimes, when an application crashes the <b>GNU/EDMA</b> signal handler
		aren't executed and this shared memory gets corrupted. The script 
		cleanup_after_crash.sh just removes the shared memory chunk.<p>

		Note that running this script while other <b>GNU/EDMA</b> applications are
		running will make them crash.<p>
	  
	</li>
</ul>


<h3>GNU EDMA Classes/Components</h3>
<ul>
	<li>
	<b>What is a pure abstract class?</b><br>
	It is a class without implementation, what in other systems is named
	<i>interface</i>. Such a class just have an IDF file an no implementation
	file.<p>
	</li>

  <li>
    <b>How do I install a GNU/EDMA component?</b><br> 
		<b>GNU/EDMA</b> components should provide a <i>make install</i> to do this works.<p>
		Anyway, you can install them manually following the steps listed bellow. Become root if necessary.
		<ul>
			<li> 
			Check the associated <b>NameSpace</b> for the component in the .ines file, included
			with the component package
			</li>
			<li>
			Copy the shared library to /usr/local/lib/edma/<b>NameSpace</b>
			</li>
			<li>
			Copy the .idf file to /usr/local/share/edma/idf/<b>NameSpace</b>
			</li>
			<li>
			Run <i>ines_class_register</i> against the provided .ines file.
			</li>
		</ul>
	</li>
	<p>
	<li>
	<b>Can I install new components while GNU/EDMA applications are running?</b><br>
	Yes, you can.<p>
	You can even install new versions of exsiting components while GNU/EDMA applications are running.
	In this case the existing objects continue using the old version of the class, but the new
	created objects will use the new version. This process will be improved in future versions, allowing
	to migrate existing objects to the new installed version if desired.<p>

	Note that in order to do not break running applications during this process, the new component
	version must provide the same interface the old version. The new version can add new properties and
	methods, but the old ones must be retained.<p>

	</li>
	<li>
	<b>Do I need to build a shared library for each class?</b><br>
	No. You can pack as many classes as you want on any shared library, so you
	can distribute a set of classes together.<p>
	Procedding this way reduces granurality of the system in the sense that you can't update
	just one class.<p>
	</li>
	<li>
	<b>Can I define static vars for my classes?</b><br>
	Yes. You just need to declare a global variable in the class C code.
	Such variables can't be managed by <b>GNU/EDMA</b> so, you must provide
	accessor methods for them.<p>
	For example, using static methods:<p>
	<pre>
	static ESint32   my_static_var = 0;

	ESint32 EDMAPROC
	MYCLASSget_static_var (CLASSID class_id)
	{
		return my_static_var;
	}

	EVoid EDMAPROC
	MYCLASSset_static_var (CLASSID class_id, ESint32 val)
	{
		my_static_var = val;
	}
	</pre>
	</li>
	<li>
	<b>How can I do some global initialization for my class?</b><br>
	You can use the <i>OnLoad</i> and <i>OnUnload</i> methods that are called
	when the shared library is first loaded and unloaded respectively.<p>
	</li>
</ul>

<h3>GNU/EDMA Inheritance</h3>
<ul>
  <li>
	  <b>Does GNU/EDMA support inheritance?</b><br>
		Yes, you can use typical class inheritance like in C++ or Java, or you
		can use object-based inheritance like in Self.<p>
		<b>GNU/EDMA</b> inheritance is a run-time operation.<p>
	</li>
	<li>
	<b>What does run-time inheritance mean?</b><br>
	It means that inheritance can be done at run-time. In other words, it means
	that you can build derived classes from binary components installed in your
	system.<p>
	</li>
	<li>
	<b>What is On-Demand Inheritance?</b><br>
	<i>On-Demand Inheritance</i> is a unique feature of <b>GNU/EDMA</b> that
	allows programmer to build hierarchy inheritances dynamically. An example
	will show how it works:<p>
	<pre>
	OBJID   id = edma_new_obj ("ONE_CLASS");
	edma_met3 (id, "A_SUPERCLASS&lt;superclass_method");
	edma_met3 (id, "A_SUBCLASS&gt;subclass_method");
	</pre>
	<p>
	In the example above we begin with a simple class named ONE_CLASS. Then we
	add a superclass named A_SUPERCLASS just invoking a method of it. The &lt;
	symbol means that this class must be attached above current class in the
	class hierarchy.<p>
	Second method invocation works the same way, but in this case adding a
	subclass.<p>
	One time the class has been attached we can use it without specifying
	the <i>classpath</i>.<p>
	</li>
	<li>
	<b>What is a classpath?</b><br>
	A <i>classpath</i> is a string that defines a path along an inheritance
	hierarchy. It can be used to exploit <i>On-demand inheritance</i> and to
	resolve name clashes.<p>
	</li>
	<li>
	<b>What actions can I do on an inheritance hierarchy?</b><br>
	You can add, delete, insert and override any class in a given inheritance
	hierarchy.<p>
	</li>
	<li>
	<b>Can I use repeated inheritance</b><br>
	Yes, you can. You just need to provide different anchor points for each
	path in your hierarchy. Here is an example:<br>
	<pre>

	OBJID   id_obj   = edma_new_obj ("SOME_CLASS");
	CLASSID id_class = edma_get_class_id ("SUPERCLASS");

	edma_add_superclass (id_obj, id_class, "SUPER1");
	edma_add_superclass (id_obj, id_class, "SUPER2");
	</pre>
	Even, you can do this using <i>On-Demand Inheritance</i>.<br>
	<pre>
	OBJID  id = edma_new_obj ("SOME_CLASS");

	edma_met3 (id, "SUPERCLASS@SUPER1&lt;a_method");	
	edma_met3 (id, "SUPERCLASS@SUPER2&lt;a_method");	
	</pre>
	</li>
	<li>
	<b>What is an anchor point?</b><br>
	An 	<i>anchor point</i> is a label you can attach to any link between <i>subobjects</i>.<p>
	You can use class name or anchor points when building a <i>classpath</i>, and, as showed in
	previous question, you can use then to build repeated inheritance hierarchies.<p>
	Finally note that you can add a label for the uplink and for the downlink at the same time.
	Take a look to this piece of code:<br>
	<pre>
	OBJID   id = edma_new_obj ("PERSON");

	edma_met3 (id, "PERSONALITY@JEKIL|WHO&lt;work_at_lab");
	edma_met3 (id, "PERSONALITY@HIDE|WHO&lt;kill");
	</pre>
	</li>
	<li>
	<b>How do I overwrite an anchor point?</b><br>
	You can do that directly using the classpath when accessing to your objects. 
	For example:
	<pre>
	OBJID   id = edma_new_obj ("DOG");
	
	edma_wprop3 (id, "name", "Bobby");

	edma_met3 (id, "BULLDOG@TYPE&lt;bite");
	/* Change bobby to be now a Fox Terrier */	
	edma_met3 (id, "FOX-TERRIER&lr;!bite");
	</pre>
	</li>
	<li>
	<b>Can I see one object's current inheritance hierarchy?</b><br>
	Yes, you can use the <tt>edma_show_subobjects_up</tt> and the
	<tt>edma_show_subobject_down</tt> within your application.<p>
	Output will look like this:
	<pre>
-----------------------------------------------------
Root ==> AP_TEST [0]
  SUPER ==> AP_TEST [1]
    SUPER ==> AP_TEST [2]
      MOST_TOP2 ==> AP_TEST [5]
    SUPER1 ==> AP_TEST [3]
      MOST_TOP ==> AP_TEST [4]

-----------------------------------------------------
      AP_TEST ==> AP_TEST [0]
    AP_TEST ==> AP_TEST [1]
  AP_TEST ==> AP_TEST [3]
Root ==> AP_TEST [4]
	</pre>
	</li>
	<li>
	<b>Classpaths are fine, but... Is there other way?</b><br>
	Yes. GNU/EDMA provides a rich API to deal with dynamic inheritance and
	classpaths.<p>
	Some of the available functions you can use are:<p>
	 <tt>edma_rename_superclass_ap</tt>: Renames superclasses anchor points<br>
	 <tt>edma_rename_subclass_ap</tt>: Renames subclasses anchor points<br>
	 <tt>edma_add_superclass</tt>: Adds a new superclass to a given object<br>
	 <tt>edma_add_subclass</tt>: Adds a new subclass to a given object<br>
	 <tt>edma_add_superobject</tt>: Adds a superobject to a given object<br>
	 <tt>edma_add_subobject</tt>: Adds a subobject to a given object<br>
	 <tt>edma_insert_superclass</tt>: Inserts a superclass up a given object<br>
	 <tt>edma_insert_subclass</tt>: Inserts a subclass down a given obejct<br>
	 <tt>edma_insert_superobject</tt>: Inserts a superobject up a given object<br>
	 <tt>edma_insert_subobject</tt>: Inserts a subobject down a given object<br>
	 <tt>edma_remove_superclass_ap</tt>: Remove a superclass from a given object<br>
	 <tt>edma_remove_subclass_ap</tt>: remove a subclass from a given objext<br>
	</li>
</ul>
<h3>GNU/EDMA Graphical Tools</h3>
<ul>
	<li>
	<b>How can I browse installed GNU/EDMA classes in my system?</b><br>
	You can use <i>GNOME Class Browser</i>, a GNOME applications which allows you to browse
	your GNU/EDMA registry with a graphical interface.<p>
	This simple applications is also a good example on how to use the <b>GNU/EDMA</b> reflection
	API.<p>
	</li>
	<li>
	<b>I must generate a lot of file to deploy a class. Can I generate them automatically</b>
	You can use <i>GNOME IDF Wizard</i> tool for that. With this tool you can easyly build your
	component interface and generate the required files to build your component with just one mouse
	click.<p>
	With <i>GNOME IDF Wizard</i> you can generate .idf files, C language skeletons for the class
	implementation, or even a full directory tree to build your component using GNU autotools.<p>
	</li>
	<li>
	<b>Can I extend <i>GNOME IDF Wizard</i> with new file types?</b>
	Of course. <i>GNOME IDF Wizard</i> is a <b>GNU/EDMA</b> modular application which uses 
	<b>GNU/EDMA</b> classes for building skeleton files.<p>
	Take a look to <i>classes/edma_tools/idf_wizard_support</i> for examples. You can easely add
	new file types, just providing your own <b>GNU/EDMA</b> class and updating the <i>builders.db</i>
	file in <i>/usr/local/share/edma</i>.<p>
	</li>
</ul>
<h3>GNU/EDMA Friends</h3>
<ul>
  <li>
	  <b>What projects are using GNU/EDMA?</b><br>
		There is a set of projects in development to provide <b>GNU/EDMA</b> with
		extra funcionalities. Some of then are: PIA, ANNA, GUILIAN, FAYE, EDNA.
		<p>
	</li>
	<li>
		<b>What abut PIA?</b><br>
		PIA is the <b>GNU/EDMA</b> Perl interface. Currently exists a Perl
		extension that allow to use <b>GNU/EDMA</b> from Perl code. The goal
		is to extend it with a SIU Proxy to allow us to write <b>GNU/EDMA</b>
		components using Perl.<p>
		
		A modified Perl interpreted, named <i>pia</i>, is supplied. Here you can see a simple
		example on how to use this extensions:<p>
		<pre>
	#!/usr/local/bin/pia

	use GNUEDMA;
	$id = GNUEDMA::new_obj ("NFILE");

	GNUEDMA::met3x ($id, "open", "ZZ", "hello.txt", "wt");
	GNUEDMA::met3x ($id, "puts", "Z", "Hello World from PIA!!!!\n");
	GNUEDMA::met3x ($id, "close", "");

	GNUEDMA::free_obj ($id);
		</pre>
		At this moment just the basic GNU/EDMA primitives are implemented, output parameters
		in methoid calls aren't supported, and method signatures are mandatory.<p>
		A Perl interpreter class is provided to embed Perl code in your applications and so
		use this language for scripting in them.<p>
	<pre>
	EDMAInit();

	id = edma_new_obj ("PERL_INTERPRETER");
	edma_met3 (id, "Run", "$hello=\"hello world!!\"; print $hello");
	edma_free_obj (id);

	EDMAEnd();
	</pre>

	</li>
	<li>
		<b>What about ANNA?</b><br>
		ANNA is the Python version of PIA. Curently a limited interface is
		available, with limitation quiet similar to the ones found on PIA.<p>
		
		The main problem is that Python do not support output parameters in an easy
		way. In fact the right way is to return the values changing (returning more than
		one value), what makes the interface a bit messy.<p>

		Here you can see a simple example on how an ANNA script looks like:<p>
		<pre>
	id = edma.new_obj ("NFILE");

	edma.met3x (id, "open", "ZZ", "hello.txt", "wt");
	edma.met3x (id, "puts", "ZS32", "Hello World!!!\n", 15);
	edma.met3x (id, "close" );

	edma.free_obj (id);
		</pre>
		A Python interpreter class is provided to embed Python code in your applications and so
		use this language for scripting in them.<p>
	<pre>
	EDMAInit();

	id = edma_new_obj ("ANNA_PYTHON_INTERP");
	edma_met3 (id, "Initialize");

	edma_met3 (id, "Run_SimpleString", "print 'Hello world from Python!!!\n'");
	edma_met3 (id, "Run_Script", "./my_python_script.py");

	edma_met3 (id, "Finalize");

	EDMAEnd();
	</pre>
	</li>
	<li>
		<b>What about MONNA?</b><br>
		MONNA is the <b>GNU/EDMA</b> <i>Mono</i> interface. Mono is a project which tries
		to develop an open port of the new .Net framework. Currently it provides a C# interpreter
		and an interpreter for CLI code.<p>
		MONNA system allows you to run CLI bytecodes and to access classes they define. 
		Bellow we can see a simple example on how to use this.
		<pre>
		jit = edma_new_obj ("MONO_JIT");

		id = edma_new_obj ("MONNA_PROXY:hello.exe|hello");
		edma_met3 (id, "say", "Z", "Johnny");
		edma_free_obj (id);

		edma_free_obj (jit);
		</pre>
		The example above runs a method named <i>say</i> in a class named <i>hello</i>
		included in the <i>hello.exe</i> file which first parameter is a string.<p>	
		Inside a C# (for example) class we will can write code like this:
		<pre>
		public void edma_test () {
			int id;

			id = GnuEDMA.new_obj ("HELLO_WORLD");
			GnuEDMA.met3 (id, "say", "Johnny");
			GnuEDMA.free_obj (id);
		}
		</pre>
		As happens with PIA and ANNA, CLI code can be executed from the GNU/EDMA applications.
		Here is a example showing how to run a CLI application.<p>
		<pre>
		id = edma_new_obj ("MONO_JIT");
		edma_met3 (id, "run","hello.exe");
		edma_free_obj (id);
		</pre>
	</li>
	<li>
		<b>What about JANE</b><br>
		JANE is indeed to provide the same interface described in previous sections but
		for the Java environment. There is old code for this project, but it need to be
		revamped for the new GNU/EDMA interface.<p>
	</li>
	<li>
		<b>What about GULIAN?</b><br>
		The same for Guile language. Current Guile version needs an special
		entry point in the main application embedding the interpreter, so
		applications that want to use this system must to that.<p>
		This project is frozen until we found a solution to this problems.<p>

	</li>
	<li>
		<b>What about FAYE?</b><br>
		FAYE will allow programmers to build distributed <b>GNU/EDMA</b> 
		applications. An old version is available but it requires a rewrite
		to fit the new <b>GNU/EDMA</b> API.
		<p>
	</li>
	<li>
		<b>What about SHARON?</b><br>
		SHARON will allow to use shared objects ala COM or CORBA, that is,
		named objects which can be accessed concurrently by various clients.
		There is no implementation of this system.
		<p>
	</li>
	<li>
		<b>What about EDNA?</b><br>
		EDNA stands for EDMA Deployment Network Architecture. This project is a
		set of <b>GNU/EDMA</b> classes an applications that will allow to
		deploy components across a network.<p>
		Basically, it allows to just install the main application in a machine.
		When the application begin running, the components it requires will be
		downloaded from the network and installed if they do not exists in the
		local system.<p>
		So, you will get installed in each machine just the GNU/EDMA components
		you need for your applications, and you just need to install components
		in one machine.<p>
	</li>
</ul>
<hr>
Return to the <a href="http://www.gnu.org/home.html">GNU home page</a>.
<p>

Please send FSF &amp; GNU inquiries &amp; questions to

<a href="mailto:gnu@gnu.org"><em>gnu@gnu.org</em></a>.
There are also <a href="http://www.gnu.org/home.html#ContactInfo">other ways to
contact</a> the FSF.
</p><p>

Please send comments on these web pages to

<a href="mailto:webmasters@www.gnu.org"><em>webmasters@www.gnu.org</em></a>,
send other questions to
<a href="mailto:gnu@gnu.org"><em>gnu@gnu.org</em></a>.
</p><p>
Copyright (C) 1998, 2001,2002 Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA  02111,  USA
</p><p>
Verbatim copying and distribution of this entire article is
permitted in any medium, provided this notice is preserved.</p><p>
Updated:
<!-- timestamp start -->
$Date: 2002/05/26 19:11:50 $ $Author: dmartin $
<!-- timestamp end -->
</p><hr>
</body></html>
