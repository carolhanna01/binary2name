@c ----------------------------------------------------------------------------
@c GNU/EDMA Tutorials 
@c Copyright (C) 1998, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
@c          by David Martínez Oliveira
@c
@c      Permission is granted to copy, distribute and/or modify this
@c      document under the terms of the GNU Free Documentation License,
@c      Version 1.3 or any later version published by the Free Software
@c      Foundation; with no Invariant Sections, no Front-Cover Texts and
@c      no Back-Cover Texts.  A copy of the license is included in the
@c      section entitled "GNU Free Documentation License".
@c ----------------------------------------------------------------------------

@menu
* AOP Introduction:: Introduction to AOP with GNU/EDMA
* SIU Proxies:: SIU Proxies for AOP
* Static AOP:: Using prederfined SIU Proxies
* Dynamic AOP:: Run-Time proxy attachment
@end menu

@node AOP Introduction, SIU Proxies, AOP, AOP
@chapter Aspect Oriented programming with GNU/EDMA
@section Introduction

This tutorial will introduce aspect oriented programming with the GNU/EDMA system

GNU/EDMA does not provides an AOP framework as we are used to see on other platforms, where an Aspect language must be used. Maybe an aspect language will be defined in the future but for now, GNU/EDMA provides a low level interface which allows to achieve AOP features in a simple way.

Strictly speaking, what GNU/EDMA provides is a general method/property interceptor solutions which allows to inject code around main object interaction primitives.

@node SIU Proxies, Static AOP, AOP Introduction, AOP
@section SIU Proxies as Method Interceptors

Method interception is performed using SIU proxies. Even when SIU proxies where designed to allow easy extension of the GNU/EDMA core to interface similar systems, those proxies can be used as general method interceptors and so, they can be used to inject code after and before any GNU/EDMA object interaction primitive.

From this point of view, Aspects become SIU proxies within the GNU/EDMA environment and after and before code blocks are seen in a very simple way. Examples in next section will show this.


@node Static AOP, Dynamic AOP, SIU Proxies, AOP
@section Static AOP. Predefined SIU Proxies
SIU proxies can be assigned to existing objects in several ways:

1. Permanently, when the SIU proxy is specified in the GNU/EDMA class registry
2. Creation-time, when the SIU proxy is attached to a given object when it is created
3. Dynamically, when the SIU proxy is attached or deattached from an existing class/component instance.

The last case is described in next section.

In the directory 'tests/aop' you can find to complete code of the examples described in this text.

To illustrate the use of static AOP lets see the general example of method call logging, common on AOP literature. For that, a SIU proxy named LOG_PROXY is defined and its 'Met3' method is coded as indicated bellow:

@example
ESint32 EDMAPROC
run_method (OBJID id, CLASSID cid, EPChar met_name, EPVoid val)
@{
  OBJID   obj;

    edma_rprop3 (id, "obj", &obj);
    edma_printf ("[LOGGING] Runnoing method %s on object %d", met_name, obj);
    return edma_met3_pargs (obj, met_name, NULL, 1, val);
@}
@end example

The Met3 method of a SIU proxy is executed whenever a method is invoked on the object the SIU proxy represents. As can be seen in the code above the method first recovers the object identifier the proxy is representing and just prints a message with the information of the method being executed. Then the real method is executed as usual.

The example above is a simple example of after joint point for the LOG_PROXY aspect (in AOP jargon).

In order to attach this aspect to a running object, it must be included in the GNU/EDMA registry or it can be specified when the object to be monitirized is created:

@example
OBJID  id = edma_new_obj ("LOG_PROXY:HELLO_WORLD");
@end example

The line above indicates that the LOG_PROXY proxy will be attached to a HELLO_WORLD object. Hereinafter, any interaction with the HELLO_WORLD instance will go through our LOG_PROXY and so, any method invocation will be logged to the standard output.	

@node Dynamic AOP, , Static AOP, AOP
@section Dynamic AOP. Run-time proxy attaching

Additionally, SIU Proxies (or aspects) can be attached or deattached to any running object. Two primitives are provided by the system for this. The sniplet below shows how to use them.

@example
OBJID    id = edma_new_obj ("HELLO_WORLD");

edma_met3 (id, "say"); /* Normal Execution */

edma_attach_proxy (id, "LOG_PROXY");
edma_met3 (id, "say"); /* Logged executuon */

edma_deattach_proxy (id);
edma_met3 (id, "say"); /* Normal executuon */
@end example

As can be seen it is very easy to attach and deattach SIU proxies (or aspects) to running instances.


@section Final Words

Even when GNU/EDMA does not provides a classical AOP/DAOP as found in other systems, the use of SIU proxies as general primitive interceptors provides the basic cross-cutting and separation of concerns philosophy behind AOP and so this ideas can be used freely in your applications without requiring external solutions. Additionally, GNU/EDMA unifies AOP and DAOP below an unique phylosophy making more easy and coherent the use of this concepts within the general GNU/EDMA programming model
