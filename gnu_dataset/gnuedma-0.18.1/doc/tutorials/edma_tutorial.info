This is edma_tutorial.info, produced by makeinfo version 4.12 from
edma_tutorial.texi.

Getting Started with GNU/EDMA

   Copyright (C) 2002 David Martínez


File: edma_tutorial.info,  Node: Top,  Next: Features,  Up: (dir)

* Menu:

* Features:: GNU/EDMA Features
* Overview:: GNU/EDMA Overview
* Applications:: How to write GNU/EDMA applications
* Components:: How to write GNU/EDMA components/classes
* GNUEDMA4C:: GNU/EDMA for C Developers
* AOP:: Aspect Oriented programming with GNU/EDMA
* Concept Index:: The Index
* Function Index:: GNU/EDMA functions listed


File: edma_tutorial.info,  Node: Overview,  Prev: Top,  Up: Top

* Menu:

* Library manager:: GNU/EDMA as a shared library manager
* OOP:: GNU/EDMA. OO Programmng in C
* CBS:: GNU/EDMA as a component based system
* LOCOOS:: GNU/EDMA LOCOOS
* IDF:: Define your own interface language
* SIU:: Integrate other systems

   GNU/EDMA Overview

   This text is a short overview to the main GNU/EDMA features, the one
already included and the ones that will be included in the future. The
objective is to provide to the reader a general overview of the
GNU/EDMA architecture and its possibilities.

   NOTE: THis is a mostly incomplete document


File: edma_tutorial.info,  Node: Library manager,  Next: OOP,  Prev: Overview,  Up: Overview

0.1 GNU/EDMA as a shared library manager
========================================

The simplest way to look at GNU/EDMA is like a "shared library
manager". If you don't worry about object oriented programming or
component based system, you can use GNU/EDMA as a simple library
manager.

   Basically you get the same functionality dlXXX function (dlopen,
dlsym,...). See gnuedma4c_developers.txt for more information about
working this way.

   Next is a quick reference on this use of GNU/EDMA

   - Run a function in a module. The module gets automatically loaded
The module/class must define static methods (smet3 stands for Static
METhod level 3)

   edma_smet3 ("MY_MODULE", "my_function", par1, par2,...);


File: edma_tutorial.info,  Node: OOP,  Next: CBS,  Prev: Library manager,  Up: Overview

0.2 GNU/EDMA. OO programming in C
=================================

The second way you can use GNU/EDMA is like a framework to build object
oriented applications using C language. This way, each GNU/EDMA
component/class (each library) can be managed like a class with all the
features commonly found in common OO programming languages
(inheritance, polimorphyms,...)

   Note that GNU/EDMA isn't a programming language, so some common
features can't be implemented. For example, operator overload can't be
achieved from outside the used programming language.

   Working this way you achieve a higher level from the point of view
of code reuse. An advantage of using GNU/EDMA instead just a C++
library is you alway can use a GNU/EDMA component in your program
without include files or the source code.

   See edma_tutorial.info for a general description of how to use
GNU/EDMA this way.

   Next is a quick reference on this use of GNU/EDMA.

   - Object creation.    OBJID id = edma_new_obj ("MY_CLASS_NAME);

   - Property write   edma_wprop3 (id, "Property", value);

   - Property read   edma_rprop3 (id, "Property", &value);

   - Method Invocation   edma_met3 (id, "Method", par1, par2,...);
edma_met3s (id, "Method", "Signature", par1, par2,...);

   - Object destruction   edma_free_obj (id);

   - Resolving name clashing conflicts.    edma_met3 (id, "Method",
par1, par2,...);    // Access most concret method   edma_met3 (id,
"SUPERCLASS>Method", par1, par,...); // Access method defined in
SUPERCLASS


File: edma_tutorial.info,  Node: CBS,  Next: LOCOOS,  Prev: OOP,  Up: Overview

0.3 GNU/EDMA as a component based system
========================================

If you use GNU/EDMA for your applications, you always are in a
component based environemnt. Each GNU/EDMA class/component can be
deployed independently and automatically included in the running system.

   GNU/EDMA provides a powerful reflection API, so you can inspect any
GNU/EDMA component and manage it programatically.


File: edma_tutorial.info,  Node: LOCOOS,  Next: IDF,  Prev: CBS,  Up: Overview

0.4 GNU/EDMA Locoos
===================

We refer to GNU/EDMA as a Locoos (Loosely Coupled Object Oriented
System). What this means is that you can use Object Oriented
programming techniques in a component based environment managing
components like classes in a seamlessly way.

   What this mean is that, for example, you can build derived
classes/components from any class/component in your system without the
need of source code or programming langyage dependency.

   In adition to this, working in a loosely coupled way allows GNU/EDMA
to provide dynamic OO features like dynamic inheritance.

   Next is a quick reference on this use of GNU/EDMA

   - Add a new superclass to a given object   edma_add_superclass_obj
(id, "SUPERCLASS", "UPLINK", "DOWNLINK");

   Access to new superclass can be:

   	 * Direct if no name clashing occurs 	 * edma_met3 (id,
"SUPERCLASS>Method", par1, par2,...); 	 * edma_met3 (id,
"UPLINK>Method", par1, par2,...);

   - Add a new subclass. Automatic overwritting of properties and
methods   edma_add_subclass_obj (id, "SUBCLASS", "DOWNLINK", "UPLINK");

   Acess to new subclass can be:

   	* Direct for overwritten properties and methods withour name
clashing 	* edma_met3 (id, "SUBCLASS<Method", par1, par2,...);
* edma_met3 (id, "DOWNLINK<Method", par1, par2,...);


File: edma_tutorial.info,  Node: IDF,  Next: SIU,  Prev: LOCOOS,  Up: Overview

0.5 Define your our Interface Language
======================================

As most of currently available component based environments, GNU/EDMA
defines its component interface using a Interface Definition Language.

   GNU/EDMA process this IDL dynamically (when the component is
required), and allows you to provide your our parser for your our IDL
format.

   In adition to the freedom to choose a IDL (remember you must program
it), this feature make more easy the integration with other systems.
Note that the class/component interface can be stored in any place this
way.

   This feature is provided through a set of API functions named,
genericly IngrIDF subsystem.


File: edma_tutorial.info,  Node: SIU,  Prev: IDF,  Up: Overview

0.6 Integrate other systems
===========================

GNU/EDMA provides the so called SIU subsystem that allows you to
override the main GNU/EDMA primitives in order to integrate other
system in the GNU/EDMA environemnt.

   THis way you can interface GNU/EDMA with other programming
environments (Java, Perl, Python,...) or with other component
frameworks (like XPCOM, or CORBA CCM,...)

   The SIU subsystem, basically allows us to define the so called SIU
Proxies, GNU/EDMA components that provides new code for the GNU/EDMA
primitives.

   This SIU proxies can be integrated in the system in two ways:

   * Blind Proxies: A blind proxy, just connects with an external
system without requiring the external component to be registered in the
main GNU/EDMA registry

   * Non-Blind Proxies: A non-blind proxy, works with external systems
but obtains information to access them from the GNU/EDMA registry. This
proxies, normally requires a IngrIDF parser that deals with the
external system and stores the external component interface in the
GNU/EDMA registry.

   There are thre levels for this SIU proxies:

   * Level 1: Just the basic primitives:            edma_new_obj,
edma_free_obj, edma_wprop3, edma_rprop3, edma_met3

   * Level 2: Deals with virtual methods, allowing to override methods
across systems

   * Level 3: Delas with inheritance, allowing to set inheritance
relationships across systems

0.7 Final Word
==============

In this text we have try to show the main features available in
GNU/EDMA and introduce some systems that, at this moment lacks of
documentation (just a bunch of examples are availables)


File: edma_tutorial.info,  Node: Features,  Prev: Top,  Up: Top

* Menu:

* Features Introduction:: GNU/EDMA Features introduction
* Features Components:: Components
* Features OOP:: Object Oriented Programming
* Features Reflection:: Reflection
* Features Extensibility:: Extensibility
* Features Reuse:: Reuse
* Features Conclusion:: Conclusion


File: edma_tutorial.info,  Node: Features Introduction,  Next: Features Components,  Up: Features

0.8 INTRODUCTION
================

In this short paper I will try to describe the main features provided
by GNU/EDMA, and how them relate to other nowadays available systems
nowadays.

   There are five key points in GNU/EDMA which will discuss in this
text: component-based architecture, object oriented programming,
reflection, extensibility and reuse. In the following section we will
describe them.


File: edma_tutorial.info,  Node: Features Components,  Next: Features OOP,  Prev: Features Introduction,  Up: Features

0.9 COMPONENTS
==============

GNU/EDMA is mainly a component system. You can think... "oh, my god!..
just another guy reinventing the wheel!". Well, that is true now, but
this project began at the end of 1996 when no such a system existed for
GNU/Linux... but that is another history.

   Today you can choose among a lot of components models. You have the
Bonobo model developed by the GNOME team, the Universal Component Model
from the Qt people, and the XPCOM brought to us by the Mozilla
comimunity to name a few.

   The main and biggest difference among all these technologies and
GNU/EDMA is that they are mostly based on the Microsoft COM model and
the technologies built on top of it. So, XPCOM and UCM are basically
COM, and Bonoboo can be seen as a higher level model closest to ActiveX
or JavaBean models with a hard orientation to GUI applications.

   GNU/EDMA is quite different to be considerated another thing.

   First of all, all the COM based systems rely on a interface based
model and a manual delegation model central to object. GNU/EDMA relies
on classes like any other programming language and object delegation is
completely transparent to the programmer.

   In GNU/EDMA you just use the method or access the property you need
without queries if an interface is there or not... of course you can
write your program this way, but "that is not the unique way to" write
your applications.

   GNU/EDMA uses an approach similar to CORBA to define its
classes/components. Each class in GNU/EDMA is composed by a interface
definition file (IDF) and an implementation file (typically a shared
library). The difference with CORBA is that interfaces are compiled at
run-time, that is, you can see it like using CORBA DII all the time
with less overhead, and, in general, a more simple interface.

   GNU/EDMA provides a very simple interface, no per-object-type
factories, no interface query, no dependencies at source code level. As
pointed above, you can work this way if you want, but you can also obey
all these topics if you just want to write an application that do not
requires those features.

   See the tutorials at http://www.gnu.org/software/edma for examples
on how to build and use GNU/EDMA components.


File: edma_tutorial.info,  Node: Features OOP,  Next: Features Reflection,  Prev: Features Components,  Up: Features

0.10 Object Oriented Programming
================================

GNU/EDMA provides object oriented facilities in the component based
environment we have just described. These facilities are integrated in
a loosely coupled way that allows us to write true object oriented
applications using a language like C.

   Additionally GNU/EDMA provides all the classical OOP concepts in a
full dynamic context, what this means is that you can use inheritance,
override virtual methods, work with multimethods, etc... all at
run-time. Hence, you can add new superclasses to your objects while
your application is running, or override virtual methods changing
objects behavior with time.

   You can't do this with any other system without using tricky and
obscure techniques. In addition to these dynamic features, all the OOP
concepts mix in a seamless way with the component based
infraestructures. So, components are classes and, for example, new
components can be created by inheritance from existing ones, even if
you don't have the source code from them, improving this way the reuse
of components.

   From a more technical point of view about OOP, GNU/EDMA allows
programmers to choose their preferred flavors when building its
applications. This way, programmer can choose among the well known
superclass approach present in the most commonly used programming
languages today (Java, C++, etc...), the INNER way ala Beta/gBeta or
even the prototype based solutions provided by languages like Self.

   The OOP features of GNU/EDMA are mostly oriented to improve the code
reuse facilitating the mixin of existing components, classes or objects
in a very easy way.

   We must keep in mind that GNU/EDMA is not a programming language it
is just a library that provides OOP features to applications. This fact
has two consequences. First one is that you can use OOP with non OOP
programming languages (like C), and in the second one your OO design
gets independent of the underlying programming language syntax.

   Of course, a native C++ program will be more efficient that its
GNU/EDMA counterpart but reusing all your C++ code could become a hard
task if you must to change your programming language, or even mix
various programming languages in one application.

   Finally, as pointer above, GNU/EDMA is enough flexible to provide
various programming models. You can use, in some part of your program
the Self way ("Parents are shared parts") in other the mostly complete
Beta's INNER way, or the classical top-down class hierarchy of
C++/Java/Smalltalk/Effiel, all of them at the same time, choosing the
best fit solution in each part of your application.


File: edma_tutorial.info,  Node: Features Reflection,  Next: Features Extensibility,  Prev: Features OOP,  Up: Features

0.11 Reflection
===============

GNU/EDMA provides a quite complete reflection API that allows
developers to virtually retrieve any information about each component
in the system.

   Reflection API in GNU/EDMA is two mainfold. In one hand, it is a
required feature due to the dynamic nature of this system, in the sense
that, if we want to exploit dynamically added features in our
applications we need to know what they are in some way..

   In the other hand, the GNU/EDMA reflection API is a key feature to
build specific development tools for this system.


File: edma_tutorial.info,  Node: Features Extensibility,  Next: Features Reuse,  Prev: Features Reflection,  Up: Features

0.12 Extensibility
==================

From the beginning, GNU/EDMA was conceived as an evolving system, in
the sense that is could embrance current and new technologies appearing
in the future, and that new features could be added to the main core in
the easiest possible way.

   Extensibility in GNU/EDMA is achieved through three main subsystems
embedded in the core of the system.

   First one is named IngrIDF and it is a set of primitives to process
classes/components interfaces. IngrIDF, allows to write your own IDF
(Interface Definition Files) parsers and it should also allow to write
parsers for processing other systems interfaces, as for example, CORBA
IDL files, or even Java bytecodes.

   Second one is named SIU and it is a generic proxy system that allows
developers to customize the basic GNU/EDMA primitives, in order to
interface GNU/EDMA with other systems and to provide further features
not envisioned at the first time. For example, the Perl interface in
progress uses SIU Proxies to forward GNU/EDMA applications calls to the
Perl interpreted. Somo Aspect Oriented Programming experiments are in
progress using this subsystem.

   Finally, the EMI subsystem provides an interface to allow developers
deal with internal problems in the core system. At the moment this is
the less mature of all this subsystem and it just allow to process the
CLASS_NOT_FOUND exception, that is, we can write code to try to find a
required class (for example through the net).

   All this three subsystems are built on top of the GNU/EDMA platform,
that is, any IngrIDF parser, SIU proxy or EMI handler are just GNU/EDMA
classes with special attributes.

   Compare the facilities provided by these subsystem with other
component models or even programming languages.

   IngriDF allows you to customize your interface definition files and
process them at run-time, that is the equivalent process to compile the
interface to build stub and skeletons in systems like CORBA. Doing this
in other systems may be quite complex or even impossible without
changing its internal behavior.

   SIU Proxies trivializes the adaptor and proxy design patterns, and
provides a uniform interface for interfacing other system with
GNU/EDMA. At the same time it provides a simple way to extend your
GNU/EDMA primitives and to apply them individually to specific objects.

   The function of EMI handlers its more common in nowadays system. For
example, you can get a quiet similar behavior with Java Class Loaders
or external services provided by other component systems (the CORBA
interface repository, for example).


File: edma_tutorial.info,  Node: Features Reuse,  Next: Features Conclusion,  Prev: Features Extensibility,  Up: Features

0.13 Reuse
==========

Reuse is one of the objectives we are trying to achieve with GNU/EDMA
and it is one of the main reasons to create this system.

   GNU/EDMA's component based model and object orientation directly
promotes code reuse but you can achieve higher reuse degrees.

   GNU/EDMA is written in C programming language, and datatype and
operating system adaptation features are built-in in the system. This
means that you can reuse most of your code even between platforms with
little or no modification at all. In the other hand, using C
programming language allows developers to interface GNU/EDMA with
virtually any other system and, this way, reuse any piece of code
available.

   The classes/components you write can be registered in a whole system
way, what makes them available to all the applications in the system.
From this point of view, GNU/EDMA is like a OO library management
system.

   An important difference between GNU/EDMA and other systems is that
GNU/EDMA extends object orientation to the components, allowing this
way build new components that inherints from existing one without
writting complex delegation code to mix the components.

   Finally, GNU/EDMA applications and components can be built without
any dependency at the source code level, that is, you do not need any
special include file for doing that. The main drawback of this approach
is that compiler can detect some error at compile-time and you must do
extra checking at run-time. Note that this is only necessary if you
want a fully dynamic, lossely coupled application.


File: edma_tutorial.info,  Node: Features Conclusion,  Prev: Features Reuse,  Up: Features

0.14 CONCLUSIONS
================

GNU/EDMA is just another try to reinvent the whell but with some
improvements that can make more easy build and tune your applications.

   Most of the functions commonly provided by similar systems can be
achieved in a more easy and comprehensive way, and with less system
requirements.

   At the same time, it is a framework for general software engineering
research


File: edma_tutorial.info,  Node: Applications,  Next: Hello World,  Prev: Top,  Up: Top

* Menu:

* Hello World:: Our first GNU/EDMA Application
* Building:: How to Build GNU/EDMA Applications
* Properties:: Dealing with properties
* Static Methods:: Static or Class Methods
* Example:: A simple extensible Application


File: edma_tutorial.info,  Node: Hello World,  Next: Building,  Prev: Applications,  Up: Applications

1 Hello World!
**************

We will begin with the basic "Hello World" application which will show
us how to compile a GNU/EDMA application and how to begin using
GNU/EDMA components. Here is the code:

   #include <edma.h>

   main () {
   	OBJID   id;

   	EDMAInit();

   	if ((id = edma_new_obj ("HELLO_WORLD")) == -1) {
   	 fprintf (stderr, "Can't create HELLO_WORLD object\n");
   	 EDMAEnd ();
   	}
   	edma_met3 (id, "hello");
   	edma_free_obj (id);
   	EDMAEnd();
   }

   As you can imagine, this simple program show a impresive "Hello
World!!" message in the console. Let's go in deep with the different
parts of the program.

1.1 Startup and Shutdown
========================

Like most systems, GNU/EDMA needs to be started up before it can be
used. As you can infere from the above code, this is done calling the
`EDMAInit()' function.

   Any GNU/EDMA application must first call this function what
registers it in the GNU/EDMA system initiating its internal structs.

   The same way, when an application finishes using GNU/EDMA it must
call `EDMAEnd()', to instruct GNU/EDMA to clean up all the application
related structs created while the program was running.

1.2 Creating/Destroying GNU/EDMA components
===========================================

Once the system was started up, the application can begin using the
services GNU/EDMA provides. The more simple operation we can do is to
create an object. This is done calling the `edma_new_obj' primitive.

   This primitive accepts as first parameter the component/class name
we want to instantiate, and returns an instance reference that  will be
used to interact with the just created object.

   If the instance can't be created, for example because the class
passed as parameter doesn't exist, `edma_new_obj' return a -1 value,
and a error message is showed in the console.

   When calling `edma_new_obj', GNU/EDMA does a lot of things. First it
checks if the class definition has already been loaded. Thinking about
CORBA, the class definition is equivalent to the IDL file. The main
difference here is that GNU/EDMA doesn't requires to precompile IDL
files, it does itself when required.

   Then, it checks if the implementation for the requested class is
loaded and mapped in the application space address, in order to allow
the application to use it. If not, GNU/EDMA locates the asociated
implementation file and makes it available to the current application.

   At this point, the interface and implementation for the requested
class or component is ready to be used. All this process is done
transparently to the programmer. In this simple introduction we will
just deal with in-process components, that is, components that are
implemented as shared libraries. More complex mechanisms can be build
on GNU/EDMA but that is another history.

   When we are done with our object, we can destroy it calling FreeObj
primitive with the object referencei we got from previous
`edma_new_obj' call. This primitive frees all the internal structs
asociated with the object.

   Really, `edma_free_obj' undoes all the operation `edma_new_obj' did
previously, but consistently. So, `edma_free_obj' will unload
implementation if the object been destroyed was the last object using
it, and even it frees the interface information related to the class if
it's no longer required by the application. Actually the current
implementation never frees interface related information until the
`EDMAEnd' function is called.

1.3 Using the objects
=====================

Now, we have a HELLO_WORLD instance and we can make it do things. This
class just defines only one method which is named `hello', and simply
shows the well-known message in the console.

   There are tree basic operation an application can do with an object.
The first one is the one showed in our example; invoke a method. This
is done using the `edma_met3' primitive, the syntax can be easyly
infered from our hello world example.

   The other two operations allows us to work with properties.
Properties are the status of the object, what C++ programmers call
member variables. To deal with properties, GNU/EDMA provides two
accessor primitives: `edma_wprop3' which allows to write a value in  a
property, and `edma_rprop3' which allows to retrieve a properties's
value.

   We will see how to use them in our next example. For now is enough
to know they exist.


File: edma_tutorial.info,  Node: Building,  Next: Properties,  Prev: Hello World,  Up: Applications

2 How to build GNU/EDMA applications
************************************

Let's write a makefile to get our application compiled. Here it is:

   CC=gcc
   CFLAGS=`edma-config --cflags-exe`
   LIBS=`edma-config --libs-exe`

   hello_test: hello.c
   	$(CC) $(CFLAGS) -o $ $< $(LIBS)

   As you can see it is a classical makefile, just run make and run the
resulting application. A impressive `Hello World!' message will be
dropped in the console.

   Let's continue.


File: edma_tutorial.info,  Node: Properties,  Next: Static Methods,  Prev: Building,  Up: Applications

3 Dealing with properties
*************************

Now we will make a little modification to our application in order to
ilustrate how to work with properties. Here is the new code.

   #include <edma.h>

   main () {
   	OBJID   id;
   	EChar   the_name[80];

   	EDMAInit();
   	if ((id = edma_new_obj ("HELLO_WORLD")) == -1) {
   	 fprintf (stderr, "Can't create HELLO_WORLD object\n");
   	 EDMAEnd();
   	}
   	edma_met3 (id, "hello");
   	/* New code follows*/
   	edma_wprop3 (id, "Name", "John");
   	edma_met3 (id, "sayHello");
   	edma_rprop3 (id, "Name", the_name);
   	/* New code ends*/
   	edma_free_obj (id);
   	EDMAEnd();
   }

   The use of `edma_wprop3' and `edma_rprop3' is straightforward as you
can see in the above code. The `sayHello' method now says `"Hello
John"', this method uses internally the property NAME we are
manipulating in this example.

   One special property type provided by GNU/EDMA is the so called
`EDMAT_BUFFER'. This data type is just a memory chunck which stores
size information. `EDMAT_BUFFER' is the preferer way to deal with
dynamic memory in GNU/EDMA. Let's see how to use this type with a new
example.

3.1 Using EDMAT_BUFFER types
============================

Next example is a simple program that reads a file and shows its first
200 bytes in screen. We suppose we are reading a text file so we don't
care about non-printable characters.

   #include <stdio.h>
   #include <edma.h>

   main () {
   	OBJID         id;
   	EDMAT_BUFFER	buf;
   	ESint32       size;

   	EDMAInit ();
   	if ((id = edma_new_obj j("NFILE")) == -1) {
   		fprintf (stderr, "Can't create NFILE object\n");
   		EDMAEnd ();
   		exit (1);
   	}
   	edma_buffer_alloc (&buf, 1024);

   	edma_met3 (id, "Load", "the_sample_file.txt", &buf);
   	printf ("%d bytes read\n",buf.Size);
   	(EPChar) buf.dat[200] = 0;
   	printf ("%s", (EPChar) buf.dat);

   	edma_buffer_free (&buf);
   	edma_free_obj (id);
   	EDMAEnd();
   }

   The above example shows how to use `EDMAT_BUFFER' vars. First, we
can see how to use `edma_buffer_alloc' and `edma_buffer_free' to alloc
and free memory chunks. Second we see how to access information stored
in the type: the `Size' field tell us the memory chunk size in bytes
and the `dat' field allow us to access the stored information.

   There is also a `edma_buffer_realloc' function we didn't need to use
in our previous example and that is used the same way as
`edma_buffer_alloc' working like the `realloc' standard C library
function.


File: edma_tutorial.info,  Node: Static Methods,  Next: Example,  Prev: Properties,  Up: Applications

4 Using Static Methods
**********************

GNU/EDMA allows to define and use static methods the same way Java
does. The difference between a ordinary method and a static one is that
the second doesn't know what object it is related to. It is just
related to a class not to an object.

   We can extend our previous file example adding an extra method call
to the `FileExist' static method in class FILESYSTEM. This class
provides a set of static method to get information about filesystem
objects. For checking if the file exists before reading it we can use
this code.

   if ((edma_smet3 ("FILESYSTEM", "FileExist", "the_sample_file.txt")) == -1)
   {
     fprintf (stderr, "File the_sample_file.txt doesn't exist\n");
     EDMAEnd ();
     exit (1);
   }

   In this case, instead of use `edma_met3' primitive we use
`edma_smet3' primitive. Instead of provide the primitive with an object
reference we provide a class/component name. No further complication
required.


File: edma_tutorial.info,  Node: Example,  Prev: Static Methods,  Up: Applications

5 A simple extensible Application
*********************************

Taking a brief look to all the examples we have showed until now, you
can advice that GNU/EDMA primitives works on character strings. This
simple fact provides a powerful extensibility mechanism. Let's see a
simple example:

   #include <edma.h>

   int main (int argc, char *argv[]) {
     EChar  viewer[1024];
     EChar  file[1024];
     OBJID  id;

     EDMAInit ();

     strcpy (viewer, argv[1]);
     strcpy (file, argv[2]);

     id = edma_new_obj (viewer);
     edma_met3 (id, "view", file);
     edma_free_obj (id);

     EDMAEnd ();
   }

   In previous example we have intentionally removed the error checking
code for space reasons. As we can see this simple application tries to
be a minimum file viewer, when invoked it receives two parameter. The
first one is the class the application will use to show us the file,
which is the second parameter.

   This is a quite silly example but it show how to build applications
that can use classes that doesn't exist at the compile time. You can
distribute this simple application and add specific viewers in future.
This viewer classes just must provide a view method, that is the only
requirement for this application.

   Of course this simple efect can be easyly achieved with dlopen
function family, but let's do a little extension to show some simple
advantage of working this way.

5.1 Adding Interactibility
==========================

Now we are going to modify the above example to allow the user to do
some basic manipulations on the file been viewed.

   #include <edma.h>

   int main (int argc, char *argv[]) {
     EChar  viewer[1024];
     EChar  file[1024];
     EChar  cmd[1024];
     OBJID  id;

     EDMAInit ();

     strcpy (viewer, argv[1]);
     strcpy (file, argv[2]);

     id = edma_new_obj (viewer);
     while (strcmp (cmd, "quit") != 0)
     {
       printf ("# ");
       scanf ("%s", cmd);
       edma_met3 (id, cmd, file);
     }
     edma_free_obj (id);

     EDMAEnd ();
   }
   Quite easy, isn't?. Now you can use any defined method in the viewer
class. For example suposse your class has a print method, then you can
print your file just writting print at the prompt, or suppose your
IMAGE_VIEWER class has a `showPseudoColor' method, you can use it
directly.

   As said, this is a very simple example that can be solved in a
variety of ways without using GNU/EDMA, or even building a simple
library to deal with shared libraries. But, GNU/EDMA is there now and
it offers a lot more facilities we will coment in future papers.


File: edma_tutorial.info,  Node: Components,  Next: Components Introduction,  Prev: Top,  Up: Top

* Menu:

* Components Introduction:: General concepts about GNU/EDMA Components
* Interface:: Writting the Interface Definition File
* Implementation:: Writting the Implementation file
* Building Components:: Building and Installing GNU/EDMA components
* Wrappers:: How to write a component wrapper

   In this paper we will describe the process we must follow to build
GNU/EDMA components and classes which can be used latter in our
applications. The whole process will be described first, and then we
will introduce some graphical tools that simplify the component built
process.


File: edma_tutorial.info,  Node: Components Introduction,  Next: Interface,  Prev: Components,  Up: Components

6 Introduction
**************

The first thing we must know is that a GNU/EDMA class has two main
parts. The first one is the so called Interface Definition File, a text
file (really it can be of any form using the IngrIDF subsystem) that
defines the class/component interface. The second one is the component
implementation, that is the code we will run when using the component.

   This is the typical approach in most OO environments (i.e. COM,
XPCOM, CORBA even RPC). You write your objects interface in some
interface definition language and, using a interface compiler you
generate some code stuff required to build your object implementation
and to use those objects from your client applications.

   In GNU/EDMA this is a bit different. You must write a interface
definition file using some interface definition language (one quite
simple is provided), but you don't need to use a interface compiler.
Actually you can do that and then generate the same code COM or CORBA
uses to provide a tight programming language mapping with the object
generated.

   Working this way has advantages and disadvantages. The main
advantage is that the code generated will be used by the compiler for
early type checking, finding posible errors in the application. The
disadvantage to using the interface compiler is that any change you can
do in the object's interface requires to recompile a lot of things.

   Currently there isn't no interface compiler and the usual way you
will be GNU/EDMA applications and components is using the system
primitives, that is no interface compiler generated wrapper is used at
all in this paper. We will do a brief comment about this at the end of
the paper.


File: edma_tutorial.info,  Node: Interface,  Next: Implementation,  Prev: Components Introduction,  Up: Components

7 Writting the interface definition file
****************************************

The default interface definition language used by GNU/EDMA is quite
simple. It just allow to define some general information as well as
properties and methods. The structure is like a .ini old windows file
format, divided in sections each section containing a set of fields.

   Let's define a IDF file for one simple HELLO_WORLD class. It will
look like this:

   [General]
   Name=HELLO_WORLD
   [SYS_DEF]
   ModuleName=HELLO_WORLD.dll
   [Definition]
   PropertiesNum=2
   MethodsNum=3
   [Prop0]
   Name=num
   Type=EUINT32
   Access=READ/WRITE
   ArrayElems=
   [Prop1]
   Name=str
   Type=EZSTRING
   Access=READ/WRITE
   ArrayElems=
   [Met0]
   Name=born
   Signature=
   Virtual=0
   [Met1]
   Name=rip
   Signature=
   Virtual=0
   [Met2]
   Name=say
   Signature=
   Virtual=0
   []

   There are five main section in a EDMAIDF file (that is how they are
named). The first one provides general information about the component,
typically it just contains the component name.

   Next section, SYS_DEF, is reserved to store system dependent
information. Typically it just contains the implementation module name,
but it isn't really necesary.

   Then follow the real component interface which has three main parts.
The first one defines the elements we will find in next sections, and
the two other defines, respectively, the properties and methods this
component has.

   The definition section has three main field. The PropertiesNum which
indicates how many properties will be defined bellow in the file. The
MethodNum which is the same but for the method definition, and finally
the SuperClass list that we will not comment in this tutorial. It is
described in detail in the GNU/EDMA Inhertiance Tutorial.

7.1 Property Definition
=======================

Each property is defined using four fields. First one is the property
name, the string we will use with WProp3 and RProp3 primitives to refer
to this property. Next we find the property type, a string that can get
its value from this list:

   ESint32, ESint16, ESint8	: Signed Integers
   EUint32, EUint16, EUint8	: Unsigned Integers
   EChar				 							: Character or Byte
   EByte, EWord, EDWord			: Byte, word and dword
   EReal32, EReal64					: float and double
   EZString									: Zero terminated string
   EBuffer										: EDMAT_BUFFER data
   EOBject										: A Generic GNU/EDMA Object
   FIXME: Check if some is missing.

   The next field required to define a property is the Access field.
This field allows to set access modifiers for the property being
defined. The permited values are: READ, WRITE, READ/WRITE

   Finally, we can make some property a fixed array of basic types,
setting the ArrayElems field.

7.2 Method Definition
=====================

Method sections are quite similar to property ones, but using some
diferent field. The first field, as in the property case is the method
name.

   Next field is the method signature. The signature is a character
string which codes the parameter and return types for the method being
defined. This field can be left blank, but it's recomended to fill in
it in order to provide full reflection capabilities to the system. Not
doing this will prevent the component being defined not to work
properly in some cases.

   Next follows the signature strings assoaciated with the basic
GNU/EDMA types:

   ESint32, ESint16, ESint8  : S32,S16,S8
   EUint32, EUint16, EUint8  : U32,U16,U8
   EChar                     : C
   EByte, EWord, EDWord      : B,W,DW
   EReal32, EReal64          : R32,R64
   EZString                  : Z
   EBuffer                   : A
   EOBject                   : O

   To define a parameter as an output parameter, a 's' must be prepend
to the signature string (s stands for salida, the spanish word for
output). The method return type is defined is specified prepending a
'r' charecter to the appropiated type signature.

   Let's see some examples of valid signatures:

   method (ESint32 a,ESint32 b,ESint32 *c) -> S32S32sS32
   ESint32 method (EPChar name)						-> ZrS32
   OBJID method(EReal64 a,EReal64 b)				-> R64R64rO

   Finally, we can provide special modificator for each method being
definedi, this modifiers are of type boolean being valid values 0 or 1,
and all are optional. The available modifiers are:

   Virtual: Defines the method as virtual what means that it can be
overriden Abstract: An abstract method is a method that don't have
assoaciated implementation.  Static: Defines the method as static what
means that it is related to the class not the instances of the class.

7.3 Constructors and Destructors
================================

GNU/EDMA allows to define contructor and destructor methods for the
classes. This methods are the executed when class instances are created
or destroyed using NewObj or FreeObj respectively.

   Contructor method must be named born and destructor method must be
named rip. In the current implementation it isn't possible to provide
parameters to this special methods.


File: edma_tutorial.info,  Node: Implementation,  Next: Building Components,  Prev: Interface,  Up: Components

8 The implementation file
*************************

Now we know how to write our IDF's (Interface Definition Files), we
must write the implementation file, the code we want our component to
provide. In this tutorial we will just deal with in-process component,
that is, components implemented with shared libraries. So, what we need
to build is a shared library, but with an special struct.

8.1 Providing a data struct to access properties
================================================

GNU/EDMA allocate the required memory to store the properties defined
in the assoaciated IDF automatically when a class/component instance is
created, and provides the primitives WProp3 and RProp3 to access them.

   However, the class implementation, normally, will often access this
properties and then it must do that in a easy way. For doing that, we
will define a C struct to access the properties we have defined in the
IDF file and then use the GetRef primitive to map the properties values
to that struct.

   For our HELLO_WORLD example we should define a struct like this:

   typedef struct
     {
   		EUint32		num;
   		EPChar		str;
   }DtHELLO_WORLD;

   Using this struct we can call GetRef primitive and the access the
properties values through an ordinary pointer instead of the property
primitives GNU/EDMA provides. Let's see how this is done:

   ESint32 EDMAPROC HELLO_WORLDborn(OBJID IdObj)
   {
   DtHELLO_WORLD	*m;

   m=(DtHELLO_WORLD*)GetRef3(IdObj);
   }

   As we can see GetRef3 primitive just provides a pointer to the
memory address where GNU/EDMA allocated the memory chunck required to
store the properties defined in the IDF file. From here we just
manipulate properties using the fields in our C struct.

8.2 Writting the code
=====================

Now we just must to write the code for our methods. For doing this we
must define a function for each defined method with a special name. The
name follows the next format:

   `CLASS_NAME|Method_Name|Signature'

   So, for our previous IDF file  we must define this methods

   ESint32 EDMAPROC HELLO_WORLDborn(OBJID IdObj)
   {
   	return 0;
   }

   ESint32 EDMAPROC HELLO_WORLDrip(OBJID IdObj)
   {
   	return 0;
   }

   ESint32 EDMAPROC HELLO_WORLDsay(OBJID IdObj)
   {
   	DtHELLO_WORLD	*m;

   	m=(DtHELLO_WORLD*)GetRef3(IdObj);
   	printf ("Hello World! %s",m->str);
   }

   Note that the first parameter for each method is always a GNU/EDMA
object. It is the equivalent to the this or self hidden parameter used
in most of the current OO programming language.

   In this simple example no signature exists for the methods been
defined and the constructor and destructor does nothing with
properties. The say method will use the properties so we declare a
pointer to our previously defined struct and we call GetRef3 in order
to access properties values through this pointer in a efective way.

   At this point we just have to write the code we want out GNU/EDMA
component to run when invoking methods.

8.3 Static Methods
==================

In the above example no static method was defined in the associated
IDF, but we must to comment how to define this static methods because
they differ from the showed above.

   As we have said, a static method is related to a class not to an
object, so, when GNU/EDMA executes the SMet3 primitive it doesn't pass
as first parameter an OBJID, instead it passes a CLASSID type what is a
class identifier. With this information a hello static method
implementation for our GNU/EDMA component will look like this:

   EVoid EDMAPROC HELLO_WORLDhello(CLASSID cid) {
   	printf ("Hello World!!!\n");
   }

   Or with paramters:

   EVoid EDMAPROC HELLO_WORLDhelloYou(CLASSID cid,EPChar name) {
     printf ("Hello %s!!!\n",name);
   }

   This methods can be used form your applications this way:

   SMet3("HELLO_WORLD","hello");
   SMet3("HELLO_WORLD","helloYou","John");


File: edma_tutorial.info,  Node: Building Components,  Next: Wrappers,  Prev: Implementation,  Up: Components

9 Building the dynamic library
******************************

To generate the implementation shared library we will use a simple
makefile that we show here:

   CC=gcc
   CFLAGS=`edma-config --cflafs-class`
   LIBS=`edma-config --libs-class`
   HELLO_WORLD.so: temp.o
   	$(CC) -shared -Wl,-soname,libHELLO_WORLD.so.1 -o $ temp.o $(LIBS)
   temp.o: HELLO_WORLD_imp.c
   	$(CC)  $(CCFLAGS) $< -o $

   As we can see it is a classical shared library make file without no
more complications

9.1 Installing the component
============================

Once we have our interface and implementation files we can install our
just built GNU/EDMA component in the system and make it available to
every application.

   The installation consists on putting the IDF file and the shared
library in place and then update the GNU/EDMA registry. In a default
instalation the IDF files are stored in /usr/local/share/edma/idf and
the shared libraries are saved in /usr/local/lib.

   To update the GNU/EDMA registry you have two choices. The first is
to manually edit the registry that, by default is located at
/usr/local/etc/edma/edma32.cfg. The second is to generate a .ines file
and use the class_register tool distributed with the system. Let's see
how a .ines file looks like:

   ClassName=HELLO_WORLD
   Machine=i386
   OperatingSystem=LINUX
   Implementation=HELLO_WORLD.so
   IDFParser=EDMAIDF

   Basically a .ines file contains the same information you must add
manually to the GNU/EDMA registry needed to inform GNU/EDMA about the
kind of class it must deal with. In our example we will deal with a
simple class, but there are some special classes that should be defined
in the system registry.

   To add manually a class to the system, you must first increment the
value in file nClasses at the begining of the edma32.cfg file, and the
add a section at the end of the file with the fields showed above when
we talk about .ines file. The end of edma32.cfg after installing our
HELLO_WORLD class will look like this (then numbers in [ClassXXX] will
vary depending on how many classes you have installed in your system)

   [General]
   nClasses=28
   [CLASS0]

   ...

   [CLASS26]
   ClassName=NFILE1
   Machine=i386
   OperatingSystem=LINUX
   Implementation=libNFILE1.so
   IDFParser=EDMAIDF
   [CLASS27]
   ClassName=HELLO_WORLD
   Machine=i386
   OperatingSystem=LINUX
   Implementation=HELLO_WORLD.so
   IDFParser=EDMAIDF

   []

9.1.1 Testing the new component
-------------------------------

The first test you must to do is run the GNOME Class Browser and check
the new component is correctly detected and the interface the
application shows is the one you defined.

   Then you can write a simple test program. Refer to Writting GNU/EDMA
application tutorial to do this.


File: edma_tutorial.info,  Node: Wrappers,  Prev: Building Components,  Up: Components

10 Writting a wrapper for our HELLO_WORLD class
***********************************************

At this point writing a wrapper for a GNU/EDMA component should be a
trivial task you simple need to write functions invoking the Met3
primitive. Let's see a minimal example:

   typedef OBJID HELLO_WORLD_OBJ;

   HELLO_WORLD_OBJ NewHelloWorld() {
   	return NewObj("HELLO_WORLD");
   }

   void say (HELLO_WORLD_OBJ id) {
   	Met3 (id,"say");
   }

   void helloYou(HELLO_WORLD_OBJ id,char *name) {
   	SMet3 ("HELLO_WORLD",id,name);
   }

   Now your compiler will take care of type checking and you will write
programs in a safeltier way. It's your choice. Note you can do the same
using any programming language that can be interfaced to GNU/EDMA, for
example using C++:

   class HELLO_WORLD {
   	private:
   		OBJID   id;
   	public:
   		HELLO_WORLD() {id=NewObj("HELLO_WORLD");};
   		void say (void) { Met3 (id,"say");
   		static  void helloYou (char *name) {SMet3("HELLO_WORLD","helloYou",name);}
   }

   That can be used this simple way:

   HELLO_WORLD  *o;

   o=new HELLO_WORLD();ç
   o->say();
   o->helloYou("John");

   This is the way most OO environments woks (COM, XPCOM, CORBA), the
main drawback working this way is at the same time the main advantage,
the intefaces get static so compiler can deal with them, but your
application gets restricted to the interfaces availables at compile
time.

   FIXME: Check how COM deal with future components not available at
compile time... fixes interfaces????

10.1 Final Words
================

In this papers we have showed how to manually build a GNU/EDMA
component. GNU/EDMA is distributed with a tool called GNOME IDF Wizard
that is able to build skeletons for most of the files required to build
a component. Really it creates .IDF and .INES files completelly and for
the implementation files you just need to add the desired parameters
and the code itself.

   In addition to this main objective we have introduced the concept of
run-time interface compiling as a main diference with available OO
environments nowdays.


File: edma_tutorial.info,  Node: GNUEDMA4C,  Next: GNUEDMA4C Introduction,  Prev: Top,  Up: Top

* Menu:

* GNUEDMA4C Introduction::      Introduction to GNU/EDMA for C Developers
* Comments:: Comments for the C/C++ Developer
* ADT:: Abstract Data Types with GNU/EDMA
* Why use EDMA:: Why should you use GNU/EDMA?


File: edma_tutorial.info,  Node: GNUEDMA4C Introduction,  Next: Comments,  Prev: GNUEDMA4C,  Up: GNUEDMA4C

11 GNU/EDMA for C Programmers
*****************************

11.1 Introduction
=================

11.2 Abstract
=============

This tutorial provides a brief description of the GNU/EDMA development
system suitable for C/C++ developers. The paper will provide examples
of the advantages and drawbacks of using GNU/EDMA and will show how to
mix GNU/EDMA in C/C++ developments

11.3 A Simple Library Manager
=============================

GNU/EDMA provides a rich set of features to build software system, but
at the lowest level, the system can be seen as a simple library/module
manager, which allows to load and link modules dynamically on a given
application.

   In next section examples about how to use this facilities are shown
and some comments about this approach are provided at the end of the
text

11.4 How do you deal with Modules in C/C++ Applications?
========================================================

A C/C++ developer will see GNU/EDMA as a simple interface to the dlXXX
family function in a typical UNIX system. Programmers can load shared
libraries using dlopen, link function using dlsym, and unload the
libraries through dlclose.

   A simple example about how to do this follows. The example was
extracted from the dlopen man page.

   #include <stdio.h>
   #include <dlfcn.h>

   int main(int argc, char **argv)
   {
   void   *handle;
   double (*the_func)(double);
   char   *error;

   handle = dlopen ("/library_path/libNAME.so", RTLD_LAZY);
   if (!handle) {
      fputs (dlerror(), stderr);
      exit(1);
   }

   the_function = dlsym(handle, "my_func");
   if ((error = dlerror()) != NULL)  {
      fprintf (stderr, "%s\n", error);
      exit(1);
   }

   printf ("%f\n", (*the_function)(2.0));
   dlclose(handle);
   }

   Figure: Use of dlopen from C/C++

   The above example can be rewrite using GNU/EDMA. The result is shown
bellow

   #include <stdio.h>
   #include <edma.h>

   int
   main (int argc, char *argv[])
   {
   EDMAInit();
   printf ("%f\n", (double) edma_smet3s ("LIB_NAME", "my_func", "R64rR64", 2.0));
   EDMAEnd();
   }
   Figure: Equivalent dlopen example using GNU/EDMA

   As you can imagine, this example just runs a static method defined
in the class/component/library 'LIB_NAME'. Basically a static method is
the same that a function in the OOP jargon.

   In order to execute a static method the 'edma_smet3s' primitive must
be used. This primitive receives as first parameter the name of the
module that contains the static method, followed by, the name of the
method you want to invoke, its signature and finally the required
parameters.

   The signature is a string which define the types of the parameters
and the return value of a given function. In the above example, "R64"
represents a real value of 64bits (that, is, a double), and the "r"
modifier, means that what follows is the function return type.

   Signatures are used to provide support for parametric polimorphism
when OO features are used, to help on data serialization (for
persistence and distributed computing) and for building type-safe
wrappers for the GNU/EDMA modules.

   Obviously, the use of edma_smet3 is less efficient that the function
call in our previous C/C++ example. Developers can choose to use this
primitive of directly work in the same way than in the first example by
using the lower-level GNU/EDMA API.

   Bellow you can see our example rewritten using the GNU/EDMA
low-level API

   #include <stdio.h>
   #include <edma.h>

   int
   main (int argc, char *argv[])
   {
   double  (*the_function) (CLASSID, double);
   CLASSIS cid;

   EDMAInit ();
   if ((cid = edma_get_classid ("LIB_NAME")) == -1)
      {
        EDMAEnd();
        return -1;
      }

   the_function = edma_get_mets_func (cid, "my_func", "R64rR64");

   if (the_function == 0)
     {
       fputs ("Can't resolve static method 'my_func'", stderr);
       EDMAEnd();
       exit (1);
     }

   printf ("%f\n", the_function (cid, 2.0));

   EDMAEnd();
   }
   Figure: Using GNU/EDMA low-level API

   This example uses the 'edma_get_mets_func' function which returns
the function pointer to the specified method within the module
indicated as first parameter. GNU/EDMA automatically loads the library
LIB_NAME, if it is not already in memory, and resolves the symbol.

   This is the lowest level API provided by GNU/EDMA. This means that
you are accessing to the functions as they are defined in the module.
This is the reason for the first parameter in the function pointer (the
class identifier parameter is automatically attached when using
'edma_smet3s' primitive, but must be manually provided when working at
this level).

   Static methods in GNU/EDMA receives as first parameter the
identifier of the class/module they belongs to, in order to allow the
method to access their class if required.

   In the example above the  first parameter in the function call can
be set to any value if the method do not require any access to class
information. In those cases the first parameter can be substituted by
anything because it will be never used, however, this practice is not
recommended from the point of view of updating the application in the
future.

   GNU/EDMA provides an intermediate solution, based on the IDF wizard
tool. This tool provides a graphical interface to generate skeletons
for all the required files to build a GNU/EDMA module. Additionally,
this tool can incorporate plug-ins to generate special files.

   One of this plug-ins, named EDMAIDF_C_INTERFACE_BUILDER, generates a
header file with prototype declaration and helper functions that will
allow the compiler to detect type errors in the code. This solution add
safety to the code at cost of some flexibility lost.

   Here is our example again, using the generated wrapper for our
example component

   #include <stdio.h>
   #include <edma.h>

   #include <lib_namespace/lib_name.h>

   int
   main (int argc, char *argv[])
   {
   EDMAInit();

   if ((lib_name_open_class ()) == 0) {
     fputs ("Can't open LIBNAME class", stderr);
     EDMAEnd();
     exit (1);
   }

   printf ("%lf", lib_name_my_func (lib_name_cid, 2.0));
   EDMAEnd();
   }

   And here is the generated wrapper for the libname
(libname_space/lib_name.h), which was included in the code above.

   #ifndef LIB_NAME_WARPPER_H
   #define LIB_NAME_WARPPER_H

   CLASSID lib_name_cid;

   double (*lib_name_my_func) (CLASSID, double);

   void lib_name_open_class ()
   {
   	cid = edma_get_class_id ("LIB_NAME");
   	_lib_name_my_func = edma_get_mets_func (cid, "my_func", "R64sR64");
   	/* Resolve the rest of required applications*/
   	...
   }

   #endif

   The code above is the simplest straightforward way to wrap a
GNU/EDMA class into a C/C++ application. More complex wrappers can be
built as we will show in next sections.


File: edma_tutorial.info,  Node: Comments,  Next: ADT,  Prev: GNUEDMA4C Introduction,  Up: GNUEDMA4C

11.5 Comments for the C/C++ Developer
=====================================

In previous section the lowest-level programming model provided by
GNU/EDMA was described.

   As showed, code becomes shorter and more clear using GNU/EDMA to
manage shared libraries, at the same time, that a generic API to access
modules and a generic process to generate this modules is provided,
without lost of flexibility or efficiency (when lowest level API are
used).

   In addition to this simplicity, the use of GNU/EDMA to manage
modules has some interesting advantages which will be commented in the
following paragraphs.

   In first place, GNU/EDMA provides a subsystem comparable to generic
Java Class Loaders, that is, developers can write its own modules to
get code loaded in memory from different places, as for example, a
central module server. A general network installation system (EDNA EDMA
Deployment Network Architecture) is been developed to provide this
feature by default.

   So, for a development team, each time a new version of a component
is available it will get installed in the class server. When other
members of the team requires the use of the library, they only need to
use it in the way described in previous section. The module will get
local installed the first time it is used in each system.

   Note also, that GNU/EDMA provides a versioning system which allows
developers to work with different versions of each component. By
default, the system always provides the latest version of the required
component, but developers can force the application to use an older
version if they want. All the versions of a given component can live in
a given system without interfering one each other.

   Second, GNU/EDMA allows to write modules using different languages.
At the moment only some partial implementations for Perl, Python, C#
and and the TCC C interpreter are available. When this interfaces get
finished, multilanguage modules will be used in applications in a
transparent way, and substituted at any time for other implementation
in any other language.

   This feature allows developers to write each component in its
preferer programming language or the language best suited for a given
action, and then, they can use those components the same way they use
their C/C++ libraries. Note that in this case, a proxy is required in
order to interface the main applications with the target environment (a
JVM or a Perl interpreter, for example), so when using the low-level
API you get a pointer to those proxy functions.

   What this means is that in this case the system will be less
efficient that an ad-hoc implementation. Developers win in simplicity
and lost flexibility. Anyway, this depends on the target system and you
always can change, in future, your interpreted code for native code
without changing your main application.

   Third, GNU/EDMA provides a set of hot-swapping features which are
being heavily developed. This facilities will allow applications to be
updated at run-time. Of course this feature cannot work directly with
the lowest level API, due to the use of static pointers. In such a
case, programmers must define safe points in the code where updating
will be performed, and obtain again the pointers to the methods they
are using.

   Finally, developers can use OOP in an easy way from a non-OO
programming language as for example C, but this topic is not covered
here.


File: edma_tutorial.info,  Node: ADT,  Next: Why use EDMA,  Prev: Comments,  Up: GNUEDMA4C

11.6 GNU/EDMA and ADT
=====================

In previous section we show how to use GNU/EDMA as a basic module
manager. No big differences with using any library in the system, nut
GNU/EDMA can be used as a general Abstract Data Type system.

   To work this way, developer just need to add properties and methods
to its modules. Such a module is defined with an Interface Definition
File (IDF) which will look like this.

   [General]
   Name=HELLO_WORLD
   [SYS_DEF]
   ModuleName=libHELLO_WORLD.so
   NameSpace=examples
   [Definition]
   PropertiesNum=2
   MethodsNum=1
   [Prop0]
   Name=num
   Type=EUINT32
   Access=READ/WRITE
   ArrayElems=
   [Prop1]
   Name=str
   Type=EZSTRING
   Access=READ/WRITE
   ArrayElems=
   [Met0]
   Name=say
   Signature=
   Virtual=0
   []

   The IDF shown above, defines a new module named "HELLO_WORLD". Each
instance of this module has two properties (or two variables if you
prefer). First one is named 'num' and is of type 'EUint32' (unsigned
integer 32 bits long), and the second one is named 'str' and is of type
'EZSTRING' (zero terminated string).

   Additionally the module defines a method named 'say' which has no
parameter and do not return any value (empty signature).

   This IDL allows you to write a piece of code like this:

   main ()
   {
      OBJID   hello;
      EUint32 val;

      EDMAInit();

      hello = edma_new_obj ("HELLO_WORLD");

      edma_set_prop_sint32 (hello, "num", 100);
      edma_set_prop_strz (hello, "str", "John");

      val = edma_get_prop_sint32 (hello, "num");

      /* Or using the type-unsafe primitives */

      edma_wprop3 (hello, "num", 100);
      edma_wprop3 (hello, "str", "John");

      edma_rprop3 (hello, "stre", &val);

      EDMAEnd();
   }

   That is, the system is in charge to allocate memory to place the
properties defined by the developer in the IDF file for each instance
of the component 'HELLO_WORLD', and automatically provides basic
assessor method to write/read these properties. Of course you can
provide your own special assessor methods, but the simpler case is
automatically covered by the system.

   Using plain C we must write something like this.

   hello.h:
   #ifndef HELLO_H
   #define HELLO_H

   #ifndef HELLO_C
   typedef void *HELLO_INSTANCE;
   #endif

   HELLO_INSTANCE hello_new ();
   int            hello_free (HELLO_INSTANCE);
   void           hello_set_num (HELLO_INSTANCE obj, unsigned int value);
   unsigned int   hello_get_num (HELLO_INSTANCE obj);

   void           hello_set_str (HELLO_INSTANCE obj, char *);
   char *         hello_get_str (HELLO_INSTANCE obj);

   #endif

   hello.c:
   #define HELLO_C
   #include "hello.h"

   typedef struct hello_instace_t
   {
   	unsigned int num;
   	char         *str;
   } *HELLO_INSTANCE;

   HELLO_INSTANCE
   hello_new ()
   {
     HELLO_INSTANCE aux;

     if ((aux = (HELLO_INSTANCE) malloc (sizeof (struct hello_instance_t))) == NULL)
        {
   	fprintf (stderr, "Can't alloc memory");
   	return NULL;
        }
     memset (aux, 0, sizeof (struct hello_instance_t));
     return aux;
   }

   void
   hello_free (HELLO_INSTANCE obj)
   {
     free (obj);
   }

   void
   hello_set_num (HELLO_INSTANCE obj, unsigned long value)
   {
     obj->num = value;
   }
   /* Rest of accesor follows */
   .....

   Writing the code showed above is a mechanical task, easy but
tedious. When using GNU/EDMA you get all that code automatically, you
just need to write the behavior of your ADT.

   There is an additional advantage of using GNU/EDMA instead of write
your ADT directly. If you changes your ADT in a way do not affecting
its interface, you don't need to re link the whole application. Of
course, you can make a shared library with your ADT and write a piece
of code as the one shown in first section of this doc, but you will
finish writing something like GNU/EDMA.

   If C++ is used the developer needs to write less code, but the
solution also lacks recompiling artifacts. Sometimes it is not a
problem other times it is a not desired feature. Note that you can use
GNU/EDMA with C++, so you can write part of your application in the
classical way, and move the updateable parts to GNU/EDMA components.

   Other choice is use glib based solutions (GObject + GModule). You
get a similar functionality to the one describe up to here, but you
cannot enjoy the rest of facilities GNU/EDMA provides.

   More complex solutions exists XPCOM/UNO, Bonobo, CORBA, etc... But
they are full object-oriented component-based system that are beyond
the scope of this tutorial. They are covered in the "GNU/EDMA for the
Component Developer".


File: edma_tutorial.info,  Node: Why use EDMA,  Prev: ADT,  Up: GNUEDMA4C

11.7 Why should you use GNU/EDMA?
=================================

This is a key question when a new system appears and, in this case, the
answer is: Why not? there is no penalty on using it.

   GNU/EDMA is a wide open system which doesn't impose special
requirements to your applications. You can substitute some feature in
your application to use GNU/EDMA, and let the other unchanged without
further complexity, but, anyway, What do you win using GNU/EDMA?

   When compared to dlXXX family functions you get:

   - A more simple interface to access the code in the shared library -
A portable way to deal with modules in your applications - An uniform
way to write modules for your application in a neutral programming
language way - A versioning system for the modules your application uses
- A simple way to dynamically update your modules without
loading/unloading/remapping the new library version - A generic
mechanism for loading code, (Class loaders ala Java)

   When compared with other component system, for simple stand-alone
applications (other applications fall out the scope of this tutorial)
you get:

   - A very simple interface. No big-slope learning curves, no complex
APIs and interfaces to learn.    Complex API's are required for complex
applications, but the bad thing is that you must use such   complex
API's even when your application is simple.  - A very lightweight
system, just a shared library and no special infrastructure required.
No never used features bloating your application - An open door to
integrate your system with any other.

   Additionally

   - You can use GNU/EDMA in a way that you do not lose performance at
all - You get default ADT common code automatically for your C/C++
applications - You get a mostly automagic plug-in system for your
application

   So, you can or you cannot use GNU/EDMA but using it has no drawback
and a lot of advantages. Now, you can read the rest of tutorials on the
"Getting Started with GNU/EDMA" series to learn more about the
advantages of using this system.


File: edma_tutorial.info,  Node: AOP,  Next: AOP Introduction,  Prev: Top,  Up: Top

* Menu:

* AOP Introduction:: Introduction to AOP with GNU/EDMA
* SIU Proxies:: SIU Proxies for AOP
* Static AOP:: Using prederfined SIU Proxies
* Dynamic AOP:: Run-Time proxy attachment


File: edma_tutorial.info,  Node: AOP Introduction,  Next: SIU Proxies,  Prev: AOP,  Up: AOP

12 Aspect Oriented programming with GNU/EDMA
********************************************

12.1 Introduction
=================

This tutorial will introduce aspect oriented programming with the
GNU/EDMA system

   GNU/EDMA does not provides an AOP framework as we are used to see on
other platforms, where an Aspect language must be used. Maybe an aspect
language will be defined in the future but for now, GNU/EDMA provides a
low level interface which allows to achieve AOP features in a simple
way.

   Strictly speaking, what GNU/EDMA provides is a general
method/property interceptor solutions which allows to inject code
around main object interaction primitives.


File: edma_tutorial.info,  Node: SIU Proxies,  Next: Static AOP,  Prev: AOP Introduction,  Up: AOP

12.2 SIU Proxies as Method Interceptors
=======================================

Method interception is performed using SIU proxies. Even when SIU
proxies where designed to allow easy extension of the GNU/EDMA core to
interface similar systems, those proxies can be used as general method
interceptors and so, they can be used to inject code after and before
any GNU/EDMA object interaction primitive.

   From this point of view, Aspects become SIU proxies within the
GNU/EDMA environment and after and before code blocks are seen in a
very simple way. Examples in next section will show this.


File: edma_tutorial.info,  Node: Static AOP,  Next: Dynamic AOP,  Prev: SIU Proxies,  Up: AOP

12.3 Static AOP. Predefined SIU Proxies
=======================================

SIU proxies can be assigned to existing objects in several ways:

   1. Permanently, when the SIU proxy is specified in the GNU/EDMA
class registry 2. Creation-time, when the SIU proxy is attached to a
given object when it is created 3. Dynamically, when the SIU proxy is
attached or deattached from an existing class/component instance.

   The last case is described in next section.

   In the directory 'tests/aop' you can find to complete code of the
examples described in this text.

   To illustrate the use of static AOP lets see the general example of
method call logging, common on AOP literature. For that, a SIU proxy
named LOG_PROXY is defined and its 'Met3' method is coded as indicated
bellow:

   ESint32 EDMAPROC
   run_method (OBJID id, CLASSID cid, EPChar met_name, EPVoid val)
   {
     OBJID   obj;

       edma_rprop3 (id, "obj", &obj);
       edma_printf ("[LOGGING] Runnoing method %s on object %d", met_name, obj);
       return edma_met3_pargs (obj, met_name, NULL, 1, val);
   }

   The Met3 method of a SIU proxy is executed whenever a method is
invoked on the object the SIU proxy represents. As can be seen in the
code above the method first recovers the object identifier the proxy is
representing and just prints a message with the information of the
method being executed. Then the real method is executed as usual.

   The example above is a simple example of after joint point for the
LOG_PROXY aspect (in AOP jargon).

   In order to attach this aspect to a running object, it must be
included in the GNU/EDMA registry or it can be specified when the
object to be monitirized is created:

   OBJID  id = edma_new_obj ("LOG_PROXY:HELLO_WORLD");

   The line above indicates that the LOG_PROXY proxy will be attached
to a HELLO_WORLD object. Hereinafter, any interaction with the
HELLO_WORLD instance will go through our LOG_PROXY and so, any method
invocation will be logged to the standard output.


File: edma_tutorial.info,  Node: Dynamic AOP,  Prev: Static AOP,  Up: AOP

12.4 Dynamic AOP. Run-time proxy attaching
==========================================

Additionally, SIU Proxies (or aspects) can be attached or deattached to
any running object. Two primitives are provided by the system for this.
The sniplet below shows how to use them.

   OBJID    id = edma_new_obj ("HELLO_WORLD");

   edma_met3 (id, "say"); /* Normal Execution */

   edma_attach_proxy (id, "LOG_PROXY");
   edma_met3 (id, "say"); /* Logged executuon */

   edma_deattach_proxy (id);
   edma_met3 (id, "say"); /* Normal executuon */

   As can be seen it is very easy to attach and deattach SIU proxies
(or aspects) to running instances.

12.5 Final Words
================

Even when GNU/EDMA does not provides a classical AOP/DAOP as found in
other systems, the use of SIU proxies as general primitive interceptors
provides the basic cross-cutting and separation of concerns philosophy
behind AOP and so this ideas can be used freely in your applications
without requiring external solutions. Additionally, GNU/EDMA unifies
AOP and DAOP below an unique phylosophy making more easy and coherent
the use of this concepts within the general GNU/EDMA programming model


File: edma_tutorial.info,  Node: Concept Index,  Next: Function Index,  Prev: Top,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* Accessing Properties:                  Hello World.         (line 102)
* An Extensible Application:             Example.             (line  11)
* Creating GNU/EDMA components:          Hello World.         (line  47)
* Dealing with Buffers:                  Properties.          (line  35)
* Dealing with Buffers example:          Properties.          (line  48)
* Destroying GNU/EDMA components:        Hello World.         (line  55)
* edma_rprop3:                           Hello World.         (line 102)
* Hello World Example:                   Hello World.         (line  10)
* Hello World examples with Properties:  Properties.          (line   9)
* IDL:                                   Hello World.         (line  59)
* Invoking Class Methods:                Hello World.         (line  97)
* Makefile for GNU/EDMA Applications:    Building.            (line   8)


File: edma_tutorial.info,  Node: Function Index,  Prev: Concept Index,  Up: Top

Function Index
**************

 [index ]
* Menu:

* edma_buffer_alloc:                     Properties.          (line  74)
* edma_buffer_free:                      Properties.          (line  74)
* edma_free_obj:                         Hello World.         (line  55)
* edma_met3:                             Hello World.         (line  97)
* edma_new_obj:                          Hello World.         (line  47)
* edma_smet3:                            Static Methods.      (line  17)
* edma_wprop3:                           Hello World.         (line 102)
* EDMAEnd:                               Hello World.         (line  40)
* EDMAInit:                              Hello World.         (line  33)
* Static Method Example:                 Static Methods.      (line  17)



Tag Table:
Node: Top157
Node: Overview569
Node: Library manager1209
Node: OOP2018
Node: CBS3626
Node: LOCOOS4116
Node: IDF5508
Node: SIU6269
Node: Features7969
Node: Features Introduction8319
Node: Features Components8824
Node: Features OOP11184
Node: Features Reflection13965
Node: Features Extensibility14650
Node: Features Reuse17388
Node: Features Conclusion19090
Node: Applications19590
Node: Hello World19912
Node: Building24422
Node: Properties24994
Node: Static Methods27608
Node: Example28689
Node: Components31368
Node: Components Introduction32052
Node: Interface33858
Node: Implementation39061
Node: Building Components43075
Node: Wrappers45970
Node: GNUEDMA4C48149
Node: GNUEDMA4C Introduction48466
Node: Comments55403
Node: ADT58938
Node: Why use EDMA63676
Node: AOP65804
Node: AOP Introduction66079
Node: SIU Proxies66844
Node: Static AOP67542
Node: Dynamic AOP69655
Node: Concept Index70905
Node: Function Index71927

End Tag Table
