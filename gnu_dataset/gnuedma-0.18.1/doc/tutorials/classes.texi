@c ----------------------------------------------------------------------------
@c GNU/EDMA Tutorials 
@c Copyright (C) 1998, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
@c          by David Martínez Oliveira
@c
@c      Permission is granted to copy, distribute and/or modify this
@c      document under the terms of the GNU Free Documentation License,
@c      Version 1.3 or any later version published by the Free Software
@c      Foundation; with no Invariant Sections, no Front-Cover Texts and
@c      no Back-Cover Texts.  A copy of the license is included in the
@c      section entitled "GNU Free Documentation License".
@c ----------------------------------------------------------------------------

@menu
* Components Introduction:: General concepts about GNU/EDMA Components
* Interface:: Writting the Interface Definition File
* Implementation:: Writting the Implementation file
* Building Components:: Building and Installing GNU/EDMA components
* Wrappers:: How to write a component wrapper
@end menu

In this tutorial we will describe the process we must follow to build GNU/EDMA components and classes which can be used later in our applications. The whole process will be described first, and then we will introduce some graphical tools that simplify the component built process.

@node Components Introduction, Interface. Implementation. Components
@chapter Introduction

The first thing we must know is that a GNU/EDMA class has two main parts. The first one is the so called Interface Definition File, a text file (really it can be of any form using the appropriated IngrIDF parsers) that defines the class/component interface. The second one is the component implementation, that is the code we will run when using the component.

This is the typical approach in most OO environments (i.e. COM, XPCOM, CORBA even RPC). You write your objects interface in some interface definition language and, using a interface compiler you generate some code stubs required to build your object implementation and to use those objects from your client applications.

In GNU/EDMA this is a bit different. You must write a interface definition file using some interface definition language (one quite simple is provided), but you don't need to use a interface compiler. Actually you can do that and then generate the same code COM or CORBA uses to provide a tight programming language mapping with the object generated.

Working this way has advantages and disadvantages. The main advantage is that the code generated will be used by the compiler for early type checking, finding possible errors in the application. The disadvantage of using the interface compiler is that any change you can do in the object's interface requires to recompile a lot of things. 

Currently there is no interface compiler and the usual way you will build GNU/EDMA applications and components is using the system primitives, that is no interface compiler generated wrapper is used at all. We will do a brief comment about this at the end of the tutorial.

@node Interface, Implementation, Components Introduction, Components
@chapter Writting the interface definition file

The default interface definition language used by GNU/EDMA is quite simple. It just allow to define some general information as well as properties and methods. The structure is like a .ini old windows file format, divided in sections each section containing a set of fields.

Let's define a IDF file for one simple HELLO_WORLD class. It will look like this:

@example
[General]
Name=HELLO_WORLD
[SYS_DEF]
ModuleName=HELLO_WORLD.dll
[Definition]
PropertiesNum=2
MethodsNum=3
[Prop0]
Name=num
Type=EUINT32
Access=READ/WRITE
ArrayElems=
[Prop1]
Name=str
Type=EZSTRING
Access=READ/WRITE
ArrayElems=
[Met0]
Name=born
Signature=
Virtual=0
[Met1]
Name=rip
Signature=
Virtual=0
[Met2]
Name=say
Signature=
Virtual=0
[]
@end example

There are five main section in a EDMAIDF file (that is how they are named). The first one provides general information about the component, typically it just contains the component name.

Next section, SYS_DEF, is reserved to store system dependent information. Typically it just contains the implementation module name, but it isn't really necessary.

Then follow the real component interface which has three main parts. The first one defines the elements we will find in next sections, and the two other defines, respectively, the properties and methods this component has.

The definition section has three main field. The PropertiesNum which indicates how many properties will be defined bellow in the file. The MethodNum which is the same but for the method definition, and finally the SuperClass list that we will not comment in this tutorial. It is described in detail in the GNU/EDMA Inhertiance Tutorial.

@section Property Definition

Each property is defined using four fields. First one is the property name, the string we will use with @code{edma_wprop3} and @code{edma_rprop3} primitives to refer to this property. Next we find the property type, a string that can get its value from this list:

@example
ESint32, ESint16, ESint8	: Signed Integers
EUint32, EUint16, EUint8	: Unsigned Integers
EChar 				: Character or Byte
EByte, EWord, EDWord		: Byte, word and dword
EReal32, EReal64		: float and double
EZString			: Zero terminated string
EBuffer				: EDMAT_BUFFER data
EOBject				: A Generic GNU/EDMA Object
@end example
FIXME: Check if some is missing.

The next field required to define a property is the Access field. This field allows to set access modifiers for the property being defined. The permitted values are: READ, WRITE, READ/WRITE

Finally, we can make some property a fixed array of basic types, setting the ArrayElems field.

@section Method Definition
Method sections are quite similar to property ones, but using some different field. The first field, as in the property case is the method name.

Next field is the method signature. The signature is a character string which codes the parameter and return types for the method being defined. This field can be left blank, but it's recommended to fill in it in order to provide full reflection capabilities to the system. Not doing this will prevent the component being defined not to work properly in some cases.

Next follows the signature strings associated with the basic GNU/EDMA types:

@example
ESint32, ESint16, ESint8  : S32,S16,S8
EUint32, EUint16, EUint8  : U32,U16,U8
EChar                     : C
EByte, EWord, EDWord      : B,W,DW
EReal32, EReal64          : R32,R64
EZString                  : Z
EBuffer                   : A
EOBject                   : O
@end example

To define a parameter as an output parameter, a 's' must be prepend to the signature string (s stands for salida, the Spanish word for output). The method return type is defined is specified prepending a 'r' character to the appropriated type signature.

Let's see some examples of valid signatures:

@example
method (ESint32 a,ESint32 b,ESint32 *c) -> S32S32sS32
ESint32 method (EPChar name)		-> ZrS32
OBJID method(EReal64 a,EReal64 b)	-> R64R64rO
@end example

Finally, we can provide special modifiers for each method being defined, this modifiers are of type boolean being valid values 0 or 1, and all are optional. The available modifiers are:

* Virtual: Defines the method as virtual what means that it can be overridden

* Abstract: An abstract method is a method that don't have associated implementation.

* Static: Defines the method as static what means that it is related to the class not the instances of the class.

@section Constructors and Destructors
GNU/EDMA allows to define constructor and destructor methods for the classes. This methods are the executed when class instances are created or destroyed using @code{edma_new_obj} or @code{edma_free_obj} respectively.

Constructor method must be named @code{born} and destructor method must be named @code{rip}. In the current implementation it isn't possible to provide parameters to this special methods.

@node Implementation, Building Components, Interface, Components
@chapter The implementation file

Now we know how to write our IDF's (Interface Definition Files), we must write the implementation file, the code we want our component to provide. In this tutorial we will just deal with in-process component, that is, components implemented with shared libraries. So, what we need to build is a shared library, but with an special struct.

@section Providing a data struct to access properties
GNU/EDMA allocate the required memory to store the properties defined in the associated IDF automatically when a class/component instance is created, and provides the primitives @code{edma_wprop3} and @code{edma_rprop3} to access them. 

However, the class implementation, normally, will access often to these properties and therefore it must do that in a easy way. For doing that, we will define a C struct to access the properties we have defined in the IDF file and then use the @code{edma_get_data_ref} primitive to map the properties values to that structure.

For our HELLO_WORLD example we should define a struct like this:

@example
typedef struct
  @{
		EUint32		num;
		EPChar		str;
@}DtHELLO_WORLD;
@end example

Using this struct we can call @code{edma_get_data_ref} primitive and then access the properties values through an ordinary pointer instead of the property primitives GNU/EDMA provides. Let's see how this is done:

@example
ESint32 EDMAPROC HELLO_WORLDborn(OBJID IdObj)
@{
DtHELLO_WORLD	*m;

m=(DtHELLO_WORLD*)GetRef3(IdObj);
@}
@end example

The @code{edma_get_data_ref} primitive just provides a pointer to the memory address where GNU/EDMA allocated the memory chunk required to store the properties defined in the IDF file. From this point on we just manipulate properties using the fields in our C struct.

@section Writting the code

Now we just have to write the code for our methods. For doing that we have to define a function for each defined method with a special name. The name follows the next format:

@samp{CLASS_NAME|Method_Name|Signature}

So, for our previous IDF file  we must define this methods

@example
ESint32 EDMAPROC HELLO_WORLDborn(OBJID IdObj)
@{
	return 0;
@}

ESint32 EDMAPROC HELLO_WORLDrip(OBJID IdObj)
@{
	return 0;
@}

ESint32 EDMAPROC HELLO_WORLDsay(OBJID IdObj)
@{
	DtHELLO_WORLD	*m;

	m=(DtHELLO_WORLD*)GetRef3(IdObj);
	printf ("Hello World! %s",m->str);
@}
@end example

Note that the first parameter for each method is always a GNU/EDMA object. It is the equivalent to the this or self hidden parameter used in most of the current OO programming language. 

In this simple example no signature exists for the methods been defined and the constructor and destructor does nothing with properties. The say method will use the properties so we declare a pointer to our previously defined struct and we call @code{edma_get_data_ref} in order to access properties values through this pointer in a efficient way.

At this point we just have to write the code we want our GNU/EDMA component to run when methods are invoked.

@section Static Methods
In the above example no static method was defined in the associated IDF, but we must to comment how to define this static methods because they differ from the showed above.

As we have said, a static method is related to a class not to an object, so, when GNU/EDMA executes the @code{edma_smet3} primitive it doesn't pass as first parameter an OBJID, instead it passes a CLASSID type what is a class identifier. With this information a hello static method implementation for our GNU/EDMA component will look like this:

@example
EVoid EDMAPROC HELLO_WORLDhello(CLASSID cid) @{
	printf ("Hello World!!!\n");
@}
@end example

Or with parameters:

@example
EVoid EDMAPROC HELLO_WORLDhelloYou(CLASSID cid,EPChar name) @{
  printf ("Hello %s!!!\n",name);
@}
@end example

These methods can be used form your applications this way:

@example
SMet3("HELLO_WORLD","hello");
SMet3("HELLO_WORLD","helloYou","John");
@end example

@node Building Components, Wrappers, Implementation, Components 
@chapter Building the dynamic library
To generate the implementation shared library we will use a simple makefile that we show here:

@example
CFLAGS=`edma-config --cflafs-class`
LIBS=`edma-config --libs-class`
HELLO_WORLD.so: temp.o
	$(CC) -shared -Wl,-soname,libHELLO_WORLD.so.1 -o $@ temp.o $(LIBS)
temp.o: HELLO_WORLD_imp.c
	$(CC)  $(CCFLAGS) $< -o $@
@end example

This is just the classical shared library make file.

@section Installing the component
Once we have our interface and implementation files we can install our just built GNU/EDMA component in the system and make it available to every application.

The installation consists on putting the IDF file and the shared library in place and then update the GNU/EDMA registry. In a default instalation the IDF files are stored in /usr/local/share/edma/idf and the shared libraries are saved in /usr/local/lib.

To update the GNU/EDMA registry you have two choices. The first is to manually edit the registry that, by default is located at /usr/local/etc/edma/edma32.cfg. The second is to generate a .ines file and use the class_register tool distributed with the system. Let's see how a .ines file looks like:

@c FIXME: Need to talk about namespaces
@c        and versions

@example
ClassName=HELLO_WORLD
Machine=i386
OperatingSystem=LINUX
Implementation=HELLO_WORLD.so
IDFParser=EDMAIDF
@end example

Basically a .ines file contains the same information you must add manually to the GNU/EDMA registry needed to inform GNU/EDMA about the kind of class it must deal with. In our example we will deal with a simple class, but there are some special classes that should be defined in the system registry.

To add manually a class to the system, you must first increment the value in file nClasses at the beginning of the edma32.cfg file, and then add a section at the end of the file with the fields showed above when we talk about .ines file. The end of edma32.cfg after installing our HELLO_WORLD class will look like this (then numbers in [ClassXXX] will vary depending on how many classes you have installed in your system)

@example
[General]
nClasses=28
[CLASS0]

...

[CLASS26]
ClassName=NFILE1
Machine=i386
OperatingSystem=LINUX
Implementation=libNFILE1.so
IDFParser=EDMAIDF
[CLASS27]
ClassName=HELLO_WORLD
Machine=i386
OperatingSystem=LINUX
Implementation=HELLO_WORLD.so
IDFParser=EDMAIDF
[]
@end example

@subsection Testing the new component
The first test you must to do is run the Graphical Class Browser and check the new component is correctly detected and the interface the application shows is the one you defined.

Then you can write a simple test program. Refer to Writting GNU/EDMA application tutorial to do this.

@node Wrappers, , Building Components , Components
@chapter Writting a wrapper for our HELLO_WORLD class

At this point writing a wrapper for a GNU/EDMA component should be a trivial task you simple need to write functions invoking the @code{edma_met3} primitive. Let's see a minimal example:

@example
typedef OBJID HELLO_WORLD_OBJ;

HELLO_WORLD_OBJ NewHelloWorld() @{
	return edma_new_obj ("HELLO_WORLD");
@}

void say (HELLO_WORLD_OBJ id) @{
	edma_met3 (id,"say");
@}

void helloYou(HELLO_WORLD_OBJ id,char *name) @{
	edma_smet3 ("HELLO_WORLD",id,name);
@}
@end example

Now your compiler will take care of type checking and you will write programs in a safer way. It's your choice. Note you can do the same using any programming language that can be interfaced to GNU/EDMA, for example using C++:

@example
class HELLO_WORLD @{
	private:
		OBJID   id;
	public:
		HELLO_WORLD() @{id=NewObj("HELLO_WORLD");@};
		void say (void) @{ Met3 (id,"say");
		static  void helloYou (char *name) @{SMet3("HELLO_WORLD","helloYou",name);@}
@}
@end example

That can be used this simple way:

@example
HELLO_WORLD  *o;

o=new HELLO_WORLD();ç
o->say();
o->helloYou("John");
@end example

This is the way most OO environments works (COM, XPCOM, CORBA), the main drawback working this way is at the same time the main advantage, the interfaces get static so compiler can deal with them, but your application gets restricted to the interfaces available at compile time.

FIXME: Check how COM deal with future components not available at compile time... fixes interfaces????

@section Final Words
In this papers we have showed how to manually build a GNU/EDMA component. GNU/EDMA is distributed with a tool called GNOME IDF Wizard that is able to build skeletons for most of the files required to build a component. Really it creates .IDF and .INES files completely and for the implementation files you just need to add the desired parameters and the code itself.

In addition to this main objective we have introduced the concept of run-time interface compiling as a main difference with available OO environments nowadays.
