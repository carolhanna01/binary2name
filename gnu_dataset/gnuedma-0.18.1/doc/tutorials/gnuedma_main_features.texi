@c ----------------------------------------------------------------------------
@c GNU/EDMA Tutorials 
@c Copyright (C) 1998, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
@c          by David Martínez Oliveira
@c
@c      Permission is granted to copy, distribute and/or modify this
@c      document under the terms of the GNU Free Documentation License,
@c      Version 1.3 or any later version published by the Free Software
@c      Foundation; with no Invariant Sections, no Front-Cover Texts and
@c      no Back-Cover Texts.  A copy of the license is included in the
@c      section entitled "GNU Free Documentation License".
@c ----------------------------------------------------------------------------

@menu
* Features Introduction:: GNU/EDMA Features introduction
* Features Components:: Components
* Features OOP:: Object Oriented Programming
* Features Reflection:: Reflection
* Features Extensibility:: Extensibility
* Features Reuse:: Reuse
* Features Conclusion:: Conclusion
@end menu

@node Features Introduction, Features Components, , Features
@section INTRODUCTION

In this short tutorial I will try to describe the main features provided by GNU/EDMA, and how them relate to other available systems nowadays.

There are five key points in GNU/EDMA which we will discuss in this text: component-based architecture, object oriented programming, reflection, extensibility and reuse. 

@node Features Components, Features OOP, Features Introduction, Features
@section COMPONENTS

GNU/EDMA is mainly a component system. You can think... "oh, my god!.. just another guy reinventing the wheel!". Well, that is true now, but this project began at the end of 1996 when no such a system existed for GNU/Linux... but that is another history.

Today you can choose among a lot of components models. You have the Bonobo model developed by the GNOME team, the Universal Component Model from the Qt people, and the XPCOM brought to us by the Mozilla community to name a few.

The main and biggest difference among all these technologies and GNU/EDMA is that they are mostly based on the Microsoft COM model and the technologies built on top of it. So, XPCOM and UCM are basically COM, and Bonoboo can be seen as a higher level model closest to ActiveX or JavaBean with a strong orientation towards GUI applications.

First of all, all the COM based systems rely on an interface based model and a manual delegation model centered on the objects. GNU/EDMA relies on classes like most programming language and object delegation is completely transparent to the programmer.

In GNU/EDMA you just use the method or access the property you need without queries if an interface is there or not... of course you can write your program this way, but "that is not the unique way to" write your applications.

GNU/EDMA uses an approach similar to CORBA to define its classes/components. Each class in GNU/EDMA is composed of an interface definition file (IDF) and an implementation file (typically a shared library). The difference with CORBA is that components interfaces are compiled at run-time. You can see it like using CORBA DII all the time with less overhead, and, in general, a more simple interface. 

GNU/EDMA provides a very simple interface, no per-object-type factories, no interface query, no dependencies at source code level. As we said above, you can work this way if you want, but you can also obviate all these topics if you just want to write an application that do not requires that many features.

Later in this tutorial we will get into those topics.

@node Features OOP, Features Reflection, Features Components, Features
@section Object Oriented Programming

GNU/EDMA provides object oriented facilities within the component based environment we have just described. These facilities are integrated in a loosely coupled way allowing to write true object oriented applications using a language like C.

Additionally GNU/EDMA provides all the classical OOP concepts in a fully dynamical context. This means that you can use inheritance, override virtual methods, work with multimethods, etc... all at run-time. Hence, you can add new superclasses to your objects while your application is running, or override virtual methods changing objects behavior with time.

You can't do this with any other system without using tricky and obscure techniques. In addition to these dynamic features, all the OOP concepts mix in a seamless way with the component based infrastructures. So, components are classes and, for example, new components can be created by inheritance from existing ones, even if you don't have the source code from them, improving this way the reuse of components.

From a more technical point of view about OOP, GNU/EDMA allows programmers to choose their preferred flavors when building its applications. This way, programmer can choose among the well known superclass approach present in the most commonly used programming languages today (Java, C++, etc...), the INNER way ala Beta/gBeta or even the prototype based solutions provided by languages like Self.

The OOP features of GNU/EDMA are mostly oriented to improve the code reuse facilitating the mix-in of existing components, classes or objects in a very easy way.

We must keep in mind that GNU/EDMA is not a programming language. It is just a library that provides OOP features to applications. This fact has two consequences. First one is that you can use OOP with non OOP programming languages (like C), and in the second one your OO design gets independent of the underlying programming language syntax.

Of course, a native C++ program will be more efficient that its GNU/EDMA counterpart but reusing all your C++ code could become a hard task if you have to change your programming language, or even mix various programming languages in one application.

Finally, as pointed out above, GNU/EDMA is enough flexible to provide various programming models. You can use, in some part of your program the Self way ("Parents are shared parts") in other the mostly complete Beta's INNER way, or the classical top-down class hierarchy of C++/Java/Smalltalk/Effiel, all of them at the same time, choosing the best fit solution in each part of your application.

@node Features Reflection, Features Extensibility, Features OOP, Features
@section Reflection

GNU/EDMA provides a quite complete reflection API that allows developers to virtually retrieve any information about each component in the system.

Reflection API in GNU/EDMA is two manifold. In one hand, it is a required feature due to the dynamic nature of this system, in the sense that, if we want to exploit dynamically added features in our applications we need to know what they are in some way..

In the other hand, the GNU/EDMA reflection API is a key feature to build specific development tools for this system.

@node Features Extensibility, Features Reuse, Features Reflection, Features
@section Extensibility

From the beginning, GNU/EDMA was conceived as an evolving system, in the sense that is could embrace current and new technologies appearing in the future, and that new features could be added to the main core in the easiest possible way.

This has been somehow achieved as recent programming models like AOP or COP fits well into the current architecture.

Extensibility in GNU/EDMA is achieved through three main subsystems embedded in its core.

First one is named IngrIDF and it is a set of primitives to process classes/components interfaces. IngrIDF, allows to write your own IDF (Interface Definition Files) parsers and it should also allow to write parsers for processing other systems interfaces, as for example, CORBA IDL files, or even Java bytecodes (we did that in an early version of GNU/EDMA and Java :).

Second one is named SIU and it is a generic proxy system that allows developers to customize the basic GNU/EDMA primitives, in order to interface GNU/EDMA with other systems and to provide further features not envisioned at the first time. For example, the Python interface (under development) uses SIU Proxies to forward GNU/EDMA applications calls to the Python interpreted. 

The SIU sub-system can also be seen as a generic method interceptor and it plays a key role in dynamically updating and evolving applications.

Finally, the EMI subsystem provides an interface to allow developers deal with internal problems in the core system. At the moment this is the less mature of all this subsystem and it just allow to process the CLASS_NOT_FOUND exception, that is, we can write code to try to find a required class (for example through the net) if it is not found in the default repositories.

All these three subsystems are built on top of the GNU/EDMA platform. Any IngrIDF parser, SIU proxy or EMI handler are just GNU/EDMA classes implementing a given interface.

IngriDF allows you to customize your interface definition files and process them at run-time, that is the equivalent process to compile the interface to build stub and skeletons in systems like CORBA. Doing this in other systems may be quite complex or even impossible without changing its internal behavior.

SIU Proxies trivializes several design patterns, allows easy AOP developments, and provides an uniform way to interface other system to GNU/EDMA. At the same time it provides a simple way to extend your GNU/EDMA primitives and to apply them individually to specific objects.

The function of EMI handlers its more common in nowadays system. For example, you can get a quite similar behavior with Java Class Loaders or external services provided by other component systems (the CORBA interface repository, for example).

@node Features Reuse, Features Conclusion, Features Extensibility, Features
@section Reuse

Reuse is one of the objectives we are trying to achieve with GNU/EDMA and it is one of the main reasons to create this system.

GNU/EDMA's component based model and object orientation directly promotes code reuse but you can achieve higher reuse levels.

GNU/EDMA is written in C programming language, and datatype and operating system adaptation features are built-in in the system. This means that you can reuse most of your code even between platforms with little or no modification at all. In the other hand, using C programming language allows developers to interface GNU/EDMA with virtually any other system and, this way, reuse any piece of code available.

The classes/components you write can be registered in a whole system way, what makes them available to all the applications in the system. From this point of view, GNU/EDMA is like a OO library management system.

An important difference between GNU/EDMA and other systems is that GNU/EDMA extends object orientation to the components, allowing this way build new components that inherits from existing one without writing complex delegation code to mix the components. Similar features can be found in the MS .Net platform.

Finally, GNU/EDMA applications and components can be built without any dependency at the source code level, that is, you do not need any special include file for doing that. The main drawback of this approach is that compiler cannot detect some error at compile-time and you must do extra checking at run-time. Note that this is only necessary if you want a fully dynamic, loosely coupled application.

@node Features Conclusion, , Features Reuse, Features
@section CONCLUSIONS

GNU/EDMA is just another try to reinvent the whell but with some improvements that can make more easy build and tune your applications.

Most of the functions commonly provided by similar systems can be achieved in a more easy and comprehensive way, and with less system requirements.

At the same time, it is a framework for general software engineering research 
