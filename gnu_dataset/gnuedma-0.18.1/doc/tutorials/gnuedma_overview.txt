GNU/EDMA Overview
-----------------

This text is a short overview to the main GNU/EDMA features, the one already included and the ones that will be included in the future. The objective is to provide to the reader a general overview of the GNU/EDMA architecture and its possibilities.

NOTE: THis is a mostly incomplete document

1. GNU/EDMA as a shared library manager
---------------------------------------
The simplest way to look at GNU/EDMA is like a "shared library manager". If you don't worry about object oriented programming or component based system, you can use GNU/EDMA as a simple library manager.

Basically you get the same functionality dlXXX function (dlopen, dlsym,...). See gnuedma4c_developers.txt for more information about working this way.

Next is a quick reference on this use of GNU/EDMA

- Run a function in a module. The module gets automatically loaded
  The module/class must define static methods (smet3 stands for Static METhod level 3)

  edma_smet3 ("MY_MODULE", "my_function", par1, par2,...);

2. GNU/EDMA. OO programming in C
--------------------------------
The second way you can use GNU/EDMA is like a framework to build object oriented applications using C language. This way, each GNU/EDMA component/class (each library) can be managed like a class with all the features commonly found in common OO programming languages (inheritance, polimorphyms,...)

Note that GNU/EDMA isn't a programming language, so some common features can't be implemented. For example, operator overload can't be achieved from outside the used programming language.

Working this way you achieve a higher level from the point of view of code reuse. An advantage of using GNU/EDMA instead just a C++ library is you alway can use a GNU/EDMA component in your program without include files or the source code.

See edma_tutorial.info for a general description of how to use GNU/EDMA this way.

Next is a quick reference on this use of GNU/EDMA.

- Object creation. 
  OBJID id = edma_new_obj ("MY_CLASS_NAME);

- Property write
  edma_wprop3 (id, "Property", value);

- Property read
  edma_rprop3 (id, "Property", &value);

- Method Invocation
  edma_met3 (id, "Method", par1, par2,...);
  edma_met3s (id, "Method", "Signature", par1, par2,...);

- Object destruction
  edma_free_obj (id);

- Resolving name clashing conflicts.
  edma_met3 (id, "Method", par1, par2,...);    // Access most concret method
  edma_met3 (id, "SUPERCLASS>Method", par1, par,...); // Access method defined in SUPERCLASS


3. GNU/EDMA as a component based environment
--------------------------------------------
If you use GNU/EDMA for your applications, you always are in a component based environemnt. Each GNU/EDMA class/component can be deployed independently and automatically included in the running system. 

GNU/EDMA provides a powerful reflection API, so you can inspect any GNU/EDMA component and manage it programatically.

4. GNU/EDMA Locoos
------------------
We refer to GNU/EDMA as a Locoos (Loosely Coupled Object Oriented System). What this means is that you can use Object Oriented programming techniques in a component based environment managing components like classes in a seamlessly way. 

What this mean is that, for example, you can build derived classes/components from any class/component in your system without the need of source code or programming langyage dependency.

In adition to this, working in a loosely coupled way allows GNU/EDMA to provide dynamic OO features like dynamic inheritance.

Next is a quick reference on this use of GNU/EDMA

- Add a new superclass to a given object
  edma_add_superclass_obj (id, "SUPERCLASS", "UPLINK", "DOWNLINK");

  Access to new superclass can be:
	 * Direct if no name clashing occurs
	 * edma_met3 (id, "SUPERCLASS>Method", par1, par2,...);
	 * edma_met3 (id, "UPLINK>Method", par1, par2,...);

- Add a new subclass. Automatic overwritting of properties and methods
  edma_add_subclass_obj (id, "SUBCLASS", "DOWNLINK", "UPLINK");

  Acess to new subclass can be:
	* Direct for overwritten properties and methods withour name clashing
	* edma_met3 (id, "SUBCLASS<Method", par1, par2,...);
	* edma_met3 (id, "DOWNLINK<Method", par1, par2,...);

5. Define your our Interface Language
-------------------------------------
As most of currently available component based environments, GNU/EDMA defines its component interface using a Interface Definition Language. 

GNU/EDMA process this IDL dynamically (when the component is required), and allows you to provide your our parser for your our IDL format. 

In adition to the freedom to choose a IDL (remember you must program it), this feature make more easy the integration with other systems. Note that the class/component interface can be stored in any place this way.

This feature is provided through a set of API functions named, genericly IngrIDF subsystem.

6. Integrate other systems
--------------------------
GNU/EDMA provides the so called SIU subsystem that allows you to override the main GNU/EDMA primitives in order to integrate other system in the GNU/EDMA environemnt.

THis way you can interface GNU/EDMA with other programming environments (Java, Perl, Python,...) or with other component frameworks (like XPCOM, or CORBA CCM,...)

The SIU proxy, basically allows us to define the so called SIU Proxies, GNU/EDMA components that provides new code for the GNU/EDMA primitives.

This SIU proxies can be integrated in the system in two ways:

* Blind Proxies: A blind proxy, just connects with an external system without requiring the external component to be registered in the main GNU/EDMA registry
* Non-Blind Proxies: A non-blind proxy, works with external systems but obtains information to access them from the GNU/EDMA registry. This proxies, normally requires a IngrIDF parser that deals with the external system and stores the external component interface in the GNU/EDMA registry.

There are thre levels for this SIU proxies:
* Level 1: Just the basic primitives:
           edma_new_obj, edma_free_obj, edma_wprop3, edma_rprop3, edma_met3
* Level 2: Deals with virtual methods, allowing to override methods across systems
* Level 3: Delas with inheritance, allowing to set inheritance relationships across systems

7. Final Words
--------------
In this text we have try to show the main features available in GNU/EDMA and introduce some systems that, at this moment lacks of documentation (just a bunch of examples are availables)

