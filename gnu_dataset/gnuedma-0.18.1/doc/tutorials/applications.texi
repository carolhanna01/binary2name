@menu
* Hello World:: Our first GNU/EDMA Application
* Building:: How to Build GNU/EDMA Applications
* Properties:: Dealing with properties
* Static Methods:: Static or Class Methods
* Example:: A simple extensible Application
@end menu

@node Hello World, Building, Applications, Applications
@comment node-name, next, previous, up
@chapter Hello World!

We will begin with the basic "Hello World" application which will show us how to compile a GNU/EDMA application and how to begin using GNU/EDMA components. Here is the code:

@cindex Hello World Example
@example
#include <edma.h>

main () @{
	OBJID   id;

	EDMAInit();

	if ((id = edma_new_obj ("HELLO_WORLD")) == -1) @{
	 fprintf (stderr, "Can't create HELLO_WORLD object\n");
	 EDMAEnd ();
	@}
	edma_met3 (id, "hello");
	edma_free_obj (id);
	EDMAEnd();
@}
@end example


As you can imagine, this simple program show a impressive "Hello World!!" message in the console. Let's go in deep with the different parts of the program.

@section Startup and Shutdown

@findex EDMAInit
Like most systems, GNU/EDMA needs to be started up before it can be used. As you can infer from the above code, this is done calling the @code{EDMAInit()} function. 

Any GNU/EDMA application must first call this function to register themselves it in the GNU/EDMA system.

@findex EDMAEnd
The same way, when an application finishes using GNU/EDMA it must call @code{EDMAEnd()}, to instruct GNU/EDMA to clean up all the application related structures created while the program was running. 

@section Creating/Destroying GNU/EDMA components
@findex edma_new_obj
@cindex Creating GNU/EDMA components
Once the system was started up, the application can begin using the services GNU/EDMA provides. The more simple operation we can do is to create an object. This is done calling the @code{edma_new_obj} primitive.

This primitive accepts as first parameter the component/class name we want to instantiate, and returns an instance reference that  will be used to interact with the just created object.

@findex edma_free_obj
@cindex Destroying GNU/EDMA components

If the instance can't be created, for example because the class passed as parameter doesn't exist, @code{edma_new_obj} return a -1 value, and a error message is showed in the console.

@cindex IDL
When calling @code{edma_new_obj}, GNU/EDMA does a lot of things. First it checks if the class definition has already been loaded. Thinking about @acronym{CORBA}, the class definition is equivalent to the @acronym{IDL} file. The main difference here is that GNU/EDMA doesn't requires to precompile @acronym{IDL} files, it does itself when required.

Then, it checks if the implementation for the requested class is loaded and mapped in the application, in order to allow the application to use it. If not, GNU/EDMA locates the associated implementation file and makes it available to the current application.

At this point, the interface and implementation for the requested class or component is ready to be used. All this process is done transparently to the programmer. In this simple introduction we will just deal with in-process components, that is, components that are implemented as shared libraries. More complex mechanisms can be build on GNU/EDMA but that is another history.

@findex edma_new_obj
@findex edma_free_obj
When we are done with our object, we can destroy it calling @code{edma_free_obj} primitive with the object reference we got from previous @code{edma_new_obj} call. This primitive frees all the internal structures associated with the object.

Really, @code{edma_free_obj} undoes all the operation @code{edma_new_obj} did previously, but consistently. So, @code{edma_free_obj} will unload implementation if the object been destroyed was the last object using it, and even it frees the interface information related to the class if it's no longer required by the application. Actually the current implementation never frees interface related information until the @code{EDMAEnd} function is called.

@section Using the objects

Now, we have a @var{HELLO_WORLD} instance and we can ask it to do things. This class just defines only one method which is named @code{hello}, and simply shows the well-known message in the console.

@findex edma_met3
@cindex Invoking Class Methods

There are tree basic operation an application can do with an object. The first one is the one showed in our example; invoke a method. This is done using the @code{edma_met3} primitive, the syntax can be easily inferred from our hello world example.

@findex edma_wprop3
@cindex edma_rprop3
@cindex Accessing Properties
The other two operations allows us to work with properties. Properties are the state of the object, what C++ programmers call member variables. To deal with properties, GNU/EDMA provides two accessor primitives: @code{edma_wprop3} which allows to write a value in  a property, and @code{edma_rprop3} which allows to retrieve a property value. 

We will see how to use them in our next example. For now is enough to know they exist.

@node Building, Properties, Hello World, Applications
@comment node-name, next, previous, up
@chapter How to build GNU/EDMA applications

Let's write a makefile to get our application compiled. Here it is:

@cindex Makefile for GNU/EDMA Applications
@example
CFLAGS=`edma-config --cflags-exe`
LIBS=`edma-config --libs-exe`

hello_test: hello.c
	$(CC) $(CFLAGS) -o $@ $< $(LIBS)
@end example

It is the classical makefile, just run make and execute the resulting application. A impressive @samp{Hello World!} message will be shown in the console.

Let's continue.

@node Properties, Static Methods, Building, Applications
@comment node-name, next, previous, up
@chapter Dealing with properties

Now we will make a small modification to our application in order to illustrate how to work with properties. Here is the new code.

@cindex Hello World examples with Properties
@example
#include <edma.h>

main () @{
	OBJID   id;
	EChar   the_name[80];

	EDMAInit();
	if ((id = edma_new_obj ("HELLO_WORLD")) == -1) @{
	 fprintf (stderr, "Can't create HELLO_WORLD object\n");
	 EDMAEnd();
	@}
	edma_met3 (id, "hello");
	/* New code follows*/
	edma_wprop3 (id, "Name", "John");
	edma_met3 (id, "sayHello");
	edma_rprop3 (id, "Name", the_name);
	/* New code ends*/
	edma_free_obj (id);
	EDMAEnd();
@}
@end example

The use of @code{edma_wprop3} and @code{edma_rprop3} is straightforward as you can see in the above code. The @code{sayHello} method now says @samp{"Hello John"}, this method uses internally the property @var{Name} that we set in this example.

@tindex EDMAT_BUFFER
@cindex Dealing with Buffers

One special property type provided by GNU/EDMA is the so called @code{EDMAT_BUFFER}. This data type is just a memory chunk which stores size information. @code{EDMAT_BUFFER} is the preferrer way to deal with dynamic memory in GNU/EDMA. Let's see how to use this type with a new example.

@section Using EDMAT_BUFFER types
Next example is a simple program that reads a file and shows its first 200 bytes in screen. We suppose we are reading a text file so we don't care about non-printable characters.

@cindex Dealing with Buffers example
@example
#include <stdio.h>
#include <edma.h>

main () @{
	OBJID         id;
	EDMAT_BUFFER	buf;
	ESint32       size;

	EDMAInit ();
	if ((id = edma_new_obj j("NFILE")) == -1) @{
		fprintf (stderr, "Can't create NFILE object\n");
		EDMAEnd ();
		exit (1);
	@}
	edma_buffer_alloc (&buf, 1024);
	
	edma_met3 (id, "Load", "the_sample_file.txt", &buf);
	printf ("%d bytes read\n",buf.Size);
	(EPChar) buf.dat[200] = 0;
	printf ("%s", (EPChar) buf.dat);
	
	edma_buffer_free (&buf);
	edma_free_obj (id);
	EDMAEnd();
@}
@end example

@findex edma_buffer_alloc
@findex edma_buffer_free
The above example shows how to use @code{EDMAT_BUFFER} vars. We can see how to use @code{edma_buffer_alloc} and @code{edma_buffer_free} to alloc and free memory chunks. We can also see how to access information stored in the type: the @code{Size} field tell us the memory chunk size in bytes and the @code{dat} field allow us to access the stored information.

There is also a @code{edma_buffer_realloc} function we didn't need to use in our previous example and that is used the same way as @code{edma_buffer_alloc} working like the @code{realloc} standard C library function.


@node Static Methods, Example, Properties, Applications
@comment node-name, next, previous, up
@chapter Using Static Methods

GNU/EDMA allows to define and use static methods the same way C++ or Java does. The difference between a ordinary method and a static one is that the second doesn't know what object it is related to. It is just related to a class not to an object.

We can extend our previous file example adding an extra method call to the @code{FileExist} static method in class @var{FILESYSTEM}. This class provides a set of static method to get information about filesystem objects. In order to check if the file exists before reading it we can use this code.

@findex edma_smet3
@findex Static Method Example

@example
if ((edma_smet3 ("FILESYSTEM", "FileExist", "the_sample_file.txt")) == -1) 
@{
  fprintf (stderr, "File the_sample_file.txt doesn't exist\n");
  EDMAEnd ();
  exit (1);
@}
@end example

In this case, instead of use @code{edma_met3} primitive we use @code{edma_smet3} primitive. Instead of provide the primitive with an object reference we provide a class/component name. 

@node Example, , Static Methods, Applications
@comment node-name, next, previous, up
@chapter A simple extensible Application

Taking a brief look to all the examples we have showed until now, you should have noticed that GNU/EDMA primitives works on character strings. This simple fact provides a powerful extensibility mechanism. Let's see a simple example:

@cindex An Extensible Application

@example
#include <edma.h>

int main (int argc, char *argv[]) @{
  EChar  viewer[1024];
  EChar  file[1024];
  OBJID  id;

  EDMAInit ();
	
  strcpy (viewer, argv[1]);
  strcpy (file, argv[2]);

  id = edma_new_obj (viewer);
  edma_met3 (id, "view", file);
  edma_free_obj (id);

  EDMAEnd ();
@}
@end example

In this example we have intentionally removed the error checking code to save some space. As we can see, this simple application tries to be a minimum file viewer, when invoked it receives two parameter. The first one is the class the application will use to show us the file, the second one is the file itself.

This is a quite silly example but it show how to build applications that can use classes that doesn't exist at the compile time. You can distribute this simple application and add specific viewers in future. This viewer classes just must provide a view method, that is the only requirement for this application.

Of course this simple effect can be easily achieved with dlXXX family functions, but let's do a little modification to show some advantage on working this way.

@section Adding Interactibility
Now we are going to modify the above example to allow the user to do some basic manipulations on the file been viewed.

@example
#include <edma.h>

int main (int argc, char *argv[]) @{
  EChar  viewer[1024];
  EChar  file[1024];
  EChar  cmd[1024];
  OBJID  id;

  EDMAInit ();
	
  strcpy (viewer, argv[1]);
  strcpy (file, argv[2]);
	
  id = edma_new_obj (viewer);
  while (strcmp (cmd, "quit") != 0) 
  @{
    printf ("# ");
    scanf ("%s", cmd);
    edma_met3 (id, cmd, file);
  @}
  edma_free_obj (id);
	
  EDMAEnd ();
@}
@end example

Quite easy, isn't?. Now you can use any defined method in the viewer class. For example suppose your class has a print method, then you can print your file just writing print at the prompt, or suppose your @var{IMAGE_VIEWER} class has a @code{showPseudoColor} method, you can use it directly.

As said, this is a very simple example that can be solved in a variety of ways without using GNU/EDMA, or even building a simple library to deal with shared libraries. But, GNU/EDMA is there now and it offers a lot more facilities we will comment soon.


@contents
