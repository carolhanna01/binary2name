@c ----------------------------------------------------------------------------
@c GNU/EDMA Tutorials 
@c Copyright (C) 1998, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
@c          by David MartÃ­nez Oliveira
@c
@c      Permission is granted to copy, distribute and/or modify this
@c      document under the terms of the GNU Free Documentation License,
@c      Version 1.3 or any later version published by the Free Software
@c      Foundation; with no Invariant Sections, no Front-Cover Texts and
@c      no Back-Cover Texts.  A copy of the license is included in the
@c      section entitled "GNU Free Documentation License".
@c ----------------------------------------------------------------------------

@menu
* Library manager:: GNU/EDMA as a shared library manager
* OOP:: GNU/EDMA. OO Programmng in C
* CBS:: GNU/EDMA as a component based system
* LOCOOS:: GNU/EDMA LOCOOS
* IDF:: Define your own interface language
* SIU:: Integrate other systems
@end menu

GNU/EDMA Overview

This text is a short overview to the main GNU/EDMA features. The ones already included and the ones that will be included in future. The objective is to provide to the reader a general overview of the GNU/EDMA architecture and its possibilities.

@node Library manager, OOP, Overview, Overview
@section GNU/EDMA as a shared library manager

The simplest way to look at GNU/EDMA is like a "shared library manager". If you don't worry about object oriented programming or component based system, you can use GNU/EDMA as a simple library manager.

Basically you get the same functionality provided by dlXXX function (dlopen, dlsym,...). See ``GNU/EDMA for C developrs'' for more information about working this way.

Next is a quick reference on this use of GNU/EDMA

- Run a function in a module. The module gets automatically loaded.  The module/class must define static methods (smet3 stands for Static METhod level 3)

  edma_smet3 ("MY_MODULE", "my_function", par1, par2,...);

@node OOP, CBS, Library manager, Overview
@section GNU/EDMA. OO programming in C

The second way you can use GNU/EDMA is like a framework to build object oriented applications using the C programming language. This way, each GNU/EDMA component/class (each library) can be managed like a class with all the features commonly found in OO programming languages (inheritance, polymorphism,...)

Note that GNU/EDMA isn't a programming language, so some features can't be implemented. For example, operator overload can't be achieved from outside the used programming language. 

Working this way you achieve a higher level from the point of view of code reuse. An advantage of using GNU/EDMA instead just a C++ library is you alway can use a GNU/EDMA component in your program without include files or the source code.

Next is a quick reference on this use of GNU/EDMA.

- Object creation. 

  OBJID id = edma_new_obj ("MY_CLASS_NAME);

- Property write

  edma_wprop3 (id, "Property", value);

- Property read

  edma_rprop3 (id, "Property", &value);

- Method Invocation

  edma_met3 (id, "Method", par1, par2,...);
  edma_met3s (id, "Method", "Signature", par1, par2,...);

- Object destruction

  edma_free_obj (id);

- Resolving name clashing conflicts.

  edma_met3 (id, "Method", par1, par2,...);    // Access most concret method
  edma_met3 (id, "SUPERCLASS>Method", par1, par,...); // Access method defined in SUPERCLASS

@node CBS, LOCOOS, OOP, Overview
@section GNU/EDMA as a component based system

If you use GNU/EDMA for your applications, you always are in a component based environment. Each GNU/EDMA class/component can be deployed independently and automatically included in the running system. 

GNU/EDMA provides a powerful reflection API, so you can inspect any GNU/EDMA component and manage it programmatically.

@node LOCOOS, IDF, CBS, Overview
@section GNU/EDMA Locoos
Sometimes we refer to GNU/EDMA as a Locoos (Loosely Coupled Object Oriented System). That means that you can use Object Oriented programming techniques in a component based environment managing components like classes in a seamlessly way. 

For example, you can build derived classes/components from any class/component in your system without the need of source code or programming language dependency.

In addition to this, working in a loosely coupled way allows GNU/EDMA to provide dynamic OO features like dynamic inheritance.

Next is a quick reference on this use of GNU/EDMA

- Add a new superclass to a given object

  edma_add_superclass_obj (id, "SUPERCLASS", "UPLINK", "DOWNLINK");

  Access to new superclass can be:

	 * Direct if no name clashing occurs

	 * edma_met3 (id, "SUPERCLASS>Method", par1, par2,...);

	 * edma_met3 (id, "UPLINK>Method", par1, par2,...);

- Add a new subclass. Automatic overwritting of properties and methods

  edma_add_subclass_obj (id, "SUBCLASS", "DOWNLINK", "UPLINK");

  Access to new subclass can be:

	* Direct for overwritten properties and methods withour name clashing

	* edma_met3 (id, "SUBCLASS<Method", par1, par2,...);

	* edma_met3 (id, "DOWNLINK<Method", par1, par2,...);

@node IDF, SIU, LOCOOS, Overview
@section Define your our Interface Language

As most of currently available component based environments, GNU/EDMA defines its component interface using a Interface Definition Language. 

GNU/EDMA process this IDL dynamically (when the component is required), and allows you to provide your our parser for your our IDL format. 

In addition to the freedom to choose a IDL (as far as a IDF parser exists, otherwise  you have to code it), this feature makes more easy the integration with other systems. Note that the class/component interface can be stored in any place this way.

This feature is provided through a set of API functions named, generically IngrIDF subsystem.

@node SIU, , IDF, Overview
@section Integrate other systems

GNU/EDMA provides the so called SIU subsystem that allows you to override the main GNU/EDMA primitives in order to integrate other system in the GNU/EDMA environment.

This way you can interface GNU/EDMA with other programming environments (Java, Perl, Python,...) or with other component frameworks (like XPCOM, or CORBA CCM,...)

The SIU subsystem, basically allows us to define the so called SIU Proxies, GNU/EDMA components that provides new code for the GNU/EDMA primitives.

This SIU proxies can be integrated in the system in two ways:

* Blind Proxies: A blind proxy, just connects with an external system without requiring the external component to be registered in the main GNU/EDMA registry

* Non-Blind Proxies: A non-blind proxy, works with external systems but obtains information to access them from the GNU/EDMA registry. This proxies, normally requires a IngrIDF parser that deals with the external system and stores the external component interface in the GNU/EDMA registry.

There are thre levels for this SIU proxies:

* Level 1: Just the basic primitives:
           edma_new_obj, edma_free_obj, edma_wprop3, edma_rprop3, edma_met3

* Level 2: Deals with virtual methods, allowing to override methods across systems

* Level 3: Delas with inheritance, allowing to set inheritance relationships across systems

