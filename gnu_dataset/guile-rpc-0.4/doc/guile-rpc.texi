\input texinfo  @c -*-texinfo-*-

@c Copyright (C) 2007, 2008, 2009, 2010, 2012, 2014  Free Software Foundation, Inc.
@c
@c Permission is granted to copy, distribute and/or modify this
@c document under the terms of the GNU Free Documentation License,
@c Version 1.1 or any later version published by the Free Software
@c Foundation; with no Invariant Sections, no Front-Cover Texts and
@c no Back-Cover Texts.  A copy of the license is included in the
@c section entitled "GNU Free Documentation License".


@c %**start of header
@setfilename guile-rpc.info
@settitle An ONC RPC Framework for Guile
@footnotestyle end
@setchapternewpage odd
@c %**end of header

@set EDITION 1
@include version.texi

@set YEARS 2007, 2008, 2009, 2010, 2012, 2014

@copying
This file documents GNU Guile-RPC @value{VERSION}.

Copyright @copyright{} @value{YEARS} Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".
@end quotation
@end copying

@dircategory The Algorithmic Language Scheme
@direntry
* Guile-RPC: (guile-rpc).      An ONC RPC Framework for Guile.
@end direntry

@dircategory Network Applications
@direntry
* grpc-rpcinfo: (guile-rpc)Invoking grpc-rpcinfo.
                               Guile-RPC's portmapper client
@end direntry

@titlepage
@title An ONC RPC Framework for Guile
@subtitle for GNU Guile-RPC @value{VERSION}
@author Ludovic Court@`es

@page
@vskip 0pt plus 1filll
Edition @value{EDITION} @*
@c Updated for Guile-RPC @value{VERSION} @*
@value{UPDATED} @*

Copyright @copyright{} @value{YEARS} Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the author.
@end titlepage

@contents

@c *********************************************************************
@node Top, Introduction, (dir), (dir)
@top An ONC RPC Framework for Guile

This document describes GNU Guile-RPC version @value{VERSION}.  It was
last updated in @value{UPDATED-MONTH}.

@menu
* Introduction::                Overview of Guile-RPC
* Obtaining and Installing::    Notes on installation

* Quick Start::                 Writing an RPC client/server in a glimpse
* API Reference::               Everything about Guile-RPC
* Stand-Alone Tools::           Command-line tools

* References::                  Useful documents
* Portability::			Porting Guile-RPC to other Schemes

* GNU Free Documentation License::  The license of this manual

* Concept Index::               Concepts discussed in this document
* Function Index::              Index of Scheme procedures
* Variable Index::              Index of Scheme variables
@end menu


@c *********************************************************************
@node Introduction, Obtaining and Installing, Top, Top
@chapter Introduction

GNU Guile-RPC is a framework for distributed programming under GNU
Guile.  It is a pure Scheme implementation of the ONC RPC standard,
i.e., the ``Open Network Computing'' Remote Procedure Call standard.
ONC RPC is standardized by the Internet Engineering Task Force (IETF) as
RFC 1831.  It is based on the External Data Representation standard
(XDR), known as RFC 4506 (@pxref{References}).

@cindex marshalling
@cindex distributed programming
Remote procedure calls allow programs on different, potentially remote
machines to interact together.  A @dfn{remote procedure call} is the
invocation of the procedure of a program located on a remote host (the
@dfn{RPC server}), as the name implies.  Doing so requires the
procedure arguments on the client-side to be encoded, or
@dfn{marshalled}, i.e., converted to a representation suitable for
transfer over the network.  On the server-side, upon reception of the
RPC, those arguments must be decoded or @dfn{unmarshalled}, i.e.,
converted back to a form that is directly understandable by the server
program---for instance, data using Scheme data types, should the
server program be written in Scheme.  The value returned by the RPC
server must be encoded and decoded similarly.

When using the ONC RPC protocol, the way data items are encoded is
dictated by the XDR standard.  This encoding has the advantage of being
particularly compact, allowing for relatively low bandwidth requirements
and fast implementations, especially compared to more verbose RPC
protocols such as XML-RPC and SOAP.

The XDR encoding is not @dfn{self-describing}, i.e., it is impossible
given an arbitrary XDR encoded sequence to determine the XDR type of the
encoded data.  This is different from
@uref{http://dbus.freedesktop.org/, D-Bus}, for example, which uses a
compact and self-describing encoding.  In practice, this is sufficient
for a wide range of applications.

GNU Guile-RPC provides an easy access to the ONC RPC protocol for the
Guile Scheme programmer.  In particular, it allows standard Scheme
types to be mapped to XDR data types, so that Scheme objects are
easily encoded to or decoded from XDR.

Please send bug reports, comments and patches to the
@email{bug-guile-rpc@@gnu.org, Guile-RPC mailing list}.


@c *********************************************************************
@node Obtaining and Installing, Quick Start, Introduction, Top
@chapter Obtaining and Installing GNU Guile-RPC

The GNU Guile-RPC web page is located at
@uref{http://www.gnu.org/software/guile-rpc/}.  You can obtain copy of
GNU Guile-RPC from @uref{ftp://alpha.gnu.org/gnu/guile-rpc/}.

In order to use GNU Guile-RPC, all that is needed is
@uref{http://www.gnu.org/software/guile/guile.html, GNU Guile 2.0}
or later.


@c *********************************************************************
@node Quick Start, API Reference, Obtaining and Installing, Top
@chapter Quick Start

@cindex interface description language
@cindex IDL
@cindex XDR/RPC language
This section illustrates how ONC RPC clients and servers can be
implemented using Guile-RPC.  ONC RPC defines a language to describe
RPCs and the data types they depend on (@pxref{References, RFC
4506@comma{} Section 6 and RFC 1831@comma{} Section 11}).  This
language, which we refer to as the @dfn{XDR/RPC language} or simply
@dfn{RPC language}, is essentially an @dfn{interface description
language} (IDL).  It resembles the C programming language and borrows
C's type definition constructs and adds the @code{program} and
@code{version} constructs that introduce RPC definitions.

Consider the following RPC definition, written using the XDR/RPC
language:

@example
struct result_t
@{
  int          integer_part;
  unsigned int decimal_part;
@};

program ARITHMETIC_PROGRAM
@{
  version ARITHMETIC_VERSION
  @{
    /* Return the integer part and the 1000th of the
       given double-precision floating point number.  */
    result_t split_number (double) = 1;
  @} = 0;
@} = 80000;
@end example

It defines a simple RPC @dfn{interface} named @code{ARITHMETIC}
which contains only one procedure called @code{split_number ()}.  The
interface itself has a @dfn{program number} that identifies it (here,
80000).  Normally, program numbers below 20000000 (hexadecimal) are
assigned by Sun Microsystems, Inc. and thus should not be used unless
the number has been properly registered (@pxref{References, RFC 1831},
for details).  It also has a @dfn{version number} (here, 0) that is
user-defined and should be increased when the interface changes (e.g.,
when procedures are added, modified, etc.).  Finally, the procedure
@code{split_number ()} has a procedure number (here, 1) that allows it
to be distinguished from other procedures.

People vaguely familiar with the C programming language should have
guessed by now that this simple interface defines a procedure that
takes a double-precision floating-point number and returns a structure
that contains two fields.

Client and server creation are two-step.  Since the first step---data
type definition---is the same for both, that leaves us with a total of
three steps, described below.  Nicely, each of these steps can be
automated using the XDR/RPC language compiler (@pxref{Invoking
grpc-compile, @code{grpc-compile}}).

@menu
* Defining Data Types::         Defining RPC data types
* Creating the Client::         Creating the RPC client
* Creating the Server::         Creating the RPC server
@end menu

More details about the XDR type definition as well as client and
server creation are available in the API reference (@pxref{API
Reference}).


@node Defining Data Types, Creating the Client, Quick Start, Quick Start
@section Defining Data Types

Before actually creating a client or server for this interface, one must
define the types it uses.  The simplest way to define one or several
data types is to pipe their definition in XDR/RPC language through the
compiler (@pxref{Invoking grpc-compile, @command{grpc-compile}}):

@example
$ grpc-compile --xdr --constants < input.x > types.scm
@end example

Given the description from @file{input.x} in RPC language, this command
generates code that provides access to the constants and data types
defined therein.  The resulting Scheme code, @file{types.scm}, can then
be @code{load}ed in other Scheme files (@pxref{Loading,,, guile, The GNU
Guile Reference Manual}).

In addition, code in @file{types.scm} depends on Guile-RPC modules that
it uses at run-time.  Thus, it must first import the relevant modules:

@example
(use-modules (rpc xdr)
             (rpc xdr types))
@end example

Then, the @code{result_t} type is defined (this is the code generated by
the compiler but it can also be written ``by hand''):

@example
(define result-type
  (make-xdr-struct-type (list xdr-integer             ;; `integer_part'
                              xdr-unsigned-integer))) ;; `decimal_part'
@end example

@node Creating the Client, Creating the Server, Defining Data Types, Quick Start
@subsection Creating the Client

Producing a client to invoke @code{split_number ()} is as simple as
this:

@example
(use-modules (rpc rpc))

(define invoke-split-number
  (make-synchronous-rpc-call 80000 0    ;; program and version
                             1          ;; procedure number
                             xdr-double ;; argument type
                             result-type))
@end example

Again, this definition, minus the @code{use-modules} clause, can
alternatively be generated by the compiler from the RPC description in
XDR/RPC language (@pxref{Invoking grpc-compile,
@command{grpc-compile}}):

@example
$ grpc-compile --client < input.x > client.scm
@end example

Once this is done, invoking the procedure is as simple as this:

@example
(invoke-split-number 3.14 #x7777 socket)
@end example

@cindex transaction ID (xid)

The first argument to @code{invoke-split-number} is the argument of
@code{split_number ()}; the second argument is a transaction ID, i.e.,
an arbitrarily chosen number that identifies the remote procedure
call; the third argument should be an output port, typically one
bound to a connection to the RPC server:

@example
(define socket (socket PF_INET SOCK_STREAM 0))
(connect socket AF_INET INADDR_LOOPBACK 6666)
@end example

This example creates an IPv4 connection to the local host on port 6666
(@pxref{Network Sockets and Communication,,, guile, The GNU Guile
Reference Manual}).

On success, @code{invoke-split-number} returns a two-element list
where the first element corresponds to the @code{integer_part} field
of the result and the second element correspond to the
@code{decimal_part} field of the result, both represented as Scheme
exact integers.

@node Creating the Server,  , Creating the Client, Quick Start
@subsection Creating the Server

Creating a TCP server for our RPC interface should be quite easy as
well.  We can re-use our previous type definitions (@pxref{Defining
Data Types}).  Then, all we have to do is to create a definition for
our program.

@example
(use-modules (rpc rpc server))

(define (split-number-handler number)
  ;; Handle a `split-number' request.
  (let* ((int (floor number))
         (dec (floor (* 1000 (- number int)))))
    (list (inexact->exact int)
          (inexact->exact dec))))

(define my-rpc-program
  ;; Define our RPC program.
  (let* ((proc    (make-rpc-procedure 1 xdr-double result-type
                                      split-number-handler))
         (version (make-rpc-program-version 0 (list proc))))
    (make-rpc-program 80000 (list version))))
@end example

Alternatively, using the compiler allows the above definition of
@var{my-rpc-program} to be automatically generated from the XDR/RPC
definition file (@pxref{Invoking grpc-compile, @command{grpc-compile}}):

@example
$ grpc-compile --server < input.x > server.scm
@end example

However, there is a slight difference compared to the above
``hand-written'' approach: @file{server.scm} does not contain the actual
definition of @var{my-rpc-program} since it does not know about your
@code{split-number-handler} procedure.  Instead, given the RPC/XDR
definition given earlier, it contains a
@code{make-ARITHMETIC-PROGRAM-server} procedure; this procedure can be
passed a list associating RPC names to Scheme procedures, and returns
the resulting RPC program object:

@example
(define my-rpc-program
  (make-ARITHMETIC-PROGRAM-server
    `(("ARITHMETIC_VERSION"  ;; specify the target version

        ;; list all supported RPCs for this version
        ("split_number" . ,split-number-handler)))))
@end example

As can be seen, using the compiler-generated server stub, one doesn't
have to deal explicitly with program, version and RPC numbers, which
clarifies the code.


Finally, we can make the server listen for incoming connections and
handle client requests, using @ref{Network Sockets and Communication,
Guile's networking primitives,, guile, The GNU Guile Reference Manual}.

@example
;; Creating a listening TCP socket.
(define server-socket (socket PF_INET SOCK_STREAM 0))

;; Listen for connections on 127.0.0.1, port 6666.
(bind server-socket AF_INET INADDR_LOOPBACK 6666)
(listen server-socket 1024)

;; Go ahead and serve requests.
(run-stream-rpc-server (list (cons server-socket my-rpc-program))
                       1000000 ;; a one-second timeout
                       #f      ;; we don't care about closed connections
                       (lambda () ;; our idle thunk
                         (format #t "one second passed~%")))
@end example

And now we're all set: We have a working TCP client and server for
this wonderful RPC interface!  This would work similarly for other
stream-oriented transports such as Unix-domain sockets: only the
@code{socket} and @code{bind} calls need to be adapted.


@c *********************************************************************
@node API Reference, Stand-Alone Tools, Quick Start, Top
@chapter API Reference

This section first details facilities available to manipulate XDR
types.  It then describes Scheme procedures that should be used to
build ONC RPC clients and servers.

@menu
* Usage Notes::                 Preliminary remarks
* Implementation of XDR::       The external data representation
* Implementation of ONC RPC::   Remote procedure calls
* Standard RPC Programs::       Interfaces to common RPC programs
* Compiler::                    The XDR/RPC language compiler
@end menu

@node Usage Notes, Implementation of XDR, API Reference, API Reference
@section Usage Notes

Guile-RPC makes use of the
@uref{http://srfi.schemers.org/srfi-34/srfi-34.html, SRFI-34 exception
mechanism} along with
@uref{http://srfi.schemers.org/srfi-35/srfi-35.html, SRFI-35 error
conditions} to deal with the various protocol errors@footnote{Guile
1.8 provides an implementation of the former in the @code{(srfi
srfi-34)} module, while the latter is currently provided by the
@uref{http://www.nongnu.org/guile-lib/, @code{guile-lib} package}.}.
Thus, users are expected to use these mechanisms to handle the error
conditions described in the following sections.  Hopefully, in most
cases, error conditions raised by Guile-RPC code provide users
with detailed information about the error.

@node Implementation of XDR, Implementation of ONC RPC, Usage Notes, API Reference
@section Implementation of XDR

This section describes how XDR types are represented in Guile-RPC, as
well as how one can encode Scheme values to XDR and decode XDR binary
data to Scheme values.

@menu
* XDR Type Representations::    Foundations
* XDR Standard Data Types::     The XDR standard types
* XDR Encoding and Decoding::   Encoding to and decoding from XDR
@end menu

@node XDR Type Representations, XDR Standard Data Types, Implementation of XDR, Implementation of XDR
@subsection XDR Type Representations

@cindex XDR type objects

The XDR standard defines various basic data types and allows for the
definition of compound data types (``structs''), fixed-size and
variable-size arrays as well as ``unions''.  Fixed-size arrays and
structs can actually be thought as the same type: Their size if known
in advance and they are encoded as the succession of the data they
contain.  Thus, those types can be summarized as 4 great classes:
``basic'' types, variable-length arrays, structs and unions.

The @code{(rpc xdr)} module provides facilities to create Scheme objects
representing XDR data types and to manipulate them.  These Scheme
objects, described below, are all immutable, i.e., they cannot be
modified after creation.

@deffn {Scheme Procedure} make-xdr-basic-type name size type-pred encoder decoder [vector-encoder [vector-decoder]]
This returns an @code{<xdr-basic-type>} object describing a type whose
encoding fits on @var{size} octets, and which is encoded/decoded using
the @var{encoder} and @var{decoder} procedures.  @var{type-pred}
should be a predicate checking the validity of an input Scheme value
for encoding into this type.

Optionally, @var{vector-encoder} and @var{vector-decoder} can be passed
and should be procedures that efficiently encode/decode sequences of
data items of this type (for instance, the vector decoder could use the
@code{bytevector->int-list} procedure of the @code{(rnrs bytevectors)}
module to speed up decoding).  The vector encoder is invoked as
@code{(@var{vector-encoder} type value bv index)} while the vector
decoder is invoked as @code{(@var{vector-decoder} type count port)}.

Users should normally not need to define new basic types since all the
basic types defined by XDR are already available in @code{(rpc xdr
types)} (@pxref{XDR Standard Data Types}).  Thus, we will not describe
its use further.
@end deffn

@deffn {Scheme Procedure} make-xdr-struct-type base-types
Return a new XDR struct type made of a sequence of XDR data items
whose types are listed in @var{base-types}.

Struct types encode from/decode to Scheme lists whose length is that
of @var{base-types}.
@end deffn

@deffn {Scheme Procedure} make-xdr-vector-type base-type max-element-count
Return an object describing an XDR variable-length array of elements
of types @var{base-type} (again, an XDR type object).  If
@var{max-element-count} is a number, then it describes the maximum
number of items of type @var{base-type} that are allow in actual
arrays of this type.  If @var{base-type} is @code{#f}, then arrays of
this type may contain up to 2^32 - 1 items of type @var{base-type}.

Vector types are encoded from @dfn{arrays}, which includes Scheme
vectors, SRFI-4 vectors or strings (@pxref{Arrays,,, guile,
The GNU Guile Reference Manual}).  By default, vector types decode to
vectors, but any other kind of array can be used: it only
needs to be specified as the @var{vector-decoder} argument of
@code{make-xdr-basic-type} for the corresponding base type.  Of course,
SRFI-4 vectors, for example, may only be used when an XDR integer vector
with a matching integer range is expected.

If @var{max-element-count} is specified and a vector to be encoded
contains more than @var{max-element-count} elements, then an
@code{&xdr-vector-size-exceeded-error} error condition is raised.
Likewise, if XDR data to be decoded describes vectors larger than
@var{max-element-count}, this error condition is raised.
@end deffn

@deffn {Scheme Procedure} make-xdr-union-type discr-type discr/type-alist default-type
Return a new XDR discriminated union type, using @var{discr-type} as the
discriminant type (which must be a 32-bit basic type) and
@var{discr/type-alist} to select the ``arm'' type depending on the
discriminant value.  If no suitable value is found in @var{discr/type-alist}
and @var{default-type} is not @code{#f}, then default type is used as the arm
type.

Union types encode from/decode to Scheme pairs whose @code{car} is the
discriminant's value and whose @code{cdr} is the actual union value.
@end deffn

@deffn {Scheme Procedure} xdr-union-arm-type union discriminant
Return the type that should be used for @var{union}'s arm given
@var{discriminant} (a Scheme value).
@end deffn

@cindex recursive types
@cindex self-referencing types
Sometimes, one may want to define @dfn{recursive types}, i.e., types
that refer to themselves.  This is particularly useful to implement
lists.  For example, in XDR language, a list of integers can be defined
as follows:

@example
struct integer_list_t
@{
  int x;
  integer_list_t *next;
@};
@end example

This notation is a shortcut for the following structure:

@example
struct integer_list_t
@{
  int x;
  union switch (bool opted)
  @{
    case TRUE:
      integer_list_t value;
    case FALSE:
      void;
  @} next;
@};
@end example

The @code{integer_list_t} type references itself.  Defining it using our
API seems impossible at first: one cannot pass a self-reference to
@code{make-xdr-struct-type} (since the object is not yet created!), and
the self-reference cannot be added after the fact since objects returned
by @code{make-xdr-struct-type} are immutable.

The API addresses this problem by allowing @dfn{thunks} (zero-argument
procedures) to be used as types.  Together with Scheme's @code{letrec}
recursive binding construct or a top-level @code{define} (@pxref{Binding
constructs, @code{letrec},, r5rs, Revised@math{^5} Report on the
Algorithmic Language Scheme}), it makes it possible to create such
recursive types:

@example
(letrec ((integer-list
          (make-xdr-struct-type
           (list xdr-integer
                 (make-xdr-union-type xdr-boolean
                                      `((TRUE . ,(lambda ()
                                                   integer-list))
                                        (FALSE . ,xdr-void))
                                      #f)))))
  integer-list)
@end example

The trick here is that using the thunk effectively @emph{defers} the
evaluation of the self-reference@footnote{This idea was inspired by Oleg
Kiselyov's description of @dfn{thunked parent pointers} in SXML, which
may be found at @uref{http://okmij.org/ftp/Scheme/parent-pointers.txt}.}.


It is often useful to know the size in octets it takes to encode a
given value according to an XDR type.  However, as we just saw, the
size of some XDR types (variable-length arrays and unions) cannot be
known in advance: The encoding size depends on the actual value to
encode.  The following procedure allow the computation of the size of
the XDR representation of some value.

@deffn {Scheme Procedure} xdr-type-size type value
Return the size (in octets) of @var{type} when applied to
@var{value}.  @var{type} must be an XDR type object returned by one of
the above procedures, while @var{value} should be a Scheme value
suitable for encoding with @var{type}.
@end deffn

The following section lists the standard XDR data types.


@node XDR Standard Data Types, XDR Encoding and Decoding, XDR Type Representations, Implementation of XDR
@subsection XDR Standard Data Types

All the basic data types defined by XDR are defined in the @code{(rpc
xdr types)} module.

@defvr {Scheme Variable} xdr-integer
@defvrx {Scheme Variable} xdr-unsigned-integer
@defvrx {Scheme Variable} xdr-hyper-integer
@defvrx {Scheme Variable} xdr-unsigned-hyper-integer
XDR's 32-bit and 64-bit signed and unsigned integer types.  This type
decodes to/encodes from Scheme exact numbers.
@end defvr

@defvr {Scheme Variable} xdr-float
@defvrx {Scheme Variable} xdr-double
32-bit and 64-bit IEEE-754 floating point numbers.  This type decodes
to/encodes from Scheme inexact numbers.  Note that XDR also defines a
``quadruple-precision floating point type'' (i.e., 128-bit long) that
is currently not available (FIXME).
@end defvr

@defvr {Scheme Variable} xdr-void
@vindex %void
The ``void'' type that yields zero bits.  Any Scheme value is suitable
as an input when encoding with this type.  When decoding this type,
the @code{%void} value (which may be compared via @code{eq?}) is
returned.
@end defvr

XDR provides support for ``enumerations'', similar to that found in C.
An enumeration type maps symbols to integers and are actually encoded
as 32-bit integers.

@deffn {Scheme Procedure} make-xdr-enumeration name enum-alist
Return an enumeration type that obeys the symbol-integer mapping
provided in @var{enum-alist} which should be a list of symbol-integer
pairs.  The returned type decodes to/encodes from Scheme symbols, as
provided in @var{enum-alist}.  Upon decoding/encoding of an
enumeration, an @code{&xdr-enumeration-error} is raised if an
incorrect value (i.e., one not listed in @var{enum-alist}) is found.
@end deffn

@deffn {Scheme Variable} xdr-boolean
XDR's boolean type which is an enumeration.  It encodes to/decodes
from Scheme symbols @code{TRUE} and @code{FALSE}.
@end deffn

Several fixed-size and variable-size are predefined in the standard.

@deffn {Scheme Procedure} make-xdr-fixed-length-opaque-array size
Return a fixed-length ``opaque'' array of @var{size} octets.  An
opaque array is simply a sequence of octets.

The returned XDR type object is actually an @code{<xdr-struct-type>}
object.  Thus, it encodes from/decodes to Scheme lists of exact
integers.  Conversion to a Scheme string, if needed, is left to the
user.
@end deffn

@deffn {Scheme Procedure} make-xdr-variable-length-opaque-array limit
Return a variable-length opaque array.  As for
@code{make-xdr-vector-type} (@pxref{XDR Type Representations}),
@var{limit} can be either a number specifying the maximum number of
elements that can be held by the created type, or @code{#f} in which
case the variable-length array can hold up to 2^32 - 1 octets.

The returned XDR type object is actually an @code{<xdr-vector-type>}
object.  Thus, it encodes from/decodes to Scheme vectors of exact
integers.
@end deffn

@deffn {Scheme Procedure} make-xdr-string limit
This is a synonym of @code{make-xdr-variable-length-opaque-array}
since XDR's string type actually represents ASCII strings, i.e.,
sequences of octets.
@end deffn

@defvr {Scheme Variable} xdr-variable-length-opaque-array
@defvrx {Scheme Variable} xdr-string
These convenience variables contain the unlimited variable-length
opaque array.
@end defvr


@node XDR Encoding and Decoding,  , XDR Standard Data Types, Implementation of XDR
@subsection XDR Encoding and Decoding

The following primitives are exported by the @code{(rpc xdr)} module.
They implement the encoding of Scheme values to XDR data types, and
the decoding of binary XDR data to Scheme values.  The exact mapping
between XDR data types and Scheme data types has been discussed
earlier.

@deffn {Scheme Procedure} xdr-encode! bv index type value
Encode @var{value} (a suitable Scheme value), using XDR type
@var{type}, into bytevector @var{bv} at @var{index}.  Return the index
where encoding ended.

@var{bv} should be an R6RS bytevector large enough to hold the XDR
representation of value according to @var{type}.  To that end, users
may rely on @code{xdr-type-size} (@pxref{XDR Type Representations}).

Error conditions sub-classing @code{&xdr-error} may be raised during
encoding.  The exact exceptions that may be raised are type-dependent
and have been discussed in the previous sections.
@end deffn

@deffn {Scheme Procedure} xdr-decode type port
Decode from @var{port} (a binary input port) a value of XDR type
@var{type}.  Return the decoded value.

Error conditions sub-classing @code{&xdr-error} may be raised during
encoding.  The exact exceptions that may be raised are type-dependent
and have been discussed in the previous sections.
@end deffn


@node Implementation of ONC RPC, Standard RPC Programs, Implementation of XDR, API Reference
@section Implementation of ONC RPC

This section describes facilities available for the creation of ONC
RPC clients and servers, as well as lower-level details about raw RPC
messages.

@menu
* Building an RPC Client::      Sending RPC requests
* Building an RPC Server::      Processing RPC requests
* ONC RPC Message Types::       Low-level details
* Record Marking Standard::     Standard encoding for ONC RPC over TCP
@end menu

@node Building an RPC Client, Building an RPC Server, Implementation of ONC RPC, Implementation of ONC RPC
@subsection Building an RPC Client

Basic building blocks for the creation of RPC clients are provided by
the @code{(rpc rpc)} module.  The easiest way to build an RPC client
is through @code{make-synchronous-rpc-call}.

@deffn {Scheme Procedure} make-synchronous-rpc-call program version procedure arg-type result-type
Return a procedure that may be applied to a list of arguments,
transaction ID (any unsigned number representable on 32 bits), and I/O
port, to make a synchronous RPC call to the remote procedure numbered
@var{procedure} in @var{program}, version @var{version}.  On success,
the invocation result is eventually returned.  Otherwise, an error
condition is raised.  @var{arg-type} and @var{result-type} should be
XDR type objects (@pxref{XDR Type Representations}).

Error conditions that may be raised include those related to XDR
encoding and decoding (@pxref{XDR Encoding and Decoding}), as well as
RPC-specific error conditions inheriting from @code{&rpc-error} (i.e.,
conditions that pass the @code{rpc-error?} predicate).  These are
detailed in @ref{ONC RPC Message Types,
@code{assert-successful-reply}}.
@end deffn

For an example, see @ref{Creating the Client}.

@cindex batched calls
@cindex one-way calls

It is also possible to create ``one-way'' calls, i.e., RPC calls that do
not expect a reply (i.e., no return value, not even @code{void}).  This
is useful, for instance, to implement batched calls where clients do not
wait for the server to reply (@pxref{References, Section 7.4.1 of RFC
1831}).  Asynchronous calls can be implemented in terms of this, too.

@deffn {Scheme Procedure} make-one-way-rpc-call program version procedure arg-type result-type
Similar to @code{make-synchronous-rpc-call}, except that the returned
procedure does @emph{not} wait for a reply.
@end deffn


@node Building an RPC Server, ONC RPC Message Types, Building an RPC Client, Implementation of ONC RPC
@subsection Building an RPC Server

@cindex event loop

The @code{(rpc rpc server)} module provides helpful facilities for
building an ONC RPC server.  In particular, it provides tools to
decode RPC call messages, as well as an event loop mechanisms that
allows RPC calls to be automatically dispatched to the corresponding
Scheme handlers.

@deffn {Scheme Procedure} procedure-call-information call-msg
Return an @code{<rpc-call>} object that denotes the procedure call
requested in @var{call-msg} (the result of an @code{(xdr-decode
rpc-message port)} operation).  If @var{call-msg} is not an
appropriate RPC call message, an error condition is raised.

The error condition raised may be either
@code{onc-rpc-version-mismatch-error?} or
@code{rpc-invalid-call-message-error?}.

The returned object can be queried using the @code{rpc-call-}
procedures described below.
@end deffn

@deffn {Scheme Procedure} rpc-call-xid call
@cindex transaction ID (xid)
Return the transaction ID (``xid'' for short) of @var{call}.
@end deffn

@deffn {Scheme Procedure} rpc-call-program call
@deffnx {Scheme Procedure} rpc-call-version call
@deffnx {Scheme Procedure} rpc-call-procedure call
Return the program, version or procedure number of @var{call}.
@end deffn

@deffn {Scheme Procedure} rpc-call-credentials call
@deffnx {Scheme Procedure} rpc-call-verifier call
Return the credentials and verifier provided by the client for
@var{call}.  FIXME: As of version @value{VERSION}, this information is
not usable.
@end deffn

The following procedures allow the description of RPC ``programs''.
Such descriptions can then be readily used to produced a full-blown
RPC processing loop.

@deffn {Scheme Procedure} make-rpc-program number versions
Return a new object describing the RPC program identified by @var{number}
and consisting of the versions listed in @var{versions}.
@end deffn

@deffn {Scheme Procedure} make-rpc-program-version number procedures
Return a new object describing the RPC program version identified by
@var{number} and consisting of the procedures listed in
@var{procedures}.
@end deffn

@cindex batched calls
@cindex one-way calls

@deffn {Scheme Procedure} make-rpc-procedure number argument-xdr-type result-xdr-type handler [one-way?]
Return a new object describing a procedure whose number is @var{number},
whose argument type is @var{argument-xdr-type} and whose result type is
@var{result-xdr-type} (@pxref{XDR Type Representations}).  @var{handler}
should be a procedure that will be invoked upon reception of an RPC call
for that procedure.

If synchronous RPC processing is used, i.e., through
@code{serve-one-stream-request}, then @var{handler} is passed the
decoded argument and should return a result type that may be encoded as
@var{result-xdr-type}.  If asynchronous processing is used, i.e.,
through @code{serve-one-stream-request/asynchronous}, then @var{handler}
is passed the decoded argument along with a continuation that must be
invoked to actually return the result.

If @var{one-way?} is passed and is true, then the returned procedure is
marked as ``one-way'' (@pxref{Building an RPC Client,
@code{make-one-way-rpc-call}}).  For one-way procedures,
@code{run-stream-rpc-server} and similar procedures ignores the return
value of @var{handler} and don't send any reply when procedure
@var{number} is invoked.
@end deffn

@vindex @code{SOCK_STREAM}

Once a program, its versions and procedures have been defined, an RPC
server for that program (and possibly others) can be run using the
following procedures.

@deffn {Scheme Procedure} run-stream-rpc-server sockets+rpc-programs timeout close-connection-proc idle-thunk
Run a full-blown connection-oriented (i.e., @code{SOCK_STREAM}, be it
@code{PF_UNIX} or @code{PF_INET}) RPC server for the given listening
sockets and RPC programs.  @var{sockets+rpc-programs} should be a list
of listening socket-RPC program pairs (where ``RPC programs'' are
objects as returned by @code{make-rpc-program}).  @var{timeout} should
be a number of microseconds that the loop should wait for input; when no
input is available, @var{idle-thunk} is invoked, thus at most every
@var{timeout} microseconds.  If @var{close-connection-proc} is a
procedure, it is called when a connection is being closed is passed the
corresponding @code{<stream-connection>} object.
@end deffn

While an RPC server is running over a stream-oriented transport such as
TCP using @code{run-stream-rpc-server}, its procedure handlers can get
information about the current connection and client:

@deffn {Scheme Procedure} current-stream-connection
This procedure returns a @code{<stream-connection>} object describing the
current TCP connection (when within a @code{run-stream-rpc-server}
invocation).  This object can be queried with the procedures described
below.
@end deffn

@deffn {Scheme Procedure} stream-connection? obj
Return @code{#t} if @var{obj} is a @code{<stream-connection>} object.
@end deffn

@deffn {Scheme Procedure} stream-connection-port connection
Return the I/O port (@emph{not} the TCP port) for @var{connection}.
@end deffn

@deffn {Scheme Procedure} stream-connection-peer-address connection
Return the IP address of the peer/client of @var{connection}
(@pxref{Network Socket Address,,, guile, The GNU Guile Reference
Manual}).
@end deffn

@deffn {Scheme Procedure} stream-connection-rpc-program connection
Return the RPC program object corresponding to @var{connection}.
@end deffn

For a complete RPC server example, @ref{Creating the Server}.

@cindex I/O manager

The @code{run-stream-rpc-server} mechanism is limited to servers
managing only RPC connections, and only over stream-oriented
transports.  Should your server need to handle other input sources, a
more geneneral event handling mechanism is available.  This works by
first creating a set of @dfn{I/O managers} and then passing
@code{run-input-event-loop} a list of I/O manager-file descriptor pairs
to actually handle I/O events.

@deffn {Scheme Procedure} make-i/o-manager exception-handler read-handler
Return an I/O manager.  When data is available for reading,
@var{read-handler} will be called and passed a port to read from; when
an exception occurs on a port, @var{exception-handler} is called and
passed the failing port.
@end deffn

@deffn {Scheme Procedure} i/o-manager? obj
Return @code{#t} if @var{obj} is an I/O manager.
@end deffn

@deffn {Scheme Procedure} i/o-manager-exception-handler manager
@deffnx {Scheme Procedure} i/o-manager-read-handler manager
Return, respectively, the exception handler and the read handler of
@var{manager}.
@end deffn

@deffn {Scheme Procedure} run-input-event-loop fd+manager-list timeout idle-thunk
Run an input event loop based on @var{fd+manager-list}, a list of pairs of
input ports (or file descriptors) and I/O managers.  I/O managers are invoked
are invoked and passed the corresponding port when data becomes readable or
when an exception occurs.  I/O manager handlers can:

@itemize
@item return @code{#f}, in which case the port and I/O manager are removed
from the list of watched ports;
@item return a pair containing an input port and I/O manager, in which case
this pair is added to the list of watched ports;
@item return true, in which case the list of watched ports remains unchanged.
@end itemize

When @var{timeout} (a number of microseconds) is reached, @var{idle-thunk} is
invoked.  If timeout is @code{#f}, then an infinite timeout is assumed and
@var{idle-thunk} is never run.  The event loop returns when no watched port
is left.
@end deffn

The event loop provided by @code{run-input-event-loop} should cover a
wide range of applications.  However, it will turn out to be
insufficient in situations where tasks must be executed at specific
times, and where the interval between consecutive executions varies over
the program's lifetime.

Finally, a lower-level mechanism is available to handle a single
incoming RPC:

@deffn {Scheme Procedure} serve-one-stream-request program port
Serve one RPC for @var{program}, reading the RPC from @var{port} (using
the record-marking protocol) and writing the reply to @var{port}.  If
@var{port} is closed or the end-of-file was reached, an
@code{&rpc-connection-lost-error} is raised.
@end deffn

@deffn {Scheme Procedure} serve-one-stream-request/asynchronous program port
Same as @code{serve-one-stream-request} except that the RPC is to be
handled in an asynchronous fashion.

Concretely, the procedure handler passed to @code{make-rpc-procedure} is
called with two arguments instead of one: the first one is the actual
procedure argument, and the second one is a one-argument procedure that
must be invoked to return the procedure's result---in other words,
procedure call processing is decoupled from procedure call return using
@emph{continuation-passing style}.
@end deffn


@node ONC RPC Message Types, Record Marking Standard, Building an RPC Server, Implementation of ONC RPC
@subsection ONC RPC Message Types

@cindex @code{rpc_msg} struct type

The @code{(rpc rpc types)} module provides a representation of the
various XDR types defined in the standard to represent RPC messages
(@pxref{References}).  We only describe the most important ones as
well as procedures from the @code{(rpc rpc)} module that help use it.

@defvr {Scheme Variable} rpc-message
This variable contains a XDR struct type representing all possible RPC
messages---the @code{rpc_msg} struct type defined in RFC 1831.  By
``rpc message'' we mean the header that is transmitted before the
actual procedure argument to describe the procedure call being made.

Roughly, this header contains a transaction ID allowing clients to
match call/reply pairs, plus information describing either the call or
the reply being made.  Calls essentially contain a program, version
and procedure numbers.  Replies, on the other hand, can be more
complex since they can describe a large class of errors.
@end defvr

@defvr {Scheme Variable} rpc-message-type
This variable is bound to an XDR enumeration.  Its two possible values
are @code{CALL} and @code{REPLY} (both represented in Scheme using
symbols), denoting a procedure call and a reply to a procedure call,
respectively.
@end defvr

@deffn {Scheme Procedure} make-rpc-message xid type args ...
Return an @code{rpc-message} datum.  @var{type} should be either
@code{CALL} or @code{REPLY} (the two values of the
@code{rpc-message-type} enumeration).  The arguments @var{args} are
message-type-specific.  For example, a message denoting a procedure
call to procedure number 5 of version 1 of program 77 can be created
as follows:

@example
(define my-call-msg
  (make-rpc-message #x123 ;; the transaction ID
                    'CALL ;; the message type
                    77 1 5))
@end example

It can then be encoded in the usual way (@pxref{XDR Encoding and
Decoding}):

@example
(let* ((size (xdr-type-size rpc-message my-call-msg))
       (bv   (make-bytevector size)))
  (xdr-encode! bv 0 rpc-message my-call-msg)
  ;;; ...
  )
@end example

Likewise, a reply message denoting a successful RPC call can be
produced as follows:

@example
(make-rpc-message xid 'REPLY 'MSG_ACCEPTED 'SUCCESS)
@end example

It is worth noting that in practice, ``messages'' of type
@var{rpc-message} are followed by additional data representing either
the procedure call arguments (if the message is a @code{CALL} message)
or the procedure return value (if the message is a @code{REPLY}
message).
@end deffn

@deffn {Scheme Procedure} assert-successful-reply rpc-msg xid
@cindex transaction ID (xid)

Return true if @var{rpc-msg} (an RPC message as returned by a previous
@code{(xdr-decode rpc-message port)} call) is a valid reply for the
invocation labeled with transaction ID @var{xid} indicating that it
was accepted.  If @var{xid} is @code{#t}, any reply transaction ID is
accepted and it is returned (provided the rest of the message denotes
an accepted message).  On failure, an appropriate error condition is
raised.

@findex rpc-error?
@findex rpc-call-error?
The error conditions that may be raised obey @code{rpc-error?} and
@code{rpc-call-error?}.  More precisely, error conditions include the
following:

@table @code
@item rpc-program-unavailable-error?
@findex rpc-program-unavailable-error?
If @var{rpc-msg} denotes the fact that the program requested by the
corresponding RPC call is not available.

@item rpc-program-mismatch-error?
@findex rpc-program-mismatch-error?
If the corresponding RPC call requested a program version that is not
available.  The procedures
@code{rpc-program-mismatch-error:low-version} and
@code{rpc-program-mismatch-error:high-version} return, respectively,
the lowest and highest version numbers supported by the remote server.

@item rpc-procedure-unavailable-error?
@findex rpc-procedure-unavailable-error?
If the corresponding RPC call requested a procedure that is not
available.

@item rpc-garbage-arguments-error?
@findex rpc-garbage-arguments-error?
If the remote server failed to decode the procedure arguments.

@item rpc-system-error?
@findex rpc-system-error?
If the remote server failed to allocate enough memory for argument
decoding, for instance.

@end table
@end deffn


@node Record Marking Standard,  , ONC RPC Message Types, Implementation of ONC RPC
@subsection Record Marking Standard

@cindex record-marking protocol

The ONC RPC standard defines a @dfn{record-marking protocol} for
stream-oriented transport layers such as TCP whereby (1) each RPC
message is sent out as a single @dfn{record} and (2) where records may
be split into several @dfn{fragments}.  This allows implementations to
``delimit one message from another in order to detect and possibly
recover from protocol errors'' (@pxref{References, @code{RFC
1831}@comma{} Section 10}).

This protocol is implemented by the @code{(rpc rpc transports)}
module.  It is automatically used by the high-level client and server
facilities, namely @ref{Building an RPC Client,
@code{make-synchronous-rpc-call}} and @ref{Building an RPC Server,
@code{run-stream-rpc-server}}.  The available facilities are described
below.

@deffn {Scheme Procedure} send-rpc-record port bv offset len
Send the RPC message of @var{len} octets encoded at offset
@var{offset} in @var{bv} (a bytevector) to @var{port}.  This procedure
sends the @var{len} octets of the record without fragmenting them.
@end deffn

@deffn {Scheme Procedure} make-rpc-record-sender fragment-len
This procedure is a generalization of @code{send-rpc-record}.

Return a procedure that sends data according to the record marking
standard, chopping its input bytevector into fragments of size
@var{fragment-len} octets.
@end deffn

@deffn {Scheme Procedure} rpc-record-marking-input-port port
Return a binary input port that proxies @var{port} in order to implement
decoding of the record marking standard (RFC 1831, Section 10).
@end deffn


@node Standard RPC Programs, Compiler, Implementation of ONC RPC, API Reference
@section Standard RPC Programs

GNU Guile-RPC provides client-side and/or server-side of some commonly
found ONC RPC program, which are described below.  Currently, this is
limited to the portmapper interface, but other interfaces (e.g.,
``mount'', NFSv2) may follow.

@menu
* The Portmapper Program::      A directory of instances of RPC programs
@end menu

@node The Portmapper Program,  , Standard RPC Programs, Standard RPC Programs
@subsection The Portmapper Program

@cindex portmapper

The @code{(rpc rpc portmap)} module implements the widespread
@dfn{portmapper} RPC program defined in RFC 1833 (@pxref{References, RFC
1833@comma{} Section 3}).  As the name suggests, the portmapper
interface allows servers to be queried for the association between an
RPC service and the port it is listening to.  It also allows clients to
query the list of services registered.

@cindex @code{portmap} daemon
@cindex service discovery

In practice, most machines run a system-wide @code{portmap} daemon on
port 111 (TCP or UDP), and it is this server that is queried for
information about locally hosted RPC programs.  The @code{grpc-rpcinfo}
program is a portmapper client that can be used to query a portmapper
server (@pxref{Invoking grpc-rpcinfo, the @code{grpc-rpcinfo} tool})

Note that registering RPC programs with the portmapper is optional: it
is basically a directory mechanism that allows servers to be located
quite easily, but other existing mechanisms could be used for that
purpose, e.g., decentralized @dfn{service discovery}
(@pxref{Introduction,, service discovery with DNS-SD in Guile-Avahi,
guile-avahi, Using Avahi in Guile Scheme Programs}).

The module exports client-side procedures, as returned by
@code{make-synchronous-rpc-call} (@pxref{Building an RPC Client}), for
the various portmapper procedures.  They are listed below.

@deffn {Scheme Procedure} portmapper-null arg xid port
Invoke the @code{null} RPC over @var{port}, ignoring @var{arg}, and
return @code{%void}.
@end deffn

@deffn {Scheme Procedure} portmapper-set arg xid port
Invoke the @code{set} RPC over @var{port} with argument @var{arg}.  The
invoked server should register the RPC program specified by @var{arg},
where @var{arg} must be an XDR struct (i.e., a Scheme list) containing
these four elements: the RPC program number, its version number, its
protocol and its port.  The protocol number should be one of
@code{IPPROTO_TCP} or @code{IPPROTO_UDP} (@pxref{Network Sockets and
Communication,,, guile, The GNU Guile Reference Manual}).  An XDR
boolean is returned, indicating whether the request successful.
@end deffn

@deffn {Scheme Procedure} portmapper-unset arg xid port
Invoke the @code{unset} RPC over @var{port} with argument @var{arg}.
The invoked server should unregister the RPC program specified by
@var{arg}, where @var{arg} must have the same form as for
@code{portmapper-set}.  Again, an XDR boolean is returned, indicating
whether the request was successful.
@end deffn

@deffn {Scheme Procedure} portmapper-get-port arg xid port
Invoke the @code{get-port} RPC over @var{port} with argument @var{arg},
which must have the same form as previously mentioned (except that its
port number is ignored).  The invoked server returns an unsigned integer
indicating the port of that RPC program.
@end deffn

@deffn {Scheme Procedure} portmapper-dump arg xid port
Invoke the @code{dump} RPC over @var{port}, ignoring @var{arg}.  The
invoked server should return a list of 4-element lists describing the
registered RPC programs.  Those four element list are the same as for
@code{portmapper-set} and @code{portmapper-get}, namely the RPC program
number and version, its protocol and its port.
@end deffn

@deffn {Scheme Procedure} portmapper-call-it arg xid port
Invoke the @var{call-it} procedure over @var{port}.  Quoting RFC 1833,
this procedure ``allows a client to call another remote procedure on the
same machine without knowing the remote procedure's port number''.
Concretely, it makes the portmapper invoke over UDP the procedure of the
program matching the description in @var{arg}, where @var{arg} is an XDR
struct (i.e., a Scheme list) containing an RPC program and version
number, a procedure number, and an opaque array denoting the procedure
arguments (an @code{xdr-variable-length-opaque-array}).

On success, it returns a struct consisting of the port number of the
matching program and an opaque array representing the RPC reply.  On
failure, it does not return.  Therefore, this synchronous call version
may be inappropriate.  We recommend that you do not use it.
@end deffn

The @code{portmap} module also provides convenience functions to
retrieve the symbolic name associated with common RPC program numbers.
The association between program numbers and their name is usually stored
in @file{/etc/rpc} on Unix systems and it can be parsed using the
@code{read-rpc-service-list} procedure.

@deffn {Scheme Procedure} read-rpc-service-list port
Return a list of name-program pairs read from @var{port} (e.g., the
@file{/etc/rpc} file), showing the connection between an RPC program
human-readable name and its program number.
@end deffn

@deffn {Scheme Procedure} lookup-rpc-service-name service-list program
Lookup RPC program numbered @var{program} in @var{service-list} (a list as
returned by @code{read-rpc-service-list}) and return its human-readable
name.
@end deffn

@deffn {Scheme Procedure} lookup-rpc-service-number service-list program
Lookup RPC program named @var{program} in @var{service-list} (a list as
returned by @code{read-rpc-service-list}) and return its RPC program
number.
@end deffn

@node Compiler,  , Standard RPC Programs, API Reference
@section XDR/RPC Language Compiler

This section describes the compiler's @emph{programming interface}.
Most of the time, its command-line interface is all is needed; it is
described in @ref{Invoking grpc-compile, @command{grpc-compile}}.  This
section is intended for users who need more flexibility than is provided
by @command{grpc-compile}.

@cindex compiler back-ends

The compiler consists of a lexer, a parser and two @dfn{compiler
back-ends}.  The lexer separates input data into valid XDR/RPC language
tokens; the parser then validates the input syntax and produces an
abstract syntax tree of the input.  Finally, the back-ends are
responsible for actually ``compiling'' the input into something usable
by the programmer.  The back-end used by the @command{grpc-compile}
command is the @dfn{code generation back-end}.  In addition, an
experimental @dfn{run-time compiler back-end} is available, making it
possible to compile dynamically definitions in the XDR/RPC language
@emph{at run-time}; this technology paves the way for a wide range of
crazy distributed applications, the programmer's imagination being the
only real limitation@footnote{Finding useful applications leveraging the
flexibility offered by the run-time compiler back-end is left as an
exercise to the reader.}.

@menu
* Parser::                      Parser API
* Code Generation Compiler Back-End::  Code generation API
* Run-Time Compiler Back-End::  The incredible run-time compiler
@end menu


@node Parser, Code Generation Compiler Back-End, Compiler, Compiler
@subsection Parser

@cindex parser
@cindex abstract syntax tree

The parser is available under the @code{(rpc compiler parser)} module.
The main procedure, @code{rpc-language->sexp}, reads XDR/RPC language
descriptions and returns the abstract syntax tree (AST) in the form of
an S-expression.  The AST can be shown using the @code{--intermediate}
option of the @code{grpc-compile} command-line tool (@pxref{Invoking
grpc-compile}).  Below is an illustration of the mapping between the
XDR/RPC language and the S-exp representation.

@example
const SIZE = 10;
struct foo
@{
  int x;
  enum @{ NO = 0, YES = 1 @} y;
  float z[SIZE];
@};
@end example

... yields:

@example
(define-constant "SIZE" 10)
(define-type
  "foo"
  (struct
    ("x" "int")
    ("y" (enum ("NO" 0) ("YES" 1)))
    ("z" (fixed-length-array "float" "SIZE"))))
@end example

@deffn {Scheme Procedure} rpc-language->sexp port
Read a specification written in the XDR Language from @var{port} and
return the corresponding sexp-based representation.  This procedure can
raise a @code{&compiler-error} exception (see below).
@end deffn

The behavior of the parser can be controlled using the
@var{*parser-options*} parameter object:

@defvr {Scheme Variable} *parser-options*
This @uref{http://srfi.schemers.org/srfi-39/srfi-39.html, SRFI-39
parameter object} must be a list of symbols or the empty list.  Each
symbol describes an option.  For instance, @code{allow-unsigned}
instructs the parser to recognize @code{unsigned} as if it were
@code{unsigned int} (@pxref{Invoking grpc-compile, Sun XDR/RPC language
extensions}).
@end defvr

Source location information is attached to the S-expressions returned by
@code{rpc-language->sexp}.  It can be queried using the procedures
below.  Note that not-only top-level S-expressions (such as
@code{define-type} or @code{define-constant} expressions) can be
queried, but also sub-expressions, e.g., the @code{enum} S-expression
above.

@deffn {Scheme Procedure} sexp-location sexp
Return the source location associated with @var{sexp} or @code{#f} if no
source location information is available.
@end deffn

@deffn {Scheme Procedure} location-line loc
@deffnx {Scheme Procedure} location-column loc
@deffnx {Scheme Procedure} location-file loc
Return the line number, column number or file name from location
@var{loc}, an object returned by @code{sexp-location}.
@end deffn

@cindex compiler errors
In case of parse errors or other compiler errors, a
@code{&compiler-error} error condition (or an instance of a sub-type
thereof) may be raise.

@defvr {Scheme Variable} &compiler-error
The ``compiler error'' error condition type.
@end defvr

@deffn {Scheme Procedure} compiler-error? c
Return @code{#t} if @var{c} is a compiler error.
@end deffn

@deffn {Scheme Procedure} compiler-error:location c
Return the source location information associated with @var{c}, or
@code{#f} if that information is not available.
@end deffn


@node Code Generation Compiler Back-End, Run-Time Compiler Back-End, Parser, Compiler
@subsection Code Generation Compiler Back-End

The code generation back-end is provided by the @code{(rpc compiler)}
module.  Given an XDR/RPC description, it returns a list of
S-expressions, each of which is a top-level Scheme expression
implementing an element of the input description.  These expressions are
meant to be dumped to a Scheme file; this is what the command-line
interface of the compiler does (@pxref{Invoking grpc-compile,
@command{grpc-compile}}).

Here is an example XDR/RPC description and the resulting client code, as
obtained, e.g., with @command{grpc-compile --xdr --constants --client}:

@example
const max = 010;

struct foo
@{
  int   x;
  float y<max>;
@};

=>

(define max 8)
(define foo
  (make-xdr-struct-type
    (list xdr-integer
          (make-xdr-vector-type xdr-float max))))
@end example

As can be seen here, the generated code uses the run-time support
routines described earlier (@pxref{Implementation of XDR}); an
optimization would consist in generating specialized code that does not
depend on the run-time support, but it is not implemented yet.

This front-end consists of two procedures:

@deffn {Scheme Procedure} rpc-language->scheme-client input type-defs? constant-defs?
@deffnx {Scheme Procedure} rpc-language->scheme-server input type-defs? constant-defs?
These procedures return a list of top-level Scheme expressions
implementing @var{input} for an RPC client or, respectively, a server.

@var{input} can be either an input port, a string, or an AST as returned
by @code{rpc-language->sexp} (@pxref{Parser}).  If @var{type-defs?} is
@code{#t}, then type definition code is produced; if
@var{constant-defs?} is @code{#t}, then constant definition code is
produced.

Both procedures can raise error conditions having a sub-type of
@code{&compiler-error}.
@end deffn


@node Run-Time Compiler Back-End,  , Code Generation Compiler Back-End, Compiler
@subsection Run-Time Compiler Back-End

The run-time compiler back-end is also provided by the @code{(rpc
compiler)} module.  It reads XDR/RPC definitions and returns data
structures readily usable to deal with the XDR data types or RPC
programs described, @emph{at run-time}.  Actually, as of version
@value{VERSION}, it does not have an API to deal with RPC programs, only
with XDR data types.

@deffn {Scheme Procedure} rpc-language->xdr-types input
Read XDR type definitions from @var{input} and return an alist; element
of the returned alist is a pair whose @code{car} is a string naming an
XDR data type and whose @code{cdr} is an XDR data type object
(@pxref{XDR Type Representations}).  @var{input} can be either an input
port, a string, or an AST as returned by @code{rpc-language->sexp}
(@pxref{Parser}).

This procedure can raise error conditions having a sub-type of
@code{&compiler-error}.
@end deffn

Here is an example of two procedures that, given XDR type definitions,
decode (respectively encode) an object of that type:

@example
(use-modules (rpc compiler)
             (rpc xdr)
             (rnrs bytevectors)
             (rnrs io ports))

(define (decode-data type-defs type-name port)
  ;; Read binary data from PORT as an object of type
  ;; TYPE-NAME whose definition is given in TYPE-DEFS.
  (let* ((types (rpc-language->xdr-types type-defs))
         (type  (cdr (assoc type-name types))))
    (xdr-decode type port)))

(define (encode-data type-defs type-name object)
  ;; Encode OBJECT as XDR data type named TYPE-NAME from
  ;; the XDR type definitions in TYPE-DEFS.
  (let* ((types (rpc-language->xdr-types type-defs))
         (type  (cdr (assoc type-name types)))
         (size  (xdr-type-size type object))
         (bv    (make-bytevector size)))
    (xdr-encode! bv 0 type object)
    (open-bytevector-input-port bv)))
@end example

These procedures can then be used as follows:

@example
(let ((type-defs (string-append "typedef hyper chbouib<>;"
                                "struct foo @{ "
                                "  int x; float y; chbouib z;"
                                "@};"))
      (type-name "foo")
      (object    '(1 2.0 #(3 4 5))))
  (equal? (decode-data type-defs type-name
                       (encode-data type-defs type-name
                                    object))
          object))

=>

#t
@end example

Note that in this example @var{type-defs} contains two type definitions,
which is why the @var{type-name} argument is absolutely needed.


@c *********************************************************************
@node Stand-Alone Tools, References, API Reference, Top
@chapter Stand-Alone Tools

GNU Guile-RPC comes with stand-alone tools that can be used from the
command-line.

@menu
* Invoking grpc-compile::       Using the XDR/RPC compiler
* Invoking grpc-rpcinfo::       Querying the portmapper
* Invoking grpc-nfs-export::    Playing with the toy NFS server
@end menu


@node Invoking grpc-compile, Invoking grpc-rpcinfo, Stand-Alone Tools, Stand-Alone Tools
@section Invoking @code{grpc-compile}

@cindex @command{grpc-compile}

The @command{grpc-compile} command provides a simple command-line
interface to the XDR/RPC language compiler (@pxref{Compiler}).  It reads
a RPC definitions written in the XDR/RPC language on the standard input
and, depending on the options, write Scheme code containing client,
server, data type or constant definitions on the standard output.

@cindex compiler invocation

@table @option

@item --help
Print a summary of the command-line options and exit.

@item --version
Print the version number of GNU Guile-RPC and exit.

@item --xdr
@itemx -x
Compile XDR type definitions.

@item --constants
@itemx -C
Compile XDR constant definitions.

@item --client
@itemx -c
Compile client RPC stubs.

@item --server
@itemx -s
Compile server RPC stubs.

@item --strict
@itemx -S
@cindex Sun XDR/RPC language extensions
@cindex @code{rpcgen}

Use strict XDR standard compliance per @ref{References, RFC 4506@comma{}
Section 6}.  By default, the compiler recognizes extensions implemented
by Sun Microsystems, Inc., and also available in the GNU C Library's
@code{rpcgen}.  These extensions include:

@itemize
@item support for @code{%} line comments; these are actually treated
as special directives by @code{rpcgen} but they are simply ignored by
@code{grpc-compile};

@item support for the @code{char} type, equivalent to @code{int};

@item support for the @code{unsigned} type, equivalent to
@code{unsigned int};

@item the ability to use @code{struct} in type specifiers;

@item the ability to use @code{string} as the type specifier of a
procedure parameter.

@end itemize

@cindex C preprocessor
Also note that some XDR/RPC definition files (@file{.x} files)
originally designed to be used in C programs with @code{rpcgen} include
C preprocessor directives.  Unlike @code{rpcgen}, which automatically
invokes @code{cpp}, such input files need to be piped through
@command{cpp -P} before being fed to @code{grpc-compile}.

@item --intermediate
Output the intermediate form produced by the parser (@pxref{Parser}).

@end table

Code generation options can be combined.  For instance, the command line
below writes data type and constant definitions as well as client stubs
in a single file:

@example
$ grpc-compile --xdr --constants --client < input.x > client-stubs.scm
@end example

The various pieces of generated code can also be stored in separate
files.  The following example shows how to create one file containing
constant and type definitions, another one containing client stubs, and
a third one containing server stubs.  Since the two last files depend on
the first one, care must be taken to load them beforehand.

@example
$ grpc-compile --xdr --constants < input.x > types+constants.scm
$ echo '(load "types+constants.scm")' > client-stubs.scm
$ grpc-compile --client < input.x >> client-stubs.scm
$ echo '(load "types+constants.scm")' > server-stubs.scm
$ grpc-compile --server < input.x >> server-stubs.scm
@end example

@c FIXME: Remove paragraph when it's done.
In the future, there may be additional @code{--use-module} and
@code{--define-module} options to make it easier to use Guile's module
system in generated code.


@node Invoking grpc-rpcinfo, Invoking grpc-nfs-export, Invoking grpc-compile, Stand-Alone Tools
@section Invoking @code{grpc-rpcinfo}

@cindex @command{rpcinfo}
@cindex @command{grpc-rpcinfo}

This program is equivalent to the @code{rpcinfo} program available on
most Unix systems and notably provided by the GNU C Library.  In is a
client of the portmapper RPC program (@pxref{The Portmapper Program}).
Among the options supported by @code{rpcinfo}, only a few of them are
supported at this moment:

@table @option

@item --help
Print a summary of the command-line options and exit.

@item --version
Print the version number of GNU Guile-RPC and exit.

@item --dump
@itemx -p
Query the portmapper and list the registered RPC services.

@item --delete
@itemx -d
Unregister the RPC program with the given RPC program and version
numbers from the portmapper.

@end table

Note that the host where the portmapper lives can be specified as the
last argument to @code{grpc-rpcinfo}:

@example
# Query the portmapper at host `klimt'.

$ grpc-rpcinfo -p klimt
program vers    proto   port    name
100000  2       tcp     111     portmapper
100000  2       udp     111     portmapper
$ grpc-rpcinfo -d 100000 2 klimt 
ERROR: `portmapper-unset' failed FALSE
@end example


@node Invoking grpc-nfs-export,  , Invoking grpc-rpcinfo, Stand-Alone Tools
@section Invoking @code{grpc-nfs-export}

@cindex NFS
@cindex Network File System
@cindex @command{grpc-nfs-export}

Guile-RPC comes with an example NFS (Network File System) server,
provided by the @command{grpc-nfs-export} command.  More precisely, it
implements NFS version 2, i.e., the @code{NFS_PROGRAM} RPC program
version 2 along with the @code{MOUNTPROG} program version 1, which are
closely related (@pxref{References, RFC 1094}).  It is a TCP server.

Enough technical details.  The important thing about
@code{grpc-nfs-export} is this: although it's of little use in one's
everyday life, this NFS server is nothing less than life-changing.  It's
different from any file system you've seen before.  It's the ultimate
debugging aid for any good Guile hacker.

The ``file hierarchy'' served by @code{grpc-nfs-export} is---guess
what?---Guile's module hierarchy!  In other words, when mounting the
file system exported by @command{grpc-nfs-export}, the available files
are @dfn{bindings}, while directories represent @dfn{modules}
(@pxref{The Guile module system,,, guile, The GNU Guile Reference
Manual}).  The module hierarchy can also be browsed from the REPL using
Guile's @code{nested-ref} procedure.  Here's a sample session:

@example
$ ./grpc-nfs-export &

$ sudo mount -t nfs -o nfsvers=2,tcp,port=2049 localhost: /nfs/

$ ls /nfs/%app/modules/
guile/  guile-rpc/  guile-user/  ice-9/  r6rs/  rpc/  srfi/

$ ls /nfs/%app/modules/rpc/rpc/portmap/%module-public-interface/
lookup-rpc-service-name    %portmapper-port
lookup-rpc-service-number  %portmapper-program-number
portmapper-call-it         portmapper-set
portmapper-dump            portmapper-unset
portmapper-get-port        %portmapper-version-number
portmapper-null            read-rpc-service-list

$ cat /nfs/%app/modules/rpc/xdr/xdr-decode 
#<procedure xdr-decode (type port)>

$ cat /nfs/%app/modules/rpc/xdr/%xdr-endianness 
big
@end example

Here is the option reference:

@table @option

@item --help
Print a summary of the command-line options and exit.

@item --version
Print the version number of GNU Guile-RPC and exit.

@item --nfs-port=@var{port}
@itemx -p @var{port}
Listen for NFS connections on @var{port} (default: 2049).

@item --mount-port=@var{mount-port}
@itemx -P @var{mount-port}
Listen for @code{mount} connections on @var{mount-port} (default: 6666).

@item --debug
Produce debugging messages.

@end table

In addition, @command{grpc-nfs-export} can be passed the name of a
Scheme source file, in which case it will load that file in a separate
thread while still serving NFS and @code{mount} requests.  This allows
the program's global variables to be monitored via the NFS mount.

@c FIXME: Update when it's in a better shape.
As of version @value{VERSION}, this toy server exhibits poor
performance, notably when running @command{ls} (which translates into a
few @code{readdir} and many @code{lookup} RPCs, the latter being costly)
in directories containing a lot of files.  This is probably partly due
to the use of TCP, and partly due to other inefficiencies that we hope
to fix soon.



@c *********************************************************************
@node References, Portability, Stand-Alone Tools, Top
@chapter References

@table @code
@item RFC 1831
R. Srinivasan et al., @uref{http://tools.ietf.org/html/rfc1831,``RPC:
Remote Procedure Call Protocol Specification Version 2''}, August
1995.
@item RFC 4506
M. Eisler et al., @uref{http://tools.ietf.org/html/rfc4506, ``XDR:
External Data Representation Standard''}, May 2006.
@item RFC 1833
R. Srinivasan et al., @uref{http://tools.ietf.org/html/rfc1833,
``Binding Protocols for ONC RPC Version 2''}, August 2005.
@item RFC 1094
B. Nowicki, @uref{http://tools.ietf.org/html/rfc1094, ``NFS: Network
File System Protocol Specification''}, March 1989.
@end table


@c *********************************************************************
@node Portability, GNU Free Documentation License, References, Top
@appendix Portability Notes

@include portability.texi


@c *********************************************************************
@node GNU Free Documentation License, Concept Index, Portability, Top
@appendix GNU Free Documentation License

@include fdl.texi


@c *********************************************************************
@node Concept Index, Function Index, GNU Free Documentation License, Top
@unnumbered Concept Index
@printindex cp

@node Function Index, Variable Index, Concept Index, Top
@unnumbered Function Index
@printindex fn

@node Variable Index,  , Function Index, Top
@unnumbered Variable Index
@printindex vr


@bye

@ignore
;;; arch-tag: 412a400f-ccbb-42d8-97a2-036301f92235
@end ignore

@c Local Variables:
@c ispell-local-dictionary: "american"
@c End:

