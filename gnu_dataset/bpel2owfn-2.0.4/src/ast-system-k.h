/* translation of file(s)
	"petrinet-patterns-basic.k"
	"petrinet-patterns-structured.k"
	"petrinet-patterns-scopes.k"
	"petrinet-patterns-handlers.k"
	"petrinet-patterns-links.k"
	"petrinet-patterns-shortcuts.k"
	"ast-grammar.k"
	"ast-config.k"
	"ast-to-petrinet.k"
	"ast-to-xml.k"
	"ast-to-cfg.k"
	"ast-postprocess.k"
	"ast-rewrite.k"
	"ast-to-visualization.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.11 (C) 1998-2007 Humboldt-University of Berlin $
 */
#ifndef KC_TYPES_HEADER
#define KC_TYPES_HEADER

#define KIMWITUVERSIONMAJOR 2
#define KIMWITUVERSIONMINOR 3
#define KIMWITUVERSIONMICRO 11

#include <stdio.h>
#include <stddef.h>
#include <string>
#include <vector>

namespace kc {

#ifndef INTEGER
# define INTEGER int
#endif
#ifndef REAL
# define REAL double
#endif

#ifdef KC_UNICODE

#define kc_t(TEXT) L ## TEXT
typedef wchar_t kc_char_t;
typedef std::wstring kc_string_t;

#if defined(_WIN32) && ! defined (__GNUC__)
#define kc_strlen wcslen
#define kc_strcmp wcscmp
#define kc_strcasecmp _wcsicmp
#define kc_strcpy wcscpy
#define kc_strncpy wcsncpy
#define kc_tolower towlower
#define kc_print_integer(buf,number) swprintf(buf,kc_t("%d"),number)
#define kc_print_real(buf,number) swprintf(buf,kc_t("%g"),number)

// needed for printdot and csgio only
inline
std::string kc_to_cstring(const std::wstring& s) {
    USES_CONVERSION;
    return W2CA(s.c_str());
}

// needed for csgio only
inline
std::wstring kc_to_wstring(const std::string& s) {
    USES_CONVERSION;
    return A2CW(s.c_str());
}

#else // !defined(_WIN32) || defined(__GNUC__)
// if you want to use UNICODE on other platforms you have to write
// the following functions on your own
int kc_strlen(const kc_char_t*);
int kc_strcmp(const kc_char_t*,const kc_char_t*);
int kc_strcasecmp(const kc_char_t*,const kc_char_t*);
int kc_strcpy(kc_char_t*,const kc_char_t*);
int kc_strncpy(kc_char_t*,const kc_char_t*, int);
kc_char_t kc_tolower(kc_char_t);
int kc_print_integer(kc_char_t* buffer, INTEGER number );
int kc_print_real(kc_char_t* buffer, REAL number);

// needed for printdot and csgio only
std::string kc_to_cstring(const std::wstring& );
// needed for csgio only
std::wstring kc_to_wstring(const std::string& );

#endif

#else // !KC_UNICODE

#define kc_t(TEXT) TEXT  
typedef char kc_char_t;
typedef std::string kc_string_t;

#define kc_strlen strlen
#define kc_strcmp strcmp
#if defined(_WIN32) && ! defined (__GNUC__)
#define kc_strcasecmp _stricmp
#else
#define kc_strcasecmp strcasecmp
#endif
#define kc_strcpy strcpy
#define kc_strncpy strncpy
#define kc_tolower tolower  
#define kc_print_integer(buf,number) sprintf(buf,kc_t("%d"),number)
#define kc_print_real(buf,number) sprintf(buf,kc_t("%g"),number)
#endif
class uview_class;
typedef uview_class& uview;
typedef const uview_class& c_uview;

typedef class printer_functor_class& printer_functor;
typedef void (*printer_function)(const kc_char_t*, uview);

class rview_class;
typedef rview_class& rview;
typedef const rview_class& c_rview;

}

// Some compilers know __attribute__. Right now we test for the GNU compiler
// and Intel's icc (for ia32) and ecc (for ia64).
#if !defined __GNUC__ && !defined __ICC && !defined __ECC
# define __attribute__(x)
#endif

// Since all definitions are in namespace kc now, there is no need
// give them a kc_ prefix. Old code may still rely on the prefix, so these
// macros are generated for backwards compatibility
#ifdef KC_DEPRECATED
#define kc_PhylumInfo           phylum_info
#define kc_OperatorInfo         operator_info
#define kc_last_uview           last_uview
#define kc_uviews               uviews
#define kc_rviews               rviews
#define kc_ht_reuse             ht_clear
#define kc_ht_clear             ht_clear
#define kc_ht_assign            ht_assign
#define kc_ht_assigned          ht_assigned
#define kc_phylum_nocasestring phylum_nocasestring
#define kc_tag_nocasestring_NoCaseStr impl_nocasestring_NoCaseStr
#define kc_phylum_casestring phylum_casestring
#define kc_tag_casestring__Str impl_casestring__Str
#define kc_phylum_real phylum_real
#define kc_tag_real__Real impl_real__Real
#define kc_phylum_integer phylum_integer
#define kc_tag_integer__Int impl_integer__Int
#define kc_phylum_voidptr phylum_voidptr
#define kc_tag_voidptr__VoidPtr impl_voidptr__VoidPtr
#define kc_phylum_tProcess phylum_tProcess
#define kc_tag_tProcess_Process impl_tProcess_Process
#define kc_phylum_activity phylum_activity
#define kc_tag_activity_activityReceive impl_activity_activityReceive
#define kc_tag_activity_activityReply impl_activity_activityReply
#define kc_tag_activity_activityInvoke impl_activity_activityInvoke
#define kc_tag_activity_activityAssign impl_activity_activityAssign
#define kc_tag_activity_activityValidate impl_activity_activityValidate
#define kc_tag_activity_activityEmpty impl_activity_activityEmpty
#define kc_tag_activity_activityOpaqueActivity impl_activity_activityOpaqueActivity
#define kc_tag_activity_activityWait impl_activity_activityWait
#define kc_tag_activity_activityExit impl_activity_activityExit
#define kc_tag_activity_activityThrow impl_activity_activityThrow
#define kc_tag_activity_activityRethrow impl_activity_activityRethrow
#define kc_tag_activity_activityCompensate impl_activity_activityCompensate
#define kc_tag_activity_activitySequence impl_activity_activitySequence
#define kc_tag_activity_activityIf impl_activity_activityIf
#define kc_tag_activity_activityWhile impl_activity_activityWhile
#define kc_tag_activity_activityRepeatUntil impl_activity_activityRepeatUntil
#define kc_tag_activity_activityForEach impl_activity_activityForEach
#define kc_tag_activity_activityPick impl_activity_activityPick
#define kc_tag_activity_activityFlow impl_activity_activityFlow
#define kc_tag_activity_activityScope impl_activity_activityScope
#define kc_phylum_activity_list phylum_activity_list
#define kc_tag_activity_list_Nilactivity_list impl_activity_list_Nilactivity_list
#define kc_tag_activity_list_Consactivity_list impl_activity_list_Consactivity_list
#define kc_phylum_tPartnerLink_list phylum_tPartnerLink_list
#define kc_tag_tPartnerLink_list_NiltPartnerLink_list impl_tPartnerLink_list_NiltPartnerLink_list
#define kc_tag_tPartnerLink_list_ConstPartnerLink_list impl_tPartnerLink_list_ConstPartnerLink_list
#define kc_phylum_tPartnerLink phylum_tPartnerLink
#define kc_tag_tPartnerLink_PartnerLink impl_tPartnerLink_PartnerLink
#define kc_phylum_tPartner_list phylum_tPartner_list
#define kc_tag_tPartner_list_NiltPartner_list impl_tPartner_list_NiltPartner_list
#define kc_tag_tPartner_list_ConstPartner_list impl_tPartner_list_ConstPartner_list
#define kc_phylum_tPartner phylum_tPartner
#define kc_tag_tPartner_Partner impl_tPartner_Partner
#define kc_phylum_tFaultHandlers phylum_tFaultHandlers
#define kc_tag_tFaultHandlers_volatile_standardFaultHandlers impl_tFaultHandlers_volatile_standardFaultHandlers
#define kc_tag_tFaultHandlers_FaultHandlers impl_tFaultHandlers_FaultHandlers
#define kc_phylum_tCatch_list phylum_tCatch_list
#define kc_tag_tCatch_list_NiltCatch_list impl_tCatch_list_NiltCatch_list
#define kc_tag_tCatch_list_ConstCatch_list impl_tCatch_list_ConstCatch_list
#define kc_phylum_tCatch phylum_tCatch
#define kc_tag_tCatch_Catch impl_tCatch_Catch
#define kc_phylum_tCatchAll phylum_tCatchAll
#define kc_tag_tCatchAll_CatchAll impl_tCatchAll_CatchAll
#define kc_tag_tCatchAll_NoCatchAll impl_tCatchAll_NoCatchAll
#define kc_phylum_tTerminationHandler phylum_tTerminationHandler
#define kc_tag_tTerminationHandler_volatile_standardTerminationHandler impl_tTerminationHandler_volatile_standardTerminationHandler
#define kc_tag_tTerminationHandler_TerminationHandler impl_tTerminationHandler_TerminationHandler
#define kc_phylum_tCompensationHandler phylum_tCompensationHandler
#define kc_tag_tCompensationHandler_volatile_standardCompensationHandler impl_tCompensationHandler_volatile_standardCompensationHandler
#define kc_tag_tCompensationHandler_CompensationHandler impl_tCompensationHandler_CompensationHandler
#define kc_phylum_tEventHandlers phylum_tEventHandlers
#define kc_tag_tEventHandlers_emptyEventHandlers impl_tEventHandlers_emptyEventHandlers
#define kc_tag_tEventHandlers_EventHandlers impl_tEventHandlers_EventHandlers
#define kc_phylum_tOnMessage_list phylum_tOnMessage_list
#define kc_tag_tOnMessage_list_NiltOnMessage_list impl_tOnMessage_list_NiltOnMessage_list
#define kc_tag_tOnMessage_list_ConstOnMessage_list impl_tOnMessage_list_ConstOnMessage_list
#define kc_phylum_tOnMessage phylum_tOnMessage
#define kc_tag_tOnMessage_OnMessage impl_tOnMessage_OnMessage
#define kc_phylum_tOnAlarm_list phylum_tOnAlarm_list
#define kc_tag_tOnAlarm_list_NiltOnAlarm_list impl_tOnAlarm_list_NiltOnAlarm_list
#define kc_tag_tOnAlarm_list_ConstOnAlarm_list impl_tOnAlarm_list_ConstOnAlarm_list
#define kc_phylum_tOnAlarm phylum_tOnAlarm
#define kc_tag_tOnAlarm_OnAlarm impl_tOnAlarm_OnAlarm
#define kc_phylum_tRepeatEvery phylum_tRepeatEvery
#define kc_tag_tRepeatEvery_emptyRepeatEvery impl_tRepeatEvery_emptyRepeatEvery
#define kc_tag_tRepeatEvery_RepeatEvery impl_tRepeatEvery_RepeatEvery
#define kc_phylum_tVariable_list phylum_tVariable_list
#define kc_tag_tVariable_list_NiltVariable_list impl_tVariable_list_NiltVariable_list
#define kc_tag_tVariable_list_ConstVariable_list impl_tVariable_list_ConstVariable_list
#define kc_phylum_tVariable phylum_tVariable
#define kc_tag_tVariable_Variable impl_tVariable_Variable
#define kc_phylum_tMessageExchange_list phylum_tMessageExchange_list
#define kc_tag_tMessageExchange_list_NiltMessageExchange_list impl_tMessageExchange_list_NiltMessageExchange_list
#define kc_tag_tMessageExchange_list_ConstMessageExchange_list impl_tMessageExchange_list_ConstMessageExchange_list
#define kc_phylum_tMessageExchange phylum_tMessageExchange
#define kc_tag_tMessageExchange_MessageExchange impl_tMessageExchange_MessageExchange
#define kc_phylum_tCorrelationSet_list phylum_tCorrelationSet_list
#define kc_tag_tCorrelationSet_list_NiltCorrelationSet_list impl_tCorrelationSet_list_NiltCorrelationSet_list
#define kc_tag_tCorrelationSet_list_ConstCorrelationSet_list impl_tCorrelationSet_list_ConstCorrelationSet_list
#define kc_phylum_tCorrelationSet phylum_tCorrelationSet
#define kc_tag_tCorrelationSet_CorrelationSet impl_tCorrelationSet_CorrelationSet
#define kc_phylum_tCorrelation_list phylum_tCorrelation_list
#define kc_tag_tCorrelation_list_NiltCorrelation_list impl_tCorrelation_list_NiltCorrelation_list
#define kc_tag_tCorrelation_list_ConstCorrelation_list impl_tCorrelation_list_ConstCorrelation_list
#define kc_phylum_tCorrelation phylum_tCorrelation
#define kc_tag_tCorrelation_Correlation impl_tCorrelation_Correlation
#define kc_phylum_tToPart_list phylum_tToPart_list
#define kc_tag_tToPart_list_NiltToPart_list impl_tToPart_list_NiltToPart_list
#define kc_tag_tToPart_list_ConstToPart_list impl_tToPart_list_ConstToPart_list
#define kc_phylum_tToPart phylum_tToPart
#define kc_tag_tToPart_ToPart impl_tToPart_ToPart
#define kc_phylum_tFromPart_list phylum_tFromPart_list
#define kc_tag_tFromPart_list_NiltFromPart_list impl_tFromPart_list_NiltFromPart_list
#define kc_tag_tFromPart_list_ConstFromPart_list impl_tFromPart_list_ConstFromPart_list
#define kc_phylum_tFromPart phylum_tFromPart
#define kc_tag_tFromPart_FromPart impl_tFromPart_FromPart
#define kc_phylum_tReceive phylum_tReceive
#define kc_tag_tReceive_Receive impl_tReceive_Receive
#define kc_phylum_tReply phylum_tReply
#define kc_tag_tReply_Reply impl_tReply_Reply
#define kc_phylum_tInvoke phylum_tInvoke
#define kc_tag_tInvoke_volatile_Invoke impl_tInvoke_volatile_Invoke
#define kc_tag_tInvoke_SynchronousInvoke impl_tInvoke_SynchronousInvoke
#define kc_tag_tInvoke_AsynchronousInvoke impl_tInvoke_AsynchronousInvoke
#define kc_tag_tInvoke_volatile_annotatedInvoke impl_tInvoke_volatile_annotatedInvoke
#define kc_phylum_tAssign phylum_tAssign
#define kc_tag_tAssign_Assign impl_tAssign_Assign
#define kc_phylum_tCopy_list phylum_tCopy_list
#define kc_tag_tCopy_list_NiltCopy_list impl_tCopy_list_NiltCopy_list
#define kc_tag_tCopy_list_ConstCopy_list impl_tCopy_list_ConstCopy_list
#define kc_phylum_tCopy phylum_tCopy
#define kc_tag_tCopy_Copy impl_tCopy_Copy
#define kc_phylum_tFrom phylum_tFrom
#define kc_tag_tFrom_From impl_tFrom_From
#define kc_phylum_tTo phylum_tTo
#define kc_tag_tTo_To impl_tTo_To
#define kc_phylum_tValidate phylum_tValidate
#define kc_tag_tValidate_Validate impl_tValidate_Validate
#define kc_phylum_tEmpty phylum_tEmpty
#define kc_tag_tEmpty_Empty impl_tEmpty_Empty
#define kc_phylum_tOpaqueActivity phylum_tOpaqueActivity
#define kc_tag_tOpaqueActivity_OpaqueActivity impl_tOpaqueActivity_OpaqueActivity
#define kc_phylum_tWait phylum_tWait
#define kc_tag_tWait_Wait impl_tWait_Wait
#define kc_phylum_tExit phylum_tExit
#define kc_tag_tExit_Exit impl_tExit_Exit
#define kc_phylum_tThrow phylum_tThrow
#define kc_tag_tThrow_Throw impl_tThrow_Throw
#define kc_phylum_tRethrow phylum_tRethrow
#define kc_tag_tRethrow_Rethrow impl_tRethrow_Rethrow
#define kc_phylum_tCompensate phylum_tCompensate
#define kc_tag_tCompensate_Compensate impl_tCompensate_Compensate
#define kc_tag_tCompensate_CompensateScope impl_tCompensate_CompensateScope
#define kc_phylum_tSequence phylum_tSequence
#define kc_tag_tSequence_Sequence impl_tSequence_Sequence
#define kc_phylum_tIf phylum_tIf
#define kc_tag_tIf_If impl_tIf_If
#define kc_phylum_tElseIf_list phylum_tElseIf_list
#define kc_tag_tElseIf_list_NiltElseIf_list impl_tElseIf_list_NiltElseIf_list
#define kc_tag_tElseIf_list_ConstElseIf_list impl_tElseIf_list_ConstElseIf_list
#define kc_phylum_tElseIf phylum_tElseIf
#define kc_tag_tElseIf_ElseIf impl_tElseIf_ElseIf
#define kc_phylum_tElse phylum_tElse
#define kc_tag_tElse_Else impl_tElse_Else
#define kc_tag_tElse_NoElse impl_tElse_NoElse
#define kc_phylum_tWhile phylum_tWhile
#define kc_tag_tWhile_While impl_tWhile_While
#define kc_phylum_tRepeatUntil phylum_tRepeatUntil
#define kc_tag_tRepeatUntil_RepeatUntil impl_tRepeatUntil_RepeatUntil
#define kc_phylum_tForEach phylum_tForEach
#define kc_tag_tForEach_ForEach impl_tForEach_ForEach
#define kc_phylum_tPick phylum_tPick
#define kc_tag_tPick_Pick impl_tPick_Pick
#define kc_phylum_tFlow phylum_tFlow
#define kc_tag_tFlow_Flow impl_tFlow_Flow
#define kc_phylum_tLink_list phylum_tLink_list
#define kc_tag_tLink_list_NiltLink_list impl_tLink_list_NiltLink_list
#define kc_tag_tLink_list_ConstLink_list impl_tLink_list_ConstLink_list
#define kc_phylum_tLink phylum_tLink
#define kc_tag_tLink_Link impl_tLink_Link
#define kc_phylum_tScope phylum_tScope
#define kc_tag_tScope_Scope impl_tScope_Scope
#define kc_phylum_standardElements phylum_standardElements
#define kc_tag_standardElements_StandardElements impl_standardElements_StandardElements
#define kc_tag_standardElements_NoStandardElements impl_standardElements_NoStandardElements
#define kc_phylum_tTarget_list phylum_tTarget_list
#define kc_tag_tTarget_list_NiltTarget_list impl_tTarget_list_NiltTarget_list
#define kc_tag_tTarget_list_ConstTarget_list impl_tTarget_list_ConstTarget_list
#define kc_phylum_tTarget phylum_tTarget
#define kc_tag_tTarget_Target impl_tTarget_Target
#define kc_phylum_tSource_list phylum_tSource_list
#define kc_tag_tSource_list_NiltSource_list impl_tSource_list_NiltSource_list
#define kc_tag_tSource_list_ConstSource_list impl_tSource_list_ConstSource_list
#define kc_phylum_tSource phylum_tSource
#define kc_tag_tSource_Source impl_tSource_Source
#define kc_phylum_joinCondition phylum_joinCondition
#define kc_tag_joinCondition_standardJoinCondition impl_joinCondition_standardJoinCondition
#define kc_tag_joinCondition_userDefinedJoinCondition impl_joinCondition_userDefinedJoinCondition
#define kc_phylum_expression phylum_expression
#define kc_tag_expression_Term impl_expression_Term
#define kc_tag_expression_Conjunction impl_expression_Conjunction
#define kc_tag_expression_Disjunction impl_expression_Disjunction

#endif // KC_DEPRECATED

// Some compilers are too stupid to detect that a function will always return
// a proper value when it returns one in all branches of an if- or switch-
// statement (with final else or default, of course).
#if !defined __GNUC__
# define NORETURN throw 0;
#else
# define NORETURN
#endif

namespace kc {


typedef enum { one_before_first_phylum = 0 ,
    phylum_nocasestring = 1,
    phylum_casestring = 2,
    phylum_real = 3,
    phylum_integer = 4,
    phylum_voidptr = 5,
    phylum_tProcess = 6,
    phylum_activity = 7,
    phylum_activity_list = 8,
    phylum_tPartnerLink_list = 9,
    phylum_tPartnerLink = 10,
    phylum_tPartner_list = 11,
    phylum_tPartner = 12,
    phylum_tFaultHandlers = 13,
    phylum_tCatch_list = 14,
    phylum_tCatch = 15,
    phylum_tCatchAll = 16,
    phylum_tTerminationHandler = 17,
    phylum_tCompensationHandler = 18,
    phylum_tEventHandlers = 19,
    phylum_tOnMessage_list = 20,
    phylum_tOnMessage = 21,
    phylum_tOnAlarm_list = 22,
    phylum_tOnAlarm = 23,
    phylum_tRepeatEvery = 24,
    phylum_tVariable_list = 25,
    phylum_tVariable = 26,
    phylum_tMessageExchange_list = 27,
    phylum_tMessageExchange = 28,
    phylum_tCorrelationSet_list = 29,
    phylum_tCorrelationSet = 30,
    phylum_tCorrelation_list = 31,
    phylum_tCorrelation = 32,
    phylum_tToPart_list = 33,
    phylum_tToPart = 34,
    phylum_tFromPart_list = 35,
    phylum_tFromPart = 36,
    phylum_tReceive = 37,
    phylum_tReply = 38,
    phylum_tInvoke = 39,
    phylum_tAssign = 40,
    phylum_tCopy_list = 41,
    phylum_tCopy = 42,
    phylum_tFrom = 43,
    phylum_tTo = 44,
    phylum_tValidate = 45,
    phylum_tEmpty = 46,
    phylum_tOpaqueActivity = 47,
    phylum_tWait = 48,
    phylum_tExit = 49,
    phylum_tThrow = 50,
    phylum_tRethrow = 51,
    phylum_tCompensate = 52,
    phylum_tSequence = 53,
    phylum_tIf = 54,
    phylum_tElseIf_list = 55,
    phylum_tElseIf = 56,
    phylum_tElse = 57,
    phylum_tWhile = 58,
    phylum_tRepeatUntil = 59,
    phylum_tForEach = 60,
    phylum_tPick = 61,
    phylum_tFlow = 62,
    phylum_tLink_list = 63,
    phylum_tLink = 64,
    phylum_tScope = 65,
    phylum_standardElements = 66,
    phylum_tTarget_list = 67,
    phylum_tTarget = 68,
    phylum_tSource_list = 69,
    phylum_tSource = 70,
    phylum_joinCondition = 71,
    phylum_expression = 72,
    last_phylum = 73
} enum_phyla;

typedef enum { one_before_first_operator = 0 ,
    sel_NoCaseStr = 1,
    sel__Str = 2,
    sel__Real = 3,
    sel__Int = 4,
    sel__VoidPtr = 5,
    sel_Process = 6,
    sel_activityReceive = 7,
    sel_activityReply = 8,
    sel_activityInvoke = 9,
    sel_activityAssign = 10,
    sel_activityValidate = 11,
    sel_activityEmpty = 12,
    sel_activityOpaqueActivity = 13,
    sel_activityWait = 14,
    sel_activityExit = 15,
    sel_activityThrow = 16,
    sel_activityRethrow = 17,
    sel_activityCompensate = 18,
    sel_activitySequence = 19,
    sel_activityIf = 20,
    sel_activityWhile = 21,
    sel_activityRepeatUntil = 22,
    sel_activityForEach = 23,
    sel_activityPick = 24,
    sel_activityFlow = 25,
    sel_activityScope = 26,
    sel_Nilactivity_list = 27,
    sel_Consactivity_list = 28,
    sel_NiltPartnerLink_list = 29,
    sel_ConstPartnerLink_list = 30,
    sel_PartnerLink = 31,
    sel_NiltPartner_list = 32,
    sel_ConstPartner_list = 33,
    sel_Partner = 34,
    sel_volatile_standardFaultHandlers = 35,
    sel_FaultHandlers = 36,
    sel_NiltCatch_list = 37,
    sel_ConstCatch_list = 38,
    sel_Catch = 39,
    sel_CatchAll = 40,
    sel_NoCatchAll = 41,
    sel_volatile_standardTerminationHandler = 42,
    sel_TerminationHandler = 43,
    sel_volatile_standardCompensationHandler = 44,
    sel_CompensationHandler = 45,
    sel_emptyEventHandlers = 46,
    sel_EventHandlers = 47,
    sel_NiltOnMessage_list = 48,
    sel_ConstOnMessage_list = 49,
    sel_OnMessage = 50,
    sel_NiltOnAlarm_list = 51,
    sel_ConstOnAlarm_list = 52,
    sel_OnAlarm = 53,
    sel_emptyRepeatEvery = 54,
    sel_RepeatEvery = 55,
    sel_NiltVariable_list = 56,
    sel_ConstVariable_list = 57,
    sel_Variable = 58,
    sel_NiltMessageExchange_list = 59,
    sel_ConstMessageExchange_list = 60,
    sel_MessageExchange = 61,
    sel_NiltCorrelationSet_list = 62,
    sel_ConstCorrelationSet_list = 63,
    sel_CorrelationSet = 64,
    sel_NiltCorrelation_list = 65,
    sel_ConstCorrelation_list = 66,
    sel_Correlation = 67,
    sel_NiltToPart_list = 68,
    sel_ConstToPart_list = 69,
    sel_ToPart = 70,
    sel_NiltFromPart_list = 71,
    sel_ConstFromPart_list = 72,
    sel_FromPart = 73,
    sel_Receive = 74,
    sel_Reply = 75,
    sel_volatile_Invoke = 76,
    sel_SynchronousInvoke = 77,
    sel_AsynchronousInvoke = 78,
    sel_volatile_annotatedInvoke = 79,
    sel_Assign = 80,
    sel_NiltCopy_list = 81,
    sel_ConstCopy_list = 82,
    sel_Copy = 83,
    sel_From = 84,
    sel_To = 85,
    sel_Validate = 86,
    sel_Empty = 87,
    sel_OpaqueActivity = 88,
    sel_Wait = 89,
    sel_Exit = 90,
    sel_Throw = 91,
    sel_Rethrow = 92,
    sel_Compensate = 93,
    sel_CompensateScope = 94,
    sel_Sequence = 95,
    sel_If = 96,
    sel_NiltElseIf_list = 97,
    sel_ConstElseIf_list = 98,
    sel_ElseIf = 99,
    sel_Else = 100,
    sel_NoElse = 101,
    sel_While = 102,
    sel_RepeatUntil = 103,
    sel_ForEach = 104,
    sel_Pick = 105,
    sel_Flow = 106,
    sel_NiltLink_list = 107,
    sel_ConstLink_list = 108,
    sel_Link = 109,
    sel_Scope = 110,
    sel_StandardElements = 111,
    sel_NoStandardElements = 112,
    sel_NiltTarget_list = 113,
    sel_ConstTarget_list = 114,
    sel_Target = 115,
    sel_NiltSource_list = 116,
    sel_ConstSource_list = 117,
    sel_Source = 118,
    sel_standardJoinCondition = 119,
    sel_userDefinedJoinCondition = 120,
    sel_Term = 121,
    sel_Conjunction = 122,
    sel_Disjunction = 123,
    last_operator = 124
} enum_operators;

class impl_abstract_phylum;
typedef impl_abstract_phylum * abstract_phylum;
typedef const impl_abstract_phylum * c_abstract_phylum;
class impl_abstract_list;
typedef impl_abstract_list * abstract_list;
typedef const impl_abstract_list * c_abstract_list;

template <typename P, typename T>
P phylum_cast(T* t) {
    return static_cast<P>(t);
}
template <typename P, typename T>
const P phylum_cast(const T* t) {
    return static_cast<const P>(t);
}
class impl_nocasestring_NoCaseStr;
class impl_casestring__Str;
class impl_real__Real;
class impl_integer__Int;
class impl_voidptr__VoidPtr;
class impl_tProcess;
class impl_activity;
class impl_activity_list;
class impl_tPartnerLink_list;
class impl_tPartnerLink;
class impl_tPartner_list;
class impl_tPartner;
class impl_tFaultHandlers;
class impl_tCatch_list;
class impl_tCatch;
class impl_tCatchAll;
class impl_tTerminationHandler;
class impl_tCompensationHandler;
class impl_tEventHandlers;
class impl_tOnMessage_list;
class impl_tOnMessage;
class impl_tOnAlarm_list;
class impl_tOnAlarm;
class impl_tRepeatEvery;
class impl_tVariable_list;
class impl_tVariable;
class impl_tMessageExchange_list;
class impl_tMessageExchange;
class impl_tCorrelationSet_list;
class impl_tCorrelationSet;
class impl_tCorrelation_list;
class impl_tCorrelation;
class impl_tToPart_list;
class impl_tToPart;
class impl_tFromPart_list;
class impl_tFromPart;
class impl_tReceive;
class impl_tReply;
class impl_tInvoke;
class impl_tAssign;
class impl_tCopy_list;
class impl_tCopy;
class impl_tFrom;
class impl_tTo;
class impl_tValidate;
class impl_tEmpty;
class impl_tOpaqueActivity;
class impl_tWait;
class impl_tExit;
class impl_tThrow;
class impl_tRethrow;
class impl_tCompensate;
class impl_tSequence;
class impl_tIf;
class impl_tElseIf_list;
class impl_tElseIf;
class impl_tElse;
class impl_tWhile;
class impl_tRepeatUntil;
class impl_tForEach;
class impl_tPick;
class impl_tFlow;
class impl_tLink_list;
class impl_tLink;
class impl_tScope;
class impl_standardElements;
class impl_tTarget_list;
class impl_tTarget;
class impl_tSource_list;
class impl_tSource;
class impl_joinCondition;
class impl_expression;


void kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line,
    const char *kc_file, enum_operators kc_oper ) __attribute__ ((noreturn));

typedef enum_phyla *enum_phyla_list;

/*
 * make sure that the first 'real' storage class _always_ gets a value > 0
 * and kc_not_uniq gets a value == 0
 * (because then we can use it as a C boolean)
 */
enum kc_storageclass_t {
    kc_not_uniq,
    uniq,
    last_storageclass
};

typedef struct {
    const char *name;			// name of the phylum
    enum_operators first_operator;	// index in operator_info[]
    enum_operators last_operator;	// index in operator_info[]
    kc_storageclass_t uniq_stored;	// storage class
} KC_PHYLUM_INFO;

typedef struct {
    const char *name;			// name of the operator
    size_t no_sons;			// number of sons
    bool atomicity;			// atomic type or not
    enum_phyla phylum;			// index in phylum_info[]
    enum_phyla_list subphylum;		// indexes in phylum_info[]
    int no_attrs;			// number of attributes
    enum_phyla_list attribute;		// indexes in phylum_info[]
    size_t size;			// size of operator (for statistics)
} KC_OPERATOR_INFO;

typedef enum_phyla_list KC_UNIQ_INFO;

extern KC_OPERATOR_INFO operator_info[];
extern KC_PHYLUM_INFO phylum_info[];
extern KC_UNIQ_INFO kc_UniqInfo[];

#define KC_OP_NAME(op) (operator_info[op].name)
#define KC_NO_SONS(prod) (operator_info[prod].no_sons)
#define KC_ATOMICITY(prod) (operator_info[prod].atomicity)

typedef class impl_kc_dotedgenode_t *kc_dotedgenode_t;

typedef impl_nocasestring_NoCaseStr *nocasestring;
typedef const impl_nocasestring_NoCaseStr *c_nocasestring;
typedef impl_casestring__Str *casestring;
typedef const impl_casestring__Str *c_casestring;
typedef impl_real__Real *real;
typedef const impl_real__Real *c_real;
typedef impl_integer__Int *integer;
typedef const impl_integer__Int *c_integer;
typedef impl_voidptr__VoidPtr *voidptr;
typedef const impl_voidptr__VoidPtr *c_voidptr;
typedef impl_tProcess *tProcess;
typedef const impl_tProcess *c_tProcess;
typedef impl_activity *activity;
typedef const impl_activity *c_activity;
typedef impl_activity_list *activity_list;
typedef const impl_activity_list *c_activity_list;
typedef impl_tPartnerLink_list *tPartnerLink_list;
typedef const impl_tPartnerLink_list *c_tPartnerLink_list;
typedef impl_tPartnerLink *tPartnerLink;
typedef const impl_tPartnerLink *c_tPartnerLink;
typedef impl_tPartner_list *tPartner_list;
typedef const impl_tPartner_list *c_tPartner_list;
typedef impl_tPartner *tPartner;
typedef const impl_tPartner *c_tPartner;
typedef impl_tFaultHandlers *tFaultHandlers;
typedef const impl_tFaultHandlers *c_tFaultHandlers;
typedef impl_tCatch_list *tCatch_list;
typedef const impl_tCatch_list *c_tCatch_list;
typedef impl_tCatch *tCatch;
typedef const impl_tCatch *c_tCatch;
typedef impl_tCatchAll *tCatchAll;
typedef const impl_tCatchAll *c_tCatchAll;
typedef impl_tTerminationHandler *tTerminationHandler;
typedef const impl_tTerminationHandler *c_tTerminationHandler;
typedef impl_tCompensationHandler *tCompensationHandler;
typedef const impl_tCompensationHandler *c_tCompensationHandler;
typedef impl_tEventHandlers *tEventHandlers;
typedef const impl_tEventHandlers *c_tEventHandlers;
typedef impl_tOnMessage_list *tOnMessage_list;
typedef const impl_tOnMessage_list *c_tOnMessage_list;
typedef impl_tOnMessage *tOnMessage;
typedef const impl_tOnMessage *c_tOnMessage;
typedef impl_tOnAlarm_list *tOnAlarm_list;
typedef const impl_tOnAlarm_list *c_tOnAlarm_list;
typedef impl_tOnAlarm *tOnAlarm;
typedef const impl_tOnAlarm *c_tOnAlarm;
typedef impl_tRepeatEvery *tRepeatEvery;
typedef const impl_tRepeatEvery *c_tRepeatEvery;
typedef impl_tVariable_list *tVariable_list;
typedef const impl_tVariable_list *c_tVariable_list;
typedef impl_tVariable *tVariable;
typedef const impl_tVariable *c_tVariable;
typedef impl_tMessageExchange_list *tMessageExchange_list;
typedef const impl_tMessageExchange_list *c_tMessageExchange_list;
typedef impl_tMessageExchange *tMessageExchange;
typedef const impl_tMessageExchange *c_tMessageExchange;
typedef impl_tCorrelationSet_list *tCorrelationSet_list;
typedef const impl_tCorrelationSet_list *c_tCorrelationSet_list;
typedef impl_tCorrelationSet *tCorrelationSet;
typedef const impl_tCorrelationSet *c_tCorrelationSet;
typedef impl_tCorrelation_list *tCorrelation_list;
typedef const impl_tCorrelation_list *c_tCorrelation_list;
typedef impl_tCorrelation *tCorrelation;
typedef const impl_tCorrelation *c_tCorrelation;
typedef impl_tToPart_list *tToPart_list;
typedef const impl_tToPart_list *c_tToPart_list;
typedef impl_tToPart *tToPart;
typedef const impl_tToPart *c_tToPart;
typedef impl_tFromPart_list *tFromPart_list;
typedef const impl_tFromPart_list *c_tFromPart_list;
typedef impl_tFromPart *tFromPart;
typedef const impl_tFromPart *c_tFromPart;
typedef impl_tReceive *tReceive;
typedef const impl_tReceive *c_tReceive;
typedef impl_tReply *tReply;
typedef const impl_tReply *c_tReply;
typedef impl_tInvoke *tInvoke;
typedef const impl_tInvoke *c_tInvoke;
typedef impl_tAssign *tAssign;
typedef const impl_tAssign *c_tAssign;
typedef impl_tCopy_list *tCopy_list;
typedef const impl_tCopy_list *c_tCopy_list;
typedef impl_tCopy *tCopy;
typedef const impl_tCopy *c_tCopy;
typedef impl_tFrom *tFrom;
typedef const impl_tFrom *c_tFrom;
typedef impl_tTo *tTo;
typedef const impl_tTo *c_tTo;
typedef impl_tValidate *tValidate;
typedef const impl_tValidate *c_tValidate;
typedef impl_tEmpty *tEmpty;
typedef const impl_tEmpty *c_tEmpty;
typedef impl_tOpaqueActivity *tOpaqueActivity;
typedef const impl_tOpaqueActivity *c_tOpaqueActivity;
typedef impl_tWait *tWait;
typedef const impl_tWait *c_tWait;
typedef impl_tExit *tExit;
typedef const impl_tExit *c_tExit;
typedef impl_tThrow *tThrow;
typedef const impl_tThrow *c_tThrow;
typedef impl_tRethrow *tRethrow;
typedef const impl_tRethrow *c_tRethrow;
typedef impl_tCompensate *tCompensate;
typedef const impl_tCompensate *c_tCompensate;
typedef impl_tSequence *tSequence;
typedef const impl_tSequence *c_tSequence;
typedef impl_tIf *tIf;
typedef const impl_tIf *c_tIf;
typedef impl_tElseIf_list *tElseIf_list;
typedef const impl_tElseIf_list *c_tElseIf_list;
typedef impl_tElseIf *tElseIf;
typedef const impl_tElseIf *c_tElseIf;
typedef impl_tElse *tElse;
typedef const impl_tElse *c_tElse;
typedef impl_tWhile *tWhile;
typedef const impl_tWhile *c_tWhile;
typedef impl_tRepeatUntil *tRepeatUntil;
typedef const impl_tRepeatUntil *c_tRepeatUntil;
typedef impl_tForEach *tForEach;
typedef const impl_tForEach *c_tForEach;
typedef impl_tPick *tPick;
typedef const impl_tPick *c_tPick;
typedef impl_tFlow *tFlow;
typedef const impl_tFlow *c_tFlow;
typedef impl_tLink_list *tLink_list;
typedef const impl_tLink_list *c_tLink_list;
typedef impl_tLink *tLink;
typedef const impl_tLink *c_tLink;
typedef impl_tScope *tScope;
typedef const impl_tScope *c_tScope;
typedef impl_standardElements *standardElements;
typedef const impl_standardElements *c_standardElements;
typedef impl_tTarget_list *tTarget_list;
typedef const impl_tTarget_list *c_tTarget_list;
typedef impl_tTarget *tTarget;
typedef const impl_tTarget *c_tTarget;
typedef impl_tSource_list *tSource_list;
typedef const impl_tSource_list *c_tSource_list;
typedef impl_tSource *tSource;
typedef const impl_tSource *c_tSource;
typedef impl_joinCondition *joinCondition;
typedef const impl_joinCondition *c_joinCondition;
typedef impl_expression *expression;
typedef const impl_expression *c_expression;

#define KC_NO_OF_OPERATORS 124


} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 160 "ast-config.k"
#include <string>
#include <iostream>
#include <map>

#include "debug.h"	// for (SAerror, trace)
#include "helpers.h"	// for (toString)

/*!
 * \brief  a preprocessor directive for the quite generic constructors
 *
 *         This preprocessor defines a constructor for ASTE objects. It is
 *         invoked by the constructors of the AST phyla. The latter constructor
 *         can be invoked explictly by the BPEL parser (defined in in
 *         frontend-parser.yy), or implicitly during rewriting.
 *
 *         Each AST phylum has an integer value defined which is interpreted as
 *         the identifier of this phylum. If this value is non-zero, it is
 *         directly passed to the ASTE constructor and used in mapping
 *         globals::ASTEmap to reference to the newly created object. If,
 *         however, the identifier has the value 0, the value of the global
 *         variable globals::ASTEid is used as identifier. The latter case is
 *         used if an AST phylum is added by an unparser an thus cannot be
 *         linked to any information of the parser such as an attribute map.
 *
 * \param  token  The token name (e.g. "K_PROCESS" for the <process>) which is
 *                passed to the ASTE constructor.
 */
#define CTOR(token) { \
    ENTER("[AST]"); \
    assert(integer_1 != NULL); \
    bool id_was_zero = (integer_1->value == 0); \
    if (integer_1->value == 0) \
    { \
	id = globals::ASTEid; \
	integer_1 = mkinteger(globals::ASTEid++); \
    } \
    else { \
	id = integer_1->value; \
    } \
    if (globals::ASTEmap[id] == NULL) \
    { \
	globals::ASTEmap[id] = new ASTE(id, token); \
    } \
    assert(globals::ASTEmap[id] != NULL); \
    globals::ASTEmap[id]->phylum = this; \
    if (id_was_zero) \
	globals::ASTEmap[id]->isUserDefined = globals::parsing; \
    LEAVE("[AST]"); \
}





// use to get ANSI C
#undef kc_strcasecmp
#define kc_strcasecmp strcmp


#line  902 "ast-system-k.h"
/* end included stuff */


namespace kc {

#ifndef KC_NO_DEFAULT_IN_WITH
# define KC_NO_DEFAULT_IN_WITH "Internal Error: no default action defined in function %s at %s:%d\n"
#endif
void kc_no_default_in_with (const char*, int, const char*);
void kc_returnless_function (const char *, int, const char*);

#ifndef NDEBUG
# define assertCond(t) do {if (!(t)) kc_assertionFailed(__FILE__,__LINE__);}while(false)
# define assertReason(t,s) do {if (!(t)) kc_assertionReasonFailed(__FILE__,__LINE__,s);}while(false)
# define assertNonNull(p) do {if (p == 0) kc_assertionNonNullFailed(__FILE__,__LINE__,#p);}while(false)
# define assertPhylum(ptr,phy) do { \
    assertNonNull(ptr); \
    if (ptr->phylum()!=phy) \
	kc_assertionOperatorInPhylumFailed(ptr->prod_sel(),#ptr,"->prod_sel()","phy",__FILE__,__LINE__); \
} while(false)
#else
# define assertCond(t)
# define assertReason(t,s)
# define assertNonNull(ptr)
# define assertPhylum(op,phy)
#endif
#define assertionFailed(s) kc_assertionReasonFailed(__FILE__,__LINE__,s)

void kc_assertionFailed (const char*, int) __attribute__ ((noreturn));
void kc_assertionReasonFailed (const char*, int, const char*) __attribute__ ((noreturn));
void kc_assertionNonNullFailed (const char*, int, const char*) __attribute__ ((noreturn));
void kc_assertionOperatorInPhylumFailed (int, const char*, const char*, const char*, const char*, int) __attribute__ ((noreturn));

casestring mkcasestring( const kc_char_t *, int length = -1);
nocasestring mknocasestring( const kc_char_t *, int length = -1);
integer mkinteger( const INTEGER );
real mkreal( const REAL );
inline casestring _Str( const kc_char_t * cc) { return mkcasestring(cc); }
inline nocasestring NoCaseStr( const kc_char_t * cc) { return mknocasestring(cc); }
inline integer _Int( const INTEGER cc) { return mkinteger(cc); }
inline real _Real( const REAL cc) { return mkreal(cc); }
class impl_tProcess_Process* Process (tPartnerLink_list, tPartner_list, tMessageExchange_list, tVariable_list, tCorrelationSet_list, tFaultHandlers, tEventHandlers, activity, integer);
class impl_activity_activityReceive* activityReceive (tReceive);
class impl_activity_activityReply* activityReply (tReply);
class impl_activity_activityInvoke* activityInvoke (tInvoke);
class impl_activity_activityAssign* activityAssign (tAssign);
class impl_activity_activityValidate* activityValidate (tValidate);
class impl_activity_activityEmpty* activityEmpty (tEmpty);
class impl_activity_activityOpaqueActivity* activityOpaqueActivity (tOpaqueActivity);
class impl_activity_activityWait* activityWait (tWait);
class impl_activity_activityExit* activityExit (tExit);
class impl_activity_activityThrow* activityThrow (tThrow);
class impl_activity_activityRethrow* activityRethrow (tRethrow);
class impl_activity_activityCompensate* activityCompensate (tCompensate);
class impl_activity_activitySequence* activitySequence (tSequence);
class impl_activity_activityIf* activityIf (tIf);
class impl_activity_activityWhile* activityWhile (tWhile);
class impl_activity_activityRepeatUntil* activityRepeatUntil (tRepeatUntil);
class impl_activity_activityForEach* activityForEach (tForEach);
class impl_activity_activityPick* activityPick (tPick);
class impl_activity_activityFlow* activityFlow (tFlow);
class impl_activity_activityScope* activityScope (tScope);
activity_list Nilactivity_list();
activity_list Consactivity_list(activity,activity_list);
tPartnerLink_list NiltPartnerLink_list();
tPartnerLink_list ConstPartnerLink_list(tPartnerLink,tPartnerLink_list);
class impl_tPartnerLink_PartnerLink* PartnerLink (integer);
tPartner_list NiltPartner_list();
tPartner_list ConstPartner_list(tPartner,tPartner_list);
class impl_tPartner_Partner* Partner (tPartnerLink_list, integer);
class impl_tFaultHandlers_volatile_standardFaultHandlers* volatile_standardFaultHandlers (integer);
class impl_tFaultHandlers_FaultHandlers* FaultHandlers (tCatch_list, tCatchAll, integer);
tCatch_list NiltCatch_list();
tCatch_list ConstCatch_list(tCatch,tCatch_list);
class impl_tCatch_Catch* Catch (activity, integer);
class impl_tCatchAll_CatchAll* CatchAll (activity, integer);
class impl_tCatchAll_NoCatchAll* NoCatchAll ();
class impl_tTerminationHandler_volatile_standardTerminationHandler* volatile_standardTerminationHandler (integer);
class impl_tTerminationHandler_TerminationHandler* TerminationHandler (activity, integer);
class impl_tCompensationHandler_volatile_standardCompensationHandler* volatile_standardCompensationHandler (integer);
class impl_tCompensationHandler_CompensationHandler* CompensationHandler (activity, integer);
class impl_tEventHandlers_emptyEventHandlers* emptyEventHandlers (integer);
class impl_tEventHandlers_EventHandlers* EventHandlers (tOnMessage_list, tOnAlarm_list, integer);
tOnMessage_list NiltOnMessage_list();
tOnMessage_list ConstOnMessage_list(tOnMessage,tOnMessage_list);
class impl_tOnMessage_OnMessage* OnMessage (tCorrelation_list, tFromPart_list, activity, integer);
tOnAlarm_list NiltOnAlarm_list();
tOnAlarm_list ConstOnAlarm_list(tOnAlarm,tOnAlarm_list);
class impl_tOnAlarm_OnAlarm* OnAlarm (tRepeatEvery, activity, integer);
class impl_tRepeatEvery_emptyRepeatEvery* emptyRepeatEvery (integer);
class impl_tRepeatEvery_RepeatEvery* RepeatEvery (integer);
tVariable_list NiltVariable_list();
tVariable_list ConstVariable_list(tVariable,tVariable_list);
class impl_tVariable_Variable* Variable (integer);
tMessageExchange_list NiltMessageExchange_list();
tMessageExchange_list ConstMessageExchange_list(tMessageExchange,tMessageExchange_list);
class impl_tMessageExchange_MessageExchange* MessageExchange (integer);
tCorrelationSet_list NiltCorrelationSet_list();
tCorrelationSet_list ConstCorrelationSet_list(tCorrelationSet,tCorrelationSet_list);
class impl_tCorrelationSet_CorrelationSet* CorrelationSet (integer);
tCorrelation_list NiltCorrelation_list();
tCorrelation_list ConstCorrelation_list(tCorrelation,tCorrelation_list);
class impl_tCorrelation_Correlation* Correlation (integer);
tToPart_list NiltToPart_list();
tToPart_list ConstToPart_list(tToPart,tToPart_list);
class impl_tToPart_ToPart* ToPart (integer);
tFromPart_list NiltFromPart_list();
tFromPart_list ConstFromPart_list(tFromPart,tFromPart_list);
class impl_tFromPart_FromPart* FromPart (integer);
class impl_tReceive_Receive* Receive (standardElements, tCorrelation_list, tFromPart_list, integer);
class impl_tReply_Reply* Reply (standardElements, tCorrelation_list, tToPart_list, integer);
class impl_tInvoke_volatile_Invoke* volatile_Invoke (standardElements, tCorrelation_list, tToPart_list, tFromPart_list, integer);
class impl_tInvoke_SynchronousInvoke* SynchronousInvoke (standardElements, tCorrelation_list, tToPart_list, tFromPart_list, integer);
class impl_tInvoke_AsynchronousInvoke* AsynchronousInvoke (standardElements, tCorrelation_list, tToPart_list, tFromPart_list, integer);
class impl_tInvoke_volatile_annotatedInvoke* volatile_annotatedInvoke (standardElements, tCorrelation_list, tCatch_list, tCatchAll, tCompensationHandler, tToPart_list, tFromPart_list, integer);
class impl_tAssign_Assign* Assign (standardElements, tCopy_list, integer);
tCopy_list NiltCopy_list();
tCopy_list ConstCopy_list(tCopy,tCopy_list);
class impl_tCopy_Copy* Copy (tFrom, tTo, integer);
class impl_tFrom_From* From (integer);
class impl_tTo_To* To (integer);
class impl_tValidate_Validate* Validate (standardElements, integer);
class impl_tEmpty_Empty* Empty (standardElements, integer);
class impl_tOpaqueActivity_OpaqueActivity* OpaqueActivity (standardElements, integer);
class impl_tWait_Wait* Wait (standardElements, integer);
class impl_tExit_Exit* Exit (standardElements, integer);
class impl_tThrow_Throw* Throw (standardElements, integer);
class impl_tRethrow_Rethrow* Rethrow (standardElements, integer);
class impl_tCompensate_Compensate* Compensate (standardElements, integer);
class impl_tCompensate_CompensateScope* CompensateScope (standardElements, casestring, integer);
class impl_tSequence_Sequence* Sequence (standardElements, activity_list, integer);
class impl_tIf_If* If (standardElements, tElseIf_list, tElse, integer);
tElseIf_list NiltElseIf_list();
tElseIf_list ConstElseIf_list(tElseIf,tElseIf_list);
class impl_tElseIf_ElseIf* ElseIf (activity, integer);
class impl_tElse_Else* Else (activity, integer);
class impl_tElse_NoElse* NoElse (integer);
class impl_tWhile_While* While (standardElements, activity, integer);
class impl_tRepeatUntil_RepeatUntil* RepeatUntil (standardElements, activity, integer);
class impl_tForEach_ForEach* ForEach (standardElements, casestring, casestring, casestring, tScope, integer);
class impl_tPick_Pick* Pick (standardElements, tOnMessage_list, tOnAlarm_list, integer);
class impl_tFlow_Flow* Flow (standardElements, tLink_list, activity_list, integer);
tLink_list NiltLink_list();
tLink_list ConstLink_list(tLink,tLink_list);
class impl_tLink_Link* Link (integer);
class impl_tScope_Scope* Scope (standardElements, tVariable_list, tMessageExchange_list, tFaultHandlers, tCompensationHandler, tTerminationHandler, tEventHandlers, tCorrelationSet_list, activity, tPartnerLink_list, integer);
class impl_standardElements_StandardElements* StandardElements (tTarget_list, tSource_list, joinCondition);
class impl_standardElements_NoStandardElements* NoStandardElements ();
tTarget_list NiltTarget_list();
tTarget_list ConstTarget_list(tTarget,tTarget_list);
class impl_tTarget_Target* Target (integer);
tSource_list NiltSource_list();
tSource_list ConstSource_list(tSource,tSource_list);
class impl_tSource_Source* Source (integer);
class impl_joinCondition_standardJoinCondition* standardJoinCondition ();
class impl_joinCondition_userDefinedJoinCondition* userDefinedJoinCondition (expression);
class impl_expression_Term* Term (casestring);
class impl_expression_Conjunction* Conjunction (expression, expression);
class impl_expression_Disjunction* Disjunction (expression, expression);

//namespace Phylum {

class impl_abstract_phylum {
public:
    virtual enum_operators prod_sel() const =0;
    static const enum_phyla phylum_sel_;
    enum_phyla phylum() const;
    const char* phylum_name() const;
    const char* op_name() const;
    virtual abstract_phylum subphylum(int) const;
    virtual void set_subphylum(int, abstract_phylum);
    void free(bool recursive=true);
    bool eq(c_abstract_phylum) const;
    void print();
    void fprint(FILE *);
    abstract_phylum copy(bool kc_copy_attributes) const;
    void unparse(printer_functor pf, uview uv)
	{ do_unparse(pf, uv); }
    void unparse(printer_function opf, uview uv);

    void printdot_add_edge (c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*) const;
    void do_printdot_id (FILE*, bool, c_abstract_phylum, int) const;
    void do_printdot (FILE*, bool, int*, kc_dotedgenode_t*, const char*, bool, bool, c_abstract_phylum, int) const;

    virtual void fprintdot(FILE *,
	const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes,
	bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const =0;
    virtual abstract_phylum rewrite(rview v) { return do_rewrite(v); }
    virtual abstract_phylum do_rewrite(rview) { return this;}
    // called if a subphylum of an op is rewritten and a new op is created by default rule
    virtual void rewrite_members(abstract_phylum from) {} 
    virtual void post_create(){}
    unsigned int id;
    explicit impl_abstract_phylum()
	: id() { }
    virtual ~impl_abstract_phylum() { }
private:
    virtual void do_unparse(printer_functor, uview) =0;
protected:
    virtual void default_unparse(printer_functor, uview);
};


class impl_abstract_list: public impl_abstract_phylum{
private:
    void fprint_list(FILE *);
    friend class impl_abstract_phylum;
protected:
    abstract_phylum do_concat(c_abstract_phylum other, enum_operators) const;
    abstract_phylum do_reverse(c_abstract_phylum tail, enum_operators) const;
    abstract_phylum do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators);
    abstract_phylum do_filter(bool (*kc_fp)(abstract_phylum), enum_operators);
    abstract_list   do_append(abstract_phylum, abstract_list);
    abstract_phylum do_merge(abstract_list,abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum), enum_operators);
    abstract_phylum do_reduce(abstract_phylum neutral, abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum));
public:
    virtual bool is_nil() const =0;
    virtual abstract_list reverse() const =0;
    int length() const;
    abstract_phylum last() const;
    // Non-virtual, non-existing... Type must be known exactly anyway because
    // of the function given as a parameter
    //virtual abstract_list map( abstract_phylum (*)( abstract_phylum )) =0;
    //virtual abstract_list filter(bool (*)(abstract_phylum)) =0;
    void freelist();
};

abstract_phylum kc_create(enum_operators createOp, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0);
abstract_phylum kc_create(enum_operators createOp, const std::vector<abstract_phylum>& kc_ps);
abstract_phylum& attributeOf(abstract_phylum kc_p, int no);

class impl_nocasestring_NoCaseStr;
typedef impl_nocasestring_NoCaseStr impl_nocasestring;
class impl_nocasestring_NoCaseStr:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel_NoCaseStr; }
    static const enum_phyla phylum_sel_;
private:
    explicit impl_nocasestring_NoCaseStr(const kc_char_t*);
    void make_own(int length);
    friend nocasestring mknocasestring(const kc_char_t*, int);
public:
    ~impl_nocasestring_NoCaseStr() {
#if defined (_MSC_VER) && _MSC_VER<1300
	delete [] (kc_char_t*)name;
#else
	delete [] name;
#endif
    }
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    nocasestring rewrite( rview )
	{ return this; }
    kc_char_t const* name;
private:
    void do_unparse(printer_functor, uview);
};
class impl_casestring__Str;
typedef impl_casestring__Str impl_casestring;
class impl_casestring__Str:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Str; }
    static const enum_phyla phylum_sel_;
private:
    explicit impl_casestring__Str(const kc_char_t*);
    void make_own(int length);
    friend casestring mkcasestring(const kc_char_t*, int);
public:
    ~impl_casestring__Str() {
#if defined (_MSC_VER) && _MSC_VER<1300
	delete [] (kc_char_t*)name;
#else
	delete [] name;
#endif
    }
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    casestring rewrite( rview )
	{ return this; }
    kc_char_t const* name;
private:
    void do_unparse(printer_functor, uview);
};
class impl_real__Real;
typedef impl_real__Real impl_real;
class impl_real__Real:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Real; }
    static const enum_phyla phylum_sel_;
    explicit impl_real__Real(REAL _value);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    real rewrite( rview )
	{ return this; }
    REAL value;
private:
    void do_unparse(printer_functor, uview);
};
class impl_integer__Int;
typedef impl_integer__Int impl_integer;
class impl_integer__Int:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Int; }
    static const enum_phyla phylum_sel_;
    explicit impl_integer__Int(INTEGER _value);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    integer rewrite( rview )
	{ return this; }
    INTEGER value;
private:
    void do_unparse(printer_functor, uview);
};
class impl_voidptr__VoidPtr;
typedef impl_voidptr__VoidPtr impl_voidptr;
class impl_voidptr__VoidPtr:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__VoidPtr; }
    static const enum_phyla phylum_sel_;
    explicit impl_voidptr__VoidPtr(void* _pointer);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    voidptr rewrite( rview )
	{ return this; }
    void* pointer;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tProcess: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tProcess rewrite(rview) =0;
};
class impl_tProcess_Process:public impl_tProcess{
public:
    enum_operators prod_sel() const
	{ return sel_Process; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tProcess rewrite( rview );
    impl_tPartnerLink_list* tPartnerLink_list_1;
    impl_tPartner_list* tPartner_list_1;
    impl_tMessageExchange_list* tMessageExchange_list_1;
    impl_tVariable_list* tVariable_list_1;
    impl_tCorrelationSet_list* tCorrelationSet_list_1;
    impl_tFaultHandlers* tFaultHandlers_1;
    impl_tEventHandlers* tEventHandlers_1;
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tProcess_Process(tPartnerLink_list _tPartnerLink_list_1, tPartner_list _tPartner_list_1, tMessageExchange_list _tMessageExchange_list_1, tVariable_list _tVariable_list_1, tCorrelationSet_list _tCorrelationSet_list_1, tFaultHandlers _tFaultHandlers_1, tEventHandlers _tEventHandlers_1, activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    activity rewrite(rview) =0;
};
class impl_activity_activityScope:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityScope; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tScope* tScope_1;
    impl_activity_activityScope(tScope _tScope_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityFlow:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityFlow; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tFlow* tFlow_1;
    impl_activity_activityFlow(tFlow _tFlow_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityPick:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityPick; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tPick* tPick_1;
    impl_activity_activityPick(tPick _tPick_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityForEach:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityForEach; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tForEach* tForEach_1;
    impl_activity_activityForEach(tForEach _tForEach_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityRepeatUntil:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityRepeatUntil; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tRepeatUntil* tRepeatUntil_1;
    impl_activity_activityRepeatUntil(tRepeatUntil _tRepeatUntil_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityWhile:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityWhile; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tWhile* tWhile_1;
    impl_activity_activityWhile(tWhile _tWhile_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityIf:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityIf; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tIf* tIf_1;
    impl_activity_activityIf(tIf _tIf_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activitySequence:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activitySequence; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tSequence* tSequence_1;
    impl_activity_activitySequence(tSequence _tSequence_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityCompensate:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityCompensate; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tCompensate* tCompensate_1;
    impl_activity_activityCompensate(tCompensate _tCompensate_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityRethrow:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityRethrow; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tRethrow* tRethrow_1;
    impl_activity_activityRethrow(tRethrow _tRethrow_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityThrow:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityThrow; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tThrow* tThrow_1;
    impl_activity_activityThrow(tThrow _tThrow_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityExit:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityExit; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tExit* tExit_1;
    impl_activity_activityExit(tExit _tExit_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityWait:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityWait; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tWait* tWait_1;
    impl_activity_activityWait(tWait _tWait_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityOpaqueActivity:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityOpaqueActivity; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tOpaqueActivity* tOpaqueActivity_1;
    impl_activity_activityOpaqueActivity(tOpaqueActivity _tOpaqueActivity_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityEmpty:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityEmpty; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tEmpty* tEmpty_1;
    impl_activity_activityEmpty(tEmpty _tEmpty_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityValidate:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityValidate; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tValidate* tValidate_1;
    impl_activity_activityValidate(tValidate _tValidate_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityAssign:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityAssign; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tAssign* tAssign_1;
    impl_activity_activityAssign(tAssign _tAssign_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityInvoke:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityInvoke; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tInvoke* tInvoke_1;
    impl_activity_activityInvoke(tInvoke _tInvoke_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityReply:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityReply; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tReply* tReply_1;
    impl_activity_activityReply(tReply _tReply_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_activityReceive:public impl_activity{
public:
    enum_operators prod_sel() const
	{ return sel_activityReceive; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    activity rewrite( rview );
    impl_tReceive* tReceive_1;
    impl_activity_activityReceive(tReceive _tReceive_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_activity_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_Nilactivity_list: sel_Consactivity_list;
    }
    explicit impl_activity_list(activity = 0, activity_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend activity_list concat(c_activity_list, c_activity_list);
    activity_list reverse() const;
    activity_list rewrite(rview);
    activity last() const;
    activity_list append(activity);
    activity_list map(activity (*)(activity));
    activity_list filter( bool (*)(activity));
    activity_list merge( activity_list, activity (*)(activity, activity));
    activity reduce( activity, activity (*)(activity, activity));
    bool is_nil() const;
    activity activity_1;
    activity_list activity_list_1;
private:
    impl_activity_list* nil_rewrite(rview);
    impl_activity_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tPartnerLink_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltPartnerLink_list: sel_ConstPartnerLink_list;
    }
    explicit impl_tPartnerLink_list(tPartnerLink = 0, tPartnerLink_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tPartnerLink_list concat(c_tPartnerLink_list, c_tPartnerLink_list);
    tPartnerLink_list reverse() const;
    tPartnerLink_list rewrite(rview);
    tPartnerLink last() const;
    tPartnerLink_list append(tPartnerLink);
    tPartnerLink_list map(tPartnerLink (*)(tPartnerLink));
    tPartnerLink_list filter( bool (*)(tPartnerLink));
    tPartnerLink_list merge( tPartnerLink_list, tPartnerLink (*)(tPartnerLink, tPartnerLink));
    tPartnerLink reduce( tPartnerLink, tPartnerLink (*)(tPartnerLink, tPartnerLink));
    bool is_nil() const;
    tPartnerLink tPartnerLink_1;
    tPartnerLink_list tPartnerLink_list_1;
private:
    impl_tPartnerLink_list* nil_rewrite(rview);
    impl_tPartnerLink_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tPartnerLink: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tPartnerLink rewrite(rview) =0;
};
class impl_tPartnerLink_PartnerLink:public impl_tPartnerLink{
public:
    enum_operators prod_sel() const
	{ return sel_PartnerLink; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tPartnerLink rewrite( rview );
    impl_integer* integer_1;
    impl_tPartnerLink_PartnerLink(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tPartner_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltPartner_list: sel_ConstPartner_list;
    }
    explicit impl_tPartner_list(tPartner = 0, tPartner_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tPartner_list concat(c_tPartner_list, c_tPartner_list);
    tPartner_list reverse() const;
    tPartner_list rewrite(rview);
    tPartner last() const;
    tPartner_list append(tPartner);
    tPartner_list map(tPartner (*)(tPartner));
    tPartner_list filter( bool (*)(tPartner));
    tPartner_list merge( tPartner_list, tPartner (*)(tPartner, tPartner));
    tPartner reduce( tPartner, tPartner (*)(tPartner, tPartner));
    bool is_nil() const;
    tPartner tPartner_1;
    tPartner_list tPartner_list_1;
private:
    impl_tPartner_list* nil_rewrite(rview);
    impl_tPartner_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tPartner: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tPartner rewrite(rview) =0;
};
class impl_tPartner_Partner:public impl_tPartner{
public:
    enum_operators prod_sel() const
	{ return sel_Partner; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tPartner rewrite( rview );
    impl_tPartnerLink_list* tPartnerLink_list_1;
    impl_integer* integer_1;
    impl_tPartner_Partner(tPartnerLink_list _tPartnerLink_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tFaultHandlers: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tFaultHandlers rewrite(rview) =0;
};
class impl_tFaultHandlers_FaultHandlers:public impl_tFaultHandlers{
public:
    enum_operators prod_sel() const
	{ return sel_FaultHandlers; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tFaultHandlers rewrite( rview );
    impl_tCatch_list* tCatch_list_1;
    impl_tCatchAll* tCatchAll_1;
    impl_integer* integer_1;
    impl_tFaultHandlers_FaultHandlers(tCatch_list _tCatch_list_1, tCatchAll _tCatchAll_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tFaultHandlers_volatile_standardFaultHandlers:public impl_tFaultHandlers{
public:
    enum_operators prod_sel() const
	{ return sel_volatile_standardFaultHandlers; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tFaultHandlers rewrite( rview );
    impl_integer* integer_1;
    impl_tFaultHandlers_volatile_standardFaultHandlers(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tCatch_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltCatch_list: sel_ConstCatch_list;
    }
    explicit impl_tCatch_list(tCatch = 0, tCatch_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tCatch_list concat(c_tCatch_list, c_tCatch_list);
    tCatch_list reverse() const;
    tCatch_list rewrite(rview);
    tCatch last() const;
    tCatch_list append(tCatch);
    tCatch_list map(tCatch (*)(tCatch));
    tCatch_list filter( bool (*)(tCatch));
    tCatch_list merge( tCatch_list, tCatch (*)(tCatch, tCatch));
    tCatch reduce( tCatch, tCatch (*)(tCatch, tCatch));
    bool is_nil() const;
    tCatch tCatch_1;
    tCatch_list tCatch_list_1;
private:
    impl_tCatch_list* nil_rewrite(rview);
    impl_tCatch_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tCatch: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tCatch rewrite(rview) =0;
};
class impl_tCatch_Catch:public impl_tCatch{
public:
    enum_operators prod_sel() const
	{ return sel_Catch; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tCatch rewrite( rview );
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tCatch_Catch(activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tCatchAll: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tCatchAll rewrite(rview) =0;
};
class impl_tCatchAll_NoCatchAll:public impl_tCatchAll{
public:
    enum_operators prod_sel() const
	{ return sel_NoCatchAll; }
    explicit impl_tCatchAll_NoCatchAll();

    tCatchAll rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tCatchAll_CatchAll:public impl_tCatchAll{
public:
    enum_operators prod_sel() const
	{ return sel_CatchAll; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tCatchAll rewrite( rview );
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tCatchAll_CatchAll(activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerminationHandler: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tTerminationHandler rewrite(rview) =0;
};
class impl_tTerminationHandler_TerminationHandler:public impl_tTerminationHandler{
public:
    enum_operators prod_sel() const
	{ return sel_TerminationHandler; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerminationHandler rewrite( rview );
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tTerminationHandler_TerminationHandler(activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerminationHandler_volatile_standardTerminationHandler:public impl_tTerminationHandler{
public:
    enum_operators prod_sel() const
	{ return sel_volatile_standardTerminationHandler; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerminationHandler rewrite( rview );
    impl_integer* integer_1;
    impl_tTerminationHandler_volatile_standardTerminationHandler(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tCompensationHandler: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tCompensationHandler rewrite(rview) =0;
};
class impl_tCompensationHandler_CompensationHandler:public impl_tCompensationHandler{
public:
    enum_operators prod_sel() const
	{ return sel_CompensationHandler; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tCompensationHandler rewrite( rview );
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tCompensationHandler_CompensationHandler(activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tCompensationHandler_volatile_standardCompensationHandler:public impl_tCompensationHandler{
public:
    enum_operators prod_sel() const
	{ return sel_volatile_standardCompensationHandler; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tCompensationHandler rewrite( rview );
    impl_integer* integer_1;
    impl_tCompensationHandler_volatile_standardCompensationHandler(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tEventHandlers: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tEventHandlers rewrite(rview) =0;
};
class impl_tEventHandlers_EventHandlers:public impl_tEventHandlers{
public:
    enum_operators prod_sel() const
	{ return sel_EventHandlers; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tEventHandlers rewrite( rview );
    impl_tOnMessage_list* tOnMessage_list_1;
    impl_tOnAlarm_list* tOnAlarm_list_1;
    impl_integer* integer_1;
    impl_tEventHandlers_EventHandlers(tOnMessage_list _tOnMessage_list_1, tOnAlarm_list _tOnAlarm_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tEventHandlers_emptyEventHandlers:public impl_tEventHandlers{
public:
    enum_operators prod_sel() const
	{ return sel_emptyEventHandlers; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tEventHandlers rewrite( rview );
    impl_integer* integer_1;
    impl_tEventHandlers_emptyEventHandlers(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tOnMessage_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltOnMessage_list: sel_ConstOnMessage_list;
    }
    explicit impl_tOnMessage_list(tOnMessage = 0, tOnMessage_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tOnMessage_list concat(c_tOnMessage_list, c_tOnMessage_list);
    tOnMessage_list reverse() const;
    tOnMessage_list rewrite(rview);
    tOnMessage last() const;
    tOnMessage_list append(tOnMessage);
    tOnMessage_list map(tOnMessage (*)(tOnMessage));
    tOnMessage_list filter( bool (*)(tOnMessage));
    tOnMessage_list merge( tOnMessage_list, tOnMessage (*)(tOnMessage, tOnMessage));
    tOnMessage reduce( tOnMessage, tOnMessage (*)(tOnMessage, tOnMessage));
    bool is_nil() const;
    tOnMessage tOnMessage_1;
    tOnMessage_list tOnMessage_list_1;
private:
    impl_tOnMessage_list* nil_rewrite(rview);
    impl_tOnMessage_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tOnMessage: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tOnMessage rewrite(rview) =0;
};
class impl_tOnMessage_OnMessage:public impl_tOnMessage{
public:
    enum_operators prod_sel() const
	{ return sel_OnMessage; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tOnMessage rewrite( rview );
    impl_tCorrelation_list* tCorrelation_list_1;
    impl_tFromPart_list* tFromPart_list_1;
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tOnMessage_OnMessage(tCorrelation_list _tCorrelation_list_1, tFromPart_list _tFromPart_list_1, activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tOnAlarm_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltOnAlarm_list: sel_ConstOnAlarm_list;
    }
    explicit impl_tOnAlarm_list(tOnAlarm = 0, tOnAlarm_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tOnAlarm_list concat(c_tOnAlarm_list, c_tOnAlarm_list);
    tOnAlarm_list reverse() const;
    tOnAlarm_list rewrite(rview);
    tOnAlarm last() const;
    tOnAlarm_list append(tOnAlarm);
    tOnAlarm_list map(tOnAlarm (*)(tOnAlarm));
    tOnAlarm_list filter( bool (*)(tOnAlarm));
    tOnAlarm_list merge( tOnAlarm_list, tOnAlarm (*)(tOnAlarm, tOnAlarm));
    tOnAlarm reduce( tOnAlarm, tOnAlarm (*)(tOnAlarm, tOnAlarm));
    bool is_nil() const;
    tOnAlarm tOnAlarm_1;
    tOnAlarm_list tOnAlarm_list_1;
private:
    impl_tOnAlarm_list* nil_rewrite(rview);
    impl_tOnAlarm_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tOnAlarm: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tOnAlarm rewrite(rview) =0;
};
class impl_tOnAlarm_OnAlarm:public impl_tOnAlarm{
public:
    enum_operators prod_sel() const
	{ return sel_OnAlarm; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tOnAlarm rewrite( rview );
    impl_tRepeatEvery* tRepeatEvery_1;
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tOnAlarm_OnAlarm(tRepeatEvery _tRepeatEvery_1, activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tRepeatEvery: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tRepeatEvery rewrite(rview) =0;
};
class impl_tRepeatEvery_RepeatEvery:public impl_tRepeatEvery{
public:
    enum_operators prod_sel() const
	{ return sel_RepeatEvery; }
    explicit impl_tRepeatEvery_RepeatEvery(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tRepeatEvery rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tRepeatEvery_emptyRepeatEvery:public impl_tRepeatEvery{
public:
    enum_operators prod_sel() const
	{ return sel_emptyRepeatEvery; }
    explicit impl_tRepeatEvery_emptyRepeatEvery(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tRepeatEvery rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tVariable_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltVariable_list: sel_ConstVariable_list;
    }
    explicit impl_tVariable_list(tVariable = 0, tVariable_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tVariable_list concat(c_tVariable_list, c_tVariable_list);
    tVariable_list reverse() const;
    tVariable_list rewrite(rview);
    tVariable last() const;
    tVariable_list append(tVariable);
    tVariable_list map(tVariable (*)(tVariable));
    tVariable_list filter( bool (*)(tVariable));
    tVariable_list merge( tVariable_list, tVariable (*)(tVariable, tVariable));
    tVariable reduce( tVariable, tVariable (*)(tVariable, tVariable));
    bool is_nil() const;
    tVariable tVariable_1;
    tVariable_list tVariable_list_1;
private:
    impl_tVariable_list* nil_rewrite(rview);
    impl_tVariable_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tVariable: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tVariable rewrite(rview) =0;
};
class impl_tVariable_Variable:public impl_tVariable{
public:
    enum_operators prod_sel() const
	{ return sel_Variable; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tVariable rewrite( rview );
    impl_integer* integer_1;
    impl_tVariable_Variable(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tMessageExchange_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltMessageExchange_list: sel_ConstMessageExchange_list;
    }
    explicit impl_tMessageExchange_list(tMessageExchange = 0, tMessageExchange_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tMessageExchange_list concat(c_tMessageExchange_list, c_tMessageExchange_list);
    tMessageExchange_list reverse() const;
    tMessageExchange_list rewrite(rview);
    tMessageExchange last() const;
    tMessageExchange_list append(tMessageExchange);
    tMessageExchange_list map(tMessageExchange (*)(tMessageExchange));
    tMessageExchange_list filter( bool (*)(tMessageExchange));
    tMessageExchange_list merge( tMessageExchange_list, tMessageExchange (*)(tMessageExchange, tMessageExchange));
    tMessageExchange reduce( tMessageExchange, tMessageExchange (*)(tMessageExchange, tMessageExchange));
    bool is_nil() const;
    tMessageExchange tMessageExchange_1;
    tMessageExchange_list tMessageExchange_list_1;
private:
    impl_tMessageExchange_list* nil_rewrite(rview);
    impl_tMessageExchange_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tMessageExchange: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tMessageExchange rewrite(rview) =0;
};
class impl_tMessageExchange_MessageExchange:public impl_tMessageExchange{
public:
    enum_operators prod_sel() const
	{ return sel_MessageExchange; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tMessageExchange rewrite( rview );
    impl_integer* integer_1;
    impl_tMessageExchange_MessageExchange(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tCorrelationSet_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltCorrelationSet_list: sel_ConstCorrelationSet_list;
    }
    explicit impl_tCorrelationSet_list(tCorrelationSet = 0, tCorrelationSet_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tCorrelationSet_list concat(c_tCorrelationSet_list, c_tCorrelationSet_list);
    tCorrelationSet_list reverse() const;
    tCorrelationSet_list rewrite(rview);
    tCorrelationSet last() const;
    tCorrelationSet_list append(tCorrelationSet);
    tCorrelationSet_list map(tCorrelationSet (*)(tCorrelationSet));
    tCorrelationSet_list filter( bool (*)(tCorrelationSet));
    tCorrelationSet_list merge( tCorrelationSet_list, tCorrelationSet (*)(tCorrelationSet, tCorrelationSet));
    tCorrelationSet reduce( tCorrelationSet, tCorrelationSet (*)(tCorrelationSet, tCorrelationSet));
    bool is_nil() const;
    tCorrelationSet tCorrelationSet_1;
    tCorrelationSet_list tCorrelationSet_list_1;
private:
    impl_tCorrelationSet_list* nil_rewrite(rview);
    impl_tCorrelationSet_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tCorrelationSet: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tCorrelationSet rewrite(rview) =0;
};
class impl_tCorrelationSet_CorrelationSet:public impl_tCorrelationSet{
public:
    enum_operators prod_sel() const
	{ return sel_CorrelationSet; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tCorrelationSet rewrite( rview );
    impl_integer* integer_1;
    impl_tCorrelationSet_CorrelationSet(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tCorrelation_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltCorrelation_list: sel_ConstCorrelation_list;
    }
    explicit impl_tCorrelation_list(tCorrelation = 0, tCorrelation_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tCorrelation_list concat(c_tCorrelation_list, c_tCorrelation_list);
    tCorrelation_list reverse() const;
    tCorrelation_list rewrite(rview);
    tCorrelation last() const;
    tCorrelation_list append(tCorrelation);
    tCorrelation_list map(tCorrelation (*)(tCorrelation));
    tCorrelation_list filter( bool (*)(tCorrelation));
    tCorrelation_list merge( tCorrelation_list, tCorrelation (*)(tCorrelation, tCorrelation));
    tCorrelation reduce( tCorrelation, tCorrelation (*)(tCorrelation, tCorrelation));
    bool is_nil() const;
    tCorrelation tCorrelation_1;
    tCorrelation_list tCorrelation_list_1;
private:
    impl_tCorrelation_list* nil_rewrite(rview);
    impl_tCorrelation_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tCorrelation: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tCorrelation rewrite(rview) =0;
};
class impl_tCorrelation_Correlation:public impl_tCorrelation{
public:
    enum_operators prod_sel() const
	{ return sel_Correlation; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tCorrelation rewrite( rview );
    impl_integer* integer_1;
    impl_tCorrelation_Correlation(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tToPart_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltToPart_list: sel_ConstToPart_list;
    }
    explicit impl_tToPart_list(tToPart = 0, tToPart_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tToPart_list concat(c_tToPart_list, c_tToPart_list);
    tToPart_list reverse() const;
    tToPart_list rewrite(rview);
    tToPart last() const;
    tToPart_list append(tToPart);
    tToPart_list map(tToPart (*)(tToPart));
    tToPart_list filter( bool (*)(tToPart));
    tToPart_list merge( tToPart_list, tToPart (*)(tToPart, tToPart));
    tToPart reduce( tToPart, tToPart (*)(tToPart, tToPart));
    bool is_nil() const;
    tToPart tToPart_1;
    tToPart_list tToPart_list_1;
private:
    impl_tToPart_list* nil_rewrite(rview);
    impl_tToPart_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tToPart: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tToPart rewrite(rview) =0;
};
class impl_tToPart_ToPart:public impl_tToPart{
public:
    enum_operators prod_sel() const
	{ return sel_ToPart; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tToPart rewrite( rview );
    impl_integer* integer_1;
    impl_tToPart_ToPart(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tFromPart_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltFromPart_list: sel_ConstFromPart_list;
    }
    explicit impl_tFromPart_list(tFromPart = 0, tFromPart_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tFromPart_list concat(c_tFromPart_list, c_tFromPart_list);
    tFromPart_list reverse() const;
    tFromPart_list rewrite(rview);
    tFromPart last() const;
    tFromPart_list append(tFromPart);
    tFromPart_list map(tFromPart (*)(tFromPart));
    tFromPart_list filter( bool (*)(tFromPart));
    tFromPart_list merge( tFromPart_list, tFromPart (*)(tFromPart, tFromPart));
    tFromPart reduce( tFromPart, tFromPart (*)(tFromPart, tFromPart));
    bool is_nil() const;
    tFromPart tFromPart_1;
    tFromPart_list tFromPart_list_1;
private:
    impl_tFromPart_list* nil_rewrite(rview);
    impl_tFromPart_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tFromPart: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tFromPart rewrite(rview) =0;
};
class impl_tFromPart_FromPart:public impl_tFromPart{
public:
    enum_operators prod_sel() const
	{ return sel_FromPart; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tFromPart rewrite( rview );
    impl_integer* integer_1;
    impl_tFromPart_FromPart(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tReceive: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tReceive rewrite(rview) =0;
};
class impl_tReceive_Receive:public impl_tReceive{
public:
    enum_operators prod_sel() const
	{ return sel_Receive; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tReceive rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tCorrelation_list* tCorrelation_list_1;
    impl_tFromPart_list* tFromPart_list_1;
    impl_integer* integer_1;
    impl_tReceive_Receive(standardElements _standardElements_1, tCorrelation_list _tCorrelation_list_1, tFromPart_list _tFromPart_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tReply: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tReply rewrite(rview) =0;
};
class impl_tReply_Reply:public impl_tReply{
public:
    enum_operators prod_sel() const
	{ return sel_Reply; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tReply rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tCorrelation_list* tCorrelation_list_1;
    impl_tToPart_list* tToPart_list_1;
    impl_integer* integer_1;
    impl_tReply_Reply(standardElements _standardElements_1, tCorrelation_list _tCorrelation_list_1, tToPart_list _tToPart_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tInvoke: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tInvoke rewrite(rview) =0;
};
class impl_tInvoke_volatile_annotatedInvoke:public impl_tInvoke{
public:
    enum_operators prod_sel() const
	{ return sel_volatile_annotatedInvoke; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tInvoke rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tCorrelation_list* tCorrelation_list_1;
    impl_tCatch_list* tCatch_list_1;
    impl_tCatchAll* tCatchAll_1;
    impl_tCompensationHandler* tCompensationHandler_1;
    impl_tToPart_list* tToPart_list_1;
    impl_tFromPart_list* tFromPart_list_1;
    impl_integer* integer_1;
    impl_tInvoke_volatile_annotatedInvoke(standardElements _standardElements_1, tCorrelation_list _tCorrelation_list_1, tCatch_list _tCatch_list_1, tCatchAll _tCatchAll_1, tCompensationHandler _tCompensationHandler_1, tToPart_list _tToPart_list_1, tFromPart_list _tFromPart_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tInvoke_AsynchronousInvoke:public impl_tInvoke{
public:
    enum_operators prod_sel() const
	{ return sel_AsynchronousInvoke; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tInvoke rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tCorrelation_list* tCorrelation_list_1;
    impl_tToPart_list* tToPart_list_1;
    impl_tFromPart_list* tFromPart_list_1;
    impl_integer* integer_1;
    impl_tInvoke_AsynchronousInvoke(standardElements _standardElements_1, tCorrelation_list _tCorrelation_list_1, tToPart_list _tToPart_list_1, tFromPart_list _tFromPart_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tInvoke_SynchronousInvoke:public impl_tInvoke{
public:
    enum_operators prod_sel() const
	{ return sel_SynchronousInvoke; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tInvoke rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tCorrelation_list* tCorrelation_list_1;
    impl_tToPart_list* tToPart_list_1;
    impl_tFromPart_list* tFromPart_list_1;
    impl_integer* integer_1;
    impl_tInvoke_SynchronousInvoke(standardElements _standardElements_1, tCorrelation_list _tCorrelation_list_1, tToPart_list _tToPart_list_1, tFromPart_list _tFromPart_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tInvoke_volatile_Invoke:public impl_tInvoke{
public:
    enum_operators prod_sel() const
	{ return sel_volatile_Invoke; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tInvoke rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tCorrelation_list* tCorrelation_list_1;
    impl_tToPart_list* tToPart_list_1;
    impl_tFromPart_list* tFromPart_list_1;
    impl_integer* integer_1;
    impl_tInvoke_volatile_Invoke(standardElements _standardElements_1, tCorrelation_list _tCorrelation_list_1, tToPart_list _tToPart_list_1, tFromPart_list _tFromPart_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAssign: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tAssign rewrite(rview) =0;
};
class impl_tAssign_Assign:public impl_tAssign{
public:
    enum_operators prod_sel() const
	{ return sel_Assign; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAssign rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tCopy_list* tCopy_list_1;
    impl_integer* integer_1;
    impl_tAssign_Assign(standardElements _standardElements_1, tCopy_list _tCopy_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tCopy_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltCopy_list: sel_ConstCopy_list;
    }
    explicit impl_tCopy_list(tCopy = 0, tCopy_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tCopy_list concat(c_tCopy_list, c_tCopy_list);
    tCopy_list reverse() const;
    tCopy_list rewrite(rview);
    tCopy last() const;
    tCopy_list append(tCopy);
    tCopy_list map(tCopy (*)(tCopy));
    tCopy_list filter( bool (*)(tCopy));
    tCopy_list merge( tCopy_list, tCopy (*)(tCopy, tCopy));
    tCopy reduce( tCopy, tCopy (*)(tCopy, tCopy));
    bool is_nil() const;
    tCopy tCopy_1;
    tCopy_list tCopy_list_1;
private:
    impl_tCopy_list* nil_rewrite(rview);
    impl_tCopy_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tCopy: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tCopy rewrite(rview) =0;
};
class impl_tCopy_Copy:public impl_tCopy{
public:
    enum_operators prod_sel() const
	{ return sel_Copy; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tCopy rewrite( rview );
    impl_tFrom* tFrom_1;
    impl_tTo* tTo_1;
    impl_integer* integer_1;
    impl_tCopy_Copy(tFrom _tFrom_1, tTo _tTo_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tFrom: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tFrom rewrite(rview) =0;
};
class impl_tFrom_From:public impl_tFrom{
public:
    enum_operators prod_sel() const
	{ return sel_From; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tFrom rewrite( rview );
    impl_integer* integer_1;
    impl_tFrom_From(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTo: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tTo rewrite(rview) =0;
};
class impl_tTo_To:public impl_tTo{
public:
    enum_operators prod_sel() const
	{ return sel_To; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTo rewrite( rview );
    impl_integer* integer_1;
    impl_tTo_To(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tValidate: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tValidate rewrite(rview) =0;
};
class impl_tValidate_Validate:public impl_tValidate{
public:
    enum_operators prod_sel() const
	{ return sel_Validate; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tValidate rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_integer* integer_1;
    impl_tValidate_Validate(standardElements _standardElements_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tEmpty: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tEmpty rewrite(rview) =0;
};
class impl_tEmpty_Empty:public impl_tEmpty{
public:
    enum_operators prod_sel() const
	{ return sel_Empty; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tEmpty rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_integer* integer_1;
    impl_tEmpty_Empty(standardElements _standardElements_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tOpaqueActivity: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tOpaqueActivity rewrite(rview) =0;
};
class impl_tOpaqueActivity_OpaqueActivity:public impl_tOpaqueActivity{
public:
    enum_operators prod_sel() const
	{ return sel_OpaqueActivity; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tOpaqueActivity rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_integer* integer_1;
    impl_tOpaqueActivity_OpaqueActivity(standardElements _standardElements_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tWait: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tWait rewrite(rview) =0;
};
class impl_tWait_Wait:public impl_tWait{
public:
    enum_operators prod_sel() const
	{ return sel_Wait; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tWait rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_integer* integer_1;
    impl_tWait_Wait(standardElements _standardElements_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tExit: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tExit rewrite(rview) =0;
};
class impl_tExit_Exit:public impl_tExit{
public:
    enum_operators prod_sel() const
	{ return sel_Exit; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tExit rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_integer* integer_1;
    impl_tExit_Exit(standardElements _standardElements_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tThrow: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tThrow rewrite(rview) =0;
};
class impl_tThrow_Throw:public impl_tThrow{
public:
    enum_operators prod_sel() const
	{ return sel_Throw; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tThrow rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_integer* integer_1;
    impl_tThrow_Throw(standardElements _standardElements_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tRethrow: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tRethrow rewrite(rview) =0;
};
class impl_tRethrow_Rethrow:public impl_tRethrow{
public:
    enum_operators prod_sel() const
	{ return sel_Rethrow; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tRethrow rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_integer* integer_1;
    impl_tRethrow_Rethrow(standardElements _standardElements_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tCompensate: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tCompensate rewrite(rview) =0;
};
class impl_tCompensate_CompensateScope:public impl_tCompensate{
public:
    enum_operators prod_sel() const
	{ return sel_CompensateScope; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tCompensate rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_casestring* casestring_1;
    impl_integer* integer_1;
    impl_tCompensate_CompensateScope(standardElements _standardElements_1, casestring _casestring_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tCompensate_Compensate:public impl_tCompensate{
public:
    enum_operators prod_sel() const
	{ return sel_Compensate; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tCompensate rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_integer* integer_1;
    impl_tCompensate_Compensate(standardElements _standardElements_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tSequence: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tSequence rewrite(rview) =0;
};
class impl_tSequence_Sequence:public impl_tSequence{
public:
    enum_operators prod_sel() const
	{ return sel_Sequence; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tSequence rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_activity_list* activity_list_1;
    impl_integer* integer_1;
    impl_tSequence_Sequence(standardElements _standardElements_1, activity_list _activity_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tIf: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tIf rewrite(rview) =0;
};
class impl_tIf_If:public impl_tIf{
public:
    enum_operators prod_sel() const
	{ return sel_If; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tIf rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tElseIf_list* tElseIf_list_1;
    impl_tElse* tElse_1;
    impl_integer* integer_1;
    impl_tIf_If(standardElements _standardElements_1, tElseIf_list _tElseIf_list_1, tElse _tElse_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tElseIf_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltElseIf_list: sel_ConstElseIf_list;
    }
    explicit impl_tElseIf_list(tElseIf = 0, tElseIf_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tElseIf_list concat(c_tElseIf_list, c_tElseIf_list);
    tElseIf_list reverse() const;
    tElseIf_list rewrite(rview);
    tElseIf last() const;
    tElseIf_list append(tElseIf);
    tElseIf_list map(tElseIf (*)(tElseIf));
    tElseIf_list filter( bool (*)(tElseIf));
    tElseIf_list merge( tElseIf_list, tElseIf (*)(tElseIf, tElseIf));
    tElseIf reduce( tElseIf, tElseIf (*)(tElseIf, tElseIf));
    bool is_nil() const;
    tElseIf tElseIf_1;
    tElseIf_list tElseIf_list_1;
private:
    impl_tElseIf_list* nil_rewrite(rview);
    impl_tElseIf_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tElseIf: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tElseIf rewrite(rview) =0;
};
class impl_tElseIf_ElseIf:public impl_tElseIf{
public:
    enum_operators prod_sel() const
	{ return sel_ElseIf; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tElseIf rewrite( rview );
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tElseIf_ElseIf(activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tElse: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tElse rewrite(rview) =0;
};
class impl_tElse_NoElse:public impl_tElse{
public:
    enum_operators prod_sel() const
	{ return sel_NoElse; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tElse rewrite( rview );
    impl_integer* integer_1;
    impl_tElse_NoElse(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tElse_Else:public impl_tElse{
public:
    enum_operators prod_sel() const
	{ return sel_Else; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tElse rewrite( rview );
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tElse_Else(activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tWhile: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tWhile rewrite(rview) =0;
};
class impl_tWhile_While:public impl_tWhile{
public:
    enum_operators prod_sel() const
	{ return sel_While; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tWhile rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tWhile_While(standardElements _standardElements_1, activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tRepeatUntil: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tRepeatUntil rewrite(rview) =0;
};
class impl_tRepeatUntil_RepeatUntil:public impl_tRepeatUntil{
public:
    enum_operators prod_sel() const
	{ return sel_RepeatUntil; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tRepeatUntil rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_activity* activity_1;
    impl_integer* integer_1;
    impl_tRepeatUntil_RepeatUntil(standardElements _standardElements_1, activity _activity_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tForEach: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tForEach rewrite(rview) =0;
};
class impl_tForEach_ForEach:public impl_tForEach{
public:
    enum_operators prod_sel() const
	{ return sel_ForEach; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tForEach rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_casestring* casestring_1;
    impl_casestring* casestring_2;
    impl_casestring* casestring_3;
    impl_tScope* tScope_1;
    impl_integer* integer_1;
    impl_tForEach_ForEach(standardElements _standardElements_1, casestring _casestring_1, casestring _casestring_2, casestring _casestring_3, tScope _tScope_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tPick: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tPick rewrite(rview) =0;
};
class impl_tPick_Pick:public impl_tPick{
public:
    enum_operators prod_sel() const
	{ return sel_Pick; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tPick rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tOnMessage_list* tOnMessage_list_1;
    impl_tOnAlarm_list* tOnAlarm_list_1;
    impl_integer* integer_1;
    impl_tPick_Pick(standardElements _standardElements_1, tOnMessage_list _tOnMessage_list_1, tOnAlarm_list _tOnAlarm_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tFlow: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tFlow rewrite(rview) =0;
};
class impl_tFlow_Flow:public impl_tFlow{
public:
    enum_operators prod_sel() const
	{ return sel_Flow; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tFlow rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tLink_list* tLink_list_1;
    impl_activity_list* activity_list_1;
    impl_integer* integer_1;
    impl_tFlow_Flow(standardElements _standardElements_1, tLink_list _tLink_list_1, activity_list _activity_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tLink_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltLink_list: sel_ConstLink_list;
    }
    explicit impl_tLink_list(tLink = 0, tLink_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tLink_list concat(c_tLink_list, c_tLink_list);
    tLink_list reverse() const;
    tLink_list rewrite(rview);
    tLink last() const;
    tLink_list append(tLink);
    tLink_list map(tLink (*)(tLink));
    tLink_list filter( bool (*)(tLink));
    tLink_list merge( tLink_list, tLink (*)(tLink, tLink));
    tLink reduce( tLink, tLink (*)(tLink, tLink));
    bool is_nil() const;
    tLink tLink_1;
    tLink_list tLink_list_1;
private:
    impl_tLink_list* nil_rewrite(rview);
    impl_tLink_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tLink: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tLink rewrite(rview) =0;
};
class impl_tLink_Link:public impl_tLink{
public:
    enum_operators prod_sel() const
	{ return sel_Link; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tLink rewrite( rview );
    impl_integer* integer_1;
    impl_tLink_Link(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tScope: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tScope rewrite(rview) =0;
};
class impl_tScope_Scope:public impl_tScope{
public:
    enum_operators prod_sel() const
	{ return sel_Scope; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tScope rewrite( rview );
    impl_standardElements* standardElements_1;
    impl_tVariable_list* tVariable_list_1;
    impl_tMessageExchange_list* tMessageExchange_list_1;
    impl_tFaultHandlers* tFaultHandlers_1;
    impl_tCompensationHandler* tCompensationHandler_1;
    impl_tTerminationHandler* tTerminationHandler_1;
    impl_tEventHandlers* tEventHandlers_1;
    impl_tCorrelationSet_list* tCorrelationSet_list_1;
    impl_activity* activity_1;
    impl_tPartnerLink_list* tPartnerLink_list_1;
    impl_integer* integer_1;
    impl_tScope_Scope(standardElements _standardElements_1, tVariable_list _tVariable_list_1, tMessageExchange_list _tMessageExchange_list_1, tFaultHandlers _tFaultHandlers_1, tCompensationHandler _tCompensationHandler_1, tTerminationHandler _tTerminationHandler_1, tEventHandlers _tEventHandlers_1, tCorrelationSet_list _tCorrelationSet_list_1, activity _activity_1, tPartnerLink_list _tPartnerLink_list_1, integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_standardElements: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    bool suppressJF;
    int parentId;
    standardElements rewrite(rview) =0;
};
class impl_standardElements_NoStandardElements:public impl_standardElements{
public:
    enum_operators prod_sel() const
	{ return sel_NoStandardElements; }
    explicit impl_standardElements_NoStandardElements();

    standardElements rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_standardElements_StandardElements:public impl_standardElements{
public:
    enum_operators prod_sel() const
	{ return sel_StandardElements; }
    explicit impl_standardElements_StandardElements(tTarget_list, tSource_list, joinCondition);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    standardElements rewrite( rview );
    impl_tTarget_list* tTarget_list_1;
    impl_tSource_list* tSource_list_1;
    impl_joinCondition* joinCondition_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTarget_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltTarget_list: sel_ConstTarget_list;
    }
    explicit impl_tTarget_list(tTarget = 0, tTarget_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tTarget_list concat(c_tTarget_list, c_tTarget_list);
    tTarget_list reverse() const;
    tTarget_list rewrite(rview);
    tTarget last() const;
    tTarget_list append(tTarget);
    tTarget_list map(tTarget (*)(tTarget));
    tTarget_list filter( bool (*)(tTarget));
    tTarget_list merge( tTarget_list, tTarget (*)(tTarget, tTarget));
    tTarget reduce( tTarget, tTarget (*)(tTarget, tTarget));
    bool is_nil() const;
    tTarget tTarget_1;
    tTarget_list tTarget_list_1;
private:
    impl_tTarget_list* nil_rewrite(rview);
    impl_tTarget_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tTarget: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tTarget rewrite(rview) =0;
};
class impl_tTarget_Target:public impl_tTarget{
public:
    enum_operators prod_sel() const
	{ return sel_Target; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTarget rewrite( rview );
    impl_integer* integer_1;
    impl_tTarget_Target(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_tSource_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltSource_list: sel_ConstSource_list;
    }
    explicit impl_tSource_list(tSource = 0, tSource_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tSource_list concat(c_tSource_list, c_tSource_list);
    tSource_list reverse() const;
    tSource_list rewrite(rview);
    tSource last() const;
    tSource_list append(tSource);
    tSource_list map(tSource (*)(tSource));
    tSource_list filter( bool (*)(tSource));
    tSource_list merge( tSource_list, tSource (*)(tSource, tSource));
    tSource reduce( tSource, tSource (*)(tSource, tSource));
    bool is_nil() const;
    tSource tSource_1;
    tSource_list tSource_list_1;
private:
    impl_tSource_list* nil_rewrite(rview);
    impl_tSource_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tSource: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tSource rewrite(rview) =0;
};
class impl_tSource_Source:public impl_tSource{
public:
    enum_operators prod_sel() const
	{ return sel_Source; }
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tSource rewrite( rview );
    impl_integer* integer_1;
    impl_tSource_Source(integer _integer_1);
private:
    void do_unparse(printer_functor, uview);
};
class impl_joinCondition: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    int parentId;
    joinCondition rewrite(rview) =0;
};
class impl_joinCondition_userDefinedJoinCondition:public impl_joinCondition{
public:
    enum_operators prod_sel() const
	{ return sel_userDefinedJoinCondition; }
    explicit impl_joinCondition_userDefinedJoinCondition(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    joinCondition rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_joinCondition_standardJoinCondition:public impl_joinCondition{
public:
    enum_operators prod_sel() const
	{ return sel_standardJoinCondition; }
    explicit impl_joinCondition_standardJoinCondition();

    joinCondition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    int parentId;
    bool value;
    expression rewrite(rview) =0;
};
class impl_expression_Disjunction:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Disjunction; }
    explicit impl_expression_Disjunction(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Conjunction:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Conjunction; }
    explicit impl_expression_Conjunction(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Term:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Term; }
    explicit impl_expression_Term(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};

//} // namespace Phylum


extern bool kc_storageclass_still_uniq[];

typedef struct {
    int created;
    int existing_not_found;
    int free_called[2];
    int freed[2];
} KC_OPERATOR_STATISTICS;

#ifdef KC_STATISTICS
# define print_operator_statistics(kc_f) do_print_operator_statistics(kc_f)
void	do_print_operator_statistics(FILE*);
#else
# define print_operator_statistics(kc_f)
#endif

typedef class hashtable_struct_t* hashtable_t;
void	ht_static (kc_storageclass_t);
void	ht_dynamic (kc_storageclass_t);
void	ht_inc_level (kc_storageclass_t);
void	ht_dec_level (kc_storageclass_t);
void	ht_free_level (kc_storageclass_t);
hashtable_t	ht_create_simple ();
hashtable_t	ht_assign (hashtable_t, kc_storageclass_t, bool still_unique=false);
hashtable_t	ht_assigned (kc_storageclass_t);
void	ht_clear (hashtable_t);
void	ht_delete (hashtable_t);
const char *phylumname_or_error ( enum_phyla );
const char *kc_operatorname_or_error ( enum_operators );


void fprintdotprologue ( FILE* );
void fprintdotepilogue ( FILE* );

} // namespace kc
#endif // KC_TYPES_HEADER
