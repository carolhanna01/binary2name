This is gnuastro.info, produced by makeinfo version 6.7 from
gnuastro.texi.

This book documents version 0.12 of the GNU Astronomy Utilities
(Gnuastro).  Gnuastro provides various programs and libraries for
astronomical data manipulation and analysis.

   Copyright © 2015-2020, Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled “GNU Free Documentation License”.
INFO-DIR-SECTION Astronomy
START-INFO-DIR-ENTRY
* Gnuastro: (gnuastro).       GNU Astronomy Utilities.
* libgnuastro: (gnuastro)Gnuastro library. Full Gnuastro library doc.

* help-gnuastro: (gnuastro)help-gnuastro mailing list. Getting help.

* bug-gnuastro: (gnuastro)Report a bug. How to report bugs

* Arithmetic: (gnuastro)Arithmetic. Arithmetic operations on pixels.
* astarithmetic: (gnuastro)Invoking astarithmetic. Options to Arithmetic.

* BuildProgram: (gnuastro)BuildProgram. Compile and run programs using Gnuastro’s library.
* astbuildprog: (gnuastro)Invoking astbuildprog. Options to BuildProgram.

* ConvertType: (gnuastro)ConvertType. Convert different file types.
* astconvertt: (gnuastro)Invoking astconvertt. Options to ConvertType.

* Convolve: (gnuastro)Convolve. Convolve an input file with kernel.
* astconvolve: (gnuastro)Invoking astconvolve. Options to Convolve.

* CosmicCalculator: (gnuastro)CosmicCalculator. For cosmological params.
* astcosmiccal: (gnuastro)Invoking astcosmiccal. Options to CosmicCalculator.

* Crop: (gnuastro)Crop. Crop region(s) from image(s).
* astcrop: (gnuastro)Invoking astcrop. Options to Crop.

* Fits: (gnuastro)Fits. View and manipulate FITS extensions and keywords.
* astfits: (gnuastro)Invoking astfits. Options to Fits.

* MakeCatalog: (gnuastro)MakeCatalog. Make a catalog from labeled image.
* astmkcatalog: (gnuastro)Invoking astmkcatalog. Options to MakeCatalog.

* MakeNoise: (gnuastro)MakeNoise. Make (add) noise to an image.
* astmknoise: (gnuastro)Invoking astmknoise. Options to MakeNoise.

* MakeProfiles: (gnuastro)MakeProfiles. Make mock profiles.
* astmkprof: (gnuastro)Invoking astmkprof. Options to MakeProfiles.

* Match: (gnuastro)Match. Match two separate catalogs.
* astmatch: (gnuastro)Invoking astmatch. Options to Match.

* NoiseChisel: (gnuastro)NoiseChisel. Detect signal in noise.
* astnoisechisel: (gnuastro)Invoking astnoisechisel. Options to NoiseChisel.

* Segment: (gnuastro)Segment. Segment detections based on signal structure.
* astsegment: (gnuastro)Invoking astsegment. Options to Segment.

* Statistics: (gnuastro)Statistics. Get image Statistics.
* aststatistics: (gnuastro)Invoking aststatistics. Options to Statistics.

* Table: (gnuastro)Table. Read and write FITS binary or ASCII tables.
* asttable: (gnuastro)Invoking asttable. Options to Table.

* Warp: (gnuastro)Warp. Warp a dataset to a new grid.
* astwarp: (gnuastro)Invoking astwarp. Options to Warp.

* astscript-sort-by-night: (gnuastro)Invoking astscript-sort-by-night. Options to this script

END-INFO-DIR-ENTRY


File: gnuastro.info,  Node: Gnuastro's thread related functions,  Prev: Implementation of pthread_barrier,  Up: Multithreaded programming

10.3.2.2 Gnuastro’s thread related functions
............................................

The POSIX Threads functions offered in the C library are very low-level
and offer a great range of control over the properties of the threads.
So if you are interested in customizing your tools for complicated
thread applications, it is strongly encouraged to get a nice familiarity
with them.  Some resources were introduced in *note Multithreaded
programming::.

   However, in many cases used in astronomical data analysis, you don’t
need communication between threads and each target operation can be done
independently.  Since such operations are very common, Gnuastro provides
the tools below to facilitate the creation and management of jobs
without any particular knowledge of POSIX Threads for such operations.
The most interesting high-level functions of this section are the
‘gal_threads_number’ and ‘gal_threads_spin_off’ that identify the number
of threads on the system and spin-off threads.  You can see a
demonstration of using these functions in *note Library demo -
multi-threaded operation::.

 -- C ‘struct’: gal_threads_params
     Structure keeping the parameters of each thread.  When each thread
     is created, a pointer to this structure is passed to it.  The
     ‘params’ element can be the pointer to a structure defined by the
     user which contains all the necessary parameters to pass onto the
     worker function.  The rest of the elements within this structure
     are set internally by ‘gal_threads_spin_off’ and are relevant to
     the worker function.
          struct gal_threads_params
          {
            size_t            id; /* Id of this thread.                  */
            void         *params; /* User-identified pointer.            */
            size_t       *indexs; /* Target indexs given to this thread. */
            pthread_barrier_t *b; /* Barrier for all threads.            */
          };

 -- Function:
          size_t
          gal_threads_number ()
     Return the number of threads that the operating system has
     available for your program.  This number is usually fixed for a
     single machine and doesn’t change.  So this function is useful when
     you want to run your program on different machines (with different
     CPUs).

 -- Function:
          void
          gal_threads_spin_off (void ‘*(*worker)(void *)’, void
          ‘*caller_params’, size_t ‘numactions’, size_t ‘numthreads’)
     Distribute ‘numactions’ jobs between ‘numthreads’ threads and
     spin-off each thread by calling the ‘worker’ function.  The
     ‘caller_params’ pointer will also be passed to ‘worker’ as part of
     the ‘gal_threads_params’ structure.  For a fully working example of
     this function, please see *note Library demo - multi-threaded
     operation::.

 -- Function:
          void
          gal_threads_attr_barrier_init (pthread_attr_t ‘*attr’,
          pthread_barrier_t ‘*b’, size_t ‘limit’)
     This is a low-level function in case you don’t want to use
     ‘gal_threads_spin_off’.  It will initialize the general thread
     attribute ‘attr’ and the barrier ‘b’ with ‘limit’ threads to wait
     behind the barrier.  For maximum efficiency, the threads
     initialized with this function will be detached.  Therefore no
     communication is possible between these threads and in particular
     ‘pthread_join’ won’t work on these threads.  You have to use the
     barrier constructs to wait for all threads to finish.

 -- Function:
          void
          gal_threads_dist_in_threads (size_t ‘numactions’, size_t
          ‘numthreads’, size_t ‘**outthrds’, size_t ‘*outthrdcols’)
     This is a low-level function in case you don’t want to use
     ‘gal_threads_spin_off’.  Identify the “index”es (starting from 0)
     of the actions to be done on each thread in the ‘outthrds’ array.
     ‘outthrds’ is treated as a 2D array with ‘numthreads’ rows and
     ‘outthrdcols’ columns.  The indexs in each row, identify the
     actions that should be done by one thread.  Please see the
     explanation below to understand the purpose of this operation.

     Let’s assume you have $A$ actions (where there is only one function
     and the input values differ for each action) and $T$ threads
     available to the system with $A>T$ (common values for these two
     would be $A>1000$ and $T<10$).  Spinning off a thread is not a
     cheap job and requires a significant number of CPU cycles.
     Therefore, creating $A$ threads is not the best way to address such
     a problem.  The most efficient way to manage the actions is such
     that only $T$ threads are created, and each thread works on a list
     of actions identified for it in series (one after the other).  This
     way your CPU will get all the actions done with minimal overhead.

     The purpose of this function is to do what we explained above: each
     row in the ‘outthrds’ array contains the indexs of actions which
     must be done by one thread.  ‘outthrds’ contains ‘outthrdcols’
     columns.  In using ‘outthrds’, you don’t have to know the number of
     columns.  The ‘GAL_BLANK_SIZE_T’ macro has a role very similar to a
     string’s ‘\0’: every row finishes with this macro, so can easily
     stop parsing the indexes in the row when you confront it.  Please
     see the example program in ‘tests/lib/multithread.c’ for a
     demonstration.


File: gnuastro.info,  Node: Library data types,  Next: Pointers,  Prev: Multithreaded programming,  Up: Gnuastro library

10.3.3 Library data types (‘type.h’)
------------------------------------

Data in astronomy can have many types, numeric (numbers) and strings
(names, identifiers).  The former can also be divided into integers and
floats, see *note Numeric data types:: for a thorough discussion of the
different numeric data types and which one is useful for different
contexts.

   To deal with the very large diversity of types that are available
(and used in different contexts), in Gnuastro each type is identified
with global integer variable with a fixed name, this variable is then
passed onto functions that can work on any type or is stored in
Gnuastro’s *note Generic data container:: as one piece of meta-data.

   The actual values within these integer constants is irrelevant and
you should never rely on them.  When you need to check, explicitly use
the named variable in the table below.  If you want to check with more
than one type, you can use C’s ‘switch’ statement.

   Since Gnuastro heavily deals with file input-output, the types it
defines are fixed width types, these types are portable to all systems
and are defined in the standard C header ‘stdint.h’.  You don’t need to
include this header, it is included by any Gnuastro header that deals
with the different types.  However, the most commonly used types in a C
(or C++) program (for example ‘int’ or ‘long’) are not defined by their
exact width (storage size), but by their minimum storage.  So for
example on some systems, ‘int’ may be 2 bytes (16-bits, the minimum
required by the standard) and on others it may be 4 bytes (32-bits,
common in modern systems).

   With every type, a unique “blank” value (or place holder showing the
absence of data) can be defined.  Please see *note Library blank
values:: for constants that Gnuastro recognizes as a blank value for
each type.  See *note Numeric data types:: for more explanation on the
limits and particular aspects of each type.

 -- Global integer: GAL_TYPE_INVALID
     This is just a place holder to specifically mark that no type has
     been set.

 -- Global integer: GAL_TYPE_BIT
     Identifier for a bit-stream.  Currently no program in Gnuastro
     works directly on bits, but features will be added in the future.

 -- Global integer: GAL_TYPE_UINT8
     Identifier for an unsigned, 8-bit integer type: ‘uint8_t’ (from
     ‘stdint.h’), or an ‘unsigned char’ in most modern systems.

 -- Global integer: GAL_TYPE_INT8
     Identifier for a signed, 8-bit integer type: ‘int8_t’ (from
     ‘stdint.h’), or an ‘signed char’ in most modern systems.

 -- Global integer: GAL_TYPE_UINT16
     Identifier for an unsigned, 16-bit integer type: ‘uint16_t’ (from
     ‘stdint.h’), or an ‘unsigned short’ in most modern systems.

 -- Global integer: GAL_TYPE_INT16
     Identifier for a signed, 16-bit integer type: ‘int16_t’ (from
     ‘stdint.h’), or a ‘short’ in most modern systems.

 -- Global integer: GAL_TYPE_UINT32
     Identifier for an unsigned, 32-bit integer type: ‘uint32_t’ (from
     ‘stdint.h’), or an ‘unsigned int’ in most modern systems.

 -- Global integer: GAL_TYPE_INT32
     Identifier for a signed, 32-bit integer type: ‘int32_t’ (from
     ‘stdint.h’), or an ‘int’ in most modern systems.

 -- Global integer: GAL_TYPE_UINT64
     Identifier for an unsigned, 64-bit integer type: ‘uint64_t’ (from
     ‘stdint.h’), or an ‘unsigned long’ in most modern 64-bit systems.

 -- Global integer: GAL_TYPE_INT64
     Identifier for a signed, 64-bit integer type: ‘int64_t’ (from
     ‘stdint.h’), or an ‘long’ in most modern 64-bit systems.

 -- Global integer: GAL_TYPE_INT
     Identifier for a ‘int’ type.  This is just an alias to ‘int16’, or
     ‘int32’ types, depending on the system.

 -- Global integer: GAL_TYPE_UINT
     Identifier for a ‘unsigned int’ type.  This is just an alias to
     ‘uint16’, or ‘uint32’ types, depending on the system.

 -- Global integer: GAL_TYPE_ULONG
     Identifier for a ‘unsigned long’ type.  This is just an alias to
     ‘uint32’, or ‘uint64’ types for 32-bit, or 64-bit systems
     respectively.

 -- Global integer: GAL_TYPE_LONG
     Identifier for a ‘long’ type.  This is just an alias to ‘int32’, or
     ‘int64’ types for 32-bit, or 64-bit systems respectively.

 -- Global integer: GAL_TYPE_SIZE_T
     Identifier for a ‘size_t’ type.  This is just an alias to ‘uint32’,
     or ‘uint64’ types for 32-bit, or 64-bit systems respectively.

 -- Global integer: GAL_TYPE_FLOAT32
     Identifier for a 32-bit single precision floating point type or
     ‘float’ in C.

 -- Global integer: GAL_TYPE_FLOAT64
     Identifier for a 64-bit double precision floating point type or
     ‘double’ in C.

 -- Global integer: GAL_TYPE_COMPLEX32
     Identifier for a complex number composed of two ‘float’ types.
     Note that the complex type is not yet fully implemented in all
     Gnuastro’s programs.

 -- Global integer: GAL_TYPE_COMPLEX64
     Identifier for a complex number composed of two ‘double’ types.
     Note that the complex type is not yet fully implemented in all
     Gnuastro’s programs.

 -- Global integer: GAL_TYPE_STRING
     Identifier for a string of characters (‘char *’).

 -- Global integer: GAL_TYPE_STRLL
     Identifier for a linked list of string of characters
     (‘gal_list_str_t’, see *note List of strings::).

The functions below are defined to make working with the integer
constants above easier.  In the functions below, the constants above can
be used for the ‘type’ input argument.

 -- Function:
          size_t
          gal_type_sizeof (uint8_t ‘type’)
     Return the number of bytes occupied by ‘type’.  Internally, this
     function uses C’s ‘sizeof’ operator to measure the size of each
     type.

 -- Function:
          char *
          gal_type_name (uint8_t ‘type’, int ‘long_name’)
     Return a string literal that contains the name of ‘type’.  It can
     return both short and long formats of the type names (for example
     ‘f32’ and ‘float32’).  If ‘long_name’ is non-zero, the long format
     will be returned, otherwise the short name will be returned.  The
     output string is statically allocated, so it should not be freed.
     This function is the inverse of the ‘gal_type_from_name’ function.
     For the full list of names/strings that this function will return,
     see *note Numeric data types::.

 -- Function:
          uint8_t
          gal_type_from_name (char ‘*str’)
     Return the Gnuastro integer constant that corresponds to the string
     ‘str’.  This function is the inverse of the ‘gal_type_name’
     function and accepts both the short and long formats of each type.
     For the full list of names/strings that this function will return,
     see *note Numeric data types::.

 -- Function:
          void
          gal_type_min (uint8_t ‘type’, void ‘*in’)
     Put the minimum possible value of ‘type’ in the space pointed to by
     ‘in’.  Since the value can have any type, this function doesn’t
     return anything, it assumes the space for the given type is
     available to ‘in’ and writes the value there.  Here is one example
          int32_t min;
          gal_type_min(GAL_TYPE_INT32, &min);

     Note: Do not use the minimum value for a blank value of a general
     (initially unknown) type, please use the constants/functions
     provided in *note Library blank values:: for the definition and
     usage of blank values.

 -- Function:
          void
          gal_type_max (uint8_t ‘type’, void ‘*in’)
     Put the maximum possible value of ‘type’ in the space pointed to by
     ‘in’.  Since the value can have any type, this function doesn’t
     return anything, it assumes the space for the given type is
     available to ‘in’ and writes the value there.  Here is one example
          uint16_t max;
          gal_type_max(GAL_TYPE_INT16, &max);

     Note: Do not use the maximum value for a blank value of a general
     (initially unknown) type, please use the constants/functions
     provided in *note Library blank values:: for the definition and
     usage of blank values.

 -- Function:
          int
          gal_type_is_int (uint8_t ‘type’)
     Return 1 if the type is an integer (any width and any sign).

 -- Function:
          int
          gal_type_is_list (uint8_t ‘type’)
     Return 1 if the type is a linked list and zero otherwise.

 -- Function:
          int
          gal_type_out (int ‘first_type’, int ‘second_type’)
     Return the larger of the two given types which can be used for the
     type of the output of an operation involving the two input types.

 -- Function:
          char *
          gal_type_bit_string (void ‘*in’, size_t ‘size’)
     Return the bit-string in the ‘size’ bytes that ‘in’ points to.  The
     string is dynamically allocated and must be freed afterwards.  You
     can use it to inspect the bits within one region of memory.  Here
     is one short example:

          int32_t a=2017;
          char *bitstr=gal_type_bit_string(&a, 4);
          printf("%d: %s (%X)\n", a, bitstr, a);
          free(bitstr);

     which will produce:
          2017: 11100001000001110000000000000000  (7E1)

     As the example above shows, the bit-string is not the most
     efficient way to inspect bits.  If you are familiar with
     hexadecimal notation, it is much more compact, see
     <https://en.wikipedia.org/wiki/Hexadecimal>.  You can use
     ‘printf’’s ‘%x’ or ‘%X’ to print integers in hexadecimal format.

 -- Function:
          char *
          gal_type_to_string (void ‘*ptr’, uint8_t ‘type’, int
          ‘quote_if_str_has_space’);
     Read the contents of the memory that ‘ptr’ points to (assuming it
     has type ‘type’ and print it into an allocated string which is
     returned.

     If the memory is a string of characters and
     ‘quote_if_str_has_space’ is non-zero, the output string will have
     double-quotes around it if it contains space characters.  Also,
     note that in this case, ‘ptr’ must be a pointer to an array of
     characters (or ‘char **’), as in the example below (which will put
     ‘"sample string"’ into ‘out’):

          char *out, *string="sample string"
          out = gal_type_to_string(&string, GAL_TYPE_STRING, 1);

 -- Function:
          int
          gal_type_from_string (void ‘**out’, char ‘*string’, uint8_t
          ‘type’)
     Read a string as a given data type and put a pointer to it in
     ‘*out’.  When ‘*out!=NULL’, then it is assumed to be already
     allocated and the value will be simply put there.  If ‘*out==NULL’,
     then space will be allocated for the given type and the string will
     be read into that type.

     Note that when we are dealing with a string type, ‘*out’ should be
     interpreted as ‘char **’ (one element in an array of pointers to
     different strings).  In other words, ‘out’ should be ‘char ***’.

     This function can be used to fill in arrays of numbers from strings
     (in an already allocated data structure), or add nodes to a linked
     list (if the type is a list type).  For an array, you have to pass
     the pointer to the ‘i’th element where you want the value to be
     stored, for example ‘&(array[i])’.

     If the string was successfully parsed to the requested type, this
     function will return a ‘0’ (zero), otherwise it will return ‘1’
     (one).  This output format will help you check the status of the
     conversion in a code like the example below:

          if( gal_type_from_string(&out, string, GAL_TYPE_FLOAT32) )
            {
              fprintf(stderr, "%s couldn't be read as float32.\n", string);
              exit(EXIT_FAILURE);
            }

 -- Function:
          void *
          gal_type_string_to_number (char ‘*string’, uint8_t ‘*type’)
     Read ‘string’ into smallest type that can host the number, the
     allocated space for the number will be returned and the type of the
     number will be put into the memory that ‘type’ points to.  If
     ‘string’ couldn’t be read as a number, this function will return
     ‘NULL’.

     For the ranges acceptable by each type see *note Numeric data
     types::.  For integers it is clear, for floating point types, this
     function will count the number of significant digits and determine
     if the given string is single or double precision as described in
     that section.


File: gnuastro.info,  Node: Pointers,  Next: Library blank values,  Prev: Library data types,  Up: Gnuastro library

10.3.4 Pointers (‘pointer.h’)
-----------------------------

Pointers play an important role in the C programming language.  As the
name suggests, they _point_ to a byte in memory (like an address in a
city).  The C programming language gives you complete freedom in how to
use the byte (and the bytes that follow it).  Pointers are thus a very
powerful feature of C. However, as the saying goes: “With great power
comes great responsibility”, so they must be approached with care.  The
functions in this header are not very complex, they are just wrappers
over some basic pointer functionality regarding pointer arithmetic and
allocation (in memory or HDD/SSD).

 -- Function:
          void *
          gal_pointer_increment (void ‘*pointer’, size_t ‘increment’,
          uint8_t ‘type’)
     Return a pointer to an element that is ‘increment’ elements ahead
     of ‘pointer’, assuming each element has type of ‘type’.  For the
     type codes, see *note Library data types::.

     When working with the ‘array’ elements of ‘gal_data_t’, we are
     actually dealing with ‘void *’ pointers.  However, pointer
     arithmetic doesn’t apply to ‘void *’, because the system doesn’t
     know how many bytes there are in each element to increment the
     pointer respectively.  This function will use the given ‘type’ to
     calculate where the incremented element is located in memory.

 -- Function:
          size_t
          gal_pointer_num_between (void ‘*earlier’, void ‘*later’,
          uint8_t ‘type’)
     Return the number of elements (in the given ‘type’) between
     ‘earlier’ and ‘later’.  For the type codes, see *note Library data
     types::).

 -- Function:
          void *
          gal_pointer_allocate (uint8_t ‘type’, size_t ‘size’, int
          ‘clear’, const char ‘*funcname’, const char ‘*varname’)
     Allocate an array of type ‘type’ with ‘size’ elements in RAM (for
     the type codes, see *note Library data types::).  If ‘clear!=0’,
     then the allocated space is set to zero (cleared).  This is
     effectively just a wrapper around C’s ‘malloc’ or ‘calloc’
     functions but takes Gnuastro’s integer type codes and will also
     abort with a clear error if there the allocation was not
     successful.

     When space cannot be allocated, this function will abort the
     program with a message containing the reason for the failure.
     ‘funcname’ (name of the function calling this function) and
     ‘varname’ (name of variable that needs this space) will be used in
     this error message if they are not ‘NULL’.  In most modern
     compilers, you can use the generic ‘__func__’ variable for
     ‘funcname’.  In this way, you don’t have to manually copy and paste
     the function name or worry about it changing later (‘__func__’ was
     standardized in C99).

 -- Function:
          void *
          gal_pointer_allocate_mmap (size_t ‘size’, uint8_t ‘type’, int
          ‘clear’, char ‘**mmapname’)
     Allocate the necessary space to keep ‘size’ elements of type ‘type’
     in HDD/SSD (a file, not in RAM). for the type codes, see *note
     Library data types::.  If ‘clear!=0’, then the allocated space will
     also be cleared.  The allocation is done using C’s ‘mmap’ function.
     The name of the file containing the allocated space is an allocated
     string that will be put in ‘*mmapname’.

     Note that the kernel doesn’t allow an infinite number of memory
     mappings to files.  So it is not recommended to use this function
     with every allocation.  The best case scenario to use this function
     is for large arrays that are very large and can fill up the RAM.
     Keep the smaller arrays in RAM, which is faster and can have a
     (theoretically) unlimited number of allocations.

     When you are done with the dataset and don’t need it anymore, don’t
     use ‘free’ (the dataset isn’t in RAM). Just delete the file (and
     the allocated space for the filename) with the commands below:

          remove(mmapname);
          free(mmapname);


File: gnuastro.info,  Node: Library blank values,  Next: Library data container,  Prev: Pointers,  Up: Gnuastro library

10.3.5 Library blank values (‘blank.h’)
---------------------------------------

When the position of an element in a dataset is important (for example a
pixel in an image), a place-holder is necessary for the element if we
don’t have a value to fill it with (for example the CCD cannot read
those pixels).  We cannot simply shift all the other pixels to fill in
the one we have no value for.  In other cases, it often occurs that the
field of sky that you are studying is not a clean rectangle to nicely
fit into the boundaries of an image.  You need a way to separate the
pixels outside your scientific field from those inside it.  Blank values
act as these place holders in a dataset.  They have no usable value but
they have a position.

   Every type needs a corresponding blank value (see *note Numeric data
types:: and *note Library data types::).  Floating point types have a
unique value identified by IEEE known as Not-a-Number (or NaN) which is
a unique value that is recognized by the compiler.  However, integer and
string types don’t have any standard value.  For integers, in Gnuastro
we take an extremum of the given type: for signed types (that allow
negatives), the minimum possible value is used as blank and for unsigned
types (that only accept positives), the maximum possible value is used.
To be generic and easy to read/write we define a macro for these blank
values and strongly encourage you only use these, and never make any
assumption on the value of a type’s blank value.

   The IEEE NaN blank value type is defined to fail on any comparison,
so if you are dealing with floating point types, you cannot use equality
(a NaN will _not_ be equal to a NaN). If you know your dataset if
floating point, you can use the ‘isnan’ function in C’s ‘math.h’ header.
For a description of numeric data types see *note Numeric data types::.
For the constants identifying integers, please see *note Library data
types::.

 -- Global integer: GAL_BLANK_UINT8
     Blank value for an unsigned, 8-bit integer.

 -- Global integer: GAL_BLANK_INT8
     Blank value for a signed, 8-bit integer.

 -- Global integer: GAL_BLANK_UINT16
     Blank value for an unsigned, 16-bit integer.

 -- Global integer: GAL_BLANK_INT16
     Blank value for a signed, 16-bit integer.

 -- Global integer: GAL_BLANK_UINT32
     Blank value for an unsigned, 32-bit integer.

 -- Global integer: GAL_BLANK_INT32
     Blank value for a signed, 32-bit integer.

 -- Global integer: GAL_BLANK_UINT64
     Blank value for an unsigned, 64-bit integer.

 -- Global integer: GAL_BLANK_INT64
     Blank value for a signed, 64-bit integer.

 -- Global integer: GAL_BLANK_INT
     Blank value for ‘int’ type (‘int16_t’ or ‘int32_t’ depending on the
     system.

 -- Global integer: GAL_BLANK_UINT
     Blank value for ‘int’ type (‘int16_t’ or ‘int32_t’ depending on the
     system.

 -- Global integer: GAL_BLANK_LONG
     Blank value for ‘long’ type (‘int32_t’ or ‘int64_t’ in 32-bit or
     64-bit systems).

 -- Global integer: GAL_BLANK_ULONG
     Blank value for ‘unsigned long’ type (‘uint32_t’ or ‘uint64_t’ in
     32-bit or 64-bit systems).

 -- Global integer: GAL_BLANK_SIZE_T
     Blank value for ‘size_t’ type (‘uint32_t’ or ‘uint64_t’ in 32-bit
     or 64-bit systems).

 -- Global integer: GAL_BLANK_FLOAT32
     Blank value for a single precision, 32-bit floating point type
     (IEEE NaN value).

 -- Global integer: GAL_BLANK_FLOAT64
     Blank value for a double precision, 64-bit floating point type
     (IEEE NaN value).

 -- Global integer: GAL_BLANK_STRING
     Blank value for string types (this is itself a string, it isn’t the
     ‘NULL’ pointer).

The functions below can be used to work with blank pixels.

 -- Function:
          void
          gal_blank_write (void ‘*pointer’, uint8_t ‘type’)
     Write the blank value for the given ‘type’ into the space that
     ‘pointer’ points to.  This can be used when the space is already
     allocated (for example one element in an array or a statically
     allocated variable).

 -- Function:
          void *
          gal_blank_alloc_write (uint8_t ‘type’)
     Allocate the space required to keep the blank for the given data
     type ‘type’, write the blank value into it and return the pointer
     to it.

 -- Function:
          void
          gal_blank_initialize (gal_data_t ‘*input’)
     Initialize all the elements in the ‘input’ dataset to the blank
     value that corresponds to its type.  If ‘input’ is a tile over a
     larger dataset, only the region that the tile covers will be set to
     blank.

 -- Function:
          void
          gal_blank_initialize_array (void ‘*array’, size_t ‘size’,
          uint8_t ‘type’)
     Initialize all the elements in the ‘array’ to the blank value that
     corresponds to its type (identified with ‘type’), assuming the
     array has ‘size’ elements.

 -- Function:
          char *
          gal_blank_as_string (uint8_t ‘type’, int ‘width’)
     Write the blank value for the given data type ‘type’ into a string
     and return it.  The space for the string is dynamically allocated
     so it must be freed after you are done with it.  If ‘width!=0’,
     then the final string will be padded with white space characters to
     have the requested width if it is smaller.

 -- Function:
          int
          gal_blank_is (void ‘*pointer’, uint8_t ‘type’)
     Return 1 if the contents of ‘pointer’ (assuming a type of ‘type’)
     is blank.  Otherwise, return 0.  Note that this function only works
     on one element of the given type.  So if ‘pointer’ is an array,
     only its first element will be checked.  Therefore for strings, the
     type of ‘pointer’ is assumed to be ‘char *’.  To check if an
     array/dataset has blank elements or to find which elements in an
     array are blank, you can use ‘gal_blank_present’ or
     ‘gal_blank_flag’ respectively (described below).

 -- Function:
          int
          gal_blank_present (gal_data_t ‘*input’, int ‘updateflag’)
     Return 1 if the dataset has a blank value and zero if it doesn’t.
     Before checking the dataset, this function will look at ‘input’’s
     flags.  If the ‘GAL_DATA_FLAG_BLANK_CH’ bit of ‘input->flag’ is on,
     this function will not do any check and will just use the
     information in the flags.  This can greatly speed up processing
     when a dataset needs to be checked multiple times.

     When the dataset’s flags were not used and ‘updateflags’ is
     non-zero, this function will set the flags appropriately to avoid
     having to re-check the dataset in future calls.  When
     ‘updateflags==0’, this function has no side-effects on the dataset:
     it will not toggle the flags.

     If you want to re-check a dataset with the blank-value-check flag
     already set (for example if you have made changes to it), then
     explicitly set the ‘GAL_DATA_FLAG_BLANK_CH’ bit to zero before
     calling this function.  When there are no other flags, you can just
     set the flags to zero (‘input->flag=0’), otherwise you can use this
     expression:

          input->flag &= ~GAL_DATA_FLAG_BLANK_CH;

 -- Function:
          size_t
          gal_blank_number (gal_data_t ‘*input’, int ‘updateflag’)
     Return the number of blank elements in ‘input’.  If
     ‘updateflag!=0’, then the dataset blank keyword flags will be
     updated.  See the description of ‘gal_blank_present’ (above) for
     more on these flags.  If ‘input==NULL’, then this function will
     return ‘GAL_BLANK_SIZE_T’.

 -- Function:
          gal_data_t *
          gal_blank_flag (gal_data_t ‘*input’)
     Create a dataset of the same size as the input, but with an
     ‘uint8_t’ type that has a value of 1 for data that are blank and 0
     for those that aren’t.

 -- Function:
          void
          gal_blank_flag_apply (gal_data_t ‘*input’, gal_data_t ‘*flag’)
     Set all non-zero and non-blank elements of ‘flag’ to blank in
     ‘input’.  ‘flag’ has to have an unsigned 8-bit type and be the same
     size as ‘input’.

 -- Function:
          void
          gal_blank_remove (gal_data_t ‘*input’)
     Remove blank elements from a dataset, convert it to a 1D dataset,
     adjust the size properly (the number of non-blank elements), and
     toggle the blank-value-related bit-flags.  In practice this
     function doesn’t‘realloc’ the input array (see
     ‘gal_blank_remove_realloc’ for shrinking/re-allocating also), it
     just shifts the blank elements to the end and adjusts the size
     elements of the ‘gal_data_t’, see *note Generic data container::.

     If all the elements were blank, then ‘input->size’ will be zero.
     This is thus a good parameter to check after calling this function
     to see if there actually were any non-blank elements in the input
     or not and take the appropriate measure.  This check is highly
     recommended because it will avoid strange bugs in later steps.

 -- Function:
          void
          gal_blank_remove_realloc (gal_data_t ‘*input’)
     Similar to ‘gal_blank_remove’, but also shrinks/re-allocates the
     dataset’s allocated memory.


File: gnuastro.info,  Node: Library data container,  Next: Dimensions,  Prev: Library blank values,  Up: Gnuastro library

10.3.6 Data container (‘data.h’)
--------------------------------

Astronomical datasets have various dimensions, for example 1D spectra or
table columns, 2D images, or 3D Integral field data cubes.  Datasets can
also have various numeric data types, depending on the
operation/purpose, for example processed images are commonly stored in
floating point format, but their mask images are integers (allowing
bit-wise flags to identify certain classes of pixels to keep or mask,
see *note Numeric data types::).  Certain other information about a
dataset are also commonly necessary, for example the units of the
dataset, the name of the dataset and some comments.  To deal with any
generic dataset, Gnuastro defines the ‘gal_data_t’ as input or output.

* Menu:

* Generic data container::      Definition of Gnuastro’s generic container.
* Dataset allocation::          Allocate, initialize and free a dataset.
* Arrays of datasets::          Functions to help with array of datasets.
* Copying datasets::            Functions to copy a dataset to a new one.


File: gnuastro.info,  Node: Generic data container,  Next: Dataset allocation,  Prev: Library data container,  Up: Library data container

10.3.6.1 Generic data container (‘gal_data_t’)
..............................................

To be able to deal with any dataset (various dimensions, numeric data
types, units and higher-level structures), Gnuastro defines the
‘gal_data_t’ type which is the input/output container of choice for many
of Gnuastro library’s functions.  It is defined in ‘gnuastro/data.h’.
If you will be using (‘‘# include’’ing) those libraries, you don’t need
to include this header explicitly, it is already included by any library
header that uses ‘gal_data_t’.

 -- Type (C ‘struct’): gal_data_t
     The main container for datasets in Gnuastro.  It can host data of
     any dimensions, with any numeric data type.  It is actually a
     structure, but ‘typedef’’d as a new type to avoid having to write
     the ‘struct’ before any declaration.  The actual structure is shown
     below which is followed by a description of each element.

          typedef struct gal_data_t
          {
            void     *restrict array;  /* Basic array information.   */
            uint8_t             type;
            size_t              ndim;
            size_t            *dsize;
            size_t              size;
            int            quietmmap;
            char           *mmapname;
            size_t        minmapsize;

            int                 nwcs;  /* WCS information.           */
            struct wcsprm       *wcs;

            uint8_t             flag;  /* Content description.       */
            int               status;
            char               *name;
            char               *unit;
            char            *comment;

            int             disp_fmt;  /* For text printing.         */
            int           disp_width;
            int       disp_precision;

            struct gal_data_t  *next;  /* For higher-level datasets. */
            struct gal_data_t *block;
          } gal_data_t;

The list below contains a description for each ‘gal_data_t’ element.

‘void *restrict array’
     This is the pointer to the main array of the dataset containing the
     raw data (values).  All the other elements in this data-structure
     are actually meta-data enabling us to use/understand the series of
     values in this array.  It must allow data of any type (see *note
     Numeric data types::), so it is defined as a ‘void *’ pointer.  A
     ‘void *’ array is not directly usable in C, so you have to cast it
     to proper type before using it, please see *note Library demo -
     reading a image:: for a demonstration.

     The ‘restrict’ keyword was formally introduced in C99 and is used
     to tell the compiler that at any moment only this pointer will
     modify what it points to (a pixel in an image for example)(1).
     This extra piece of information can greatly help in compiler
     optimizations and thus the running time of the program.  But older
     compilers might not have this capability, so at ‘./configure’ time,
     Gnuastro checks this feature and if the user’s compiler doesn’t
     support ‘restrict’, it will be removed from this definition.

‘uint8_t type’
     A fixed code (integer) used to identify the type of data in ‘array’
     (see *note Numeric data types::).  For the list of acceptable
     values to this variable, please see *note Library data types::.

‘size_t ndim’
     The dataset’s number of dimensions.

‘size_t *dsize’
     The size of the dataset along each dimension.  This is an array
     (with ‘ndim’ elements), of positive integers in row-major order(2)
     (based on C). When a data file is read into memory with Gnuastro’s
     libraries, this array is dynamically allocated based on the number
     of dimensions that the dataset has.

     It is important to remember that C’s row-major ordering is the
     opposite of the FITS standard which is in column-major order: in
     the FITS standard the fastest dimension’s size is specified by
     ‘NAXIS1’, and slower dimensions follow.  The FITS standard was
     defined mainly based on the FORTRAN language which is the opposite
     of C’s approach to multi-dimensional arrays (and also starts
     counting from 1 not 0).  Hence if a FITS image has ‘NAXIS1==20’ and
     ‘NAXIS2==50’, the ‘dsize’ array must be filled with ‘dsize[0]==50’
     and ‘dsize[1]==20’.

     The fastest dimension is the one that is contiguous in memory: to
     increment by one along that dimension, just go to the next element
     in the array.  As we go to slower dimensions, the number of memory
     cells we have to skip for an increment along that dimension becomes
     larger.

‘size_t size’
     The total number of elements in the dataset.  This is actually a
     multiplication of all the values in the ‘dsize’ array, so it is not
     an independent parameter.  However, low-level operations with the
     dataset (irrespective of its dimensions) commonly need this number,
     so this element is designed to avoid calculating it every time.

‘int quietmmap’
     When this value is zero, and the dataset must not be allocated in
     RAM (see ‘mmapname’ and ‘minmapsize’), a warning will be printed to
     inform the user when the file is created and when it is deleted.
     The warning includes the filename, the size in bytes, and the fact
     that they can toggle this behavior through ‘--minmapsize’ option in
     Gnuastro’s programs.

‘char *mmapname’
     Name of file hosting the ‘mmap’’d contents of ‘array’.  If the
     value of this variable is ‘NULL’, then the contents of ‘array’ are
     actually stored in RAM, not in a file on the HDD/SSD. See the
     description of ‘minmapsize’ below for more.

     If a file is used, it will be kept in the hidden ‘.gnuastro_mmap’
     directory.  Its name is randomly selected to allow multiple arrays
     at the same time, see description of ‘--minmapsize’ in *note
     Processing options::.  When ‘gal_data_free’ is called the randomly
     named file will be deleted.

‘size_t minmapsize’
     The minimum size of an array (in bytes) to store the contents of
     ‘array’ as a file (on the non-volatile HDD/SSD), not in RAM. This
     can be very useful for large datasets which can be very memory
     intensive and the user’s RAM might not be sufficient to
     keep/process it.  A random filename is assigned to the array which
     is available in the ‘mmapname’ element of ‘gal_data_t’ (above), see
     there for more.  ‘minmapsize’ is stored in each ‘gal_data_t’, so it
     can be passed on to subsequent/derived datasets.

     See the description of the ‘--minmapsize’ option in *note
     Processing options:: for more on using this value.

‘nwcs’
     The number of WCS coordinate representations (for WCSLIB).

‘struct wcsprm *wcs’
     The main WCSLIB structure keeping all the relevant information
     necessary for WCSLIB to do its processing and convert data-set
     positions into real-world positions.  When it is given a ‘NULL’
     value, all possible WCS calculations/measurements will be ignored.

‘uint8_t flag’
     Bit-wise flags to describe general properties of the dataset.  The
     number of bytes available in this flag is stored in the
     ‘GAL_DATA_FLAG_SIZE’ macro.  Note that you should use bit-wise
     operators(3) to check these flags.  The currently recognized bits
     are stored in these macros:

     ‘GAL_DATA_FLAG_BLANK_CH’
          Marking that the dataset has been checked for blank values or
          not.  When a dataset doesn’t have any blank values, the
          ‘GAL_DATA_FLAG_HASBLANK’ bit will be zero.  But upon
          initialization, all bits also get a value of zero.  Therefore,
          a checker needs this flag to see if the value in
          ‘GAL_DATA_FLAG_HASBLANK’ is reliable (dataset has actually
          been parsed for a blank value) or not.

          Also, if it is necessary to re-check the presence of flags,
          you just have to set this flag to zero and call
          ‘gal_blank_present’ for example to parse the dataset and check
          for blank values.  Note that for improved efficiency, when
          this flag is set, ‘gal_blank_present’ will not actually parse
          the dataset, it will just use ‘GAL_DATA_FLAG_HASBLANK’.

     ‘GAL_DATA_FLAG_HASBLANK’
          This bit has a value of ‘1’ when the given dataset has blank
          values.  If this bit is ‘0’ and ‘GAL_DATA_FLAG_BLANK_CH’ is
          ‘1’, then the dataset has been checked and it didn’t have any
          blank values, so there is no more need for further checks.

     ‘GAL_DATA_FLAG_SORT_CH’
          Marking that the dataset is already checked for being sorted
          or not and thus that the possible ‘0’ values in
          ‘GAL_DATA_FLAG_SORTED_I’ and ‘GAL_DATA_FLAG_SORTED_D’ are
          meaningful.  The logic behind this is similar to that in
          ‘GAL_DATA_FLAG_BLANK_CH’.

     ‘GAL_DATA_FLAG_SORTED_I’
          This bit has a value of ‘1’ when the given dataset is sorted
          in an increasing manner.  If this bit is ‘0’ and
          ‘GAL_DATA_FLAG_SORT_CH’ is ‘1’, then the dataset has been
          checked and wasn’t sorted (increasing), so there is no more
          need for further checks.

     ‘GAL_DATA_FLAG_SORTED_D’
          This bit has a value of ‘1’ when the given dataset is sorted
          in a decreasing manner.  If this bit is ‘0’ and
          ‘GAL_DATA_FLAG_SORT_CH’ is ‘1’, then the dataset has been
          checked and wasn’t sorted (decreasing), so there is no more
          need for further checks.

     The macro ‘GAL_DATA_FLAG_MAXFLAG’ contains the largest internally
     used bit-position.  Higher-level flags can be defined with the
     bit-wise shift operators using this macro to define internal flags
     for libraries/programs that depend on Gnuastro without causing any
     possible conflict with the internal flags discussed above or having
     to check the values manually on every release.

‘int status’
     A context-specific status values for this data-structure.  This
     integer will not be set by Gnuastro’s libraries.  You can use it
     keep some additional information about the dataset (with integer
     constants) depending on your applications.

‘char *name’
     The name of the dataset.  If the dataset is a multi-dimensional
     array and read/written as a FITS image, this will be the value in
     the ‘EXTNAME’ FITS keyword.  If the dataset is a one-dimensional
     table column, this will be the column name.  If it is set to ‘NULL’
     (by default), it will be ignored.

‘char *unit’
     The units of the dataset (for example ‘BUNIT’ in the standard FITS
     keywords) that will be read from or written to files/tables along
     with the dataset.  If it is set to ‘NULL’ (by default), it will be
     ignored.

‘char *comment’
     Any further explanation about the dataset which will be written to
     any output file if present.

‘disp_fmt’
     Format to use for printing each element of the dataset to a plain
     text file, the acceptable values to this element are defined in
     *note Table input output::.  Based on C’s ‘printf’ standards.

‘disp_width’
     Width of printing each element of the dataset to a plain text file,
     the acceptable values to this element are defined in *note Table
     input output::.  Based on C’s ‘printf’ standards.

‘disp_precision’
     Precision of printing each element of the dataset to a plain text
     file, the acceptable values to this element are defined in *note
     Table input output::.  Based on C’s ‘printf’ standards.

‘gal_data_t *next’
     Through this pointer, you can link a ‘gal_data_t’ with other
     datasets related datasets, for example the different columns in a
     dataset each have one ‘gal_data_t’ associate with them and they are
     linked to each other using this element.  There are several
     functions described below to facilitate using ‘gal_data_t’ as a
     linked list.  See *note Linked lists:: for more on these wonderful
     high-level constructs.

‘gal_data_t *block’
     Pointer to the start of the complete allocated block of memory.
     When this pointer is not ‘NULL’, the dataset is not treated as a
     contiguous patch of memory.  Rather, it is seen as covering only a
     portion of the larger patch of memory that ‘block’ points to.  See
     *note Tessellation library:: for a more thorough explanation and
     functions to help work with tiles that are created from this
     pointer.

   ---------- Footnotes ----------

   (1) Also see <https://en.wikipedia.org/wiki/Restrict>.

   (2) Also see
<https://en.wikipedia.org/wiki/Row-_and_column-major_order>.

   (3) See <https://en.wikipedia.org/wiki/Bitwise_operations_in_C>.


File: gnuastro.info,  Node: Dataset allocation,  Next: Arrays of datasets,  Prev: Generic data container,  Up: Library data container

10.3.6.2 Dataset allocation
...........................

Gnuastro’s main data container was defined in *note Generic data
container::.  The functions listed in this section describe the most
basic operations on ‘gal_data_t’: those related to allocation and
freeing.  These functions are declared in ‘gnuastro/data.h’ which is
also visible from the function names (see *note Gnuastro library::).

 -- Function:
          gal_data_t *
          gal_data_alloc (void ‘*array’, uint8_t ‘type’, size_t ‘ndim’,
          size_t ‘*dsize’, struct wcsprm ‘*wcs’, int ‘clear’, size_t
          ‘minmapsize’, int ‘quietmmap’, char ‘*name’, char ‘*unit’,
          char ‘*comment’)

     Dynamically allocate a ‘gal_data_t’ and initialize it will all the
     given values.  See the description of ‘gal_data_initialize’ and
     *note Generic data container:: for more information.  This function
     will often be the most frequently used because it allocates the
     ‘gal_data_t’ hosting all the values _and_ initializes it.  Once you
     are done with the dataset, be sure to clean up all the allocated
     spaces with ‘gal_data_free’.

 -- Function:
          void
          gal_data_initialize (gal_data_t ‘*data’, void ‘*array’,
          uint8_t ‘type’, size_t ‘ndim’, size_t ‘*dsize’, struct wcsprm
          ‘*wcs’, int ‘clear’, size_t ‘minmapsize’, int ‘quietmmap’,
          char ‘*name’, char ‘*unit’, char ‘*comment’)

     Initialize the given data structure (‘data’) with all the given
     values.  Note that the raw input ‘gal_data_t’ must already have
     been allocated before calling this function.  For a description of
     each variable see *note Generic data container::.  It will set the
     values and do the necessary allocations.  If they aren’t ‘NULL’,
     all input arrays (‘dsize’, ‘wcs’, ‘name’, ‘unit’, ‘comment’) are
     separately copied (allocated) by this function for usage in ‘data’,
     so you can safely use one value to initialize many datasets or use
     statically allocated variables in this function call.  Once you are
     done with the dataset, you can free all the allocated spaces with
     ‘gal_data_free_contents’.

     If ‘array’ is not ‘NULL’, it will be directly copied into
     ‘data->array’ (based on the total number of elements calculated
     from ‘dsize’) and no new space will be allocated for the array of
     this dataset, this has many low-level advantages and can be used to
     work on regions of a dataset instead of the whole allocated array
     (see the description under ‘block’ in *note Generic data
     container:: for one example).  If the given pointer is not the
     start of an allocated block of memory or it is used in multiple
     datasets, be sure to set it to ‘NULL’ (with ‘data->array=NULL’)
     before cleaning up with ‘gal_data_free_contents’.

     ‘ndim’ may be zero.  In this case no allocation will occur,
     ‘data->array’ and ‘data->dsize’ will be set to ‘NULL’ and
     ‘data->size’ will be zero.  However (when necessary) ‘dsize’ must
     not have any zero values (a dimension of length zero is not
     defined).

 -- Function:
          void
          gal_data_free_contents (gal_data_t ‘*data’)
     Free all the non-‘NULL’ pointers in ‘gal_data_t’ except for ‘next’
     and ‘block’.  If ‘data’ is actually a tile (‘data->block!=NULL’,
     see *note Tessellation library::), then ‘data->array’ is not freed.
     For a complete description of ‘gal_data_t’ and its contents, see
     *note Generic data container::.

 -- Function:
          void
          gal_data_free (gal_data_t ‘*data’)
     Free all the non-‘NULL’ pointers in ‘gal_data_t’, then free the
     actual data structure.


File: gnuastro.info,  Node: Arrays of datasets,  Next: Copying datasets,  Prev: Dataset allocation,  Up: Library data container

10.3.6.3 Arrays of datasets
...........................

Gnuastro’s generic data container (‘gal_data_t’) is a very versatile
structure that can be used in many higher-level contexts.  One such
higher-level construct is an array of ‘gal_data_t’ structures to
simplify the allocation (and later cleaning) of several ‘gal_data_t’s
that are related.

   For example, each column in a table is usually represented by one
‘gal_data_t’ (so it has its own name, data type, units, etc).  A table
(with many columns) can be seen as an array of ‘gal_data_t’s (when the
number of columns is known a-priori).  The functions below are defined
to create a cleared array of data structures and to free them when none
are necessary any more.  These functions are declared in
‘gnuastro/data.h’ which is also visible from the function names (see
*note Gnuastro library::).

 -- Function:
          gal_data_t *
          gal_data_array_calloc (size_t ‘size’)
     Allocate an array of ‘gal_data_t’ with ‘size’ elements.  This
     function will also initialize all the values (‘NULL’ for pointers
     and 0 for other types).  You can use ‘gal_data_initialize’ to fill
     each element of the array afterwards.  The following code snippet
     is one example of doing this.

          size_t i;
          gal_data_t *dataarr;
          dataarr=gal_data_array_calloc(10);
          for(i=0;i<10;++i) gal_data_initialize(&dataarr[i], ...);
          ...
          gal_data_array_free(dataarr, 10, 1);

 -- Function:
          void
          gal_data_array_free (gal_data_t ‘*dataarr’, size_t ‘num’, int
          ‘free_array’)
     Free all the ‘num’ elements within ‘dataarr’ and the actual
     allocated array.  If ‘free_array’ is not zero, then the ‘array’
     element of all the datasets will also be freed, see *note Generic
     data container::.


File: gnuastro.info,  Node: Copying datasets,  Prev: Arrays of datasets,  Up: Library data container

10.3.6.4 Copying datasets
.........................

The functions in this section describes Gnuastro’s facilities to copy a
given dataset into another.  The new dataset can have a different type
(including a string), it can be already allocated (in which case only
the values will be written into it).  In all these cases, if the input
dataset is a tile or a list, only the data within the given tile, or the
given node in a list, are copied.  If the input is a list, the ‘next’
pointer will also be copied to the output, see *note List of
gal_data_t::.

   In many of the functions here, it is possible to copy the dataset to
a new numeric data type (see *note Numeric data types::.  In such cases,
Gnuastro’s library is going to use the native conversion by C. So if you
are converting to a smaller type, it is up to you to make sure that the
values fit into the output type.

 -- Function:
          gal_data_t *
          gal_data_copy (gal_data_t ‘*in’)
     Return a new dataset that is a copy of ‘in’, all of ‘in’’s
     meta-data will also copied into the output, except for ‘block’.  If
     the dataset is a tile/list, only the given tile/node will be
     copied, the ‘next’ pointer will also be copied however.

 -- Function:
          gal_data_t *
          gal_data_copy_to_new_type (gal_data_t ‘*in’, uint8_t
          ‘newtype’)
     Return a copy of the dataset ‘in’, converted to ‘newtype’, see
     *note Library data types:: for Gnuastro library’s type identifiers.
     The returned dataset will have all meta-data except their type and
     ‘block’ equal to the input’s metadata.  If the dataset is a
     tile/list, only the given tile/node will be copied, the ‘next’
     pointer will also be copied however.

 -- Function:
          gal_data_t *
          gal_data_copy_to_new_type_free (gal_data_t ‘*in’, uint8_t
          ‘newtype’)
     Return a copy of the dataset ‘in’ that is converted to ‘newtype’
     and free the input dataset.  See *note Library data types:: for
     Gnuastro library’s type identifiers.  The returned dataset will
     have all meta-data, except their type, equal to the input’s
     metadata (including ‘next’).  Note that if the input is a tile
     within a larger block, it will not be freed.  This function is
     similar to ‘gal_data_copy_to_new_type’, except that it will free
     the input dataset.

 -- Function:
          void
          gal_data_copy_to_allocated (gal_data_t ‘*in’, gal_data_t
          ‘*out’)
     Copy the contents of the array in ‘in’ into the already allocated
     array in ‘out’.  The types of the input and output may be
     different, type conversion will be done internally.  When ‘in->size
     != out->size’ this function will behave as follows:

     ‘out->size < in->size’
          This function won’t re-allocate the necessary space, it will
          abort with an error, so please check before calling this
          function.

     ‘out->size > in->size’
          This function will write the values in ‘out->size’ and
          ‘out->dsize’ from the same values of ‘in’.  So if you want to
          use a pre-allocated space/dataset multiple times with varying
          input sizes, be sure to reset ‘out->size’ before every call to
          this function.

 -- Function:
          gal_data_t *
          gal_data_copy_string_to_number (char ‘*string’)
     Read ‘string’ into the smallest type that can store the value (see
     *note Numeric data types::).  This function is just a wrapper for
     the ‘gal_type_string_to_number’, but will put the value into a
     single-element dataset.


File: gnuastro.info,  Node: Dimensions,  Next: Linked lists,  Prev: Library data container,  Up: Gnuastro library

10.3.7 Dimensions (‘dimension.h’)
---------------------------------

An array is a contiguous region of memory.  Hence, at the lowest level,
every element of an array just has one single-valued position: the
number of elements that lie between it and the first element in the
array.  This is also known as the _index_ of the element within the
array.  A dataset’s number of dimensions is high-level abstraction
(meta-data) that we project onto that contiguous patch of memory.  When
the array is interpreted as a one-dimensional dataset, this index is
also the _coordinate_ of the element.  But once we associate the patch
of memory with a higher dimension, there must also be one coordinate for
each dimension.

   The functions and macros in this section provide you with the tools
to convert an index into a coordinate and vice-versa along with several
other issues for example issues with the neighbors of an element in a
multi-dimensional context.

 -- Function:
          size_t
          gal_dimension_total_size (size_t ‘ndim’, size_t ‘*dsize’)
     Return the total number of elements for a dataset with ‘ndim’
     dimensions that has ‘dsize’ elements along each dimension.

 -- Function:
          int
          gal_dimension_is_different (gal_data_t ‘*first’, gal_data_t
          ‘*second’)
     Return ‘1’ (one) if the two datasets don’t have the same size along
     all dimensions.  This function will also return ‘1’ when the number
     of dimensions of the two datasets are different.

 -- Function:
          size_t *
          gal_dimension_increment (size_t ‘ndim’, size_t ‘*dsize’)
     Return an allocated array that has the number of elements necessary
     to increment an index along every dimension.  For example along the
     fastest dimension (last element in the ‘dsize’ and returned
     arrays), the value is ‘1’ (one).

 -- Function:
          size_t
          gal_dimension_num_neighbors (size_t ‘ndim’)
     The maximum number of neighbors (any connectivity) that a data
     element can have in ‘ndim’ dimensions.  Effectively, this function
     just returns $3^n-1$ (where $n$ is the number of dimensions).

 -- Function-like macro: GAL_DIMENSION_FLT_TO_INT (‘FLT’)
     Calculate the integer pixel position that the floating point ‘FLT’
     number belongs to.  In the FITS format (and thus in Gnuastro), the
     center of each pixel is allocated on an integer (not it edge), so
     the pixel which hosts a floating point number cannot simply be
     found with internal type conversion.

 -- Function:
          void
          gal_dimension_add_coords (size_t ‘*c1’, size_t ‘*c2’, size_t
          ‘*out’, size_t ‘ndim’)
     For every dimension, add the coordinates in ‘c1’ with ‘c2’ and put
     the result into ‘out’.  In other words, for dimension ‘i’ run
     ‘out[i]=c1[i]+c2[i];’.  Hence ‘out’ may be equal to any one of ‘c1’
     or ‘c2’.

 -- Function:
          size_t
          gal_dimension_coord_to_index (size_t ‘ndim’, size_t ‘*dsize’,
          size_t ‘*coord’)
     Return the index (counting from zero) from the coordinates in
     ‘coord’ (counting from zero) assuming the dataset has ‘ndim’
     elements and the size of the dataset along each dimension is in the
     ‘dsize’ array.

 -- Function:
          void
          gal_dimension_index_to_coord (size_t ‘index’, size_t ‘ndim’,
          size_t ‘*dsize’, size_t ‘*coord’)
     Fill in the ‘coord’ array with the coordinates that correspond to
     ‘index’ assuming the dataset has ‘ndim’ elements and the size of
     the dataset along each dimension is in the ‘dsize’ array.  Note
     that both ‘index’ and each value in ‘coord’ are assumed to start
     from ‘0’ (zero).  Also that the space which ‘coord’ points to must
     already be allocated before calling this function.

 -- Function:
          size_t
          gal_dimension_dist_manhattan (size_t ‘*a’, size_t ‘*b’, size_t
          ‘ndim’)
     Return the manhattan distance (see Wikipedia
     (https://en.wikipedia.org/wiki/Taxicab_geometry)) between the two
     coordinates ‘a’ and ‘b’ (each an array of ‘ndim’ elements).

 -- Function:
          float
          gal_dimension_dist_radial (size_t ‘*a’, size_t ‘*b’, size_t
          ‘ndim’)
     Return the radial distance between the two coordinates ‘a’ and ‘b’
     (each an array of ‘ndim’ elements).

 -- Function:
          gal_data_t *
          gal_dimension_collapse_sum (gal_data_t ‘*in’, size_t ‘c_dim’,
          gal_data_t ‘*weight’)
     Collapse the input dataset (‘in’) along the given dimension
     (‘c_dim’, in C definition: starting from zero, from the slowest
     dimension), by summing all elements in that direction.  If
     ‘weight!=NULL’, it must be a single-dimensional array, with the
     same size as the dimension to be collapsed.  The respective weight
     will be multiplied to each element during the collapse.

     For generality, the returned dataset will have a ‘GAL_TYPE_FLOAT64’
     type.  See *note Copying datasets:: for converting the returned
     dataset to a desired type.  Also, for more on the application of
     this function, see the Arithmetic program’s ‘collapse-sum’ operator
     (which uses this function) in *note Arithmetic operators::.

 -- Function:
          gal_data_t *
          gal_dimension_collapse_mean (gal_data_t ‘*in’, size_t ‘c_dim’,
          gal_data_t ‘*weight’)
     Similar to ‘gal_dimension_collapse_sum’ (above), but the collapse
     will be done by calculating the mean along the requested dimension,
     not summing over it.

 -- Function:
          gal_data_t *
          gal_dimension_collapse_number (gal_data_t ‘*in’, size_t
          ‘c_dim’)
     Collapse the input dataset (‘in’) along the given dimension
     (‘c_dim’, in C definition: starting from zero, from the slowest
     dimension), by counting how many non-blank elements there are along
     that dimension.

     For generality, the returned dataset will have a ‘GAL_TYPE_INT32’
     type.  See *note Copying datasets:: for converting the returned
     dataset to a desired type.  Also, for more on the application of
     this function, see the Arithmetic program’s ‘collapse-number’
     operator (which uses this function) in *note Arithmetic
     operators::.

 -- Function:
          gal_data_t *
          gal_dimension_collapse_minmax (gal_data_t ‘*in’, size_t
          ‘c_dim’, int ‘max1_min0’)
     Collapse the input dataset (‘in’) along the given dimension
     (‘c_dim’, in C definition: starting from zero, from the slowest
     dimension), by using the largest/smallest non-blank value along
     that dimension.  If ‘max1_min0’ is non-zero, then the collapsed
     dataset will have the maximum value along the given dimension and
     if it is zero, the minimum.

 -- Function:
          size_t
          gal_dimension_remove_extra (size_t ‘ndim’, size_t ‘*dsize’,
          struct wcsprm ‘*wcs’)
     Remove extra dimensions (those that only have a length of 1) from
     the basic size information of a dataset.  ‘ndim’ is the number of
     dimensions and ‘dsize’ is an array with ‘ndim’ elements containing
     the size along each dimension in the C dimension order.  When
     ‘wcs!=NULL’, the respective dimension will also be removed from the
     WCS.

     This function will return the new number of dimensions and the
     ‘dsize’ elements will contain the length along each new dimension.

 -- Function-like macro: GAL_DIMENSION_NEIGHBOR_OP (‘index’, ‘ndim’,
          ‘dsize’, ‘connectivity’, ‘dinc’, ‘operation’)
     Parse the neighbors of the element located at ‘index’ and do the
     requested operation on them.  This is defined as a macro to allow
     easy definition of any operation on the neighbors of a given
     element without having to use loops within your source code (the
     loops are implemented by this macro).  For an example of using this
     function, please see *note Library demo - inspecting neighbors::.
     The input arguments to this function-like macro are described
     below:

     ‘index’
          Distance of this element from the first element in the array
          on a contiguous patch of memory (starting from 0), see the
          discussion above.
     ‘ndim’
          The number of dimensions associated with the contiguous patch
          of memory.
     ‘dsize’
          The full array size along each dimension.  This must be an
          array and is assumed to have the same number elements as
          ‘ndim’.  See the discussion under the same element in *note
          Generic data container::.
     ‘connectivity’
          Most distant neighbors to consider.  Depending on the number
          of dimensions, different neighbors may be defined for each
          element.  This function-like macro distinguish between these
          different neighbors with this argument.  It has a value
          between ‘1’ (one) and ‘ndim’.  For example in a 2D dataset,
          4-connected neighbors have a connectivity of ‘1’ and
          8-connected neighbors have a connectivity of ‘2’.  Note that
          this is inclusive, so in this example, a connectivity of ‘2’
          will also include connectivity ‘1’ neighbors.
     ‘dinc’
          An array keeping the length necessary to increment along each
          dimension.  You can make this array with the following
          function.  Just don’t forget to free the array after you are
          done with it:

               size_t *dinc=gal_dimension_increment(ndim, dsize);

          ‘dinc’ depends on ‘ndim’ and ‘dsize’, but it must be defined
          outside this function-like macro since it involves allocation
          to help in performance.

     ‘operation’
          Any C operation that you would like to do on the neighbor.
          This macro will provide you a ‘nind’ variable that can be used
          as the index of the neighbor that is currently being studied.
          It is defined as ‘‘size_t ndim;’’.  Note that ‘operation’ will
          be repeated the number of times there is a neighbor for this
          element.

     This macro works fully within its own ‘{}’ block and except for the
     ‘nind’ variable that shows the neighbor’s index, all the variables
     within this macro’s block start with ‘gdn_’.


File: gnuastro.info,  Node: Linked lists,  Next: Array input output,  Prev: Dimensions,  Up: Gnuastro library

10.3.8 Linked lists (‘list.h’)
------------------------------

An array is a contiguous region of memory that is very efficient and
easy to use for recording and later accessing any random element as fast
as any other.  This makes array the primary data container when you have
many elements (for example an image which has millions of pixels).  One
major problem with an array is that the number of elements that go into
it must be known in advance and adding or removing an element will
require a re-set of all the other elements.  For example if you want to
remove the 3rd element in a 1000 element array, all 997 subsequent
elements have to pulled back by one position, the reverse will happen if
you need to add an element.

   In many contexts such situations never come up, for example you don’t
want to shift all the pixels in an image by one or two pixels from some
random position in the image: their positions have scientific value.
But in other contexts you will find your self frequently adding/removing
an a-priori unknown number of elements.  Linked lists (or _lists_ for
short) are the data-container of choice in such situations.  As in a
chain, each _node_ in a list is an independent C structure, keeping its
own data along with pointer(s) to its immediate neighbor(s).  Below, you
can see one simple linked list node structure along with an ASCII art
schematic of how we can use the ‘next’ pointer to add any number of
elements to the list that we want.  By convention, a list is terminated
when ‘next’ is the ‘NULL’ pointer.

     struct list_float          /*     ---------    ---------           */
     {                          /*     | Value |    | Value |           */
       float             value; /*     |  ---  |    |  ---  |           */
       struct list_float *next; /*     |  next-|--> |  next-|--> NULL   */
     }                          /*     ---------    ---------           */

   The schematic shows another great advantage of linked lists: it is
very easy to add or remove/pop a node anywhere in the list.  If you want
to modify the first node, you just have to change one pointer.  If it is
in the middle, you just have to change two.  You initially define a
variable of this type with a ‘NULL’ pointer as shown below:

     struct list_float *mylist=NULL;

To add or remove/pop a node from the list you can use functions provided
for the respective type in the sections below.

When you add an element to the list, it is conventionally added to the
“top” of the list: the general list pointer will point to the newly
created node, which will point to the previously created node and so on.
So when you “pop” from the top of the list, you are actually retrieving
the last value you put in and changing the list pointer to the next
youngest node.  This is thus known as a “last-in-first-out” list.  This
is the most efficient type of linked list (easier to implement and
faster to process).  Alternatively, you can add each newly created node
at the end of the list.  If you do that, you will get a
“first-in-first-out” list.  But that will force you to go through the
whole list for each new element that is created (this will slow down the
processing)(1).

   The node example above creates the simplest kind of a list.  We can
define each node with two pointers to both the next and previous
neighbors, this is called a “Doubly linked list”.  In general, lists are
very powerful and simple constructs that can be very useful.  But going
into more detail would be out of the scope of this short introduction in
this book.  Wikipedia (https://en.wikipedia.org/wiki/Linked_list) has a
nice and more thorough discussion of the various types of lists.  To
appreciate/use the beauty and elegance of these powerful constructs even
further, see Chapter 2 (Information Structures, in volume 1) of Donald
Knuth’s “The art of computer programming”.

   In this section we will review the functions and structures that are
available in Gnuastro for working on lists.  They differ by the type of
data that each node can keep.  For each linked-list node structure, we
will first introduce the structure, then the functions for working on
the structure.  All these structures and functions are defined and
declared in ‘gnuastro/list.h’.

* Menu:

* List of strings::             Simply linked list of strings.
* List of int32_t::             Simply linked list of int32_ts.
* List of size_t::              Simply linked list of size_ts.
* List of float::               Simply linked list of floats.
* List of double::              Simply linked list of doubles
* List of void::                Simply linked list of void * pointers.
* Ordered list of size_t::      Simply linked, ordered list of size_t.
* Doubly linked ordered list of size_t::  Definition and functions.
* List of gal_data_t::          Simply linked list Gnuastro’s generic datatype.

   ---------- Footnotes ----------

   (1) A better way to get a first-in-first-out is to first keep the
data as last-in-first-out until they are all read.  Afterwards, reverse
the list by popping each node and immediately add it to the new list.
This practically reverses the last-in-first-out list to a
first-in-first-out one.  All the list types discussed in this chapter
have a function with a ‘_reverse’ suffix for this job.


File: gnuastro.info,  Node: List of strings,  Next: List of int32_t,  Prev: Linked lists,  Up: Linked lists

10.3.8.1 List of strings
........................

Probably one of the most common lists you will be using are lists of
strings.  They are the best tools when you are reading the user’s
inputs, or when adding comments to the output files.  Below you can see
Gnuastro’s string list type and several functions to help in adding,
removing/popping, reversing and freeing the list.

 -- Type (C ‘struct’): gal_list_str_t
     A single node in a list containing a string of characters.
          typedef struct gal_list_str_t
          {
            char *v;
            struct gal_list_str_t *next;
          } gal_list_str_t;

 -- Function:
          void
          gal_list_str_add (gal_list_str_t ‘**list’, char ‘*value’, int
          ‘allocate’)
     Add a new node to the list of strings (‘list’) and update it.  The
     new node will contain the string ‘value’.  If ‘allocate’ is not
     zero, space will be allocated specifically for the string of the
     new node and the contents of ‘value’ will be copied into it.  This
     can be useful when your string may be changed later in the program,
     but you want your list to remain.  Here is one short/simple example
     of initializing and adding elements to a string list:

          gal_list_str_t *strlist=NULL;
          gal_list_str_add(&strlist, "bottom of list.");
          gal_list_str_add(&strlist, "second last element of list.");

 -- Function:
          char *
          gal_list_str_pop (gal_list_str_t ‘**list’)
     Pop the top element of ‘list’, change ‘list’ to point to the next
     node in the list, and return the string that was in the popped
     node.  If ‘*list==NULL’, then this function will also return a
     ‘NULL’ pointer.

 -- Function:
          size_t
          gal_list_str_number (gal_list_str_t ‘*list’)
     Return the number of nodes in ‘list’.

 -- Function:
          size_t
          gal_list_str_last (gal_list_str_t ‘*list’)
     Return a pointer to the last node in ‘list’.

 -- Function:
          void
          gal_list_str_print (gal_list_str_t ‘*list’)
     Print the strings within each node of ‘*list’ on the standard
     output in the same order that they are stored.  Each string is
     printed on one line.  This function is mainly good for
     checking/debugging your program.  For program outputs, its best to
     make your own implementation with a better, more user-friendly,
     format.  For example the following code snippet.

          size_t i;
          gal_list_str_t *tmp;
          for(tmp=list; tmp!=NULL; tmp=tmp->next)
            printf("String %zu: %s\n", i, tmp->v);

 -- Function:
          void
          gal_list_str_reverse (gal_list_str_t ‘**list’)
     Reverse the order of the list such that the top node in the list
     before calling this function becomes the bottom node after it.

 -- Function:
          void
          gal_list_str_free (gal_list_str_t ‘*list’, int ‘freevalue’)
     Free every node in ‘list’.  If ‘freevalue’ is not zero, also free
     the string within the nodes.


File: gnuastro.info,  Node: List of int32_t,  Next: List of size_t,  Prev: List of strings,  Up: Linked lists

10.3.8.2 List of ‘int32_t’
..........................

Signed integers are the best types when you are dealing with a positive
or negative integers.  The are generally useful in many contexts, for
example when you want to keep the order of a series of states (each
state stored as a given number in an ‘enum’ for example).  On many
modern systems, ‘int32_t’ is just an alias for ‘int’, so you can use
them interchangeably.  To make sure, check the size of ‘int’ on your
system:

 -- Type (C ‘struct’): gal_list_i32_t
     A single node in a list containing a 32-bit signed integer (see
     *note Numeric data types::).
          typedef struct gal_list_i32_t
          {
            int32_t v;
            struct gal_list_i32_t *next;
          } gal_list_i32_t;

 -- Function:
          void
          gal_list_i32_add (gal_list_i32_t ‘**list’, int32_t ‘value’)
     Add a new node (containing ‘value’) to the top of the ‘list’ of
     ‘int32_t’s (‘uint32_t’ is equal to ‘int’ on many modern systems),
     and update ‘list’.  Here is one short example of initializing and
     adding elements to a string list:

          gal_list_i32_t *i32list=NULL;
          gal_list_i32_add(&i32list, 52);
          gal_list_i32_add(&i32list, -4);

 -- Function:
          int32_t
          gal_list_i32_pop (gal_list_i32_t ‘**list’)
     Pop the top element of ‘list’ and return the value.  This function
     will also change ‘list’ to point to the next node in the list.  If
     ‘*list==NULL’, then this function will also return
     ‘GAL_BLANK_INT32’ (see *note Library blank values::).

 -- Function:
          size_t
          gal_list_i32_number (gal_list_i32_t ‘*list’)
     Return the number of nodes in ‘list’.

 -- Function:
          size_t
          gal_list_i32_last (gal_list_i32_t ‘*list’)
     Return a pointer to the last node in ‘list’.

 -- Function:
          void
          gal_list_i32_print (gal_list_i32_t ‘*list’)
     Print the integers within each node of ‘*list’ on the standard
     output in the same order that they are stored.  Each integer is
     printed on one line.  This function is mainly good for
     checking/debugging your program.  For program outputs, its best to
     make your own implementation with a better, more user-friendly
     format.  For example the following code snippet.  You can also
     modify it to print all values in one line, etc, depending on the
     context of your program.

          size_t i;
          gal_list_i32_t *tmp;
          for(tmp=list; tmp!=NULL; tmp=tmp->next)
            printf("String %zu: %s\n", i, tmp->v);

 -- Function:
          void
          gal_list_i32_reverse (gal_list_i32_t ‘**list’)
     Reverse the order of the list such that the top node in the list
     before calling this function becomes the bottom node after it.

 -- Function:
          int32_t *
          gal_list_i32_to_array (gal_list_i32_t ‘*list’, int ‘reverse’,
          size_t ‘*num’)
     Dynamically allocate an array and fill it with the values in
     ‘list’.  The function will return a pointer to the allocated array
     and put the number of elements in the array into the ‘num’ pointer.
     If ‘reverse’ has a non-zero value, the array will be filled in the
     opposite order of elements in ‘list’.  This function can be useful
     after you have finished reading an initially unknown number of
     values and want to put them in an array for easy random access.

 -- Function:
          void
          gal_list_i32_free (gal_list_i32_t ‘*list’)
     Free every node in ‘list’.


File: gnuastro.info,  Node: List of size_t,  Next: List of float,  Prev: List of int32_t,  Up: Linked lists

10.3.8.3 List of ‘size_t’
.........................

The ‘size_t’ type is a unique type in C: as the name suggests it is
defined to store sizes, or more accurately, the distances between memory
locations.  Hence it is always positive (an ‘unsigned’ type) and it is
directly related to the address-able spaces on the host system: on
32-bit and 64-bit systems it is an alias for ‘uint32_t’ and ‘uint64_t’,
respectively (see *note Numeric data types::).

   ‘size_t’ is the default compiler type to index an array (recall that
an array index in C is just a pointer increment of a given _size_).
Since it is unsigned, its a great type for counting (where negative is
not defined), you are always sure it will never exceed the system’s
(virtual) memory and since its name has the word “size” inside it, it
provides a good level of documentation(1).  In Gnuastro, we do all
counting and array indexing with this type, so this list is very handy.
As discussed above, ‘size_t’ maps to different types on different
machines, so a portable way to print them with ‘printf’ is to use C99’s
‘%zu’ format.

 -- Type (C ‘struct’): gal_list_sizet_t
     A single node in a list containing a ‘size_t’ value (which maps to
     ‘uint32_t’ or ‘uint64_t’ on 32-bit and 64-bit systems), see *note
     Numeric data types::.
          typedef struct gal_list_sizet_t
          {
            size_t v;
            struct gal_list_sizet_t *next;
          } gal_list_sizet_t;

 -- Function:
          void
          gal_list_sizet_add (gal_list_sizet_t ‘**list’, size_t ‘value’)
     Add a new node (containing ‘value’) to the top of the ‘list’ of
     ‘size_t’s and update ‘list’.  Here is one short example of
     initializing and adding elements to a string list:

          gal_list_sizet_t *slist=NULL;
          gal_list_sizet_add(&slist, 45493);
          gal_list_sizet_add(&slist, 930484);

 -- Function:
          sizet_t
          gal_list_sizet_pop (gal_list_sizet_t ‘**list’)
     Pop the top element of ‘list’ and return the value.  This function
     will also change ‘list’ to point to the next node in the list.  If
     ‘*list==NULL’, then this function will also return
     ‘GAL_BLANK_SIZE_T’ (see *note Library blank values::).

 -- Function:
          size_t
          gal_list_sizet_number (gal_list_sizet_t ‘*list’)
     Return the number of nodes in ‘list’.

 -- Function:
          size_t
          gal_list_sizet_last (gal_list_sizet_t ‘*list’)
     Return a pointer to the last node in ‘list’.

 -- Function:
          void
          gal_list_sizet_print (gal_list_sizet_t ‘*list’)
     Print the values within each node of ‘*list’ on the standard output
     in the same order that they are stored.  Each integer is printed on
     one line.  This function is mainly good for checking/debugging your
     program.  For program outputs, its best to make your own
     implementation with a better, more user-friendly format.  For
     example, the following code snippet.  You can also modify it to
     print all values in one line, etc, depending on the context of your
     program.

          size_t i;
          gal_list_sizet_t *tmp;
          for(tmp=list; tmp!=NULL; tmp=tmp->next)
            printf("String %zu: %zu\n", i, tmp->v);

 -- Function:
          void
          gal_list_sizet_reverse (gal_list_sizet_t ‘**list’)
     Reverse the order of the list such that the top node in the list
     before calling this function becomes the bottom node after it.

 -- Function:
          size_t *
          gal_list_sizet_to_array (gal_list_sizet_t ‘*list’, int
          ‘reverse’, size_t ‘*num’)
     Dynamically allocate an array and fill it with the values in
     ‘list’.  The function will return a pointer to the allocated array
     and put the number of elements in the array into the ‘num’ pointer.
     If ‘reverse’ has a non-zero value, the array will be filled in the
     inverse of the order of elements in ‘list’.  This function can be
     useful after you have finished reading an initially unknown number
     of values and want to put them in an array for easy random access.

 -- Function:
          void
          gal_list_sizet_free (gal_list_sizet_t ‘*list’)
     Free every node in ‘list’.

   ---------- Footnotes ----------

   (1) So you know that a variable of this type is not used to store
some generic state for example.


File: gnuastro.info,  Node: List of float,  Next: List of double,  Prev: List of size_t,  Up: Linked lists

10.3.8.4 List of ‘float’
........................

Single precision floating point numbers can accurately store real number
until 7.2 decimals and only consume 4 bytes (32-bits) of memory, see
*note Numeric data types::.  Since astronomical data rarely reach that
level of precision, single precision floating points are the type of
choice to keep and read data.  However, when processing the data, it is
best to use double precision floating points (since errors propagate).

 -- Type (C ‘struct’): gal_list_f32_t
     A single node in a list containing a 32-bit single precision
     ‘float’ value: see *note Numeric data types::.
          typedef struct gal_list_f32_t
          {
            float v;
            struct gal_list_f32_t *next;
          } gal_list_f32_t;

 -- Function:
          void
          gal_list_f32_add (gal_list_f32_t ‘**list’, float ‘value’)
     Add a new node (containing ‘value’) to the top of the ‘list’ of
     ‘float’s and update ‘list’.  Here is one short example of
     initializing and adding elements to a string list:

          gal_list_f32_t *flist=NULL;
          gal_list_f32_add(&flist, 3.89);
          gal_list_f32_add(&flist, 1.23e-20);

 -- Function:
          float
          gal_list_f32_pop (gal_list_f32_t ‘**list’)
     Pop the top element of ‘list’ and return the value.  This function
     will also change ‘list’ to point to the next node in the list.  If
     ‘*list==NULL’, then this function will return ‘GAL_BLANK_FLOAT32’
     (NaN, see *note Library blank values::).

 -- Function:
          size_t
          gal_list_f32_number (gal_list_f32_t ‘*list’)
     Return the number of nodes in ‘list’.

 -- Function:
          size_t
          gal_list_f32_last (gal_list_f32_t ‘*list’)
     Return a pointer to the last node in ‘list’.

 -- Function:
          void
          gal_list_f32_print (gal_list_f32_t ‘*list’)
     Print the values within each node of ‘*list’ on the standard output
     in the same order that they are stored.  Each floating point number
     is printed on one line.  This function is mainly good for
     checking/debugging your program.  For program outputs, its best to
     make your own implementation with a better, more user-friendly
     format.  For example, in the following code snippet.  You can also
     modify it to print all values in one line, etc, depending on the
     context of your program.

          size_t i;
          gal_list_f32_t *tmp;
          for(tmp=list; tmp!=NULL; tmp=tmp->next)
            printf("Node %zu: %f\n", i, tmp->v);

 -- Function:
          void
          gal_list_f32_reverse (gal_list_f32_t ‘**list’)
     Reverse the order of the list such that the top node in the list
     before calling this function becomes the bottom node after it.

 -- Function:
          float *
          gal_list_f32_to_array (gal_list_f32_t ‘*list’, int ‘reverse’,
          size_t ‘*num’)
     Dynamically allocate an array and fill it with the values in
     ‘list’.  The function will return a pointer to the allocated array
     and put the number of elements in the array into the ‘num’ pointer.
     If ‘reverse’ has a non-zero value, the array will be filled in the
     inverse of the order of elements in ‘list’.  This function can be
     useful after you have finished reading an initially unknown number
     of values and want to put them in an array for easy random access.

 -- Function:
          void
          gal_list_f32_free (gal_list_f32_t ‘*list’)
     Free every node in ‘list’.


File: gnuastro.info,  Node: List of double,  Next: List of void,  Prev: List of float,  Up: Linked lists

10.3.8.5 List of ‘double’
.........................

Double precision floating point numbers can accurately store real number
until 15.9 decimals and consume 8 bytes (64-bits) of memory, see *note
Numeric data types::.  This level of precision makes them very good for
serious processing in the middle of a program’s execution: in many
cases, the propagation of errors will still be insignificant compared to
actual observational errors in a data set.  But since they consume 8
bytes and more CPU processing power, they are often not the best choice
for storing and transferring of data.

 -- Type (C ‘struct’): gal_list_f64_t
     A single node in a list containing a 64-bit double precision
     ‘double’ value: see *note Numeric data types::.
          typedef struct gal_list_f64_t
          {
            double v;
            struct gal_list_f64_t *next;
          } gal_list_f64_t;

 -- Function:
          void
          gal_list_f64_add (gal_list_f64_t ‘**list’, double ‘value’)
     Add a new node (containing ‘value’) to the top of the ‘list’ of
     ‘double’s and update ‘list’.  Here is one short example of
     initializing and adding elements to a string list:

          gal_list_f64_t *dlist=NULL;
          gal_list_f64_add(&dlist, 3.8129395763193);
          gal_list_f64_add(&dlist, 1.239378923931e-20);

 -- Function:
          double
          gal_list_f64_pop (gal_list_f64_t ‘**list’)
     Pop the top element of ‘list’ and return the value.  This function
     will also change ‘list’ to point to the next node in the list.  If
     ‘*list==NULL’, then this function will return ‘GAL_BLANK_FLOAT64’
     (NaN, see *note Library blank values::).

 -- Function:
          size_t
          gal_list_f64_number (gal_list_f64_t ‘*list’)
     Return the number of nodes in ‘list’.

 -- Function:
          size_t
          gal_list_f64_last (gal_list_f64_t ‘*list’)
     Return a pointer to the last node in ‘list’.

 -- Function:
          void
          gal_list_f64_print (gal_list_f64_t ‘*list’)
     Print the values within each node of ‘*list’ on the standard output
     in the same order that they are stored.  Each floating point number
     is printed on one line.  This function is mainly good for
     checking/debugging your program.  For program outputs, its best to
     make your own implementation with a better, more user-friendly
     format.  For example, in the following code snippet.  You can also
     modify it to print all values in one line, etc, depending on the
     context of your program.

          size_t i;
          gal_list_f64_t *tmp;
          for(tmp=list; tmp!=NULL; tmp=tmp->next)
            printf("Node %zu: %f\n", i, tmp->v);

 -- Function:
          void
          gal_list_f64_reverse (gal_list_f64_t ‘**list’)
     Reverse the order of the list such that the top node in the list
     before calling this function becomes the bottom node after it.

 -- Function:
          double *
          gal_list_f64_to_array (gal_list_f64_t ‘*list’, int ‘reverse’,
          size_t ‘*num’)
     Dynamically allocate an array and fill it with the values in
     ‘list’.  The function will return a pointer to the allocated array
     and put the number of elements in the array into the ‘num’ pointer.
     If ‘reverse’ has a non-zero value, the array will be filled in the
     inverse of the order of elements in ‘list’.  This function can be
     useful after you have finished reading an initially unknown number
     of values and want to put them in an array for easy random access.

 -- Function:
          void
          gal_list_f64_free (gal_list_f64_t ‘*list’)
     Free every node in ‘list’.


File: gnuastro.info,  Node: List of void,  Next: Ordered list of size_t,  Prev: List of double,  Up: Linked lists

10.3.8.6 List of ‘void *’
.........................

In C, ‘void *’ is the most generic pointer.  Usually pointers are
associated with the type of content they point to.  For example ‘int *’
means a pointer to an integer.  This ancillary information about the
contents of the memory location is very useful for the compiler,
catching bad errors and also documentation (it helps the reader see what
the address in memory actually contains).  However, ‘void *’ is just a
raw address (pointer), it contains no information on the contents it
points to.

   These properties make the ‘void *’ very useful when you want to treat
the contents of an address in different ways.  You can use the ‘void *’
list defined in this section and its function on any kind of data: for
example you can use it to keep a list of custom data structures that you
have built for your own separate program.  Each node in the list can
keep anything and this gives you great versatility.  But in using ‘void
*’, please beware that “with great power comes great responsibility”.

 -- Type (C ‘struct’): gal_list_void_t
     A single node in a list containing a ‘void *’ pointer.
          typedef struct gal_list_void_t
          {
            void *v;
            struct gal_list_void_t *next;
          } gal_list_void_t;

 -- Function:
          void
          gal_list_void_add (gal_list_void_t ‘**list’, void ‘*value’)
     Add a new node (containing ‘value’) to the top of the ‘list’ of
     ‘void *’s and update ‘list’.  Here is one short example of
     initializing and adding elements to a string list:

          gal_list_void_t *vlist=NULL;
          gal_list_f64_add(&vlist, some_pointer);
          gal_list_f64_add(&vlist, another_pointer);

 -- Function:
          void *
          gal_list_void_pop (gal_list_void_t ‘**list’)
     Pop the top element of ‘list’ and return the value.  This function
     will also change ‘list’ to point to the next node in the list.  If
     ‘*list==NULL’, then this function will return ‘NULL’.

 -- Function:
          size_t
          gal_list_void_number (gal_list_void_t ‘*list’)
     Return the number of nodes in ‘list’.

 -- Function:
          size_t
          gal_list_void_last (gal_list_void_t ‘*list’)
     Return a pointer to the last node in ‘list’.

 -- Function:
          void
          gal_list_void_reverse (gal_list_void_t ‘**list’)
     Reverse the order of the list such that the top node in the list
     before calling this function becomes the bottom node after it.

 -- Function:
          void
          gal_list_void_free (gal_list_void_t ‘*list’)
     Free every node in ‘list’.


File: gnuastro.info,  Node: Ordered list of size_t,  Next: Doubly linked ordered list of size_t,  Prev: List of void,  Up: Linked lists

10.3.8.7 Ordered list of ‘size_t’
.................................

Positions/sizes in a dataset are conventionally in the ‘size_t’ type
(see *note List of size_t::) and it sometimes occurs that you want to
parse and read the values in a specific order.  For example you want to
start from one pixel and add pixels to the list based on their distance
to that pixel.  So that ever time you pop an element from the list, you
know it is the nearest that has not yet been studied.  The
‘gal_list_osizet_t’ type and its functions in this section are designed
to facilitate such operations.

 -- Type (C ‘struct’): gal_list_osizet_t
     Each node in this singly-linked list contains a ‘size_t’ value and
     a floating point value.  The floating point value is used as a
     reference to add new nodes in a sorted manner.  At any moment, the
     first popped node in this list will have the smallest ‘tosort’
     value, and subsequent nodes will have larger to values.
     typedef struct gal_list_osizet_t
     {
       size_t v;                       /* The actual value. */
       float  s;                       /* The parameter to sort by. */
       struct gal_list_osizet_t *next;
     } gal_list_osizet_t;

 -- Function:
          void
          gal_list_osizet_add (gal_list_osizet_t ‘**list’, size_t
          ‘value’, float ‘tosort’)
     Allocate space for a new node in ‘list’, and store ‘value’ and
     ‘tosort’ into it.  The new node will not necessarily be at the
     “top” of the list.  If ‘*list!=NULL’, then the ‘tosort’ values of
     existing nodes is inspected and the given node is placed in the
     list such that the top element (which is popped with
     ‘gal_list_osizet_pop’) has the smallest ‘tosort’ value.

 -- Function:
          size_t
          gal_list_osizet_pop (gal_list_osizet_t ‘**list’, float
          ‘*sortvalue’)
     Pop a node from the top of ‘list’, return the node’s ‘value’ and
     put its sort value in the space that ‘sortvalue’ points to.  This
     function will also free the allocated space for the popped node and
     after this function, ‘list’ will point to the next node (which has
     a larger ‘tosort’ element).

 -- Function:
          void
          gal_list_osizet_to_sizet_free (gal_list_osizet_t ‘*in’,
          gal_list_sizet_t ‘**out’)
     Convert the ordered list of ‘size_t’s into an ordinary ‘size_t’
     linked list.  This can be useful when all the elements have been
     added and you just need to pop-out elements and don’t care about
     the sorting values any more.  After the conversion is done, this
     function will free the input list.  Note that the ‘out’ list
     doesn’t have to be empty.  If it already contains some nodes, the
     new nodes will be added on top of them.


File: gnuastro.info,  Node: Doubly linked ordered list of size_t,  Next: List of gal_data_t,  Prev: Ordered list of size_t,  Up: Linked lists

10.3.8.8 Doubly linked ordered list of ‘size_t’
...............................................

An ordered list of indexs is required in many contexts, one example was
discussed at the beginning of *note Ordered list of size_t::.  But the
list that was introduced there only has one point of entry: you can
always only parse the list from smallest to largest.  In this section,
the doubly-linked ‘gal_list_dosizet_t’ node is defined which will allow
us to parse the values in ascending or descending order.

 -- Type (C ‘struct’): gal_list_dosizet_t

     Doubly-linked, ordered ‘size_t’ list node structure.  Each node in
     this Doubly-linked list contains a ‘size_t’ value and a floating
     point value.  The floating point value is used as a reference to
     add new nodes in a sorted manner.  In the functions here, this
     linked list can be pointed to by two pointers (largest and
     smallest) with the following format:
                      largest pointer
                      |
             NULL <-- (v0,s0) <--> (v1,s1) <--> ... (vn,sn) --> NULL
                                                    |
                                     smallest pointer
     At any moment, the two pointers will point to the nodes containing
     the “largest” and “smallest” values and the rest of the nodes will
     be sorted.  This is useful when an unknown number of nodes are
     being added continuously and during the operations it is important
     to have the nodes in a sorted format.

          typedef struct gal_list_dosizet_t
          {
            size_t v;                       /* The actual value. */
            float s;                        /* The parameter to sort by. */
            struct gal_list_dosizet_t *prev;
            struct gal_list_dosizet_t *next;
          } gal_list_dosizet_t;

 -- Function:
          void
          gal_list_dosizet_add (gal_list_dosizet_t ‘**largest’,
          gal_list_dosizet_t ‘**smallest’, size_t ‘value’, float
          ‘tosort’)
     Allocate space for a new node in ‘list’, and store ‘value’ and
     ‘tosort’ into it.  If the list is empty, both ‘largest’ and
     ‘smallest’ must be ‘NULL’.

 -- Function:
          size_t
          gal_list_dosizet_pop_smallest (gal_list_dosizet_t ‘**largest’,
          gal_list_dosizet_t ‘**smallest’, float ‘tosort’)
     Pop the value with the smallest reference from the doubly linked
     list and store the reference into the space pointed to by ‘tosort’.
     Note that even though only the smallest pointer will be popped,
     when there was only one node in the list, the ‘largest’ pointer
     also has to change, so we need both.

 -- Function:
          void
          gal_list_dosizet_print (gal_list_dosizet_t ‘*largest’,
          gal_list_dosizet_t ‘*smallest’)
     Print the largest and smallest values sequentially until the list
     is parsed.

 -- Function:
          void
          gal_list_dosizet_to_sizet (gal_list_dosizet_t ‘*in’,
          gal_list_sizet_t ‘**out’)
     Convert the doubly linked, ordered ‘size_t’ list into a
     singly-linked list of ‘size_t’.

 -- Function:
          void
          gal_list_dosizet_free (gal_list_dosizet_t ‘*largest’)
     Free the doubly linked, ordered ‘sizet_t’ list.


File: gnuastro.info,  Node: List of gal_data_t,  Prev: Doubly linked ordered list of size_t,  Up: Linked lists

10.3.8.9 List of ‘gal_data_t’
.............................

Gnuastro’s generic data container has a ‘next’ element which enables it
to be used as a singly-linked list (see *note Generic data container::).
The ability to connect the different data containers offers great
advantages.  For example each column in a table in an independent
dataset: with its own name, units, numeric data type (see *note Numeric
data types::).  Another application is in Tessellating an input dataset
into separate tiles or only studying particular regions, or tiles, of a
larger dataset (see *note Tessellation:: and *note Tessellation
library::).  Each independent tile over the dataset can be connected to
the others as a linked list and thus any number of tiles can be
represented with one variable.

 -- Function:
          void
          gal_list_data_add (gal_data_t ‘**list’, gal_data_t ‘*newnode’)
     Add an already allocated dataset (‘newnode’) to top of ‘list’.
     Note that if ‘newnode->next!=NULL’ (‘newnode’ is itself a list),
     then ‘list’ will be added to its end.

     In this example multiple images are linked together as a list:
          int quietmmap=1;
          size_t minmapsize=-1;
          gal_data_t *tmp, *list=NULL;
          tmp = gal_fits_img_read("file1.fits", "1", minmapsize, quietmmap);
          gal_list_data_add( &list, tmp );
          tmp = gal_fits_img_read("file2.fits", "1", minmapsize, quietmmap);
          gal_list_data_add( &list, tmp );

 -- Function:
          void
          gal_list_data_add_alloc (gal_data_t ‘**list’, void ‘*array’,
          uint8_t ‘type’, size_t ‘ndim’, size_t ‘*dsize’, struct wcsprm
          ‘*wcs’, int ‘clear’, size_t ‘minmapsize’, int ‘quietmmap’,
          char ‘*name’, char ‘*unit’, char ‘*comment’)
     Allocate a new dataset (with ‘gal_data_alloc’ in *note Dataset
     allocation::) and put it as the first element of ‘list’.  Note that
     if this is the first node to be added to the list, ‘list’ must be
     ‘NULL’.

 -- Function:
          gal_data_t *
          gal_list_data_pop (gal_data_t ‘**list’)
     Pop the top node from ‘list’ and return it.

 -- Function:
          void
          gal_list_data_reverse (gal_data_t ‘**list’)
     Reverse the order of the list such that the top node in the list
     before calling this function becomes the bottom node after it.

 -- Function:
          gal_data_t **
          gal_list_data_to_array_ptr (gal_data_t ‘*list’, size_t ‘*num’)
     Allocate and return an array of ‘gal_data_t *’ pointers with the
     same number of elements as the nodes in ‘list’.  The pointers will
     be put in the same order that the list is parsed.  Hence the N-th
     element in the array will point to the same dataset that the N-th
     node in the list points to.

 -- Function:
          size_t
          gal_list_data_number (gal_data_t ‘*list’)
     Return the number of nodes in ‘list’.

 -- Function:
          size_t
          gal_list_data_last (gal_data_t ‘*list’)
     Return a pointer to the last node in ‘list’.

 -- Function:
          void
          gal_list_data_free (gal_data_t ‘*list’)
     Free all the datasets in ‘list’ along with all the allocated spaces
     in each.


File: gnuastro.info,  Node: Array input output,  Next: Table input output,  Prev: Linked lists,  Up: Gnuastro library

10.3.9 Array input output
-------------------------

Getting arrays (commonly images or cubes) from a file into your program
or writing them after the processing into an output file are some of the
most common operations.  The functions in this section are designed for
such operations with the known file types.  The functions here are thus
just wrappers around functions of lower-level file type functions of
this library, for example *note FITS files:: or *note TIFF files::.  If
the file type of the input/output file is already known, you can use the
functions in those sections respectively.

 -- Function:
          int
          gal_array_name_recognized (char ‘*filename’)
     Return 1 if the given file name corresponds to one of the
     recognized file types for reading arrays.

 -- Function:
          int
          gal_array_name_recognized_multiext (char ‘*filename’)
     Return 1 if the given file name corresponds to one of the
     recognized file types for reading arrays which may contain multiple
     extensions (for example FITS or TIFF) formats.

 -- Function:
          gal_data_t
          gal_array_read (char ‘*filename’, char ‘*extension’,
          gal_list_str_t ‘*lines’, size_t ‘minmapsize’, int ‘quietmmap’)
     Read the array within the given extension (‘extension’) of
     ‘filename’, or the ‘lines’ list (see below).  If the array is
     larger than ‘minmapsize’ bytes, then it won’t be read into RAM, but
     a file on the HDD/SSD (no difference for the programmer).  Messages
     about the memory-mapped file can be disabled with ‘quietmmap’.

     ‘extension’ will be ignored for files that don’t support them (for
     example JPEG or text).  For FITS files, ‘extension’ can be a number
     or a string (name of the extension), but for TIFF files, it has to
     be number.  In both cases, counting starts from zero.

     For multi-channel formats (like RGB images in JPEG or TIFF), this
     function will return a *note List of gal_data_t::: one data
     structure per channel.  Thus if you just want a single array (and
     want to check if the user hasn’t given a multi-channel input), you
     can check the ‘next’ pointer of the returned ‘gal_data_t’.

     ‘lines’ is a list of strings with each node representing one line
     (including the new-line character), see *note List of strings::.
     It will mostly be the output of ‘gal_txt_stdin_read’, which is used
     to read the program’s input as separate lines from the standard
     input (see *note Text files::).  Note that ‘filename’ and ‘lines’
     are mutually exclusive and one of them must be ‘NULL’.

 -- Function:
          void
          gal_array_read_to_type (char ‘*filename’, char ‘*extension’,
          gal_list_str_t ‘*lines’, uint8_t ‘type’, size_t ‘minmapsize’,
          int ‘quietmmap’)
     Similar to ‘gal_array_read’, but the output data structure(s) will
     have a numeric data type of ‘type’, see *note Numeric data types::.

 -- Function:
          void
          gal_array_read_one_ch (char ‘*filename’, char ‘*extension’,
          gal_list_str_t ‘*lines’, size_t ‘minmapsize’, int ‘quietmmap’)
     Read the dataset within ‘filename’ (extension/hdu/dir ‘extension’)
     and make sure it is only a single channel.  This is just a simple
     wrapper around ‘gal_array_read’ that checks if there was more than
     one dataset and aborts with an informative error if there is more
     than one channel in the dataset.

     Formats like JPEG or TIFF support multiple channels per input, but
     it may happen that your program only works on a single dataset.
     This function can be a convenient way to make sure that the data
     that comes into your program is only one channel.

 -- Function:
          void
          gal_array_read_one_ch_to_type (char ‘*filename’, char
          ‘*extension’, gal_list_str_t ‘*lines’, uint8_t ‘type’, size_t
          ‘minmapsize’, int ‘quietmmap’)
     Similar to ‘gal_array_read_one_ch’, but the output data structure
     will has a numeric data type of ‘type’, see *note Numeric data
     types::.


File: gnuastro.info,  Node: Table input output,  Next: FITS files,  Prev: Array input output,  Up: Gnuastro library

10.3.10 Table input output (‘table.h’)
--------------------------------------

Tables are a collection of one dimensional datasets that are packed
together into one file.  They are the single most common format to store
high-level (processed) information, hence they play a very important
role in Gnuastro.  For a more thorough introduction, please see *note
Table::.  Gnuastro’s Table program, and all the other programs that can
read from and write into tables, use the functions of this section for
reading and writing their input/output tables.  For a simple
demonstration of using the constructs introduced here, see *note Library
demo - reading and writing table columns::.

   Currently only plain text (see *note Gnuastro text table format::)
and FITS (ASCII and binary) tables are supported by Gnuastro.  However,
the low-level table infra-structure is written such that accommodating
other formats is also possible and in future releases more formats will
hopefully be supported.  Please don’t hesitate to suggest your favorite
format so it can be implemented when possible.

 -- Macro: GAL_TABLE_DEF_WIDTH_STR
 -- Macro: GAL_TABLE_DEF_WIDTH_INT
 -- Macro: GAL_TABLE_DEF_WIDTH_LINT
 -- Macro: GAL_TABLE_DEF_WIDTH_FLT
 -- Macro: GAL_TABLE_DEF_WIDTH_DBL
 -- Macro: GAL_TABLE_DEF_PRECISION_INT
 -- Macro: GAL_TABLE_DEF_PRECISION_FLT
 -- Macro: GAL_TABLE_DEF_PRECISION_DBL
     The default width and precision for generic types to use in writing
     numeric types into a text file (plain text and FITS ASCII tables).
     When the dataset doesn’t have any pre-set width and precision (see
     ‘disp_width’ and ‘disp_precision’ in *note Generic data
     container::) these will be directly used in C’s ‘printf’ command to
     write the number as a string.

 -- Macro: GAL_TABLE_DISPLAY_FMT_STRING
 -- Macro: GAL_TABLE_DISPLAY_FMT_DECIMAL
 -- Macro: GAL_TABLE_DISPLAY_FMT_UDECIMAL
 -- Macro: GAL_TABLE_DISPLAY_FMT_OCTAL
 -- Macro: GAL_TABLE_DISPLAY_FMT_HEX
 -- Macro: GAL_TABLE_DISPLAY_FMT_FLOAT
 -- Macro: GAL_TABLE_DISPLAY_FMT_EXP
 -- Macro: GAL_TABLE_DISPLAY_FMT_GENERAL
     The display format used in C’s ‘printf’ to display data of
     different types.  The ‘_STRING’ and ‘_DECIMAL’ are unique for
     printing strings and signed integers, they are mainly here for
     completeness.  However, unsigned integers and floating points can
     be displayed in multiple formats:

     Unsigned integer
          For unsigned integers, it is possible to choose from
          ‘_UDECIMAL’ (unsigned decimal), ‘_OCTAL’ (octal notation, for
          example ‘125’ in decimal will be displayed as ‘175’), and
          ‘_HEX’ (hexadecimal notation, for example ‘125’ in decimal
          will be displayed as ‘7D’).

     Floating point
          For floating point, it is possible to display the number in
          ‘_FLOAT’ (floating point, for example ‘1500.345’), ‘_EXP’
          (exponential, for example ‘1.500345e+03’), or ‘_GENERAL’ which
          is the best of the two for the given number.

 -- Macro: GAL_TABLE_FORMAT_INVALID
 -- Macro: GAL_TABLE_FORMAT_TXT
 -- Macro: GAL_TABLE_FORMAT_AFITS
 -- Macro: GAL_TABLE_FORMAT_BFITS
     All the current acceptable table formats to Gnuastro.  The ‘AFITS’
     and ‘BFITS’ represent FITS ASCII tables and FITS Binary tables.
     You can use these anywhere you see the ‘tableformat’ variable.

 -- Macro: GAL_TABLE_SEARCH_INVALID
 -- Macro: GAL_TABLE_SEARCH_NAME
 -- Macro: GAL_TABLE_SEARCH_UNIT
 -- Macro: GAL_TABLE_SEARCH_COMMENT
     When the desired column is not a number, these values determine if
     the string to match, or regular expression to search, be in the
     _name_, _units_ or _comments_ of the column meta data.  These
     values should be used for the ‘searchin’ variables of the
     functions.

 -- Function:
          gal_data_t *
          gal_table_info (char ‘*filename’, char ‘*hdu’, gal_list_str_t
          ‘*lines’, size_t ‘*numcols’, size_t ‘*numrows’, int
          ‘*tableformat’)
     Store the information of each column of a table into an array of
     data structures with ‘numcols’ datasets (one data structure for
     each column).  The number of rows is stored in ‘numrows’.  The
     format of the table (e.g., ASCII text file, or FITS binary or ASCII
     table) will be put in ‘tableformat’ (macros defined above).  If the
     ‘filename’ is not a FITS file, then ‘hdu’ will not be used (can be
     ‘NULL’).

     The input must be either a file (specified by ‘filename’) or a list
     of strings (‘lines’).  ‘lines’ is a list of strings with each node
     representing one line (including the new-line character), see *note
     List of strings::.  It will mostly be the output of
     ‘gal_txt_stdin_read’, which is used to read the program’s input as
     separate lines from the standard input (see *note Text files::).
     Note that ‘filename’ and ‘lines’ are mutually exclusive and one of
     them must be ‘NULL’.

     In the output datasets, only the meta-data strings (column name,
     units and comments), will be allocated and set.  This function is
     just for column information (meta-data), not column contents.

 -- Function:
          void
          gal_table_print_info (gal_data_t ‘*allcols’, size_t ‘numcols’,
          size_t ‘numrows’)
     This program will print the column information for all the columns
     (output of ‘gal_table_info’).  The output is in the same format as
     this command with Gnuastro Table program (see *note Table::):
          $ asttable --info table.fits

 -- Function:
          gal_data_t *
          gal_table_read (char ‘*filename’, char ‘*hdu’, gal_list_str_t
          ‘*lines’, gal_list_str_t ‘*cols’, int ‘searchin’, int
          ‘ignorecase’, size_t ‘minmapsize’, int ‘quietmmap’, size_t
          ‘*colmatch’)

     Read the specified columns in a file (named ‘filename’), or list of
     strings (‘lines’) into a linked list of data structures.  If the
     file is FITS, then ‘hdu’ will also be used, otherwise, ‘hdu’ is
     ignored.

     ‘lines’ is a list of strings with each node representing one line
     (including the new-line character), see *note List of strings::.
     It will mostly be the output of ‘gal_txt_stdin_read’, which is used
     to read the program’s input as separate lines from the standard
     input (see *note Text files::).  Note that ‘filename’ and ‘lines’
     are mutually exclusive and one of them must be ‘NULL’.

     The information to search for columns should be specified by the
     ‘cols’ list of strings (see *note List of strings::).  The string
     in each node of the list may be a number, an exact match to a
     column name, or a regular expression (in GNU AWK format) enclosed
     in ‘/ /’.  The ‘searchin’ value must be one of the macros defined
     above.  If ‘cols’ is NULL, then this function will read the full
     table.

     The output is an individually allocated list of datasets (see *note
     List of gal_data_t::) with the same order of the ‘cols’ list.  Note
     that one column node in the ‘cols’ list might give multiple columns
     (for example from regular expressions), in this case, the order of
     output columns that correspond to that one input, are in order of
     the table (which column was read first).  So the first requested
     column is the first popped data structure and so on.

     if ‘colmatch!=NULL’, it is assumed to be an array that has at least
     the same number of elements as nodes in the ‘cols’ list.  The
     number of columns that matched each input column will be stored in
     each element.

 -- Function:
          gal_list_sizet_t *
          gal_table_list_of_indexs (gal_list_str_t ‘*cols’, gal_data_t
          ‘*allcols’, size_t ‘numcols’, int ‘searchin’, int
          ‘ignorecase’, char ‘*filename’, char ‘*hdu’, size_t
          ‘*colmatch’)
     Returns a list of indexs (starting from 0) of the input columns
     that match the names/numbers given to ‘cols’.  This is a low-level
     operation which is called by ‘gal_table_read’ (described above),
     see there for more on each argument’s description.  ‘allcols’ is
     the returned array of ‘gal_table_info’.

 -- Function:
          void
          gal_table_comments_add_intro (gal_list_str_t ‘**comments’,
          char ‘*program_string’, time_t ‘*rawtime’)
     Add some basic information to the list of ‘comments’.  This basic
     information includes the following information
        • If the program is run in a Git version controlled directory,
          Git’s description is printed (see description under ‘COMMIT’
          in *note Output FITS files::).
        • The calendar time that is stored in ‘rawtime’ (‘time_t’ is C’s
          calendar time format defined in ‘time.h’).  You can calculate
          the time in this format with the following expressions:
               time_t rawtime;
               time(&rawtime);
        • The name of your program in ‘program_string’.  If it is
          ‘NULL’, this line is ignored.

 -- Function:
          void
          gal_table_write (gal_data_t ‘*cols’, gal_list_str_t
          ‘*comments’, int ‘tableformat’, char ‘*filename’, char
          ‘*extname’, uint8_t ‘colinfoinstdout’)
     Write ‘cols’ (a list of datasets, see *note List of gal_data_t::)
     into a table stored in ‘filename’.  The format of the table can be
     determined with ‘tableformat’ that accepts the macros defined
     above.  When ‘filename==NULL’, the column information will be
     printed on the standard output (command-line).

     If ‘comments!=NULL’, the list of comments (see *note List of
     strings::) will also be printed into the output table.  When the
     output table is a plain text file, every node of ‘comments’ will be
     printed after a ‘#’ (so it can be considered as a comment) and in
     FITS table they will follow a ‘COMMENT’ keyword.

     If a file named ‘filename’ already exists, the operation depends on
     the type of output.  When ‘filename’ is a FITS file, the table will
     be added as a new extension after all existing extensions.  If
     ‘filename’ is a plain text file, this function will abort with an
     error.

     If ‘filename’ is a FITS file, the table extension will have the
     name ‘extname’.

     When ‘colinfoinstdout!=0’ and ‘filename==NULL’ (columns are printed
     in the standard output), the dataset metadata will also printed in
     the standard output.  When printing to the standard output, the
     column information can be piped into another program for further
     processing and thus the meta-data (lines starting with a ‘#’) must
     be ignored.  In such cases, you only print the column values by
     passing ‘0’ to ‘colinfoinstdout’.

 -- Function:
          void
          gal_table_write_log (gal_data_t ‘*logll’, char
          ‘*program_string’, time_t ‘*rawtime’, gal_list_str_t
          ‘*comments’, char ‘*filename’, int ‘quiet’)
     Write the ‘logll’ list of datasets into a table in ‘filename’ (see
     *note List of gal_data_t::).  This function is just a wrapper
     around ‘gal_table_comments_add_intro’ and ‘gal_table_write’ (see
     above).  If ‘quiet’ is non-zero, this function will print a message
     saying that the ‘filename’ has been created.


File: gnuastro.info,  Node: FITS files,  Next: File input output,  Prev: Table input output,  Up: Gnuastro library

10.3.11 FITS files (‘fits.h’)
-----------------------------

The FITS format is the most common format to store data (images and
tables) in astronomy.  The CFITSIO library already provides a very good
low-level collection of functions for manipulating FITS data.  The
low-level nature of CFITSIO is defined for versatility and portability.
As a result, even a simple and basic operation, like reading an image or
table column into memory, will require a special sequence of CFITSIO
function calls which can be inconvenient and buggy to manage in separate
locations.  To ease this process, Gnuastro’s library provides wrappers
for CFITSIO functions.  With these, it much easier to read, write, or
modify FITS file data, header keywords and extensions.  Hence, if you
feel these functions don’t exactly do what you want, we strongly
recommend reading the CFITSIO manual to use its great features directly
(afterwards, send us your wrappers so we can include it here for others
to benefit also).

   All the functions and macros introduced in this section are declared
in ‘gnuastro/fits.h’.  When you include this header, you are also
including CFITSIO’s ‘fitsio.h’ header.  So you don’t need to explicitly
include ‘fitsio.h’ anymore and can freely use any of its macros or
functions in your code along with those discussed here.

* Menu:

* FITS macros errors filenames::  General macros, errors and checking names.
* CFITSIO and Gnuastro types::  Conversion between FITS and Gnuastro types.
* FITS HDUs::                   Opening and getting information about HDUs.
* FITS header keywords::        Reading and writing FITS header keywords.
* FITS arrays::                 Reading and writing FITS images/arrays.
* FITS tables::                 Reading and writing FITS tables.


File: gnuastro.info,  Node: FITS macros errors filenames,  Next: CFITSIO and Gnuastro types,  Prev: FITS files,  Up: FITS files

10.3.11.1 FITS Macros, errors and filenames
...........................................

Some general constructs provided by Gnuastro’s FITS handling functions
are discussed here.  In particular there are several useful functions
about FITS file names.

 -- Macro: GAL_FITS_MAX_NDIM
     The maximum number of dimensions a dataset can have in FITS format,
     according to the FITS standard this is 999.

 -- Function:
          void
          gal_fits_io_error (int ‘status’, char ‘*message’)
     If ‘status’ is non-zero, this function will print the CFITSIO error
     message corresponding to status, print ‘message’ (optional) in the
     next line and abort the program.  If ‘message==NULL’, it will print
     a default string after the CFITSIO error.

 -- Function:
          int
          gal_fits_name_is_fits (char ‘*name’)
     If the ‘name’ is an acceptable CFITSIO FITS filename return ‘1’
     (one), otherwise return ‘0’ (zero).  The currently acceptable FITS
     suffixes are ‘.fits’, ‘.fit’, ‘.fits.gz’, ‘.fits.Z’, ‘.imh’,
     ‘.fits.fz’.  IMH is the IRAF format which is acceptable to CFITSIO.

 -- Function:
          int
          gal_fits_suffix_is_fits (char ‘*suffix’)
     Similar to ‘gal_fits_name_is_fits’, but only for the suffix.  The
     suffix doesn’t have to start with ‘<.>’: this function will return
     ‘1’ (one) for both ‘fits’ and ‘.fits’.

 -- Function:
          char *
          gal_fits_name_save_as_string (char ‘*filename’, char ‘*hdu’)
     If the name is a FITS name, then put a ‘(hdu: ...)’ after it and
     return the string.  If it isn’t a FITS file, just print the name,
     if ‘filename==NULL’, then return the string ‘stdin’.  Note that the
     output string’s space is allocated.

     This function is useful when you want to report a random file to
     the user which may be FITS or not (for a FITS file, simply the
     filename is not enough, the HDU is also necessary).


File: gnuastro.info,  Node: CFITSIO and Gnuastro types,  Next: FITS HDUs,  Prev: FITS macros errors filenames,  Up: FITS files

10.3.11.2 CFITSIO and Gnuastro types
....................................

Both Gnuastro and CFITSIO have special identifiers for each type that
they accept.  Gnuastro’s type identifiers are fully described in *note
Library data types:: and are usable for all kinds of datasets (images,
table columns, etc) as part of Gnuastro’s *note Generic data
container::.  However, following the FITS standard, CFITSIO has
different identifiers for images and tables.  Following CFITSIO’s own
convention, we will use ‘bitpix’ for image type identifiers and
‘datatype’ for its internal identifiers (and mainly used in tables).
The functions introduced in this section can be used to convert between
CFITSIO and Gnuastro’s type identifiers.

   One important issue to consider is that CFITSIO’s types are not fixed
width (for example ‘long’ may be 32-bits or 64-bits on different
systems).  However, Gnuastro’s types are defined by their width.  These
functions will use information on the host system to do the proper
conversion.  To have a portable (usable on different systems) code, is
thus recommended to use these functions and not to assume a fixed
correspondence between CFITSIO and Gnuastro’s types.

 -- Function:
          uint8_t
          gal_fits_bitpix_to_type (int ‘bitpix’)
     Return the Gnuastro type identifier that corresponds to CFITSIO’s
     ‘bitpix’ on this system.

 -- Function:
          int
          gal_fits_type_to_bitpix (uint8_t ‘type’)
     Return the CFITSIO ‘bitpix’ value that corresponds to Gnuastro’s
     ‘type’.

 -- Function:
          char
          gal_fits_type_to_bin_tform (uint8_t ‘type’)
     Return the FITS standard binary table ‘TFORM’ character that
     corresponds to Gnuastro’s ‘type’.

 -- Function:
          int
          gal_fits_type_to_datatype (uint8_t ‘type’)
     Return the CFITSIO ‘datatype’ that corresponds to Gnuastro’s ‘type’
     on this machine.

 -- Function:
          uint8_t
          gal_fits_datatype_to_type (int ‘datatype’, int
          ‘is_table_column’)
     Return Gnuastro’s type identifier that corresponds to the CFITSIO
     ‘datatype’.  Note that when dealing with CFITSIO’s ‘TLONG’, the
     fixed width type differs between tables and images.  So if the
     corresponding dataset is a table column, put a non-zero value into
     ‘is_table_column’.


File: gnuastro.info,  Node: FITS HDUs,  Next: FITS header keywords,  Prev: CFITSIO and Gnuastro types,  Up: FITS files

10.3.11.3 FITS HDUs
...................

A FITS file can contain multiple HDUs/extensions.  The functions in this
section can be used to get basic information about the extensions or
open them.  Note that ‘fitsfile’ is defined in CFITSIO’s ‘fitsio.h’
which is automatically included by Gnuastro’s ‘gnuastro/fits.h’.

 -- Function:
          fitsfile *
          gal_fits_open_to_write (char ‘*filename’)
     If ‘filename’ exists, open it and return the ‘fitsfile’ pointer
     that corresponds to it.  If ‘filename’ doesn’t exist, the file will
     be created which contains a blank first extension and the pointer
     to its next extension will be returned.

 -- Function:
          size_t
          gal_fits_hdu_num (char ‘*filename’)
     Return the number of HDUs/extensions in ‘filename’.

 -- Function:
          int
          gal_fits_hdu_format (char ‘*filename’, char ‘*hdu’)
     Return the format of the HDU as one of CFITSIO’s recognized macros:
     ‘IMAGE_HDU’, ‘ASCII_TBL’, or ‘BINARY_TBL’.

 -- Function:
          fitsfile *
          gal_fits_hdu_open (char ‘*filename’, char ‘*hdu’, int
          ‘iomode’)
     Open the HDU/extension ‘hdu’ from ‘filename’ and return a pointer
     to CFITSIO’s ‘fitsfile’.  ‘iomode’ determines how the FITS file
     will be opened using CFITSIO’s macros: ‘READONLY’ or ‘READWRITE’.

     The string in ‘hdu’ will be appended to ‘filename’ in square
     brackets so CFITSIO only opens this extension.  You can use any
     formatting for the ‘hdu’ that is acceptable to CFITSIO. See the
     description under ‘--hdu’ in *note Input output options:: for more.

 -- Function:
          fitsfile *
          gal_fits_hdu_open_format (char ‘*filename’, char ‘*hdu’, int
          ‘img0_tab1’)
     Open (in read-only format) the ‘hdu’ HDU/extension of ‘filename’ as
     an image or table.  When ‘img0_tab1’ is ‘0’(zero) but the HDU is a
     table, this function will abort with an error.  It will also abort
     with an error when ‘img0_tab1’ is ‘1’ (one), but the HDU is an
     image.

     A FITS HDU may contain both tables or images.  When your program
     needs one of these formats, you can call this function so if the
     user provided the wrong HDU/file, it will abort and inform the user
     that the file/HDU is has the wrong format.


File: gnuastro.info,  Node: FITS header keywords,  Next: FITS arrays,  Prev: FITS HDUs,  Up: FITS files

10.3.11.4 FITS header keywords
..............................

Each FITS extension/HDU contains a raw dataset which can either be a
table or an image along with some header keywords.  The keywords can be
used to store meta-data about the actual dataset.  The functions in this
section describe Gnuastro’s high-level functions for reading and writing
FITS keywords.  Similar to all Gnuastro’s FITS-related functions, these
functions are all wrappers for CFITSIO’s low-level functions.

   The necessary meta-data (header keywords) for a particular dataset
are commonly numerous, it is much more efficient to list them in one
variable and call the reading/writing functions once.  Hence the
functions in this section use linked lists, a thorough introduction to
them is given in *note Linked lists::.  To reading FITS keywords, these
functions use a list of Gnuastro’s generic dataset format that is
discussed in *note List of gal_data_t::.  To write FITS keywords we
define the ‘gal_fits_list_key_t’ node that is defined below.

 -- Type (C ‘struct’): gal_fits_list_key_t
     Structure for writing FITS keywords.  This structure is used for
     one keyword and you don’t need to set all elements.  With the
     ‘next’ element, you can link it to another keyword thus creating a
     linked list to add any number of keywords easily and at any step
     during your program (see *note Linked lists:: for an introduction
     on lists).  See the functions below for adding elements to the
     list.

          typedef struct gal_fits_list_key_t
          {
            int                        kfree;   /* ==1, free name.      */
            int                        vfree;   /* ==1, free value.     */
            int                        cfree;   /* ==1, free comment.   */
            uint8_t                     type;   /* Keyword value type.  */
            char                    *keyname;   /* Keyword Name.        */
            void                      *value;   /* Keyword value.       */
            char                    *comment;   /* Keyword comment.     */
            char                       *unit;   /* Keyword unit.        */
            struct gal_fits_list_key_t *next;   /* Next keyword.        */
          } gal_fits_list_key_t;

 -- Function:
          void *
          gal_fits_key_img_blank (uint8_t ‘type’)
     Returns a pointer to an allocated space containing the value to the
     FITS ‘BLANK’ header keyword, when the input array has a type of
     ‘type’.  This is useful when you want to write the ‘BLANK’ keyword
     using CFITSIO’s ‘fits_write_key’ function.

     According to the FITS standard: “If the ‘BSCALE’ and ‘BZERO’
     keywords do not have the default values of 1.0 and 0.0,
     respectively, then the value of the ‘BLANK’ keyword must equal the
     actual value in the FITS data array that is used to represent an
     undefined pixel and not the corresponding physical value”.
     Therefore a special ‘BLANK’ value is needed for datasets containing
     signed 8-bit, unsigned 16-bit, unsigned 32-bit, and unsigned 64-bit
     integers (types that are defined with ‘BSCALE’ and ‘BZERO’ in the
     FITS standard).

     *Not usable when reading a dataset:* As quoted from the FITS
     standard above, the value returned by this function can only be
     generically used for the writing of the ‘BLANK’ keyword header.  It
     _must not_ be used as the blank pointer when when reading a FITS
     array using CFITSIO. When reading an array with CFITSIO, you can
     use ‘gal_blank_alloc_write’ to generate the necessary pointer.

 -- Function:
          void
          gal_fits_key_clean_str_value (char ‘*string’)
     Remove the single quotes and possible extra spaces around the
     keyword values that CFITSIO returns when reading a string keyword.
     CFITSIO doesn’t remove the two single quotes around the string
     value of a keyword.  Hence the strings it reads are like: ‘'value
     '’, or ‘'some_very_long_value'’.  To use the value during your
     processing, it is commonly necessary to remove the single quotes
     (and possible extra spaces).  This function will do this within the
     allocated space of the string.

 -- Function:
          char *
          gal_fits_key_date_to_struct_tm (char ‘*fitsdate’, struct tm
          ‘*tp’)
     Parse ‘fitsdate’ as a FITS date format string (most generally:
     ‘YYYY-MM-DDThh:mm:ss.ddd...’) into the C library’s broken-down time
     structure, or ‘struct tm’ (declared in ‘time.h’) and return a
     pointer to a newly allocated array for the sub-second part of the
     format (‘.ddd...’).  Therefore it needs to be freed afterwards (if
     it isn’t ‘NULL’) When there is no sub-second portion, this pointer
     will be ‘NULL’.

     This is a relatively low-level function, an easier function to use
     is ‘gal_fits_key_date_to_seconds’ which will return the sub-seconds
     as double precision floating point.

     Note that the FITS date format mentioned above is the most complete
     representation.  The following two formats are also acceptable:
     ‘YYYY-MM-DDThh:mm:ss’ and ‘YYYY-MM-DD’.  This option can also
     interpret the older FITS date format where only two characters are
     given to the year and the date format is reversed
     (‘DD/MM/YYThh:mm:ss.ddd...’).  In this case (following the GNU C
     Library), this option will make the following assumption: values 68
     to 99 correspond to the years 1969 to 1999, and values 0 to 68 as
     the years 2000 to 2068.

 -- Function:
          size_t
          gal_fits_key_date_to_seconds (char ‘*fitsdate’, char
          ‘**subsecstr’, double ‘*subsec’)
     Return the Unix epoch time (number of seconds that have passed
     since 00:00:00 Thursday, January 1st, 1970) corresponding to the
     FITS date format string ‘fitsdate’ (see description of
     ‘gal_fits_key_date_to_struct_tm’ above).

     The Unix epoch time is in units of seconds, but the FITS date
     format allows sub-second accuracy.  The last two arguments are for
     the (optional) sub-second portion.  If ‘fitsdate’ contains
     sub-second accuracy, then the starting of the sub-second part’s
     string is stored in ‘subsecstr’ (allocated separately), and
     ‘subsec’ will be the corresponding numerical value (between 0 and
     1, in double precision floating point).  So to avoid leaking
     memory, when ‘subsecstr!=NULL’, it must be freed.

     This is a very useful function for operations on the FITS date
     values, for example sorting FITS files by their dates, or finding
     the time difference between two FITS files.  The advantage of
     working with the Unix epoch time is that you don’t have to worry
     about calendar details (for example the number of days in different
     months, or leap years, etc).

 -- Function:
          void
          gal_fits_key_read_from_ptr (fitsfile ‘*fptr’, gal_data_t
          ‘*keysll’, int ‘readcomment’, int ‘readunit’)

     Read the list of keyword values from a FITS pointer.  The input
     should be a linked list of Gnuastro’s generic data container
     (‘gal_data_t’).  Before calling this function, you just have to set
     the ‘name’ and desired ‘type’ values of each node in the list to
     the keyword you want it to keep the value of.  The given ‘name’
     value will be directly passed to CFITSIO to read the desired
     keyword name.  This function will allocate space to keep the value.
     If ‘readcomment’ and ‘readunit’ are non-zero, this function will
     also try to read the possible comments and units of the keyword.

     Here is one example of using this function:

          /* Allocate an array of datasets. */
          gal_data_t *keysll=gal_data_array_calloc(N);

          /* Make the array usable as a list too (by setting `next'). */
          for(i=0;i<N-1;++i) keysll[i].next=keysll[i+1];

          /* Fill the datasets with a `name' and a `type'. */
          keysll[0].name="NAME1";     keysll[0].type=GAL_TYPE_INT32;
          keysll[1].name="NAME2";     keysll[1].type=GAL_TYPE_STRING;
          ...
          ...

          /* Call this function. */
          gal_fits_key_read_from_ptr(fptr, keysll, 0, 0);

          /* Use the values as you like... */

          /* Free all the allocated spaces. Note that `name' wasn't allocated
             in this example, so we should explicitly set it to NULL before
             calling `gal_data_array_free'. */
          for(i=0;i<N;++i) keysll[i].name=NULL;
          gal_data_array_free(keysll, N, 1);

     If the ‘array’ pointer of each keyword’s dataset is not ‘NULL’,
     then it is assumed that the space to keep the value has already
     been allocated.  If it is ‘NULL’, space will be allocated for the
     value by this function.

     Strings need special consideration: the reason is that generally,
     ‘gal_data_t’ needs to also allow for array of strings (as it
     supports arrays of integers for example).  Hence when reading a
     string value, two allocations may be done by this function (one if
     ‘array!=NULL’).

     Therefore, when using the values of strings after this function,
     ‘keysll[i].array’ must be interpreted as ‘char **’: one allocation
     for the pointer, one for the actual characters.  If you use
     something like the example, above you don’t have to worry about the
     freeing, ‘gal_data_array_free’ will free both allocations.  So to
     read a string, one easy way would be the following:

          char *str, **strarray;
          strarr = keysll[i].array;
          str    = strarray[0];

     If CFITSIO is unable to read a keyword for any reason the ‘status’
     element of the respective ‘gal_data_t’ will be non-zero.  If it is
     zero, then the keyword was found and successfully read.  Otherwise,
     it is a CFITSIO status value.  You can use CFITSIO’s error
     reporting tools or ‘gal_fits_io_error’ (see *note FITS macros
     errors filenames::) for reporting the reason of the failure.  A
     tip: when the keyword doesn’t exist, CFITSIO’s status value will be
     ‘KEY_NO_EXIST’.

     CFITSIO will start searching for the keywords from the last place
     in the header that it searched for a keyword.  So it is much more
     efficient if the order that you ask for keywords is based on the
     order they are stored in the header.

 -- Function:
          void
          gal_fits_key_read (char ‘*filename’, char ‘*hdu’, gal_data_t
          ‘*keysll’, int ‘readcomment’, int ‘readunit’)
     Same as ‘gal_fits_read_keywords_fptr’ (see above), but accepts the
     filename and HDU as input instead of an already opened CFITSIO
     ‘fitsfile’ pointer.

 -- Function:
          void
          gal_fits_key_list_add (gal_fits_list_key_t ‘**list’, uint8_t
          ‘type’, char ‘*keyname’, int ‘kfree’, void ‘*value’, int
          ‘vfree’, char ‘*comment’, int ‘cfree’, char ‘*unit’)
     Add a keyword to the top of list of header keywords that need to be
     written into a FITS file.  In the end, the keywords will have to be
     freed, so it is important to know before hand if they were
     allocated or not (hence the presence of the arguments ending in
     ‘free’).  If the space for the respective element is not allocated,
     set these arguments to ‘0’ (zero).

     *Important note for strings*: the value should be the pointer to
     the string its-self (‘char *’), not a pointer to a pointer (‘char
     **’).

 -- Function:
          void
          gal_fits_key_list_add_end (gal_fits_list_key_t ‘**list’,
          uint8_t ‘type’, char ‘*keyname’, int ‘kfree’, void ‘*value’,
          int ‘vfree’, char ‘*comment’, int ‘cfree’, char ‘*unit’)
     Similar to ‘gal_fits_key_list_add’ (see above) but add the keyword
     to the end of the list.  Use this function if you want the keywords
     to be written in the same order that you add nodes to the list of
     keywords.

 -- Function:
          void
          gal_fits_key_list_reverse (gal_fits_list_key_t ‘**list’)
     Reverse the input list of keywords.

 -- Function:
          void
          gal_fits_key_write_title_in_ptr (char ‘*title’, fitsfile
          ‘*fptr’)
     Add two lines of “title” keywords to the given CFITSIO ‘fptr’
     pointer.  The first line will be blank and the second will have the
     string in ‘title’ roughly in the middle of the line (a fixed
     distance from the start of the keyword line).  A title in the list
     of keywords helps in classifying the keywords into groups and
     inspecting them by eye.  If ‘title==NULL’, this function won’t do
     anything.

 -- Function:
          void
          gal_fits_key_write_filename (char ‘*keynamebase’, char
          ‘*filename’, gal_fits_list_key_t ‘**list’, int ‘top1end0’)
     Put ‘filename’ into the ‘gal_fits_list_key_t’ list (possibly broken
     up into multiple keywords) to later write into a HDU header.  The
     ‘keynamebase’ string will be appended with a ‘_N’ (N>0) and used as
     the keyword name.  If ‘top1end0!=0’, then the keywords containing
     the filename will be added to the top of the list.

     The FITS standard sets a maximum length for the value of a keyword.
     This creates problems with file names (which include directories).
     Because file names/addresses can become very long.  Therefore, when
     ‘filename’ is longer than the maximum length of a FITS keyword
     value, this function will break it into several keywords (breaking
     up the string on directory separators).

 -- Function:
          void
          gal_fits_key_write_wcsstr (fitsfile ‘*fptr’, char ‘*wcsstr’,
          int ‘nkeyrec’)
     Write the WCS header string (produced with WCSLIB’s ‘wcshdo’
     function) into the CFITSIO ‘fitsfile’ pointer.  ‘nkeyrec’ is the
     number of FITS header keywords in ‘wcsstr’.  This function will put
     a few blank keyword lines along with a comment ‘WCS information’
     before writing each keyword record.

 -- Function:
          void
          gal_fits_key_write (gal_fits_list_key_t ‘**keylist’, char
          ‘*title’, char ‘*filename’, char ‘*hdu’)
     Write the list of keywords in ‘keylist’ into the ‘hdu’ extension of
     the file called ‘filename’ (it must already exist).

 -- Function:
          void
          gal_fits_key_write_in_ptr (gal_fits_list_key_t ‘**keylist’,
          fitsfile ‘*fptr’)
     Write the list of keywords in ‘keylist’ into the given CFITSIO
     ‘fitsfile’ pointer.

 -- Function:
          void
          gal_fits_key_write_version (gal_fits_list_key_t ‘**keylist’,
          char ‘*title’, char ‘*filename’, char ‘*hdu’)
     Write the (optional, when ‘keylist!=NULL’) given list of keywords
     under the optional FITS keyword ‘title’, then print all the
     important version and date information.  This is basically, just a
     wrapper over ‘gal_fits_key_write_version_in_ptr’.

 -- Function:
          void
          gal_fits_key_write_version_in_ptr (gal_fits_list_key_t
          ‘**keylist’, char ‘*title’, fitsfile ‘*fptr’)
     Write or update (all the) keyword(s) in ‘headers’ into the FITS
     pointer, but also the date, name of your program (‘program_name’),
     along with the versions of CFITSIO, WCSLIB (when available), GSL,
     Gnuastro, and (the possible) commit information into the header as
     described in *note Output FITS files::.

     Since the data processing depends on the versions of the libraries
     you have used, it is strongly recommended to include this
     information in every FITS output.  ‘gal_fits_img_write’ and
     ‘gal_fits_tab_write’ will automatically use this function.

 -- Function:
          void
          gal_fits_key_write_config (gal_fits_list_key_t ‘**keylist’,
          char ‘*title’, char ‘*extname’, char ‘*filename’, char ‘*hdu’)
     Write the given keyword list (‘keylist’) into the ‘hdu’ extension
     of ‘filename’, ending it with version information.  This function
     will write ‘extname’ as the name of the extension (value to the
     standard ‘EXTNAME’ FITS keyword).  The list of keywords will then
     be printed under a title called ‘title’.

     This function is used by many Gnuastro programs and is primarily
     intended for writing configuration settings of a program into the
     zero-th extension of their FITS outputs (which is empty when the
     FITS file is created by Gnuastro’s program and this library).


File: gnuastro.info,  Node: FITS arrays,  Next: FITS tables,  Prev: FITS header keywords,  Up: FITS files

10.3.11.5 FITS arrays (images)
..............................

Images (or multi-dimensional arrays in general) are one of the common
data formats that is stored in FITS files.  Only one image may be stored
in each FITS HDU/extension.  The functions described here can be used to
get the information of, read, or write images in FITS files.

 -- Function:
          void
          gal_fits_img_info (fitsfile ‘*fptr’, int ‘*type’, size_t
          ‘*ndim’, size_t ‘**dsize’, char ‘**name’, char ‘**unit’)
     Read the type (see *note Library data types::), number of
     dimensions, and size along each dimension of the CFITSIO ‘fitsfile’
     into the ‘type’, ‘ndim’, and ‘dsize’ pointers respectively.  If
     ‘name’ and ‘unit’ are not ‘NULL’ (point to a ‘char *’), then if the
     image has a name and units, the respective string will be put in
     these pointers.

 -- Function:
          size_t *
          gal_fits_img_info_dim (char ‘*filename’, char ‘*hdu’, size_t
          ‘*ndim’)
     Put the number of dimensions in the ‘hdu’ extension of ‘filename’
     in the space that ‘ndim’ points to and return the size of the
     dataset along each dimension as an allocated array with ‘*ndim’
     elements.

 -- Function:
          gal_data_t *
          gal_fits_img_read (char ‘*filename’, char ‘*hdu’, size_t
          ‘minmapsize’, int ‘quietmmap’)
     Read the contents of the ‘hdu’ extension/HDU of ‘filename’ into a
     Gnuastro generic data container (see *note Generic data
     container::) and return it.  If the necessary space is larger than
     ‘minmapsize’, then don’t keep the data in RAM, but in a file on the
     HDD/SSD. For more on ‘minmapsize’ and ‘quietmmap’ see the
     description under the same name in *note Generic data container::.

     Note that this function only reads the main data within the
     requested FITS extension, the WCS will not be read into the
     returned dataset.  To read the WCS, you can use ‘gal_wcs_read’
     function as shown below.  Afterwards, the ‘gal_data_free’ function
     will free both the dataset and any WCS structure (if there are
     any).
          data=gal_fits_img_read(filename, hdu, -1, 1);
          data->wcs=gal_wcs_read(filename, hdu, 0, 0, &data->wcs->nwcs);

 -- Function:
          gal_data_t *
          gal_fits_img_read_to_type (char ‘*inputname’, char ‘*inhdu’,
          uint8_t ‘type’, size_t ‘minmapsize’, int ‘quietmmap’)
     Read the contents of the ‘hdu’ extension/HDU of ‘filename’ into a
     Gnuastro generic data container (see *note Generic data
     container::) of type ‘type’ and return it.

     This is just a wrapper around ‘gal_fits_img_read’ (to read the
     image/array of any type) and ‘gal_data_copy_to_new_type_free’ (to
     convert it to ‘type’ and free the initially read dataset).  See the
     description there for more.

 -- Function:
          gal_data_t *
          gal_fits_img_read_kernel (char ‘*filename’, char ‘*hdu’,
          size_t ‘minmapsize’, int ‘quietmmap’)
     Read the ‘hdu’ of ‘filename’ as a convolution kernel.  A
     convolution kernel must have an odd size along all dimensions, it
     must not have blank (NaN in floating point types) values and must
     be flipped around the center to make the proper convolution (see
     *note Convolution process::).  If there are blank values, this
     function will change the blank values to ‘0.0’.  If the input image
     doesn’t have the other two requirements, this function will abort
     with an error describing the condition to the user.  The finally
     returned dataset will have a ‘float32’ type.

 -- Function:
          fitsfile *
          gal_fits_img_write_to_ptr (gal_data_t ‘*input’, char
          ‘*filename’)
     Write the ‘input’ dataset into a FITS file named ‘filename’ and
     return the corresponding CFITSIO ‘fitsfile’ pointer.  This function
     won’t close ‘fitsfile’, so you can still add other extensions to it
     after this function or make other modifications.

 -- Function:
          void
          gal_fits_img_write (gal_data_t ‘*data’, char ‘*filename’,
          gal_fits_list_key_t ‘*headers’, char ‘*program_string’)
     Write the ‘input’ dataset into the FITS file named ‘filename’.
     Also add the ‘headers’ keywords to the newly created HDU/extension
     it along with your program’s name (‘program_string’).

 -- Function:
          void
          gal_fits_img_write_to_type (gal_data_t ‘*data’, char
          ‘*filename’, gal_fits_list_key_t ‘*headers’, char
          ‘*program_string’, int ‘type’)
     Convert the ‘input’ dataset into ‘type’, then write it into the
     FITS file named ‘filename’.  Also add the ‘headers’ keywords to the
     newly created HDU/extension along with your program’s name
     (‘program_string’).  After the FITS file is written, this function
     will free the copied dataset (with type ‘type’) from memory.

     This is just a wrapper for the ‘gal_data_copy_to_new_type’ and
     ‘gal_fits_img_write’ functions.

 -- Function:
          void
          gal_fits_img_write_corr_wcs_str (gal_data_t ‘*data’, char
          ‘*filename’, char ‘*wcsstr’, int ‘nkeyrec’, double ‘*crpix’,
          gal_fits_list_key_t ‘*headers’, char ‘*program_string’)
     Write the ‘input’ dataset into ‘filename’ using the ‘wcsstr’ while
     correcting the ‘CRPIX’ values.

     This function is mainly useful when you want to make FITS files in
     parallel (from one main WCS structure, with just differing CRPIX).
     This can happen in the following cases for example:

        • When a large number of FITS images (with WCS) need to be
          created in parallel, it can be much more efficient to write
          the header’s WCS keywords once at first, write them in the
          FITS file, then just correct the CRPIX values.

        • WCSLIB’s header writing function is not thread safe.  So when
          writing FITS images in parallel, we can’t write the header
          keywords in each thread.


File: gnuastro.info,  Node: FITS tables,  Prev: FITS arrays,  Up: FITS files

10.3.11.6 FITS tables
.....................

Tables are one of the common formats of data that is stored in FITS
files.  Only one table may be stored in each FITS HDU/extension, but
each table column must be viewed as a different dataset (with its own
name, units and numeric data type for example).  The only constraint of
the column datasets in a table is that they must be one-dimensional and
have the same number of elements as the other columns.  The functions
described here can be used to get the information of, read, or write
columns into FITS tables.

 -- Function:
          void
          gal_fits_tab_size (fitsfile ‘*fitsptr’, size_t ‘*nrows’,
          size_t ‘*ncols’)
     Read the number of rows and columns in the table within CFITSIO’s
     ‘fitsptr’.

 -- Function:
          int
          gal_fits_tab_format (fitsfile ‘*fitsptr’)
     Return the format of the FITS table contained in CFITSIO’s
     ‘fitsptr’.  Recall that FITS tables can be in binary or ASCII
     formats.  This function will return ‘GAL_TABLE_FORMAT_AFITS’ or
     ‘GAL_TABLE_FORMAT_BFITS’ (defined in *note Table input output::).
     If the ‘fitsptr’ is not a table, this function will abort the
     program with an error message informing the user of the problem.

 -- Function:
          gal_data_t *
          gal_fits_tab_info (char ‘*filename’, char ‘*hdu’, size_t
          ‘*numcols’, size_t ‘*numrows’, int ‘*tableformat’)
     Store the information of each column in ‘hdu’ of ‘filename’ into an
     array of data structures with ‘numcols’ elements (one data
     structure for each column) see *note Arrays of datasets::.  The
     total number of rows in the table is also put into the memory that
     ‘numrows’ points to.  The format of the table (e.g., FITS binary or
     ASCII table) will be put in ‘tableformat’ (macros defined in *note
     Table input output::).

     This function is just for column information.  Therefore it only
     stores meta-data like column name, units and comments.  No actual
     data (contents of the columns for example the ‘array’ or ‘dsize’
     elements) will be allocated by this function.  This is a low-level
     function particular to reading tables in FITS format.  To be
     generic, it is recommended to use ‘gal_table_info’ which will allow
     getting information from a variety of table formats based on the
     filename (see *note Table input output::).

 -- Function:
          gal_data_t *
          gal_fits_tab_read (char ‘*filename’, char ‘*hdu’, size_t
          ‘numrows’, gal_data_t ‘*colinfo’, gal_list_sizet_t ‘*indexll’,
          size_t ‘minmapsize’, int ‘quietmmap’)
     Read the columns given in the list ‘indexll’ from a FITS table (in
     ‘filename’ and HDU/extension ‘hdu’) into the returned linked list
     of data structures, see *note List of size_t:: and *note List of
     gal_data_t::.  If the necessary space for each column is larger
     than ‘minmapsize’, don’t keep it in the RAM, but in a file in the
     HDD/SSD. For more on ‘minmapsize’ and ‘quietmmap’, see the
     description under the same name in *note Generic data container::.

     Each column will have ‘numrows’ rows and ‘colinfo’ contains any
     further information about the columns (returned by
     ‘gal_fits_tab_info’, described above).  Note that this is a
     low-level function, so the output data linked list is the inverse
     of the input indexes linked list.  It is recommended to use
     ‘gal_table_read’ for generic reading of tables, see *note Table
     input output::.

 -- Function:
          void
          gal_fits_tab_write (gal_data_t ‘*cols’, gal_list_str_t
          ‘*comments’, int ‘tableformat’, char ‘*filename’, char
          ‘*extname’)
     Write the list of datasets in ‘cols’ (see *note List of
     gal_data_t::) as separate columns in a FITS table in ‘filename’.
     If ‘filename’ already exists then this function will write the
     table as a new extension called ‘extname’, after all existing ones.
     The format of the table (ASCII or binary) may be specified with the
     ‘tableformat’ (see *note Table input output::).  If
     ‘comments!=NULL’, each node of the list of strings will be written
     as a ‘COMMENT’ keywords in the output FITS file (see *note List of
     strings::.

     This is a low-level function for tables.  It is recommended to use
     ‘gal_table_write’ for generic writing of tables in a variety of
     formats, see *note Table input output::.


File: gnuastro.info,  Node: File input output,  Next: World Coordinate System,  Prev: FITS files,  Up: Gnuastro library

10.3.12 File input output
-------------------------

The most commonly used file format in astronomical data analysis is the
FITS format (see *note Fits:: for an introduction), therefore Gnuastro’s
library provides a large and separate collection of functions to
read/write data from/to them (see *note FITS files::).  However, FITS is
not well recognized outside the astronomical community and cannot be
imported into documents or slides.  Therefore, in this section, we
discuss the other different file formats that Gnuastro’s library
recognizes.

* Menu:

* Text files::                  Reading and writing from/to plain text files.
* TIFF files::                  Reading and writing from/to TIFF files.
* JPEG files::                  Reading and writing from/to JPEG files.
* EPS files::                   Writing to EPS files.
* PDF files::                   Writing to PDF files.


File: gnuastro.info,  Node: Text files,  Next: TIFF files,  Prev: File input output,  Up: File input output

10.3.12.1 Text files (‘txt.h’)
..............................

The most universal and portable format for data storage are plain text
files.  They can be viewed and edited on any text editor or even on the
command-line.  This section are describes some functions that help in
reading from and writing to plain text files.

   Lines are one of the most basic building blocks (delimiters) of a
text file.  Some operating systems like Microsoft Windows, terminate
their ASCII text lines with a carriage return character and a new-line
character (two characters, also known as CRLF line terminators).  While
Unix-like operating systems just use a single new-line character.  The
functions below that read an ASCII text file are able to identify lines
with both kinds of line terminators.

   Gnuastro defines a simple format for metadata of table columns in a
plain text file that is discussed in *note Gnuastro text table format::.
The functions to get information from, read from and write to plain text
files also follow those conventions.

 -- Macro: GAL_TXT_LINESTAT_INVALID
 -- Macro: GAL_TXT_LINESTAT_BLANK
 -- Macro: GAL_TXT_LINESTAT_COMMENT
 -- Macro: GAL_TXT_LINESTAT_DATAROW
     Status codes for lines in a plain text file that are returned by
     ‘gal_txt_line_stat’.  Lines which have a <#> character as their
     first non-white character are considered to be comments.  Lines
     with nothing but white space characters are considered blank.  The
     remaining lines are considered as containing data.

 -- Function:
          int
          gal_txt_line_stat (char ‘*line’)
     Check the contents of ‘line’ and see if it is a blank, comment, or
     data line.  The returned values are the macros that start with
     ‘GAL_TXT_LINESTAT’.

 -- Function:
          char *
          gal_txt_trim_space (char ‘*str’)
     Trim the white space characters before and after the given string.
     The operation is done within the allocated space of the string, so
     if you need the string untouched, please pass an allocated copy of
     the string to this function.  The returned pointer is within the
     input string.  If the input pointer is ‘NULL’, or the string only
     has white-space characters, the returned pointer will be ‘NULL’.

 -- Function:
          gal_data_t *
          gal_txt_table_info (char ‘*filename’, gal_list_str_t ‘*lines’,
          size_t ‘*numcols’, size_t ‘*numrows’)
     Store the information of each column in a text file ‘filename’, or
     list of strings (‘lines’) into an array of data structures with
     ‘numcols’ elements (one data structure for each column) see *note
     Arrays of datasets::.  The total number of rows in the table is
     also put into the memory that ‘numrows’ points to.

     ‘lines’ is a list of strings with each node representing one line
     (including the new-line character), see *note List of strings::.
     It will mostly be the output of ‘gal_txt_stdin_read’, which is used
     to read the program’s input as separate lines from the standard
     input (see below).  Note that ‘filename’ and ‘lines’ are mutually
     exclusive and one of them must be ‘NULL’.

     This function is just for column information.  Therefore it only
     stores meta-data like column name, units and comments.  No actual
     data (contents of the columns for example the ‘array’ or ‘dsize’
     elements) will be allocated by this function.  This is a low-level
     function particular to reading tables in plain text format.  To be
     generic, it is recommended to use ‘gal_table_info’ which will allow
     getting information from a variety of table formats based on the
     filename (see *note Table input output::).

 -- Function:
          gal_data_t *
          gal_txt_table_read (char ‘*filename’, gal_list_str_t ‘*lines’,
          size_t ‘numrows’, gal_data_t ‘*colinfo’, gal_list_sizet_t
          ‘*indexll’, size_t ‘minmapsize’, int ‘quietmmap’)
     Read the columns given in the list ‘indexll’ from a plain text file
     (‘filename’) or list of strings (‘lines’), into a linked list of
     data structures (see *note List of size_t:: and *note List of
     gal_data_t::).  If the necessary space for each column is larger
     than ‘minmapsize’, don’t keep it in the RAM, but in a file on the
     HDD/SSD. For more one ‘minmapsize’ and ‘quietmmap’, see the
     description under the same name in *note Generic data container::.

     ‘lines’ is a list of strings with each node representing one line
     (including the new-line character), see *note List of strings::.
     It will mostly be the output of ‘gal_txt_stdin_read’, which is used
     to read the program’s input as separate lines from the standard
     input (see below).  Note that ‘filename’ and ‘lines’ are mutually
     exclusive and one of them must be ‘NULL’.

     Note that this is a low-level function, so the output data list is
     the inverse of the input indexs linked list.  It is recommended to
     use ‘gal_table_read’ for generic reading of tables in any format,
     see *note Table input output::.

 -- Function:
          gal_data_t *
          gal_txt_image_read (char ‘*filename’, gal_list_str_t ‘*lines’,
          size_t ‘minmapsize’, int ‘quietmmap’)
     Read the 2D plain text dataset in file (‘filename’) or list of
     strings (‘lines’) into a dataset and return the dataset.  If the
     necessary space for the image is larger than ‘minmapsize’, don’t
     keep it in the RAM, but in a file on the HDD/SSD. For more on
     ‘minmapsize’ and ‘quietmmap’, see the description under the same
     name in *note Generic data container::.

     ‘lines’ is a list of strings with each node representing one line
     (including the new-line character), see *note List of strings::.
     It will mostly be the output of ‘gal_txt_stdin_read’, which is used
     to read the program’s input as separate lines from the standard
     input (see below).  Note that ‘filename’ and ‘lines’ are mutually
     exclusive and one of them must be ‘NULL’.

 -- Function:
          gal_list_str_t *
          gal_txt_stdin_read (long ‘timeout_microsec’)
     Read the complete standard input and return a list of strings with
     each line (including the new-line character) as one node of that
     list.  If the standard input is already filled (for example
     connected to another program’s output with a pipe), then this
     function will parse the whole stream.

     If Standard input is not pre-configured and the _first line_ is
     typed/written in the terminal before ‘timeout_microsec’
     micro-seconds, it will continue parsing until reaches an
     end-of-file character (<CTRL-D> after a new-line on the keyboard)
     with no time limit.  If nothing is entered before
     ‘timeout_microsec’ micro-seconds, it will return ‘NULL’.

     All the functions that can read plain text tables will accept a
     filename as well as a list of strings (intended to be the output of
     this function for using Standard input).  The reason for keeping
     the standard input is that once something is read from the standard
     input, it is hard to put it back.  We often need to read a text
     file several times: once to count how many columns it has and which
     ones are requested, and another time to read the desired columns.
     So it easier to keep it all in allocated memory and pass it on from
     the start for each round.

 -- Function:
          void
          gal_txt_write (gal_data_t ‘*cols’, gal_list_str_t ‘*comment’,
          char ‘*filename’, uint8_t ‘colinfoinstdout’)
     Write ‘cols’ in a plain text file ‘filename’.  ‘cols’ may have one
     or two dimensions which determines the output:

     1D
          ‘cols’ is treated as a column and a list of datasets (see
          *note List of gal_data_t::): every node in the list is written
          as one column in a table.

     2D
          ‘cols’ is a two dimensional array, it cannot be treated as a
          list (only one 2D array can currently be written to a text
          file).  So if ‘cols->next!=NULL’ the next nodes in the list
          are ignored and will not be written.

     This is a low-level function for tables.  It is recommended to use
     ‘gal_table_write’ for generic writing of tables in a variety of
     formats, see *note Table input output::.

     If ‘filename’ already exists this function will abort with an error
     and will not write over the existing file.  Before calling this
     function make sure if the file exists or not.  If ‘comments!=NULL’,
     a ‘#’ will be put at the start of each node of the list of strings
     and will be written in the file before the column meta-data in
     ‘filename’ (see *note List of strings::).

     When ‘filename==NULL’, the column information will be printed on
     the standard output (command-line).  When ‘colinfoinstdout!=0’ and
     ‘filename==NULL’ (columns are printed in the standard output), the
     dataset metadata will also printed in the standard output.  When
     printing to the standard output, the column information can be
     piped into another program for further processing and thus the
     meta-data (lines starting with a ‘#’) must be ignored.  In such
     cases, you only print the column values by passing ‘0’ to
     ‘colinfoinstdout’.


File: gnuastro.info,  Node: TIFF files,  Next: JPEG files,  Prev: Text files,  Up: File input output

10.3.12.2 TIFF files (‘tiff.h’)
...............................

Outside of astronomy, the TIFF standard is arguably the most commonly
used format to store high-precision data/images.  Unlike FITS however,
the TIFF standard only supports images (not tables), but like FITS, it
has support for all standard data types (see *note Numeric data types::)
which is the primary reason other fields use it.

   Another similarity of the TIFF and FITS standards is that TIFF
supports multiple images in one file.  The TIFF standard calls each one
of these images (and their accompanying meta-data) a ‘directory’
(roughly equivalent to the FITS extensions).  Unlike FITS however, the
directories can only be identified by their number (counting from zero),
recall that in FITS you can also use the extension name to identify it.

   The functions described here allow easy reading (and later writing)
of TIFF files within Gnuastro or for users of Gnuastro’s libraries.
Currently only reading is supported, but if you are interested, please
get in touch with us.

 -- Function:
          int
          gal_tiff_name_is_tiff (char ‘*name’)
     Return ‘1’ if ‘name’ has a TIFF suffix.  This can be used to make
     sure that a given input file is TIFF. See ‘gal_tiff_suffix_is_tiff’
     for a list of recognized suffixes.

 -- Function:
          int
          gal_tiff_suffix_is_tiff (char ‘*name’)
     Return ‘1’ if ‘suffix’ is a recognized TIFF suffix.  The recognized
     suffixes are ‘tif’, ‘tiff’, ‘TIFF’ and ‘TIFF’.

 -- Function:
          size_t
          gal_tiff_dir_string_read (char ‘*string’)
     Return the number within ‘string’ as a ‘size_t’ number to identify
     a TIFF directory.  Note that the directories start counting from
     zero.

 -- Function:
          gal_data_t *
          gal_tiff_read (char ‘*filename’, size_t ‘dir’, size_t
          ‘minmapsize’, int ‘quietmmap’)
     Read the ‘dir’ directory within the TIFF file ‘filename’ and return
     the contents of that TIFF directory as ‘gal_data_t’.  If the
     directory’s image contains multiple channels, the output will be a
     list (see *note List of gal_data_t::).


File: gnuastro.info,  Node: JPEG files,  Next: EPS files,  Prev: TIFF files,  Up: File input output

10.3.12.3 JPEG files (‘jpeg.h’)
...............................

The JPEG file format is one of the most common formats for storing and
transferring images, recognized by almost all image rendering and
processing programs.  In particular, because of its lossy compression
algorithm, JPEG files can have low volumes, making it used heavily on
the internet.  For more on this file format, and a comparison with
others, please see *note Recognized file formats::.

   For scientific purposes, the lossy compression and very limited
dynamic range (8-bit integers) make JPEG very unattractive for storing
of valuable data.  However, because of its commonality, it will
inevitably be needed in some situations.  The functions here can be used
to read and write JPEG images into Gnuastro’s *note Generic data
container::.  If the JPEG file has more than one color channel, each
channel is treated as a separate node in a list of datasets (see *note
List of gal_data_t::).

 -- Function:
          int
          gal_jpeg_name_is_jpeg (char ‘*name’)
     Return ‘1’ if ‘name’ has a JPEG suffix.  This can be used to make
     sure that a given input file is JPEG. See ‘gal_jpeg_suffix_is_jpeg’
     for a list of recognized suffixes.

 -- Function:
          int
          gal_jpeg_suffix_is_jpeg (char ‘*name’)
     Return ‘1’ if ‘suffix’ is a recognized JPEG suffix.  The recognized
     suffixes are ‘.jpg’, ‘.JPG’, ‘.jpeg’, ‘.JPEG’, ‘.jpe’, ‘.jif’,
     ‘.jfif’ and ‘.jfi’.

 -- Function:
          gal_data_t *
          gal_jpeg_read (char ‘*filename’, size_t ‘minmapsize’, int
          ‘quietmmap’)
     Read the JPEG file ‘filename’ and return the contents as
     ‘gal_data_t’.  If the directory’s image contains multiple
     colors/channels, the output will be a list with one node per
     color/channel (see *note List of gal_data_t::).

 -- Function:
          void
          gal_jpeg_write (gal_data_t ‘*in’, char ‘*filename’, uint8_t
          ‘quality’, float ‘widthincm’)
     Write the given dataset (‘in’) into ‘filename’ (a JPEG file).  If
     ‘in’ is a list, then each node in the list will be a color channel,
     therefore there can only be 1, 3 or 4 nodes in the list.  If the
     number of nodes is different, then this function will abort the
     program with a message describing the cause.  The lossy JPEG
     compression level can be set through ‘quality’ which is a value
     between 0 and 100 (inclusive, 100 being the best quality).  The
     display width of the JPEG file in units of centimeters (to suggest
     to viewers/users, only a meta-data) can be set through ‘widthincm’.


File: gnuastro.info,  Node: EPS files,  Next: PDF files,  Prev: JPEG files,  Up: File input output

10.3.12.4 EPS files (‘eps.h’)
.............................

The Encapsulated PostScript (EPS) format is commonly used to store
images (or individual/single-page parts of a document) in the PostScript
documents.  For a more complete introduction, please see *note
Recognized file formats::.  To provide high quality graphics, the
Postscript language is a vectorized format, therefore pixels (elements
of a “rasterized” format) aren’t defined in their context.

   To display rasterized images, PostScript does allow arrays of pixels.
However, since the over-all EPS file may contain many vectorized
elements (for example borders, text, or other lines over the text) and
interpreting them is not trivial or necessary within Gnuastro’s scope,
Gnuastro only provides some functions to write a dataset (in the
‘gal_data_t’ format, see *note Generic data container::) into EPS.

 -- Function:
          int
          gal_eps_name_is_eps (char ‘*name’)
     Return ‘1’ if ‘name’ has an EPS suffix.  This can be used to make
     sure that a given input file is EPS. See ‘gal_eps_suffix_is_eps’
     for a list of recognized suffixes.

 -- Function:
          int
          gal_eps_suffix_is_eps (char ‘*name’)
     Return ‘1’ if ‘suffix’ is a recognized EPS suffix.  The recognized
     suffixes are ‘.eps’, ‘.EPS’, ‘.epsf’, ‘.epsi’.

 -- Function:
          void
          gal_eps_to_pt (float ‘widthincm’, size_t ‘*dsize’, size_t
          ‘*w_h_in_pt’)
     Given a specific width in centimeters (‘widthincm’ and the number
     of the dataset’s pixels in each dimension (‘dsize’) calculate the
     size of the output in PostScript points.  The output values are
     written in the ‘w_h_in_pt’ array (which has to be allocated before
     calling this function).  The first element in ‘w_h_in_pt’ is the
     width and the second is the height of the image.

 -- Function:
          void
          gal_eps_write (gal_data_t ‘*in’, char ‘*filename’, float
          ‘widthincm’, uint32_t ‘borderwidth’, int ‘hex’, int
          ‘dontoptimize’, int ‘forpdf’)
     Write the ‘in’ dataset into an EPS file called ‘filename’.  ‘in’
     has to be an unsigned 8-bit character type (‘GAL_TYPE_UINT8’, see
     *note Numeric data types::).  The desired width of the image in
     human/non-pixel units (to help the displayer) can be set with the
     ‘widthincm’ argument.  If ‘borderwidth’ is non-zero, it is
     interpreted as the width (in points) of a solid black border around
     the image.  A border can helpful when importing the EPS file into a
     document.

     EPS files are plain-text (can be opened/edited in a text editor),
     therefore there are different encodings to store the data (pixel
     values) within them.  Gnuastro supports the Hexadecimal and ASCII85
     encoding.  ASCII85 is more efficient (producing small file sizes),
     so it is the default encoding.  To use Hexadecimal encoding, set
     ‘hex’ to a non-zero value.  Currently If you don’t directly want to
     import the EPS file into a PostScript document but want to later
     compile it into a PDF file, set the ‘forpdf’ argument to ‘1’.

     By default, when the dataset only has two values, this function
     will use the PostScript optimization that allows setting the pixel
     values per bit, not byte (*note Recognized file formats::).  This
     can greatly help reduce the file size.  However, when
     ‘dontoptimize!=0’, this optimization is disabled: even though there
     are only two values (is binary), the difference between them does
     not correspond to the full contrast of black and white.


File: gnuastro.info,  Node: PDF files,  Prev: EPS files,  Up: File input output

10.3.12.5 PDF files (‘pdf.h’)
.............................

The portable document format (PDF) has arguably become the most common
format used for distribution of documents.  In practice, a PDF file is
just a compiled PostScript file.  For a more complete introduction,
please see *note Recognized file formats::.  To provide high quality
graphics, the PDF is a vectorized format, therefore pixels (elements of
a “rasterized” format) aren’t defined in their context.  As a result,
similar to *note EPS files::, Gnuastro only writes datasets to a PDF
file, not vice-versa.

 -- Function:
          int
          gal_pdf_name_is_pdf (char ‘*name’)
     Return ‘1’ if ‘name’ has an PDF suffix.  This can be used to make
     sure that a given input file is PDF. See ‘gal_pdf_suffix_is_pdf’
     for a list of recognized suffixes.

 -- Function:
          int
          gal_pdf_suffix_is_pdf (char ‘*name’)
     Return ‘1’ if ‘suffix’ is a recognized PDF suffix.  The recognized
     suffixes are ‘.pdf’ and ‘.PDF’.

 -- Function:
          void
          gal_pdf_write (gal_data_t ‘*in’, char ‘*filename’, float
          ‘widthincm’, uint32_t ‘borderwidth’, int ‘dontoptimize’)
     Write the ‘in’ dataset into an EPS file called ‘filename’.  ‘in’
     has to be an unsigned 8-bit character type (‘GAL_TYPE_UINT8’, see
     *note Numeric data types::).  The desired width of the image in
     human/non-pixel units (to help the displayer) can be set with the
     ‘widthincm’ argument.  If ‘borderwidth’ is non-zero, it is
     interpreted as the width (in points) of a solid black border around
     the image.  A border can helpful when importing the PDF file into a
     document.

     This function is just a wrapper for the ‘gal_eps_write’ function in
     *note EPS files::.  After making the EPS file, Ghostscript (with a
     version of 9.10 or above, see *note Optional dependencies::) will
     be used to compile the EPS file to a PDF file.  Therefore if
     GhostScript doesn’t exist, doesn’t have the proper version, or
     fails for any other reason, the EPS file will remain.  It can be
     used to find the cause, or use another converter or PostScript
     compiler.

     By default, when the dataset only has two values, this function
     will use the PostScript optimization that allows setting the pixel
     values per bit, not byte (*note Recognized file formats::).  This
     can greatly help reduce the file size.  However, when
     ‘dontoptimize!=0’, this optimization is disabled: even though there
     are only two values (is binary), the difference between them does
     not correspond to the full contrast of black and white.


File: gnuastro.info,  Node: World Coordinate System,  Next: Arithmetic on datasets,  Prev: File input output,  Up: Gnuastro library

10.3.13 World Coordinate System (‘wcs.h’)
-----------------------------------------

The FITS standard defines the world coordinate system (WCS) as a
mechanism to associate physical values to positions within a dataset.
For example, it can be used to convert pixel coordinates in an image to
celestial coordinates like the right ascension and declination.  The
functions in this section are mainly just wrappers over CFITSIO, WCSLIB
and GSL library functions to help in common applications.

 -- Function:
          struct wcsprm *
          gal_wcs_read_fitsptr (fitsfile ‘*fptr’, size_t ‘hstartwcs’,
          size_t ‘hendwcs’, int ‘*nwcs’)
     [*Not thread-safe*] Return the WCSLIB ‘wcsprm’ structure that is
     read from the CFITSIO ‘fptr’ pointer to an opened FITS file.  Also
     put the number of coordinate representations found into the space
     that ‘nwcs’ points to.  To read the WCS structure directly from a
     filename, see ‘gal_wcs_read’ below.  After processing has finished,
     you can free the returned structure with WCSLIB’s ‘wcsvfree’
     keyword:

          status = wcsvfree(&nwcs,&wcs);

     If you don’t want to search the full FITS header for WCS-related
     FITS keywords (for example due to conflicting keywords), but only a
     specific range of the header keywords you can use the ‘hstartwcs’
     and ‘hendwcs’ arguments to specify the keyword number range
     (counting from zero).  If ‘hendwcs’ is larger than ‘hstartwcs’,
     then only keywords in the given range will be checked.  Hence, to
     ignore this feature (and search the full FITS header), give both
     these arguments the same value.

     If the WCS information couldn’t be read from the FITS file, this
     function will return a ‘NULL’ pointer and put a zero in ‘nwcs’.  A
     WCSLIB error message will also be printed in ‘stderr’ if there was
     an error.

     This function is just a wrapper over WCSLIB’s ‘wcspih’ function
     which is not thread-safe.  Therefore, be sure to not call this
     function simultaneously (over multiple threads).

 -- Function:
          struct wcsprm *
          gal_wcs_read (char ‘*filename’, char ‘*hdu’, size_t
          ‘hstartwcs’, size_t ‘hendwcs’, int ‘*nwcs’)
     [*Not thread-safe*] Return the WCSLIB structure that is read from
     the HDU/extension ‘hdu’ of the file ‘filename’.  Also put the
     number of coordinate representations found into the space that
     ‘nwcs’ points to.  Please see ‘gal_wcs_read_fitsptr’ for more.

 -- Function:
          struct wcsprm *
          gal_wcs_copy (struct wcsprm ‘*wcs’)
     Return a fully allocated (independent) copy of ‘wcs’.

 -- Function:
          void
          gal_wcs_remove_dimension (struct wcsprm ‘*wcs’, size_t
          ‘fitsdim’)
     Remove the given FITS dimension from the given ‘wcs’ structure.

 -- Function:
          void
          gal_wcs_on_tile (gal_data_t ‘*tile’)
     Create a WCSLIB ‘wcsprm’ structure for ‘tile’ using WCS parameters
     of the tile’s allocated block dataset, see *note Tessellation
     library:: for the definition of tiles.  If ‘tile’ already has a WCS
     structure, this function won’t do anything.

     In many cases, tiles are created for internal/low-level processing.
     Hence for performance reasons, when creating the tiles they don’t
     have any WCS structure.  When needed, this function can be used to
     add a WCS structure to each tile tile by copying the WCS structure
     of its block and correcting the reference point’s coordinates
     within the tile.

 -- Function:
          double *
          gal_wcs_warp_matrix (struct wcsprm ‘*wcs’)
     Return the Warping matrix of the given WCS structure as an array of
     double precision floating points.  This will be the final matrix,
     irrespective of the type of storage in the WCS structure.  Recall
     that the FITS standard has several methods to store the matrix.
     The output is an allocated square matrix with each side equal to
     the number of dimensions.

 -- Function:
          void
          gal_wcs_decompose_pc_cdelt (struct wcsprm ‘*wcs’)
     Decompose the ‘PCi_j’ and ‘CDELTi’ elements of ‘wcs’.  According to
     the FITS standard, in the ‘PCi_j’ WCS formalism, the rotation
     matrix elements $m_{ij}$ are encoded in the ‘PCi_j’ keywords and
     the scale factors are encoded in the ‘CDELTi’ keywords.  There is
     also another formalism (the ‘CDi_j’ formalism) which merges the two
     into one matrix.

     However, WCSLIB’s internal operations are apparently done in the
     ‘PCi_j’ formalism.  So its outputs are also all in that format by
     default.  When the input is a ‘CDi_j’, WCSLIB will still read the
     matrix directly into the ‘PCi_j’ matrix and the ‘CDELTi’ values are
     set to ‘1’ (one).  This function is designed to correct such
     issues: after it is finished, the ‘CDELTi’ values in ‘wcs’ will
     correspond to the pixel scale, and the ‘PCi_j’ will correction show
     the rotation.

 -- Function:
          double
          gal_wcs_angular_distance_deg (double ‘r1’, double ‘d1’, double
          ‘r2’, double ‘d2’)
     Return the angular distance (in degrees) between a point located at
     (‘r1’, ‘d1’) to (‘r2’, ‘d2’).  All input coordinates are in
     degrees.  The distance (along a great circle) on a sphere between
     two points is calculated with the equation below.

    $$\cos(d)=\sin(d_1)\sin(d_2)+\cos(d_1)\cos(d_2)\cos(r_1-r_2)$$

     However, since the pixel scales are usually very small numbers,
     this function won’t use that direct formula.  It will be use the
     Haversine formula (https://en.wikipedia.org/wiki/Haversine_formula)
     which is better considering floating point errors:

$${\sin^2(d)\over 2}=\sin^2\left( {d_1-d_2\over 2} \right)+\cos(d_1)\cos(d_2)\sin^2\left( {r_1-r_2\over 2} \right)$$

 -- Function:
          double *
          gal_wcs_pixel_scale (struct wcsprm ‘*wcs’)
     Return the pixel scale for each dimension of ‘wcs’ in degrees.  The
     output is an allocated array of double precision floating point
     type with one element for each dimension.  If its not successful,
     this function will return ‘NULL’.

 -- Function:
          double
          gal_wcs_pixel_area_arcsec2 (struct wcsprm ‘*wcs’)
     Return the pixel area of ‘wcs’ in arcsecond squared.  If the input
     WCS structure is not two dimensional and the units (‘CUNIT’
     keywords) are not ‘deg’ (for degrees), then this function will
     return a NaN.

 -- Function:
          gal_data_t *
          gal_wcs_world_to_img (gal_data_t ‘*coords’, struct wcsprm
          ‘*wcs’, int ‘inplace’)
     Convert the linked list of world coordinates in ‘coords’ to a
     linked list of image coordinates given the input WCS structure.
     ‘coords’ must be a linked list of data structures of float64
     (‘double’) type, see*note Linked lists:: and *note List of
     gal_data_t::.  The top (first popped/read) node of the linked list
     must be the first WCS coordinate (RA in an image usually) etc.
     Similarly, the top node of the output will be the first image
     coordinate (in the FITS standard).

     If ‘inplace’ is zero, then the output will be a newly allocated
     list and the input list will be untouched.  However, if ‘inplace’
     is non-zero, the output values will be written into the input’s
     already allocated array and the returned pointer will be the same
     pointer to ‘coords’ (in other words, you can ignore the returned
     value).  Note that in the latter case, only the values will be
     changed, things like units or name (if present) will be untouched.

 -- Function:
          gal_data_t *
          gal_wcs_img_to_world (gal_data_t ‘*coords’, struct wcsprm
          ‘*wcs’, int ‘inplace’)
     Convert the linked list of image coordinates in ‘coords’ to a
     linked list of world coordinates given the input WCS structure.
     See the description of ‘gal_wcs_world_to_img’ for more details.


File: gnuastro.info,  Node: Arithmetic on datasets,  Next: Tessellation library,  Prev: World Coordinate System,  Up: Gnuastro library

10.3.14 Arithmetic on datasets (‘arithmetic.h’)
-----------------------------------------------

When the dataset’s type and other information are already known, any
programming language (including C) provides some very good tools for
various operations (including arithmetic operations like addition) on
the dataset with a simple loop.  However, as an author of a program,
making assumptions about the type of data, its dimensions and other
basic characteristics will come with a large processing burden.

   For example if you always read your data as double precision floating
points for a simple operation like addition with an integer constant,
you will be wasting a lot of CPU and memory when the input dataset is
‘int32’ type for example (see *note Numeric data types::).  This
overhead may be small for small images, but as you scale your process up
and work with hundred/thousands of files that can be very large, this
overhead will take a significant portion of the processing power.  The
functions and macros in this section are designed precisely for this
purpose: to allow you to do any of the defined operations on any dataset
with no overhead (in the native type of the dataset).

   Gnuastro’s Arithmetic program uses the functions and macros of this
section, so please also have a look at the *note Arithmetic:: program
and in particular *note Arithmetic operators:: for a better description
of the operators discussed here.

   The main function of this library is ‘gal_arithmetic’ that is
described below.  It can take an arbitrary number of arguments as
operands (depending on the operator, similar to ‘printf’).  Its first
two arguments are integers specifying the flags and operator.  So first
we will review the constants for the recognized flags and operators and
discuss them, then introduce the actual function.

 -- Macro: GAL_ARITHMETIC_INPLACE
 -- Macro: GAL_ARITHMETIC_FREE
 -- Macro: GAL_ARITHMETIC_NUMOK
 -- Macro: GAL_ARITHMETIC_FLAGS_ALL
     Bit-wise flags to pass onto ‘gal_arithmetic’ (see below).  To pass
     multiple flags, use the bitwise-or operator, for example
     ‘GAL_ARITHMETIC_INPLACE | GAL_ARITHMETIC_FREE’.
     ‘GAL_ARITHMETIC_FLAGS_ALL’ is a combination of all flags to shorten
     your code if you want all flags activated.  Each flag is described
     below:
     ‘GAL_ARITHMETIC_INPLACE’
          Do the operation in-place (in the input dataset, thus
          modifying it) to improve CPU and memory usage.  If this flag
          is used, after ‘gal_arithmetic’ finishes, the input dataset
          will be modified.  It is thus useful if you have no more need
          for the input after the operation.

     ‘GAL_ARITHMETIC_FREE’
          Free (all the) input dataset(s) after the operation is done.
          Hence the inputs are no longer usable after ‘gal_arithmetic’.

     ‘GAL_ARITHMETIC_NUMOK’
          It is acceptable to use a number and an array together.  For
          example if you want to add all the pixels in an image with a
          single number you can pass this flag to avoid having to
          allocate a constant array the size of the image (with all the
          pixels having the same number).

 -- Macro: GAL_ARITHMETIC_OP_PLUS
 -- Macro: GAL_ARITHMETIC_OP_MINUS
 -- Macro: GAL_ARITHMETIC_OP_MULTIPLY
 -- Macro: GAL_ARITHMETIC_OP_DIVIDE
 -- Macro: GAL_ARITHMETIC_OP_LT
 -- Macro: GAL_ARITHMETIC_OP_LE
 -- Macro: GAL_ARITHMETIC_OP_GT
 -- Macro: GAL_ARITHMETIC_OP_GE
 -- Macro: GAL_ARITHMETIC_OP_EQ
 -- Macro: GAL_ARITHMETIC_OP_NE
 -- Macro: GAL_ARITHMETIC_OP_AND
 -- Macro: GAL_ARITHMETIC_OP_OR
     Binary operators (requiring two operands) that accept datasets of
     any recognized type (see *note Numeric data types::).  When
     ‘gal_arithmetic’ is called with any of these operators, it expects
     two datasets as arguments.  For a full description of these
     operators with the same name, see *note Arithmetic operators::.
     The first dataset/operand will be put on the left of the operator
     and the second will be put on the right.  The output type of the
     first four is determined from the input types (largest type of the
     inputs).  The rest (which are all conditional operators) will
     output a binary ‘uint8_t’ (or ‘unsigned char’) dataset with values
     of either ‘0’ (zero) or ‘1’ (one).

 -- Macro: GAL_ARITHMETIC_OP_NOT
     The logical NOT operator.  When ‘gal_arithmetic’ is called with
     this operator, it only expects one operand (dataset), since this is
     a unary operator.  The output is ‘uint8_t’ (or ‘unsigned char’)
     dataset of the same size as the input.  Any non-zero element in the
     input will be ‘0’ (zero) in the output and any ‘0’ (zero) will have
     a value of ‘1’ (one).

 -- Macro: GAL_ARITHMETIC_OP_ISBLANK
     A unary operator with output that is ‘1’ for any element in the
     input that is blank, and ‘0’ for any non-blank element.  When
     ‘gal_arithmetic’ is called with this operator, it will only expect
     one input dataset.  The output dataset will have ‘uint8_t’ (or
     ‘unsigned char’) type.

     ‘gal_arithmetic’ with this operator is just a wrapper for the
     ‘gal_blank_flag’ function of *note Library blank values:: and this
     operator is just included for completeness in arithmetic
     operations.  So in your program, it might be easier to just call
     ‘gal_blank_flag’.

 -- Macro: GAL_ARITHMETIC_OP_WHERE
     The three-operand _where_ operator thoroughly discussed in *note
     Arithmetic operators::.  When ‘gal_arithmetic’ is called with this
     operator, it will only expect three input datasets: the first
     (which is the same as the returned dataset) is the array that will
     be modified.  The second is the condition dataset (that must have a
     ‘uint8_t’ or ‘unsigned char’ type), and the third is the value to
     be used if condition is non-zero.

     As a result, note that the order of operands when calling
     ‘gal_arithmetic’ with ‘GAL_ARITHMETIC_OP_WHERE’ is the opposite of
     running Gnuastro’s Arithmetic program with the ‘where’ operator
     (see *note Arithmetic::).  This is because the latter uses the
     reverse-Polish notation which isn’t necessary when calling a
     function (see *note Reverse polish notation::).

 -- Macro: GAL_ARITHMETIC_OP_SQRT
 -- Macro: GAL_ARITHMETIC_OP_LOG
 -- Macro: GAL_ARITHMETIC_OP_LOG10
     Unary operator functions for calculating the square root
     ($\sqrt{i}$), $ln(i)$ and $log(i)$ mathematic operators on each
     element of the input dataset.  The returned dataset will have a
     floating point type, but its precision is determined from the
     input: if the input is a 64-bit floating point, the output will
     also be 64-bit.  Otherwise, the returned dataset will be 32-bit
     floating point.  See *note Numeric data types:: for the respective
     precision.

     If you want your output to be 64-bit floating point but your input
     is a different type, you can convert the input to a floating point
     type with ‘gal_data_copy_to_new_type’ or
     ‘gal_data_copy_to_new_type_free’(see *note Copying datasets::).

 -- Macro: GAL_ARITHMETIC_OP_RA_TO_DEGREE
 -- Macro: GAL_ARITHMETIC_OP_DEC_TO_DEGREE
 -- Macro: GAL_ARITHMETIC_OP_DEGREE_TO_RA
 -- Macro: GAL_ARITHMETIC_OP_DEGREE_TO_DEC
     Unary operators to convert between degrees (as a single floating
     point number) to the standard Right Ascension and Declination
     notation (as strings, respectively in the format of ‘HH:MM:SS’ and
     ‘DD:MM:SS’).  The first two operators expect a string operand and
     will return a double-precision floating point operand.  The latter
     two are the opposite.

 -- Macro: GAL_ARITHMETIC_OP_MINVAL
 -- Macro: GAL_ARITHMETIC_OP_MAXVAL
 -- Macro: GAL_ARITHMETIC_OP_NUMBERVAL
 -- Macro: GAL_ARITHMETIC_OP_SUMVAL
 -- Macro: GAL_ARITHMETIC_OP_MEANVAL
 -- Macro: GAL_ARITHMETIC_OP_STDVAL
 -- Macro: GAL_ARITHMETIC_OP_MEDIANVAL
     Unary operand statistical operators that will return a single value
     for datasets of any size.  These are just wrappers around similar
     functions in *note Statistical operations:: and are included in
     ‘gal_arithmetic’ only for completeness (to use easily in *note
     Arithmetic::).  In your programs, it will probably be easier if you
     use those ‘gal_statistics_’ functions directly.

 -- Macro: GAL_ARITHMETIC_OP_ABS
     Unary operand absolute-value operator.

 -- Macro: GAL_ARITHMETIC_OP_MIN
 -- Macro: GAL_ARITHMETIC_OP_MAX
 -- Macro: GAL_ARITHMETIC_OP_NUMBER
 -- Macro: GAL_ARITHMETIC_OP_SUM
 -- Macro: GAL_ARITHMETIC_OP_MEAN
 -- Macro: GAL_ARITHMETIC_OP_STD
 -- Macro: GAL_ARITHMETIC_OP_MEDIAN
     Multi-operand statistical operations.  When ‘gal_arithmetic’ is
     called with any of these operators, it will expect only a single
     operand that will be interpreted as a list of datasets (see *note
     List of gal_data_t::).  These operators can work on multiple
     threads using the ‘numthreads’ argument.  See the discussion under
     the ‘min’ operator in *note Arithmetic operators::.

     The output will be a single dataset with each of its elements
     replaced by the respective statistical operation on the whole list.
     The type of the output is determined from the operator
     (irrespective of the input type): for ‘GAL_ARITHMETIC_OP_MIN’ and
     ‘GAL_ARITHMETIC_OP_MAX’, it will be the same type as the input, for
     ‘GAL_ARITHMETIC_OP_NUMBER’, the output will be ‘GAL_TYPE_UINT32’
     and for the rest, it will be ‘GAL_TYPE_FLOAT32’.

 -- Macro: GAL_ARITHMETIC_OP_QUANTILE
     Similar to the operands above (including ‘GAL_ARITHMETIC_MIN’),
     except that when ‘gal_arithmetic’ is called with these operators,
     it requires two arguments.  The first is the list of datasets like
     before, and the second is the 1-element dataset with the quantile
     value.  The output type is the same as the inputs.

 -- Macro: GAL_ARITHMETIC_OP_SIGCLIP_STD
 -- Macro: GAL_ARITHMETIC_OP_SIGCLIP_MEAN
 -- Macro: GAL_ARITHMETIC_OP_SIGCLIP_MEDIAN
 -- Macro: GAL_ARITHMETIC_OP_SIGCLIP_NUMBER
     Similar to the operands above (including ‘GAL_ARITHMETIC_MIN’),
     except that when ‘gal_arithmetic’ is called with these operators,
     it requires two arguments.  The first is the list of datasets like
     before, and the second is the 2-element list of $\sigma$-clipping
     parameters.  The first element in the parameters list is the
     multiple of sigma and the second is the termination criteria (see
     *note Sigma clipping::).  The output type of
     ‘GAL_ARITHMETIC_OP_SIGCLIP_NUMBER’ will be ‘GAL_TYPE_UINT32’ and
     for the rest it will be ‘GAL_TYPE_FLOAT32’.

 -- Macro: GAL_ARITHMETIC_OP_SIZE
     Size operator that will return a single value for datasets of any
     kind.  When ‘gal_arithmetic’ is called with this operator, it
     requires two arguments.  The first is the dataset, and the second
     is a single integer value.  The output type is a single integer.

 -- Macro: GAL_ARITHMETIC_OP_POW
     Binary operator to-power operator.  When ‘gal_arithmetic’ is called
     with any of these operators, it will expect two operands: raising
     the first by the second.  This operator only accepts floating point
     inputs and the output is also floating point.

 -- Macro: GAL_ARITHMETIC_OP_BITAND
 -- Macro: GAL_ARITHMETIC_OP_BITOR
 -- Macro: GAL_ARITHMETIC_OP_BITXOR
 -- Macro: GAL_ARITHMETIC_OP_BITLSH
 -- Macro: GAL_ARITHMETIC_OP_BITRSH
 -- Macro: GAL_ARITHMETIC_OP_MODULO
     Binary integer-only operand operators.  These operators are only
     defined on integer data types.  When ‘gal_arithmetic’ is called
     with any of these operators, it will expect two operands: the first
     is put on the left of the operator and the second on the right.
     The ones starting with ‘BIT’ are the respective bit-wise operators
     in C and ‘MODULO’ is the modulo/remainder operator.  For a
     discussion on these operators, please see *note Arithmetic
     operators::.

     The output type is determined from the input types and C’s internal
     conversions: it is strongly recommended that both inputs have the
     same type (any integer type), otherwise the bit-wise behavior will
     be determined by your compiler.

 -- Macro: GAL_ARITHMETIC_OP_BITNOT
     The unary bit-wise NOT operator.  When ‘gal_arithmetic’ is called
     with any of these operators, it will expect one operand of an
     integer type and preform the bitwise-NOT operation on it.  The
     output will have the same type as the input.

 -- Macro: GAL_ARITHMETIC_OP_TO_UINT8
 -- Macro: GAL_ARITHMETIC_OP_TO_INT8
 -- Macro: GAL_ARITHMETIC_OP_TO_UINT16
 -- Macro: GAL_ARITHMETIC_OP_TO_INT16
 -- Macro: GAL_ARITHMETIC_OP_TO_UINT32
 -- Macro: GAL_ARITHMETIC_OP_TO_INT32
 -- Macro: GAL_ARITHMETIC_OP_TO_UINT64
 -- Macro: GAL_ARITHMETIC_OP_TO_INT64
 -- Macro: GAL_ARITHMETIC_OP_TO_FLOAT32
 -- Macro: GAL_ARITHMETIC_OP_TO_FLOAT64
     Unary type-conversion operators.  When ‘gal_arithmetic’ is called
     with any of these operators, it will expect one operand and convert
     it to the requested type.  Note that with these operators,
     ‘gal_arithmetic’ is just a wrapper over the
     ‘gal_data_copy_to_new_type’ or ‘gal_data_copy_to_new_type_free’
     that are discussed in ‘Copying datasets’.  It accepts these
     operators only for completeness and easy usage in *note
     Arithmetic::.  So in your programs, it might be preferable to
     directly use those functions.

 -- Function:
          gal_data_t *
          gal_arithmetic (int ‘operator’, size_t ‘numthreads’, int
          ‘flags’, ...)
     Do the arithmetic operation of ‘operator’ on the given operands
     (the third argument and any further argument).  If the operator can
     work on multiple threads, the number of threads can be specified
     with ‘numthreads’.  When the operator is single-threaded,
     ‘numthreads’ will be ignored.  Special conditions can also be
     specified with the ‘flag’ operator (a bit-flag with bits described
     above, for example ‘GAL_ARITHMETIC_INPLACE’ or
     ‘GAL_ARITHMETIC_FREE’).  The acceptable values for ‘operator’ are
     also defined in the macros above.

     ‘gal_arithmetic’ is a multi-argument function (like C’s ‘printf’).
     In other words, the number of necessary arguments is not fixed and
     depends on the value to ‘operator’.  Here are a few examples
     showing this variability:

          out_1=gal_arithmetic(GAL_ARITHMETIC_OP_LOG,   1, 0, in_1);
          out_2=gal_arithmetic(GAL_ARITHMETIC_OP_PLUS,  1, 0, in_1, in_2);
          out_3=gal_arithmetic(GAL_ARITHMETIC_OP_WHERE, 1, 0, in_1, in_2, in_3);

     The number of necessary operands for each operator (and thus the
     number of necessary arguments to ‘gal_arithmetic’) are described
     above under each operator.

 -- Function:
          int
          gal_arithmetic_set_operator (char ‘*string’, size_t
          ‘*num_operands’)
     Return the operator macro/code that corresponds to ‘string’.  The
     number of operands that it needs are written into the space that
     ‘*num_operands’ points to.  If the string couldn’t be interpreted
     as an operator, this function will return
     ‘GAL_ARITHMETIC_OP_INVALID’.

     This function will check ‘string’ with the fixed human-readable
     names (using ‘strcmp’) for the operators and return the two
     numbers.  Note that ‘string’ must only contain the single operator
     name and nothing else (not even any extra white space).

 -- Function:
          char *
          gal_arithmetic_operator_string (int ‘operator’)
     Return the human-readable standard string that corresponds to the
     given operator.  For example when the input is
     ‘GAL_ARITHMETIC_OP_PLUS’ or ‘GAL_ARITHMETIC_OP_MEAN’, the strings
     ‘+’ or ‘mean’ will be returned.


File: gnuastro.info,  Node: Tessellation library,  Next: Bounding box,  Prev: Arithmetic on datasets,  Up: Gnuastro library

10.3.15 Tessellation library (‘tile.h’)
---------------------------------------

In many contexts, it is desirable to slice the dataset into subsets or
tiles (overlapping or not).  In such a way that you can work on each
tile independently.  One method would be to copy that region to a
separate allocated space, but in many contexts this isn’t necessary and
in fact can be a big burden on CPU/Memory usage.  The ‘block’ pointer in
Gnuastro’s *note Generic data container:: is defined for such
situations: where allocation is not necessary.  You just want to read
the data or write to it independently (or in coordination with) other
regions of the dataset.  Added with parallel processing, this can
greatly improve the time/memory consumption.

   See the figure below for example: assume the ‘larger’ dataset is a
contiguous block of memory that you are interpreting as a 2D array.  But
you only want to work on the smaller ‘tile’ region.

                                 larger
                   ---------------------------------
                   |                               |
                   |              tile             |
                   |           ----------          |
                   |           |        |          |
                   |           |_       |          |
                   |           |*|      |          |
                   |           ----------          |
                   |       tile->block = larger    |
                   |_                              |
                   |*|                             |
                   ---------------------------------

   To use ‘gal_data_t’’s ‘block’ concept, you allocate a ‘gal_data_t
*tile’ which is initialized with the pointer to the first element in the
sub-array (as its ‘array’ argument).  Note that this is not necessarily
the first element in the larger array.  You can set the size of the tile
along with the initialization as you please.  Recall that, when given a
non-‘NULL’ pointer as ‘array’, ‘gal_data_initialize’ (and thus
‘gal_data_alloc’) do not allocate any space and just uses the given
pointer for the new ‘array’ element of the ‘gal_data_t’.  So your ‘tile’
data structure will not be pointing to a separately allocated space.

   After the allocation is done, you just point ‘tile->block’ to the
‘larger’ dataset which hosts the full block of memory.  Where relevant,
Gnuastro’s library functions will check the ‘block’ pointer of their
input dataset to see how to deal with dimensions and increments so they
can always remain within the tile.  The tools introduced in this section
are designed to help in defining and working with tiles that are created
in this manner.

   Since the block structure is defined as a pointer, arbitrary levels
of tessellation/grid-ing are possible (‘tile->block’ may itself be a
tile in an even larger allocated space).  Therefore, just like a
linked-list (see *note Linked lists::), it is important to have the
‘block’ pointer of the largest (allocated) dataset set to ‘NULL’.
Normally, you won’t have to worry about this, because
‘gal_data_initialize’ (and thus ‘gal_data_alloc’) will set the ‘block’
element to ‘NULL’ by default, just remember not to change it.  You can
then only change the ‘block’ element for the tiles you define over the
allocated space.

   Below, we will first review constructs for *note Independent tiles::
and then define the current approach to fully tessellating a dataset (or
covering every pixel/data-element with a non-overlapping tile grid in
*note Tile grid::.  This approach to dealing with parts of a larger
block was inspired from a similarly named concept in the GNU Scientific
Library (GSL), see its “Vectors and Matrices” chapter for their
implementation.

* Menu:

* Independent tiles::           Work on or check independent tiles.
* Tile grid::                   Cover a full dataset with non-overlapping tiles.


File: gnuastro.info,  Node: Independent tiles,  Next: Tile grid,  Prev: Tessellation library,  Up: Tessellation library

10.3.15.1 Independent tiles
...........................

The most general application of tiles is to treat each independently,
for example they may overlap, or they may not cover the full image.
This section provides functions to help in checking/inspecting such
tiles.  In *note Tile grid:: we will discuss functions that
define/work-with a tile grid (where the tiles don’t overlap and fully
cover the input dataset).  Therefore, the functions in this section are
general and can be used for the tiles produced by that section also.

 -- Function:
          void
          gal_tile_start_coord (gal_data_t ‘*tile’, size_t
          ‘*start_coord’)
     Calculate the starting coordinates of a tile in its allocated block
     of memory and write them in the memory that ‘start_coord’ points to
     (which must have ‘tile->ndim’ elements).

 -- Function:
          void
          gal_tile_start_end_coord (gal_data_t ‘*tile’, size_t
          ‘*start_end’, int ‘rel_block’)
     Put the starting and ending (end point is not inclusive)
     coordinates of ‘tile’ into the ‘start_end’ array.  It is assumed
     that a space of ‘2*tile->ndim’ has been already allocated (static
     or dynamic) for ‘start_end’ before this function is called.

     ‘rel_block’ (or relative-to-block) is only relevant when ‘tile’ has
     an intermediate tile between it and the allocated space (like a
     channel, see ‘gal_tile_full_two_layers’).  If it doesn’t
     (‘tile->block’ points the allocated dataset), then the value to
     ‘rel_block’ is irrelevant.

     When ‘tile->block’ is its self a larger block and ‘rel_block’ is
     set to 0, then the starting and ending positions will be based on
     the position within ‘tile->block’, not the allocated space.

 -- Function:
          void *
          gal_tile_start_end_ind_inclusive (gal_data_t ‘*tile’,
          gal_data_t ‘*work’, size_t ‘*start_end_inc’)
     Put the indexs of the first/start and last/end pixels (inclusive)
     in a tile into the ‘start_end’ array (that must have two elements).
     NOTE: this function stores the index of each point, not its
     coordinates.  It will then return the pointer to the start of the
     tile in the ‘work’ data structure (which doesn’t have to be equal
     to ‘tile->block’.

     The outputs of this function are defined to make it easy to parse
     over an n-dimensional tile.  For example, this function is one of
     the most important parts of the internal processing of in
     ‘GAL_TILE_PARSE_OPERATE’ function-like macro that is described
     below.

 -- Function:
          gal_data_t *
          gal_tile_series_from_minmax (gal_data_t ‘*block’, size_t
          ‘*minmax’, size_t ‘number’)
     Construct a list of tile(s) given coordinates of the minimum and
     maximum of each tile.  The minimum and maximums are assumed to be
     inclusive and in C order (slowest dimension first).  The returned
     pointer is an allocated ‘gal_data_t’ array that can later be freed
     with ‘gal_data_array_free’ (see *note Arrays of datasets::).
     Internally, each element of the output array points to the next
     element, so the output may also be treated as a list of datasets
     (see *note List of gal_data_t::) and passed onto the other
     functions described in this section.

     The array keeping the minimum and maximum coordinates for each tile
     must have the following format.  So in total ‘minmax’ must have
     ‘2*ndim*number’ elements.

          | min0_d0 | min0_d1 | max0_d0 | max0_d1 | ...
                          ... | minN_d0 | minN_d1 | maxN_d0 | maxN_d1 |

 -- Function:
          gal_data_t *
          gal_tile_block (gal_data_t ‘*tile’)
     Return the dataset that contains ‘tile’’s allocated block of
     memory.  If tile is immediately defined as part of the allocated
     block, then this is equivalent to ‘tile->block’.  However, it is
     possible to have multiple layers of tiles (where ‘tile->block’ is
     itself a tile).  So this function is the most generic way to get to
     the actual allocated dataset.

 -- Function:
          size_t
          gal_tile_block_increment (gal_data_t ‘*block’, size_t
          ‘*tsize’, size_t ‘num_increment’, size_t ‘*coord’)
     Return the increment necessary to start at the next contiguous
     patch memory associated with a tile.  ‘block’ is the allocated
     block of memory and ‘tsize’ is the size of the tile along every
     dimension.  If ‘coord’ is ‘NULL’, it is ignored.  Otherwise, it
     will contain the coordinate of the start of the next contiguous
     patch of memory.

     This function is intended to be used in a loop and ‘num_increment’
     is the main variable to this function.  For the first time you call
     this function, it should be ‘1’.  In subsequent calls (while you
     are parsing a tile), it should be increased by one.

 -- Function:
          gal_data_t *
          gal_tile_block_write_const_value (gal_data_t ‘*tilevalues’,
          gal_data_t ‘*tilesll’, int ‘withblank’, int ‘initialize’)
     Write a constant value for each tile over the area it covers in an
     allocated dataset that is the size of ‘tile’’s allocated block of
     memory (found through ‘gal_tile_block’ described above).  The
     arguments to this function are:

     ‘tilevalues’
          This must be an array that has the same number of elements as
          the nodes in in ‘tilesll’ and in the same order that ‘tilesll’
          elements are parsed (from top to bottom, see *note Linked
          lists::).  As a result the array’s number of dimensions is
          irrelevant, it will be parsed contiguously.

     ‘tilesll’
          The list of input tiles (see *note List of gal_data_t::).
          Internally, it might be stored as an array (for example the
          output of ‘gal_tile_series_from_minmax’ described above), but
          this function doesn’t care, it will parse the ‘next’ elements
          to go to the next tile.  This function will not pop-from or
          free the ‘tilesll’, it will only parse it from start to end.

     ‘withblank’
          If the block containing the tiles has blank elements, those
          blank elements will be blank in the output of this function
          also, hence the array will be initialized with blank values
          when this option is called (see below).

     ‘initialize’
          Initialize the allocated space with blank values before
          writing in the constant values.  This can be useful when the
          tiles don’t cover the full allocated block.

 -- Function:
          gal_data_t *
          gal_tile_block_check_tiles (gal_data_t ‘*tilesll’)
     Make a copy of the memory block and fill it with the index of each
     tile in ‘tilesll’ (counting from 0).  The non-filled areas will
     have blank values.  The output dataset will have a type of
     ‘GAL_TYPE_INT32’ (see *note Library data types::).

     This function can be used when you want to check the coverage of
     each tile over the allocated block of memory.  It is just a wrapper
     over the ‘gal_tile_block_write_const_value’ (with ‘withblank’ set
     to zero).

 -- Function:
          void *
          gal_tile_block_relative_to_other (gal_data_t ‘*tile’,
          gal_data_t ‘*other’)
     Return the pointer corresponding to the start of the region covered
     by ‘tile’ over the ‘other’ dataset.  See the examples in
     ‘GAL_TILE_PARSE_OPERATE’ for some example applications of this
     function.

 -- Function:
          void
          gal_tile_block_blank_flag (gal_data_t ‘*tilell’, size_t
          ‘numthreads’)
     Check if each tile in the list has blank values and update its
     ‘flag’ to mark this check and its result (see *note Generic data
     container::).  The operation will be done on ‘numthreads’ threads.

 -- Function-like macro: GAL_TILE_PARSE_OPERATE (‘IN’, ‘OTHER’,
          ‘PARSE_OTHER’, ‘CHECK_BLANK’, ‘OP’)
     Parse ‘IN’ (which can be a tile or a fully allocated block of
     memory) and do the ‘OP’ operation on it.  ‘OP’ can be any
     combination of C expressions.  If ‘OTHER!=NULL’, ‘OTHER’ will be
     interpreted as a dataset and this macro will allow access to its
     element(s) and it can optionally be parsed while parsing over ‘IN’.

     If ‘OTHER’ is a fully allocated block of memory (not a tile), then
     the same region that is covered by ‘IN’ within its own block will
     be parsed (the same starting pixel with the same number of pixels
     in each dimension).  Hence, in this case, the blocks of ‘OTHER’ and
     ‘IN’ must have the same size.  When ‘OTHER’ is a tile it must have
     the same size as ‘IN’ and parsing will start from its starting
     element/pixel.  Also, the respective allocated blocks of ‘OTHER’
     and ‘IN’ (if different) may have different sizes.  Using ‘OTHER’
     (along with ‘PARSE_OTHER’), this function-like macro will thus
     enable you to parse and define your own operation on two fixed size
     regions in one or two blocks of memory.  In the latter case, they
     may have different numeric data types, see *note Numeric data
     types::).

     The input arguments to this macro are explained below, the expected
     type of each argument are also written following the argument name:

     ‘IN (gal_data_t)’
          Input dataset, this can be a tile or an allocated block of
          memory.

     ‘OTHER (gal_data_t)’
          Dataset (‘gal_data_t’) to parse along with ‘IN’.  It can be
          ‘NULL’.  In that case, ‘o’ (see description of ‘OP’ below)
          will be ‘NULL’ and should not be used.  If ‘PARSE_OTHER’ is
          zero, only its first element will be used and the size of this
          dataset is irrelevant.

          When ‘OTHER’ is a block of memory, it has to have the same
          size as the allocated block of ‘IN’.  When its a tile, it has
          to have the same size as ‘IN’.

     ‘PARSE_OTHER (int)’
          Parse the other dataset along with the input.  When this is
          non-zero and ‘OTHER!=NULL’, then the ‘o’ pointer will be
          incremented to cover the ‘OTHER’ tile at the same rate as ‘i’,
          see description of ‘OP’ for ‘i’ and ‘o’.

     ‘CHECK_BLANK (int)’
          If it is non-zero, then the input will be checked for blank
          values and ‘OP’ will only be called when we are not on a blank
          element.

     ‘OP’
          Operator: this can be any number of C expressions.  This macro
          is going to define a ‘itype *i’ variable which will increment
          over each element of the input array/tile.  ‘itype’ will be
          replaced with the C type that corresponds to the type of
          ‘INPUT’.  As an example, if ‘INPUT’’s type is
          ‘GAL_DATA_UINT16’ or ‘GAL_DATA_FLOAT32’, ‘i’ will be defined
          as ‘uint16’ or ‘float’ respectively.

          This function-like macro will also define an ‘otype *o’ which
          you can use to access an element of the ‘OTHER’ dataset (if
          ‘OTHER!=NULL’).  ‘o’ will correspond to the type of ‘OTHER’
          (similar to ‘itype’ and ‘INPUT’ discussed above).  If
          ‘PARSE_OTHER’ is non-zero, then ‘o’ will also be incremented
          to the same index element but in the other array.  You can use
          these along with any other variable you define before this
          macro to process the input and/or the other.

          All variables within this function-like macro begin with
          ‘tpo_’ except for the three variables listed below.
          Therefore, as long as you don’t start the names of your
          variables with this prefix everything will be fine.  Note that
          ‘i’ (and possibly ‘o’) will be incremented once by this
          function-like macro, so don’t increment them within ‘OP’.

          ‘i’
               Pointer to the element of ‘INPUT’ that is being parsed
               with the proper type.

          ‘o’
               Pointer to the element of ‘OTHER’ that is being parsed
               with the proper type.  ‘o’ can only be used if
               ‘OTHER!=NULL’ and it will be parsed/incremented if
               ‘PARSE_OTHER’ is non-zero.

          ‘b’
               Blank value in the type of ‘INPUT’.

     You can use a given tile (‘tile’ on a dataset that it was not
     initialized with but has the same size, let’s call it ‘new’) with
     the following steps:

          void *tarray;
          gal_data_t *tblock;

          /* `tile->block' must be corrected AFTER `tile->array'. */
          tarray      = tile->array;
          tblock      = tile->block;
          tile->array = gal_tile_block_relative_to_other(tile, new);
          tile->block = new;

          /* Parse and operate over this region of the `new' dataset. */
          GAL_TILE_PARSE_OPERATE(tile, NULL, 0, 0, {
              YOUR_PROCESSING;
            });

          /* Reset `tile->block' and `tile->array'. */
          tile->array=tarray;
          tile->block=tblock;

     You can work on the same region of another block in one run of this
     function-like macro.  To do that, you can make a fake tile and pass
     that as the ‘OTHER’ argument.  Below is a demonstration, ‘tile’ is
     the actual tile that you start with and ‘new’ is the other block of
     allocated memory.

          size_t zero=0;
          gal_data_t *faketile;

          /* Allocate the fake tile, these can be done outside a loop
           * (over many tiles). */
          faketile=gal_data_alloc(NULL, new->type, 1, &zero,
                                  NULL, 0, -1, 1, NULL, NULL, NULL);
          free(faketile->array);               /* To keep things clean. */
          free(faketile->dsize);               /* To keep things clean. */
          faketile->block = new;
          faketile->ndim  = new->ndim;

          /* These can be done in a loop (over many tiles). */
          faketile->size  = tile->size;
          faketile->dsize = tile->dsize;
          faketile->array = gal_tile_block_relative_to_other(tile, new);

          /* Do your processing.... in a loop (over many tiles). */
          GAL_TILE_PARSE_OPERATE(tile, faketile, 1, 1, {
              YOUR_PROCESSING_EXPRESSIONS;
            });

          /* Clean up (outside the loop). */
          faketile->array=NULL;
          faketile->dsize=NULL;
          gal_data_free(faketile);


File: gnuastro.info,  Node: Tile grid,  Prev: Independent tiles,  Up: Tessellation library

10.3.15.2 Tile grid
...................

One very useful application of tiles is to completely cover an input
dataset with tiles.  Such that you know every pixel/data-element of the
input image is covered by only one tile.  The constructs in this section
allow easy definition of such a tile structure.  They will create lists
of tiles that are also usable by the general tools discussed in *note
Independent tiles::.

   As discussed in *note Tessellation::, (mainly raw) astronomical
images will mostly require two layers of tessellation, one for amplifier
channels which all have the same size and another (smaller tile-size)
tessellation over each channel.  Hence, in this section we define a
general structure to keep the main parameters of this two-layer
tessellation and help in benefiting from it.

 -- Type (C ‘struct’): gal_tile_two_layer_params
     The general structure to keep all the necessary parameters for a
     two-layer tessellation.

          struct gal_tile_two_layer_params
          {
            /* Inputs */
            size_t             *tilesize;  /*******************************/
            size_t          *numchannels;  /* These parameters have to be */
            float          remainderfrac;  /* filled manually before      */
            uint8_t           workoverch;  /* calling the functions in    */
            uint8_t           checktiles;  /* this section.               */
            uint8_t       oneelempertile;  /*******************************/

            /* Internal parameters. */
            size_t                  ndim;
            size_t              tottiles;
            size_t          tottilesinch;
            size_t           totchannels;
            size_t          *channelsize;
            size_t             *numtiles;
            size_t         *numtilesinch;
            char          *tilecheckname;
            size_t          *permutation;
            size_t           *firsttsize;

            /* Tile and channel arrays (which are also lists). */
            gal_data_t            *tiles;
            gal_data_t         *channels;
          };

 -- Function:
          size_t *
          gal_tile_full (gal_data_t ‘*input’, size_t ‘*regular’, float
          ‘remainderfrac’, gal_data_t ‘**out’, size_t ‘multiple’, size_t
          ‘**firsttsize’)
     Cover the full dataset with (mostly) identical tiles and return the
     number of tiles created along each dimension.  The regular tile
     size (along each dimension) is determined from the ‘regular’ array.
     If ‘input’’s size is not an exact multiple of ‘regular’ for each
     dimension, then the tiles touching the edges in that dimension will
     have a different size to fully cover every element of the input
     (depending on ‘remainderfrac’).

     The output is an array with the same dimensions as ‘input’ which
     contains the number of tiles along each dimension.  See *note
     Tessellation:: for a description of its application in Gnuastro’s
     programs and ‘remainderfrac’, just note that this function defines
     only one layer of tiles.

     This is a low-level function (independent of the
     ‘gal_tile_two_layer_params’ structure defined above).  If you want
     a two-layer tessellation, directly call ‘gal_tile_full_two_layers’
     that is described below.  The input arguments to this function are:

     ‘input’
          The main dataset (allocated block) which you want to create a
          tessellation over (only used for its sizes).  So ‘input’ may
          be a tile also.

     ‘regular’
          The the size of the regular tiles along each of the input’s
          dimensions.  So it must have the same number of elements as
          the dimensions of ‘input’ (or ‘input->ndim’).

     ‘remainderfrac’
          The significant fraction of the remainder space to see if it
          should be split into two and put on both sides of a dimension
          or not.  This is thus only relevant ‘input’ length along a
          dimension isn’t an exact multiple of the regular tile size
          along that dimension.  See *note Tessellation:: for a more
          thorough discussion.

     ‘out’
          Pointer to the array of data structures that will keep all the
          tiles (see *note Arrays of datasets::).  If ‘*out==NULL’, then
          the necessary space to keep all the tiles will be allocated.
          If not, then all the tile information will be filled from the
          dataset that ‘*out’ points to, see ‘multiple’ for more.

     ‘multiple’
          When ‘*out==NULL’ (and thus will be allocated by this
          function), allocate space for ‘multiple’ times the number of
          tiles needed.  This can be very useful when you have several
          more identically sized ‘inputs’, and you want all their tiles
          to be allocated (and thus indexed) together, even though they
          have different ‘block’ datasets (that then link to one
          allocated space).  See the definition of channels in *note
          Tessellation:: and ‘gal_tile_full_two_layers’ below.

     ‘firsttsize’
          The size of the first tile along every dimension.  This is
          only different from the regular tile size when ‘regular’ is
          not an exact multiple of ‘input’’s length along every
          dimension.  This array is allocated internally by this
          function.

 -- Function:
          void
          gal_tile_full_sanity_check (char ‘*filename’, char ‘*hdu’,
          gal_data_t ‘*input’, struct gal_tile_two_layer_params ‘*tl’)
     Make sure that the input parameters (in ‘tl’, short for two-layer)
     correspond to the input dataset.  ‘filename’ and ‘hdu’ are only
     required for error messages.  Also, allocate and fill the
     ‘tl->channelsize’ array.

 -- Function:
          void
          gal_tile_full_two_layers (gal_data_t ‘*input’, struct
          gal_tile_two_layer_params ‘*tl’)
     Create the two layered tessellation in ‘tl’.  The general set of
     steps you need to take to define the two-layered tessellation over
     an image can be seen in the example code below.

          gal_data_t *input;
          struct gal_tile_two_layer_params tl;
          char *filename="input.fits", *hdu="1";

          /* Set all the inputs shown in the structure definition. */
          ...

          /* Read the input dataset. */
          input=gal_fits_img_read(filename, hdu, -1, 1);

          /* Do a sanity check and preparations. */
          gal_tile_full_sanity_check(filename, hdu, input, &tl);

          /* Build the two-layer tessellation*/
          gal_tile_full_two_layers(input, &tl);

          /* `tl.tiles' and `tl.channels' are now a lists of tiles.*/

 -- Function:
          void
          gal_tile_full_permutation (struct gal_tile_two_layer_params
          ‘*tl’)
     Make a permutation to allow the conversion of tile location in
     memory to its location in the full input dataset and put it in
     ‘tl->permutation’.  If a permutation has already been defined for
     the tessellation, this function will not do anything.  If
     permutation won’t be necessary (there is only one channel or one
     dimension), then this function will not do anything
     (‘tl->permutation’ must have been initialized to ‘NULL’).

     When there is only one channel OR one dimension, the tiles are
     allocated in memory in the same order that they represent the input
     data.  However, to make channel-independent processing possible in
     a generic way, the tiles of each channel are allocated
     contiguously.  So, when there is more than one channel AND more
     than one dimension, the index of the tile does not correspond to
     its position in the grid covering the input dataset.

     The example below may help clarify: assume you have a 6x6
     tessellation with two channels in the horizontal and one in the
     vertical.  On the left you can see how the tile IDs correspond to
     the input dataset.  NOTE how ‘03’ is on the second row, not on the
     first after ‘02’.  On the right, you can see how the tiles are
     stored in memory (and shown if you simply write the array into a
     FITS file for example).

             Corresponding to input               In memory
             ----------------------             --------------
               15 16 17 33 34 35               30 31 32 33 34 35
               12 13 14 30 31 32               24 25 26 27 28 29
               09 10 11 27 28 29               18 19 20 21 22 23
               06 07 08 24 25 26      <--      12 13 14 15 16 17
               03 04 05 21 22 23               06 07 08 09 10 11
               00 01 02 18 19 20               00 01 02 03 04 05

     As a result, if your values are stored in same order as the tiles,
     and you want them in over-all memory (for example to save as a FITS
     file), you need to permute the values:

          gal_permutation_apply(values, tl->permutation);

     If you have values over-all and you want them in tile-order, you
     can apply the inverse permutation:

          gal_permutation_apply_inverse(values, tl->permutation);

     Recall that this is the definition of permutation in this context:

          permute:    IN_ALL[ i       ]   =   IN_MEMORY[ perm[i] ]
          inverse:    IN_ALL[ perm[i] ]   =   IN_MEMORY[ i       ]

 -- Function:
          void
          gal_tile_full_values_write (gal_data_t ‘*tilevalues’, struct
          gal_tile_two_layer_params ‘*tl’, int ‘withblank’, char
          ‘*filename’, gal_fits_list_key_t ‘*keys’, char
          ‘*program_string’)
     Write one value for each tile into a file.  It is important to note
     that the values in ‘tilevalues’ must be ordered in the same manner
     as the tiles, so ‘tilevalues->array[i]’ is the value that should be
     given to ‘tl->tiles[i]’.  The ‘tl->permutation’ array must have
     been initialized before calling this function with
     ‘gal_tile_full_permutation’.

     If ‘withblank’ is non-zero, then block structure of the tiles will
     be checked and all blank pixels in the block will be blank in the
     final output file also.

 -- Function:
          gal_data_t *
          gal_tile_full_values_smooth (gal_data_t ‘*tilevalues’, struct
          gal_tile_two_layer_params ‘*tl’, size_t ‘width’, size_t
          ‘numthreads’)
     Smooth the given values with a flat kernel of the given ‘width’.
     This cannot be done manually because if ‘tl->workoverch==0’, tiles
     in different channels must not be mixed/smoothed.  Also the tiles
     are contiguous within the channel, not within the image, see the
     description under ‘gal_tile_full_permutation’.

 -- Function:
          size_t
          gal_tile_full_id_from_coord (struct gal_tile_two_layer_params
          ‘*tl’, size_t ‘*coord’)
     Return the ID of the tile that corresponds to the coordinates
     ‘coord’.  Having this ID, you can use the ‘tl->tiles’ array to get
     to the proper tile or read/write a value into an array that has one
     value per tile.

 -- Function:
          void
          gal_tile_full_free_contents (struct gal_tile_two_layer_params
          ‘*tl’)
     Free all the allocated arrays within ‘tl’.


File: gnuastro.info,  Node: Bounding box,  Next: Polygons,  Prev: Tessellation library,  Up: Gnuastro library

10.3.16 Bounding box (‘box.h’)
------------------------------

Functions related to reporting the bounding box of certain inputs are
declared in ‘gnuastro/box.h’.  All coordinates in this header are in the
FITS format (first axis is the horizontal and the second axis is
vertical).

 -- Function:
          void
          gal_box_bound_ellipse_extent (double ‘a’, double ‘b’, double
          ‘theta_deg’, double ‘*extent’)
     Return the maximum extent along each dimension of the given ellipse
     from the center of the ellipse.  Therefore this is half the extent
     of the box in each dimension.  ‘a’ is the ellipse semi-major axis,
     ‘b’ is the semi-minor axis, ‘theta_deg’ is the position angle in
     degrees.  The extent in each dimension is in floating point format
     and stored in ‘extent’ which must already be allocated before this
     function.

 -- Function:
          void
          gal_box_bound_ellipse (double ‘a’, double ‘b’, double
          ‘theta_deg’, long ‘*width’)
     Any ellipse can be enclosed into a rectangular box.  This function
     will write the height and width of that box where ‘width’ points
     to.  It assumes the center of the ellipse is located within the
     central pixel of the box.  ‘a’ is the ellipse semi-major axis
     length, ‘b’ is the semi-minor axis, ‘theta_deg’ is the position
     angle in degrees.  The ‘width’ array will contain the output size
     in long integer type.  ‘width[0]’, and ‘width[1]’ are the number of
     pixels along the first and second FITS axis.  Since the ellipse
     center is assumed to be in the center of the box, all the values in
     ‘width’ will be an odd integer.

 -- Function:
          void
          gal_box_bound_ellipsoid_extent (double ‘*semiaxes’, double
          ‘*euler_deg’, double ‘*extent’)
     Return the maximum extent along each dimension of the given
     ellipsoid from its center.  Therefore this is half the extent of
     the box in each dimension.  The semi-axis lengths of the ellipsoid
     must be present in the 3 element ‘semiaxis’ array.  The ‘euler_deg’
     array contains the three ellipsoid Euler angles in degrees.  For a
     description of the Euler angles, see description of
     ‘gal_box_bound_ellipsoid’ below.  The extent in each dimension is
     in floating point format and stored in ‘extent’ which must already
     be allocated before this function.

 -- Function:
          void
          gal_box_bound_ellipsoid (double ‘*semiaxes’, double
          ‘*euler_deg’, long ‘*width’)
     Any ellipsoid can be enclosed into a rectangular volume/box.  The
     purpose of this function is to give the integer size/width of that
     box.  The semi-axes lengths of the ellipse must be in the
     ‘semiaxes’ array (with three elements).  The major axis length must
     be the first element of ‘semiaxes’.  The only other condition is
     that the next two semi-axes must both be smaller than the first.
     The orientation of the major axis is defined through three proper
     Euler angles (ZXZ order in degrees) that are given in the
     ‘euler_deg’ array.  The ‘width’ array will contain the output size
     in long integer type (in FITS axis order).  Since the ellipsoid
     center is assumed to be in the center of the box, all the values in
     ‘width’ will be an odd integer.

     The proper Euler angles can be defined in many ways (which axes to
     rotate about).  For a full description of the Euler angles, please
     see Wikipedia (https://en.wikipedia.org/wiki/Euler_angles).  Here
     we adopt the ZXZ (or $Z_1X_2Z_3$) proper Euler angles were the
     first rotation is done around the Z axis, the second one about the
     (rotated) X axis and the third about the (rotated) Z axis.

 -- Function:
          void
          gal_box_border_from_center (double ‘center’, size_t ‘ndim’,
          long ‘*width’, long ‘*fpixel’, long ‘*lpixel’)
     Given the center coordinates in ‘center’ and the ‘width’ (along
     each dimension) of a box, return the coordinates of the first
     (‘fpixel’) and last (‘lpixel’) pixels.  All arrays must have ‘ndim’
     elements (one for each dimension).

 -- Function:
          int
          gal_box_overlap (long ‘*naxes’, long ‘*fpixel_i’, long
          ‘*lpixel_i’, long ‘*fpixel_o’, long ‘*lpixel_o’, size_t
          ‘ndim’)
     An ‘ndim’-dimensional dataset of size ‘naxes’ (along each
     dimension, in FITS order) and a box with first and last (inclusive)
     coordinate of ‘fpixel_i’ and ‘lpixel_i’ is given.  This box doesn’t
     necessarily have to lie within the dataset, it can be outside of
     it, or only partially overlap.  This function will change the
     values of ‘fpixel_i’ and ‘lpixel_i’ to exactly cover the overlap in
     the input dataset’s coordinates.

     This function will return 1 if there is an overlap and 0 if there
     isn’t.  When there is an overlap, the coordinates of the first and
     last pixels of the overlap will be put in ‘fpixel_o’ and
     ‘lpixel_o’.


File: gnuastro.info,  Node: Polygons,  Next: Qsort functions,  Prev: Bounding box,  Up: Gnuastro library

10.3.17 Polygons (‘polygon.h’)
------------------------------

Polygons are commonly necessary in image processing.  For example in
Crop they are used for cutting out non-rectangular regions of a image
(see *note Crop::), and in Warp, for mapping different pixel grids over
each other (see *note Warp::).

   Polygons come in two classes: convex and concave (or generally,
non-convex!), see below for a demonstration.  Convex polygons are those
where all inner angles are less than 180 degrees.  By contrast, a convex
polygon is one where an inner angle may be more than 180 degress.

                 Concave Polygon        Convex Polygon

                  D --------C          D------------- C
                   \        |        E /              |
                    \E      |          \              |
                    /       |           \             |
                   A--------B             A ----------B

   In all the functions here the vertices (and points) are defined as an
array.  So a polygon with 4 vertices will be identified with an array of
8 elements with the first two elements keeping the 2D coordinates of the
first vertice and so on.

 -- Macro: GAL_POLYGON_MAX_CORNERS
     The largest number of vertices a polygon can have in this library.

 -- Macro: GAL_POLYGON_ROUND_ERR
     We have to consider floating point round-off errors when dealing
     with polygons.  For example we will take ‘A’ as the maximum of ‘A’
     and ‘B’ when ‘A>B-GAL_POLYGON_ROUND_ERR’.

 -- Function:
          void
          gal_polygon_vertices_sort_convex (double ‘*in’, size_t ‘n’,
          size_t ‘*ordinds’)
     We have a simple polygon (that can result from projection, so its
     edges don’t collide or it doesn’t have holes) and we want to order
     its corners in an anticlockwise fashion.  This is necessary for
     clipping it and finding its area later.  The input vertices can
     have practically any order.

     The input (‘in’) is an array containing the coordinates (two
     values) of each vertice.  ‘n’ is the number of corners.  So ‘in’
     should have ‘2*n’ elements.  The output (‘ordinds’) is an array
     with ‘n’ elements specifying the indexs in order.  This array must
     have been allocated before calling this function.  The indexes are
     output for more generic usage, for example in a homographic
     transform (necessary in warping an image, see *note Warping
     basics::), the necessary order of vertices is the same for all the
     pixels.  In other words, only the positions of the vertices change,
     not the way they need to be ordered.  Therefore, this function
     would only be necessary once.

     As a summary, the input is unchanged, only ‘n’ values will be put
     in the ‘ordinds’ array.  Such that calling the input coordinates in
     the following fashion will give an anti-clockwise order when there
     are 4 vertices:

          1st vertice: in[ordinds[0]*2], in[ordinds[0]*2+1]
          2nd vertice: in[ordinds[1]*2], in[ordinds[1]*2+1]
          3rd vertice: in[ordinds[2]*2], in[ordinds[2]*2+1]
          4th vertice: in[ordinds[3]*2], in[ordinds[3]*2+1]

     The implementation of this is very similar to the Graham scan in
     finding the Convex Hull.  However, in projection we will never have
     a concave polygon (the left condition below, where this algorithm
     will get to E before D), we will always have a convex polygon
     (right case) or E won’t exist!  This is because we are always going
     to be calculating the area of the overlap between a quadrilateral
     and the pixel grid or the quadrilateral its self.

     The ‘GAL_POLYGON_MAX_CORNERS’ macro is defined so there will be no
     need to allocate these temporary arrays separately.  Since we are
     dealing with pixels, the polygon can’t really have too many
     vertices.

 -- Function:
          int
          gal_polygon_is_convex (double ‘*v’, size_t ‘n’)
     Returns ‘1’ if the polygon is convex with vertices defined by ‘v’
     and ‘0’ if it is a concave polygon.  Note that the vertices of the
     polygon should be sorted in an anti-clockwise manner.

 -- Function:
          double
          gal_polygon_area (double ‘*v’, size_t ‘n’)
     Find the area of a polygon with vertices defined in ‘v’.  ‘v’
     points to an array of doubles which keep the positions of the
     vertices such that ‘v[0]’ and ‘v[1]’ are the positions of the first
     vertice to be considered.

 -- Function:
          int
          gal_polygon_is_inside (double ‘*v’, double ‘*p’, size_t ‘n’)
     Returns ‘0’ if point ‘p’ in inside a polygon, either convex or
     concave.  The vertices of the polygon are defined by ‘v’ and ‘0’
     otherwise, they have to be ordered in an anti-clockwise manner.
     This function uses the winding number algorithm
     (https://en.wikipedia.org/wiki/Point_in_polygon#Winding_number_algorithm),
     to check the points.  Note that this is a generic function (working
     on both concave and convex polygons, so if you know before-hand
     that your polygon is convex, it is much more efficient to use
     ‘gal_polygon_is_inside_convex’.

 -- Function:
          int
          gal_polygon_is_inside_convex (double ‘*v’, double ‘*p’, size_t
          ‘n’)
     Return ‘1’ if the point ‘p’ is within the polygon whose vertices
     are defined by ‘v’.  The polygon is assumed to be convex, for a
     more generic function that deals with concave and convex polygons,
     see ‘gal_polygon_is_inside’.  Note that the vertices of the polygon
     have to be sorted in an anti-clock-wise manner.

 -- Function:
          int
          gal_polygon_ppropin (double ‘*v’, double ‘*p’, size_t ‘n’)
     Similar to ‘gal_polygon_is_inside_convex’, except that if the point
     ‘p’ is on one of the edges of a polygon, this will return ‘0’.

 -- Function:
          int
          gal_polygon_is_counterclockwise (double ‘*v’, size_t ‘n’)
     Returns ‘1’ if the sorted polygon has a counter-clockwise
     orientation and ‘0’ otherwise.  This function uses the concept of
     “winding”, which defines the relative order in which the vertices
     of a polygon are listed to determine the orientation of vertices.
     For complex polygons (where edges, or sides, intersect), the most
     significant orientation is returned.  In a complex polygon, when
     the alternative windings are equal (for example an ‘8’-shape) it
     will return ‘1’ (as if it was counter-clockwise).  Note that the
     polygon vertices have to be sorted before calling this function.

 -- Function:
          int
          gal_polygon_to_counterclockwise (double ‘*v’, size_t ‘n’)
     Arrange the vertices of the sorted polygon in place, to be in a
     counter-clockwise direction.  If the input polygon already has a
     counter-clockwise direction it won’t touch the input.  The return
     value is ‘1’ on successful execution.  This function is just a
     wrapper over ‘gal_polygon_is_counterclockwise’, and will reverse
     the order of the vertices when necessary necessary.

 -- Function:
          void
          gal_polygon_clip (double ‘*s’, size_t ‘n’, double ‘*c’, size_t
          ‘m’, double ‘*o’, size_t ‘*numcrn’)
     Clip (find the overlap of) two polygons.  This function uses the
     Sutherland-Hodgman
     (https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)
     polygon clipping algorithm.  Note that the vertices of both
     polygons have to be sorted in an anti-clock-wise manner.

 -- Function:
          void
          gal_polygon_vertices_sort (double ‘*vertices’, size_t ‘n’,
          size_t ‘*ordinds’)
     Sort the indexs of the un-ordered ‘vertices’ array to a
     counter-clockwise polygon in the already allocated space of
     ‘ordinds’.  It is assumed that there are ‘n’ vertices, and thus
     that ‘vertices’ contains ‘2*n’ elements where the two coordinates
     of the first vertice occupy the first two elements of the array and
     so on.

     The polygon can be both concave and convex (see the start of this
     section).  However, note that for concave polygons there is no
     unique sort from an un-ordered set of vertices.  So after this
     function you may want to use ‘gal_polygon_is_convex’ and print a
     warning to check the output if the polygon was concave.

     Note that the contents of the ‘vertices’ array are left untouched
     by this function.  If you want to write the ordered vertice
     coordinates in another array with the same size, you can use a loop
     like this:

          for(i=0;i<n;++i)
          {
            ordered[i*2  ] = vertices[ ordinds[i]*2    ];
            ordered[i*2+1] = vertices[ ordinds[i]*2 + 1];
          }

     In this algorithm, we find the rightmost and leftmost points (based
     on their x-coordinate) and use the diagonal vector between those
     points to group the points in arrays based on their position with
     respect to this vector.  For anticlockwise sorting, all the points
     below the vector are sorted by their ascending x-coordinates and
     points above the vector are sorted in decreasing order using
     ‘qsort’.  Finally, both these arrays are merged together to get the
     final sorted array of points, from which the points are indexed
     into the ‘ordinds’ using linear search.


File: gnuastro.info,  Node: Qsort functions,  Next: Permutations,  Prev: Polygons,  Up: Gnuastro library

10.3.18 Qsort functions (‘qsort.h’)
-----------------------------------

When sorting a dataset is necessary, the C programming language provides
the ‘qsort’ (Quick sort) function.  ‘qsort’ is a generic function which
allows you to sort any kind of data structure (not just a single array
of numbers).  To define “greater” and “smaller” (for sorting), ‘qsort’
needs another function, even for simple numerical types.  The functions
introduced in this section are to passed onto ‘qsort’.

   Note that larger and smaller operators are not defined on NaN
elements.  Therefore, if the input array is a floating point type, and
contains NaN values, the relevant functions of this section are going to
put the NaN elements at the end of the list (after the sorted non-NaN
elements), irrespective of the requested sorting order (increasing or
decreasing).

   The first class of functions below (with ‘TYPE’ in their names) can
be used for sorting a simple numeric array.  Just replace ‘TYPE’ with
the dataset’s numeric datatype.  The second set of functions can be used
to sort indexs (leave the actual numbers untouched).  To use the second
set of functions, a global variable or structure are also necessary as
described below.

 -- Global variable: gal_qsort_index_single
     Pointer to an array (for example ‘float *’ or ‘int *’) to use as a
     reference in ‘gal_qsort_index_single_TYPE_d’ or
     ‘gal_qsort_index_single_TYPE_i’, see the explanation of these
     functions for more.  Note that if _more than one_ array is to be
     sorted in a multi-threaded operation, these functions will not work
     as expected.  However, when all the threads just sort the indexs
     based on a _single array_, this global variable can safely be used
     in a multi-threaded scenario.

 -- Type (C ‘struct’): gal_qsort_index_multi
     Structure to get the sorted indexs of multiple datasets on multiple
     threads with ‘gal_qsort_index_multi_d’ or
     ‘gal_qsort_index_multi_i’.  Note that the ‘values’ array will not
     be changed by these functions, it is only read.  Therefore all the
     ‘values’ elements in the (to be sorted) array of
     ‘gal_qsort_index_multi’ must point to the same place.

          struct gal_qsort_index_multi
          {
            float *values;         /* Array of values (same in all).      */
            size_t  index;         /* Index of each element to be sorted. */
          };

 -- Function:
          int
          gal_qsort_TYPE_d (const void ‘*a’, const void ‘*b’)
     When passed to ‘qsort’, this function will sort a ‘TYPE’ array in
     decreasing order (first element will be the largest).  Please
     replace ‘TYPE’ (in the function name) with one of the *note Numeric
     data types::, for example ‘gal_qsort_int32_d’, or
     ‘gal_qsort_float64_d’.

 -- Function:
          int
          gal_qsort_TYPE_i (const void ‘*a’, const void ‘*b’)
     When passed to ‘qsort’, this function will sort a ‘TYPE’ array in
     increasing order (first element will be the smallest).  Please
     replace ‘TYPE’ (in the function name) with one of the *note Numeric
     data types::, for example ‘gal_qsort_int32_i’, or
     ‘gal_qsort_float64_i’.

 -- Function:
          int
          gal_qsort_index_single_TYPE_d (const void ‘*a’, const void
          ‘*b’)
     When passed to ‘qsort’, this function will sort a ‘size_t’ array
     based on decreasing values in the ‘gal_qsort_index_single’.  The
     global ‘gal_qsort_index_single’ pointer has a ‘void *’ pointer
     which will be cast to the proper type based on this function: for
     example ‘gal_qsort_index_single_uint16_d’ will cast the array to an
     unsigned 16-bit integer type.  The array that
     ‘gal_qsort_index_single’ points to will not be changed, it is only
     read.  For example, see this demo program:

          #include <stdio.h>
          #include <stdlib.h>           /* qsort is defined in stdlib.h. */
          #include <gnuastro/qsort.h>

          int
          main (void)
          {
            size_t s[4]={0, 1, 2, 3};
            float f[4]={1.3,0.2,1.8,0.1};
            gal_qsort_index_single=f;
            qsort(s, 4, sizeof(size_t), gal_qsort_index_single_float_d);
            printf("%zu, %zu, %zu, %zu\n", s[0], s[1], s[2], s[3]);
            return EXIT_SUCCESS;
          }

     The output will be: ‘2, 0, 1, 3’.

 -- Function:
          int
          gal_qsort_index_single_TYPE_i (const void ‘*a’, const void
          ‘*b’)
     Similar to ‘gal_qsort_index_single_TYPE_d’, but will sort the
     indexes such that the values of ‘gal_qsort_index_single’ can be
     parsed in increasing order.

 -- Function:
          int
          gal_qsort_index_multi_d (const void ‘*a’, const void ‘*b’)
     When passed to ‘qsort’ with an array of ‘gal_qsort_index_multi’,
     this function will sort the array based on the values of the given
     indexs.  The sorting will be ordered according to the ‘values’
     pointer of ‘gal_qsort_index_multi’.  Note that ‘values’ must point
     to the same place in all the structures of the
     ‘gal_qsort_index_multi’ array.

     This function is only useful when the indexs of multiple arrays on
     multiple threads are to be sorted.  If your program is single
     threaded, or all the indexs belong to a single array (sorting
     different sub-sets of indexs in a single array on multiple
     threads), it is recommended to use ‘gal_qsort_index_single_d’.

 -- Function:
          int
          gal_qsort_index_multi_i (const void ‘*a’, const void *‘b’)
     Similar to ‘gal_qsort_index_multi_d’, but the result will be sorted
     in increasing order (first element will have the smallest value).


File: gnuastro.info,  Node: Permutations,  Next: Matching,  Prev: Qsort functions,  Up: Gnuastro library

10.3.19 Permutations (‘permutation.h’)
--------------------------------------

Permutation is the technical name for re-ordering of values.  The need
for permutations occurs a lot during (mainly low-level) processing.  To
do permutation, you must provide two inputs: an array of values (that
you want to re-order in place) and a permutation array which contains
the new index of each element (let’s call it ‘perm’).  The diagram below
shows the input array before and after the re-ordering.

     permute:    AFTER[ i       ] = BEFORE[ perm[i] ]     i = 0 .. N-1
     inverse:    AFTER[ perm[i] ] = BEFORE[ i       ]     i = 0 .. N-1

   The functions here are a re-implementation of the GNU Scientific
Library’s ‘gsl_permute’ function.  The reason we didn’t use that
function was that it uses system-specific types (like ‘long’ and ‘int’)
which can have different widths on different systems, hence are not
easily convertible to Gnuastro’s fixed width types (see *note Numeric
data types::).  There is also a separate function for each type, heavily
using macros to allow a ‘base’ function to work on all the types.  Thus
it is hard to read/understand.  Hence, Gnuastro contains a re-write of
their steps in a new type-agnostic method which is a single function
that can work on any type.

   As described in GSL’s source code and manual, this implementation
comes from Donald Knuth’s _Art of computer programming_ book, in the
"Sorting and Searching" chapter of Volume 3 (3rd ed).  Exercise 10 of
Section 5.2 defines the problem and in the answers, Knuth describes the
solution.  So if you are interested, please have a look there for more.

   We are in contact with the GSL developers and in the future(1) we
will submit these implementations to GSL. If they are finally
incorporated there, we will delete this section in future versions.

 -- Function:
          void
          gal_permutation_check (size_t ‘*permutation’, size_t ‘size’)
     Print how ‘permutation’ will re-order an array that has ‘size’
     elements for each element in one one line.

 -- Function:
          void
          gal_permutation_apply (gal_data_t ‘*input’, size_t
          ‘*permutation’)
     Apply ‘permutation’ on the ‘input’ dataset (can have any type), see
     above for the definition of permutation.

 -- Function:
          void
          gal_permutation_apply_inverse (gal_data_t ‘*input’, size_t
          ‘*permutation’)
     Apply the inverse of ‘permutation’ on the ‘input’ dataset (can have
     any type), see above for the definition of permutation.

   ---------- Footnotes ----------

   (1) Gnuastro’s Task 14497 (http://savannah.gnu.org/task/?14497).  If
this task is still “postponed” when you are reading this and you are
interested to help, your help would be very welcome.  Both Gnuastro and
GSL developers are very busy, hence both would appreciate your help.


File: gnuastro.info,  Node: Matching,  Next: Statistical operations,  Prev: Permutations,  Up: Gnuastro library

10.3.20 Matching (‘match.h’)
----------------------------

Matching is often necessary when the measurements have been done using
different instruments, different software or different configurations of
the same software.  The functions in this part of Gnuastro’s library
will be growing to allow matching of images and finding a match between
different catalogs (register them).  Currently it only provides the The
high-level measurements are stored in tables with positions (commonly in
RA and Dec with units of degrees).

 -- Function:
          gal_data_t *
          gal_match_coordinates (gal_data_t ‘*coord1’, gal_data_t
          ‘*coord2’, double ‘*aperture’, int ‘sorted_by_first’, int
          ‘inplace’, size_t ‘minmapsize’, int ‘quietmmap’, size_t
          ‘*nummatched’)

     Return the permutations that when applied, the first ‘nummatched’
     rows of both inputs match with each other (are the nearest within
     the given aperture).  The two inputs (‘coord1’ and ‘coord2’) must
     be *note List of gal_data_t::.  Each ‘gal_data_t’ node in the list
     should be a single dimensional dataset (column in a table).  The
     dimensions of the coordinates is determined by the number of
     ‘gal_data_t’ nodes in the two input lists (which must be equal).
     Note that the number of rows (or the number of elements in each
     ‘gal_data_t’) in the columns of ‘coord1’ and ‘coord2’ can be
     different.

     The matching aperture is defined by the ‘aperture’ array.  If
     several points of one catalog lie within this aperture of a point
     in the other, the nearest is defined as the match.  In a 2D
     situation (where the input lists have two nodes), for the most
     generic case, it must have three elements: the major axis length,
     axis ratio and position angle (see *note Defining an ellipse and
     ellipsoid::).  If ‘aperture[1]==1’, the aperture will be a circle
     of radius ‘aperture[0]’ and the third value won’t be used.  When
     the aperture is an ellipse, distances between the points are also
     calculated in the respective elliptical distances ($r_{el}$ in
     *note Defining an ellipse and ellipsoid::).

     To speed up the search, this function will sort the input
     coordinates by their first column (first axis).  If _both_ are
     already sorted by their first column, you can avoid the sorting
     step by giving a non-zero value to ‘sorted_by_first’.

     When sorting is necessary and ‘inplace’ is non-zero, the actual
     input columns will be sorted.  Otherwise, an internal copy of the
     inputs will be made, used (sorted) and later freed before
     returning.  Therefore, when ‘inplace==0’, inputs will remain
     untouched, but this function will take more time and memory.

     If internal allocation is necessary and the space is larger than
     ‘minmapsize’, the space will be not allocated in the RAM, but in a
     file, see description of ‘--minmapsize’ and ‘--quietmmap’ in *note
     Processing options::.

     The number of matches will be put in the space pointed by
     ‘nummatched’.  If there wasn’t any match, this function will return
     ‘NULL’.  If match(s) were found, a list with three ‘gal_data_t’
     nodes will be returned.  The top two nodes in the list are the
     permutations that must be applied to the first and second inputs
     respectively.  After applying the permutations, the top
     ‘nummatched’ elements will match with each other.  The third node
     is the distances between the respective match.  Note that the three
     nodes of the list are all one-dimensional (a column) and can have
     different lengths.

     *Output permutations ignore internal sorting*: the output
     permutations will correspond to the initial inputs.  Therefore,
     even when ‘inplace!=0’ (and this function re-arranges the inputs),
     the output permutation will correspond to original (possibly
     non-sorted) inputs.

     The reason for this is that you rarely want the actual positional
     columns after the match.  Usually, you also have other columns
     (measurements, for example magnitudes) for higher-level processing
     after the match (that correspond to the input order before
     sorting).  Once you have the permutations, they can be applied to
     those other columns (see *note Permutations::) and the higher-level
     processing can continue.

     When you read the coordinates from a table using ‘gal_table_read’
     (see *note Table input output::), and only ask for the coordinate
     columns, the inputs to this function are the returned ‘gal_data_t
     *’ from two different tables.


File: gnuastro.info,  Node: Statistical operations,  Next: Binary datasets,  Prev: Matching,  Up: Gnuastro library

10.3.21 Statistical operations (‘statistics.h’)
-----------------------------------------------

After reading a dataset into memory from a file or fully simulating it
with another process, the most common processes that will be done on it
are statistical operations to let you quantify different aspects of the
data.  the functions in this section describe Gnuastro’s current set of
tools for this job.  All these functions can work on any numeric data
type natively (see *note Numeric data types::) and can also work on
tiles over a dataset.  Hence the inputs and outputs are in Gnuastro’s
*note Generic data container::.

 -- Macro: GAL_STATISTICS_SIG_CLIP_MAX_CONVERGE
     The maximum number of clips, when $\sigma$-clipping should be done
     by convergence.  If the clipping does not converge before making
     this many clips, all $\sigma$-clipping outputs will be NaN.

 -- Macro: GAL_STATISTICS_MODE_GOOD_SYM
     The minimum acceptable symmetricity of the mode calculation.  If
     the symmetricity of the derived mode is less than this value, all
     the returned values by ‘gal_statistics_mode’ will have a value of
     NaN.

 -- Macro: GAL_STATISTICS_BINS_INVALID
 -- Macro: GAL_STATISTICS_BINS_REGULAR
 -- Macro: GAL_STATISTICS_BINS_IRREGULAR
     Macros used to identify if the regularity of the bins when defining
     bins.

 -- Function:
          gal_data_t *
          gal_statistics_number (gal_data_t ‘*input’)
     Return a single-element dataset with type ‘size_t’ which contains
     the number of non-blank elements in ‘input’.

 -- Function:
          gal_data_t *
          gal_statistics_minimum (gal_data_t ‘*input’)
     Return a single-element dataset containing the minimum non-blank
     value in ‘input’.  The numerical datatype of the output is the same
     as ‘input’.

 -- Function:
          gal_data_t *
          gal_statistics_maximum (gal_data_t ‘*input’)
     Return a single-element dataset containing the maximum non-blank
     value in ‘input’.  The numerical datatype of the output is the same
     as ‘input’.

 -- Function:
          gal_data_t *
          gal_statistics_sum (gal_data_t ‘*input’)
     Return a single-element (‘double’ or ‘float64’) dataset containing
     the sum of the non-blank values in ‘input’.

 -- Function:
          gal_data_t *
          gal_statistics_mean (gal_data_t ‘*input’)
     Return a single-element (‘double’ or ‘float64’) dataset containing
     the mean of the non-blank values in ‘input’.

 -- Function:
          gal_data_t *
          gal_statistics_std (gal_data_t ‘*input’)
     Return a single-element (‘double’ or ‘float64’) dataset containing
     the standard deviation of the non-blank values in ‘input’.

 -- Function:
          gal_data_t *
          gal_statistics_mean_std (gal_data_t ‘*input’)
     Return a two-element (‘double’ or ‘float64’) dataset containing the
     mean and standard deviation of the non-blank values in ‘input’.
     The first element of the returned dataset is the mean and the
     second is the standard deviation.

     This function will calculate both values in one pass over the
     dataset.  Hence when both the mean and standard deviation of a
     dataset are necessary, this function is much more efficient than
     calling ‘gal_statistics_mean’ and ‘gal_statistics_std’ separately.

 -- Function:
          gal_data_t *
          gal_statistics_median (gal_data_t ‘*input’, int ‘inplace’)
     Return a single-element dataset containing the median of the
     non-blank values in ‘input’.  The numerical datatype of the output
     is the same as ‘input’.

     Calculating the median involves sorting the dataset and removing
     blank values, for better performance (and less memory usage), you
     can give a non-zero value to the ‘inplace’ argument.  In this case,
     the sorting and removal of blank elements will be done directly on
     the input dataset.  However, after this function the original
     dataset may have changed (if it wasn’t sorted or had blank values).

 -- Function:
          size_t
          gal_statistics_quantile_index (size_t ‘size’, double
          ‘quantile’)
     Return the index of the element that has a quantile of ‘quantile’
     assuming the dataset has ‘size’ elements.

 -- Function:
          gal_data_t *
          gal_statistics_quantile (gal_data_t ‘*input’, double
          ‘quantile’, int ‘inplace’)
     Return a single-element dataset containing the value with in a
     quantile ‘quantile’ of the non-blank values in ‘input’.  The
     numerical datatype of the output is the same as ‘input’.  See
     ‘gal_statistics_median’ for a description of ‘inplace’.

 -- Function:
          size_t
          gal_statistics_quantile_function_index (gal_data_t ‘*input’,
          gal_data_t ‘*value’, int ‘inplace’)
     Return the index of the quantile function (inverse quantile) of
     ‘input’ at ‘value’.  In other words, this function will return the
     index of the nearest element (of a sorted and non-blank) ‘input’ to
     ‘value’.  If the value is outside the range of the input, then this
     function will return ‘GAL_BLANK_SIZE_T’.

 -- Function:
          gal_data_t *
          gal_statistics_quantile_function (gal_data_t ‘*input’,
          gal_data_t ‘*value’, int ‘inplace’)
     Return a single-element (‘double’ or ‘float64’) dataset containing
     the quantile function of the non-blank values in ‘input’ at
     ‘value’.  In other words, this function will return the quantile of
     ‘value’ in ‘input’.  If the value is smaller than the input’s
     smallest element, the returned value will be zero.  If the value is
     larger than the input’s largest element, then the returned value is
     1.  See ‘gal_statistics_median’ for a description of ‘inplace’.

 -- Function:
          gal_data_t *
          gal_statistics_unique (gal_data_t ‘*input’, int ‘inplace’)
     Return a 1D dataset with the same numeric data type as the input,
     but only containing its unique elements and without any (possible)
     blank/NaN elements.  Note that the input’s number of dimensions is
     irrelevant for this function.  If ‘inplace’ is not zero, then the
     unique values will over-write the allocated space of the input,
     otherwise a new space will be allocated and the input will not be
     touched.

 -- Function:
          gal_data_t *
          gal_statistics_mode (gal_data_t ‘*input’, float ‘mirrordist’,
          int ‘inplace’)
     Return a four-element (‘double’ or ‘float64’) dataset that contains
     the mode of the ‘input’ distribution.  This function implements the
     non-parametric algorithm to find the mode that is described in
     Appendix C of Akhlaghi and Ichikawa [2015]
     (https://arxiv.org/abs/1505.01664).

     In short it compares the actual distribution and its “mirror
     distribution” to find the mode.  In order to be efficient, you can
     determine how far the comparison goes away from the mirror through
     the ‘mirrordist’ parameter (think of it as a multiple of
     sigma/error).  See ‘gal_statistics_median’ for a description of
     ‘inplace’.

     The output array has the following elements (in the given order,
     note that counting in C starts from 0).
          array[0]: mode
          array[1]: mode quantile.
          array[2]: symmetricity.
          array[3]: value at the end of symmetricity.

 -- Function:
          gal_data_t *
          gal_statistics_mode_mirror_plots (gal_data_t ‘*input’,
          gal_data_t ‘*value’, size_t ‘numbins’, int ‘inplace’, double
          ‘*mirror_val’)
     Make a mirrored histogram and cumulative frequency plot (with
     ‘numbins’) with the mirror distribution of the ‘input’ having a
     value in ‘value’.  If all the input elements are blank, or the
     mirror value is outside the range of the input, this function will
     return a ‘NULL’ pointer.

     The output is a list of data structures (see *note List of
     gal_data_t::): the first is the bins with one bin at the mirror
     point, the second is the histogram with a maximum of one and the
     third is the cumulative frequency plot (with a maximum of one).

 -- Function:
          int
          gal_statistics_is_sorted (gal_data_t ‘*input’, int
          ‘updateflags’)
     Return ‘0’ if the input is not sorted, if it is sorted, this
     function will return ‘1’ and ‘2’ if it is increasing or decreasing,
     respectively.  This function will abort with an error if ‘input’
     has zero elements and will return ‘1’ (sorted, increasing) when
     there is only one element.  This function will only look into the
     dataset if the ‘GAL_DATA_FLAG_SORT_CH’ bit of ‘input->flag’ is ‘0’,
     see *note Generic data container::.

     When the flags don’t indicate a previous check _and_ ‘updateflags’
     is non-zero, this function will set the flags appropriately to
     avoid having to re-check the dataset in future calls (this can be
     very useful when repeated checks are necessary).  When
     ‘updateflags==0’, this function has no side-effects on the dataset:
     it will not toggle the flags.

     If you want to re-check a dataset with the blank-value-check flag
     already set (for example if you have made changes to it), then
     explicitly set the ‘GAL_DATA_FLAG_SORT_CH’ bit to zero before
     calling this function.  When there are no other flags, you can
     simply set the flags to zero (with ‘input->flag=0’), otherwise you
     can use this expression:

          input->flag &= ~GAL_DATA_FLAG_SORT_CH;

 -- Function:
          void
          gal_statistics_sort_increasing (gal_data_t ‘*input’)
     Sort the input dataset (in place) in an increasing order and toggle
     the sort-related bit flags accordingly.

 -- Function:
          void
          gal_statistics_sort_decreasing (gal_data_t ‘*input’)
     Sort the input dataset (in place) in a decreasing order and toggle
     the sort-related bit flags accordingly.

 -- Function:
          gal_data_t *
          gal_statistics_no_blank_sorted (gal_data_t ‘*input’, int
          ‘inplace’)
     Remove all the blanks and sort the input dataset.  If ‘inplace’ is
     non-zero this will happen on the input dataset (in the allocated
     space of the input dataset).  However, if ‘inplace’ is zero, this
     function will allocate a new copy of the dataset and work on that.
     Therefore if ‘inplace==0’, the input dataset will be modified.

     This function uses the bit flags of the input, so if you have
     modified the dataset, set ‘input->flag=0’ before calling this
     function.  Also note that ‘inplace’ is only for the dataset
     elements.  Therefore even when ‘inplace==0’, if the input is
     already sorted _and_ has no blank values, then the flags will be
     updated to show this.

     If all the elements were blank, then the returned dataset’s ‘size’
     will be zero.  This is thus a good parameter to check after calling
     this function to see if there actually were any non-blank elements
     in the input or not and take the appropriate measure.  This can
     help avoid strange bugs in later steps.  The flags of a zero-sized
     returned dataset will indicate that it has no blanks and is sorted
     in an increasing order.  Even if having blank values or being
     sorted is not defined on a zero-element dataset, it is up to the
     caller to choose what they will do with a zero-element dataset.
     The flags have to be set after this function any way.

 -- Function:
          gal_data_t *
          gal_statistics_regular_bins (gal_data_t ‘*input’, gal_data_t
          ‘*inrange’, size_t ‘numbins’, double ‘onebinstart’)
     Generate an array of regularly spaced elements as a 1D array
     (column) of type ‘double’ (i.e., ‘float64’, it has to be double to
     account for small differences on the bin edges).  The input
     arguments are described below

     ‘input’
          The dataset you want to apply the bins to.  This is only
          necessary if the range argument is not complete, see below.
          If ‘inrange’ has all the necessary information, you can pass a
          ‘NULL’ pointer for this.

     ‘inrange’
          This dataset keeps the desired range along each dimension of
          the input data structure, it has to be in ‘float’ (i.e.,
          ‘float32’) type.

             • If you want the full range of the dataset (in any
               dimensions, then just set ‘inrange’ to ‘NULL’ and the
               range will be specified from the minimum and maximum
               value of the dataset (‘input’ cannot be ‘NULL’ in this
               case).

             • If there is one element for each dimension in range, then
               it is viewed as a quantile (Q), and the range will be: ‘Q
               to 1-Q’.

             • If there are two elements for each dimension in range,
               then they are assumed to be your desired minimum and
               maximum values.  When either of the two are NaN, the
               minimum and maximum will be calculated for it.

     ‘numbins’
          The number of bins: must be larger than 0.

     ‘onebinstart’
          A desired value for onebinstart.  Note that with this option,
          the bins won’t start and end exactly on the given range
          values, it will be slightly shifted to accommodate this
          request.

 -- Function:
          gal_data_t *
          gal_statistics_histogram (gal_data_t ‘*input’, gal_data_t
          ‘*bins’, int ‘normalize’, int ‘maxone’)
     Make a histogram of all the elements in the given dataset with bin
     values that are defined in the ‘inbins’ structure (see
     ‘gal_statistics_regular_bins’, they currently have to be equally
     spaced).  ‘inbins’ is not mandatory, if you pass a ‘NULL’ pointer,
     the bins structure will be built within this function based on the
     ‘numbins’ input.  As a result, when you have already defined the
     bins, ‘numbins’ is not used.

     Let’s write the center of the $i$th element of the bin array as
     $b_i$, and the fixed half-bin width as $h$.  Then element $j$ of
     the input array ($in_j$) will be counted in $b_i$ if $(b_i-h) \le
     in_j < (b_i+h)$.  However, if $in_j$ is somewhere in the last bin,
     the condition changes to $(b_i-h) \le in_j \le (b_i+h)$.

 -- Function:
          gal_data_t *
          gal_statistics_cfp (gal_data_t ‘*input’, gal_data_t ‘*bins’,
          int ‘normalize’)
     Make a cumulative frequency plot (CFP) of all the elements in
     ‘input’ with bin values that are defined in the ‘bins’ structure
     (see ‘gal_statistics_regular_bins’).

     The CFP is built from the histogram: in each bin, the value is the
     sum of all previous bins in the histogram.  Thus, if you have
     already calculated the histogram before calling this function, you
     can pass it onto this function as the data structure in
     ‘bins->next’ (see ‘List of gal_data_t’).  If ‘bin->next!=NULL’,
     then it is assumed to be the histogram.  If it is ‘NULL’, then the
     histogram will be calculated internally and freed after the job is
     finished.

     When a histogram is given and it is normalized, the CFP will also
     be normalized (even if the normalized flag is not set here): note
     that a normalized CFP’s maximum value is 1.

 -- Function:
          gal_data_t *
          gal_statistics_sigma_clip (gal_data_t ‘*input’, float
          ‘multip’, float ‘param’, int ‘inplace’, int ‘quiet’)
     Apply $\sigma$-clipping on a given dataset and return a dataset
     that contains the results.  For a description of $\sigma$-clipping
     see *note Sigma clipping::.  ‘multip’ is the multiple of the
     standard deviation (or $\sigma$, that is used to define outliers in
     each round of clipping).

     The role of ‘param’ is determined based on its value.  If ‘param’
     is larger than ‘1’ (one), it must be an integer and will be
     interpreted as the number clips to do.  If it is less than ‘1’
     (one), it is interpreted as the tolerance level to stop the
     iteration.

     The returned dataset (let’s call it ‘out’) contains a four-element
     array with type ‘GAL_TYPE_FLOAT32’.  The final number of clips is
     stored in the ‘out->status’.
          float *array=out->array;
          array[0]: Number of points used.
          array[1]: Median.
          array[2]: Mean.
          array[3]: Standard deviation.

     If the $\sigma$-clipping doesn’t converge or all input elements are
     blank, then this function will return NaN values for all the
     elements above.

 -- Function:
          gal_data_t *
          gal_statistics_outlier_positive (gal_data_t ‘*input’, size_t
          ‘window_size’, float ‘sigma’, float ‘sigclip_multip’, float
          ‘sigclip_param’, int ‘inplace’, int ‘quiet’)
     Find the first positive outlier in the ‘input’ distribution.  The
     returned dataset contains a single element: the first positive
     outlier.  It is one of the dataset’s elements, in the same type as
     the input.  If the process fails for any reason (for example no
     outlier was found), a ‘NULL’ pointer will be returned.

     All (possibly existing) blank elements are first removed from the
     input dataset, then it is sorted.  A sliding window of
     ‘window_size’ elements is parsed over the dataset.  Starting from
     the ‘window_size’-th element of the dataset, in the direction of
     increasing values.  This window is used as a reference.  The first
     element where the distance to the previous (sorted) element is
     ‘sigma’ units away from the distribution of distances in its window
     is considered an outlier and returned by this function.

     Formally, if we assume there are $N$ non-blank elements.  They are
     first sorted.  Searching for the outlier starts on element $W$.
     Let’s take $v_i$ to be the $i$-th element of the sorted input (with
     no blank values) and $m$ and $\sigma$ as the $\sigma$-clipped
     median and standard deviation from the distances of the previous
     $W$ elements (not including $v_i$).  If the value given to ‘sigma’
     is displayed with $s$, the $i$-th element is considered as an
     outlier when the condition below is true.

                  $${(v_i-v_{i-1})-m\over \sigma}>s$$

     The ‘sigclip_multip’ and ‘sigclip_param’ arguments specify the
     properties of the $\sigma$-clipping (see *note Sigma clipping:: for
     more).  You see that by this definition, the outlier cannot be any
     of the lower half elements.  The advantage of this algorithm
     compared to $\sigma$-clippign is that it only looks backwards (in
     the sorted array) and parses it in one direction.

     If ‘inplace!=0’, the removing of blank elements and sorting will be
     done within the input dataset’s allocated space.  Otherwise, this
     function will internally allocate (and later free) the necessary
     space to keep the intermediate space that this process requires.

     If ‘quiet!=0’, this function will report the parameters every time
     it moves the window as a separate line with several columns.  The
     first column is the value, the second (in square brackets) is the
     sorted index, the third is the distance of this element from the
     previous one.  The Fourth and fifth (in parenthesis) are the median
     and standard deviation of the $\sigma$-clipped distribution within
     the window and the last column is the difference between the third
     and fourth, divided by the fifth.

 -- Function:
          gal_data_t *
          gal_statistics_outlier_flat_cfp (gal_data_t ‘*input’, size_t
          ‘numprev’, float ‘sigclip_multip’, float ‘sigclip_param’,
          float ‘thresh’, size_t ‘numcontig’, int ‘inplace’, int
          ‘quiet’, size_t ‘*index’)

     Return the first element in the given dataset where the cumulative
     frequency plot first becomes significantly flat for a sufficient
     number of elements.  The returned dataset only has one element
     (with the same type as the input).  If ‘index!=NULL’, the index
     (counting from zero, after sorting the dataset and removing any
     blanks) is written in the space that ‘index’ points to.  If no
     sufficiently flat portion is found, the returned pointer will be
     ‘NULL’.

     The flatness on the cumulative frequency plot is defined like this
     (see *note Histogram and Cumulative Frequency Plot::): on the
     sorted dataset, for every point ($a_i$), we calculate
     $d_i=a_{i+2}-a_{i-2}$.  This done on the first $N$ elements (value
     of ‘numprev’).  After element $a_{N+2}$, we start estimating the
     flatness as follows: for every element we use the $N$, $d_i$
     measurements before it as the reference.  Let’s call this set $D_i$
     for element $i$.  The $\sigma$-clipped median ($m$) and standard
     deviation ($s$) of $D_i$ are then calculated.  The
     $\sigma$-clipping can be configured with the two ‘sigclip_param’
     and ‘sigclip_multip’ arguments.

     Taking $t$ as the significance threshold (value to ‘thresh’), a
     point is considered flat when $a_i>m+t\sigma$.  But a single point
     satisfying this condition will probably just be due to noise.  To
     make a more robust estimate, this significance/condition has to
     hold for ‘numcontig’ contiguous elements after $a_i$.  When this is
     satisfied, $a_i$ is returned as the point where the distribution’s
     cumulative frequency plot becomes flat.

     To get a good estimate of $m$ and $s$, it is thus recommended to
     set ‘numprev’ as large as possible.  However, be careful not to set
     it too high: the checks in the paragraph above are not done on the
     first ‘numprev’ elements and this function assumes the flatness
     occurs after them.  Also, be sure that the value to ‘numcontig’ is
     much less than ‘numprev’, otherwise $\sigma$-clipping may not be
     able to remove the immediate outliers in $D_i$ near the boundary of
     the flat region.

     When ‘quiet==0’, the basic measurements done on each element are
     printed on the command-line (good for finding the best parameters).
     When ‘inplace!=0’, the sorting and removal of blank elements is
     done on the input dataset, so the input may be altered after this
     function.


File: gnuastro.info,  Node: Binary datasets,  Next: Labeled datasets,  Prev: Statistical operations,  Up: Gnuastro library

10.3.22 Binary datasets (‘binary.h’)
------------------------------------

Binary datasets only have two (usable) values: 0 (also known as
background) or 1 (also known as foreground).  They are created after
some binary classification is applied to the dataset.  The most common
is thresholding: for example in an image, pixels with a value above the
threshold are given a value of 1 and those with a value less than the
threshold are assigned a value of 0.

   Since there is only two values, in the processing of binary images,
you are usually concerned with the positioning of an element and its
vicinity (neighbors).  When a dataset has more than one dimension,
multiple classes of immediate neighbors (that are touching the element)
can be defined for each data-element.  To separate these different
classes of immediate neighbors, we define _connectivity_.

   The classification is done by the distance from element center to the
neighbor’s center.  The nearest immediate neighbors have a connectivity
of 1, the second nearest class of neighbors have a connectivity of 2 and
so on.  In total, the largest possible connectivity for data with ‘ndim’
dimensions is ‘ndim’.  For example in a 2D dataset, 4-connected
neighbors (that share an edge and have a distance of 1 pixel) have a
connectivity of 1.  The other 4 neighbors that only share a vertice
(with a distance of $\sqrt{2}$ pixels) have a connectivity of 2.
Conventionally, the class of connectivity-2 neighbors also includes the
connectivity 1 neighbors, so for example we call them 8-connected
neighbors in 2D datasets.

   Ideally, one bit is sufficient for each element of a binary dataset.
However, CPUs are not designed to work on individual bits, the smallest
unit of memory addresses is a byte (containing 8 bits on modern CPUs).
Therefore, in Gnuastro, the type used for binary dataset is ‘uint8_t’
(see *note Numeric data types::).  Although it does take 8-times more
memory, this choice offers much better performance and the some extra
(useful) features.

   The advantage of using a full byte for each element of a binary
dataset is that you can also have other values (that will be ignored in
the processing).  One such common “other” value in real datasets is a
blank value (to mark regions that should not be processed because there
is no data).  The constant ‘GAL_BLANK_UINT8’ value must be used in these
cases (see *note Library blank values::).  Another is some temporary
value(s) that can be given to a processed pixel to avoid having another
copy of the dataset as in ‘GAL_BINARY_TMP_VALUE’ that is described
below.

 -- Macro: GAL_BINARY_TMP_VALUE
     The functions described below work on a ‘uint8_t’ type dataset with
     values of 1 or 0 (no other pixel will be touched).  However, in
     some cases, it is necessary to put temporary values in each element
     during the processing of the functions.  This temporary value has a
     special meaning for the operation and will be operated on.  So if
     your input datasets have values other than 0 and 1 that you don’t
     want these functions to work on, be sure they are not equal to this
     macro’s value.  Note that this value is also different from
     ‘GAL_BLANK_UINT8’, so your input datasets may also contain blank
     elements.

 -- Function:
          gal_data_t *
          gal_binary_erode (gal_data_t ‘*input’, size_t ‘num’, int
          ‘connectivity’, int ‘inplace’)
     Do ‘num’ erosions on the ‘connectivity’-connected neighbors of
     ‘input’ (see above for the definition of connectivity).

     If ‘inplace’ is non-zero _and_ the input’s type is
     ‘GAL_TYPE_UINT8’, then the erosion will be done within the input
     dataset and the returned pointer will be ‘input’.  Otherwise,
     ‘input’ is copied (and converted if necessary) to ‘GAL_TYPE_UINT8’
     and erosion will be done on this new dataset which will also be
     returned.  This function will only work on the elements with a
     value of 1 or 0.  It will leave all the rest unchanged.

     Erosion (inverse of dilation) is an operation in mathematical
     morphology where each foreground pixel that is touching a
     background pixel is flipped (changed to background).  The
     ‘connectivity’ value determines the definition of “touching”.
     Erosion will thus decrease the area of the foreground regions by
     one layer of pixels.

 -- Function:
          gal_data_t *
          gal_binary_dilate (gal_data_t ‘*input’, size_t ‘num’, int
          ‘connectivity’, int ‘inplace’)
     Do ‘num’ dilations on the ‘connectivity’-connected neighbors of
     ‘input’ (see above for the definition of connectivity).  For more
     on ‘inplace’ and the output, see ‘gal_binary_erode’.

     Dilation (inverse of erosion) is an operation in mathematical
     morphology where each background pixel that is touching a
     foreground pixel is flipped (changed to foreground).  The
     ‘connectivity’ value determines the definition of “touching”.
     Dilation will thus increase the area of the foreground regions by
     one layer of pixels.

 -- Function:
          gal_data_t *
          gal_binary_open (gal_data_t ‘*input’, size_t ‘num’, int
          ‘connectivity’, int ‘inplace’)
     Do ‘num’ openings on the ‘connectivity’-connected neighbors of
     ‘input’ (see above for the definition of connectivity).  For more
     on ‘inplace’ and the output, see ‘gal_binary_erode’.

     Opening is an operation in mathematical morphology which is defined
     as erosion followed by dilation (see above for the definitions of
     erosion and dilation).  Opening will thus remove the outer
     structure of the foreground.  In this implementation, ‘num’
     erosions are going to be applied on the dataset, then ‘num’
     dilations.

 -- Function:
          size_t
          gal_binary_connected_components (gal_data_t ‘*binary’,
          gal_data_t ‘**out’, int ‘connectivity’)
     Return the number of connected components in ‘binary’ through the
     breadth first search algorithm (finding all pixels belonging to one
     component before going on to the next).  Connection between two
     pixels is defined based on the value to ‘connectivity’.  ‘out’ is a
     dataset with the same size as ‘binary’ with ‘GAL_TYPE_INT32’ type.
     Every pixel in ‘out’ will have the label of the connected component
     it belongs to.  The labeling of connected components starts from 1,
     so a label of zero is given to the input’s background pixels.

     When ‘*out!=NULL’ (its space is already allocated), it will be
     cleared (to zero) at the start of this function.  Otherwise, when
     ‘*out==NULL’, the necessary dataset to keep the output will be
     allocated by this function.

     ‘binary’ must have a type of ‘GAL_TYPE_UINT8’, otherwise this
     function will abort with an error.  Other than blank pixels (with a
     value of ‘GAL_BLANK_UINT8’ defined in *note Library blank
     values::), all other non-zero pixels in ‘binary’ will be considered
     as foreground (and will be labeled).  Blank pixels in the input
     will also be blank in the output.

 -- Function:
          gal_data_t *
          gal_binary_connected_indexs(gal_data_t ‘*binary’, int
          ‘connectivity’)
     Build a ‘gal_data_t’ linked list, where each node of the list
     contains an array with indexs of the connected regions.  Therefore
     the arrays of each node can have a different size.  Note that the
     indexs will only be calculated on the pixels with a value of 1 and
     internally, it will temporarily change the values to 2 (and return
     them back to 1 in the end).

 -- Function:
          gal_data_t *
          gal_binary_connected_adjacency_matrix (gal_data_t
          ‘*adjacency’, size_t ‘*numconnected’)
     Find the number of connected labels and new labels based on an
     adjacency matrix, which must be a square binary array (type
     ‘GAL_TYPE_UINT8’).  The returned dataset is a list of new labels
     for each old label.  In other words, this function will find the
     objects that are connected (possibly through a third object) and in
     the output array, the respective elements for all input labels is
     going to have the same value.  The total number of connected labels
     is put into the space that ‘numconnected’ points to.

     An adjacency matrix defines connection between two labels.  For
     example, let’s assume we have 5 labels and we know that labels 1
     and 5 are connected to label 3, but are not connected with each
     other.  Also, labels 2 and 4 are not touching any other label.  So
     in total we have 3 final labels: one combined object (merged from
     labels 1, 3, and 5) and the initial labels 2 and 4.  The input
     adjacency matrix would look like this (note the extra row and
     column for a label 0 which is ignored):

                      INPUT                             OUTPUT
                      =====                             ======
                    in_lab  1  2  3  4  5   |
                                            |       numconnected = 3
                         0  0  0  0  0  0   |
          in_lab 1 -->   0  0  0  1  0  0   |
          in_lab 2 -->   0  0  0  0  0  0   |  Returned: new labels for the
          in_lab 3 -->   0  1  0  0  0  1   |       5 initial objects
          in_lab 4 -->   0  0  0  0  0  0   |   | 0 | 1 | 2 | 1 | 3 | 1 |
          in_lab 5 -->   0  0  0  1  0  0   |

     Although the adjacency matrix as used here is symmetric, currently
     this function assumes that it is filled on both sides of the
     diagonal.

 -- Function:
          gal_data_t *
          gal_binary_holes_label (gal_data_t ‘*input’, int
          ‘connectivity’, size_t ‘*numholes’)
     Label all the holes in the foreground (non-zero elements in input)
     as independent regions.  Holes are background regions (zero-valued
     in input) that are fully surrounded by the foreground, as defined
     by ‘connectivity’.  The returned dataset has a 32-bit signed
     integer type with the size of the input.  All holes in the input
     will have labels/counters greater or equal to ‘1’.  The rest of the
     background regions will still have a value of ‘0’ and the initial
     foreground pixels will have a value of ‘-1’.  The total number of
     holes will be written where ‘numholes’ points to.

 -- Function:
          void
          gal_binary_holes_fill (gal_data_t ‘*input’, int
          ‘connectivity’, size_t ‘maxsize’)
     Fill all the holes (0 valued pixels surrounded by 1 valued pixels)
     of the binary ‘input’ dataset.  The connectivity of the holes can
     be set with ‘connectivity’.  Holes larger than ‘maxsize’ are not
     filled.  This function currently only works on a 2D dataset.

