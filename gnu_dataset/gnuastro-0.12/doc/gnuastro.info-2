This is gnuastro.info, produced by makeinfo version 6.7 from
gnuastro.texi.

This book documents version 0.12 of the GNU Astronomy Utilities
(Gnuastro).  Gnuastro provides various programs and libraries for
astronomical data manipulation and analysis.

   Copyright © 2015-2020, Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled “GNU Free Documentation License”.
INFO-DIR-SECTION Astronomy
START-INFO-DIR-ENTRY
* Gnuastro: (gnuastro).       GNU Astronomy Utilities.
* libgnuastro: (gnuastro)Gnuastro library. Full Gnuastro library doc.

* help-gnuastro: (gnuastro)help-gnuastro mailing list. Getting help.

* bug-gnuastro: (gnuastro)Report a bug. How to report bugs

* Arithmetic: (gnuastro)Arithmetic. Arithmetic operations on pixels.
* astarithmetic: (gnuastro)Invoking astarithmetic. Options to Arithmetic.

* BuildProgram: (gnuastro)BuildProgram. Compile and run programs using Gnuastro’s library.
* astbuildprog: (gnuastro)Invoking astbuildprog. Options to BuildProgram.

* ConvertType: (gnuastro)ConvertType. Convert different file types.
* astconvertt: (gnuastro)Invoking astconvertt. Options to ConvertType.

* Convolve: (gnuastro)Convolve. Convolve an input file with kernel.
* astconvolve: (gnuastro)Invoking astconvolve. Options to Convolve.

* CosmicCalculator: (gnuastro)CosmicCalculator. For cosmological params.
* astcosmiccal: (gnuastro)Invoking astcosmiccal. Options to CosmicCalculator.

* Crop: (gnuastro)Crop. Crop region(s) from image(s).
* astcrop: (gnuastro)Invoking astcrop. Options to Crop.

* Fits: (gnuastro)Fits. View and manipulate FITS extensions and keywords.
* astfits: (gnuastro)Invoking astfits. Options to Fits.

* MakeCatalog: (gnuastro)MakeCatalog. Make a catalog from labeled image.
* astmkcatalog: (gnuastro)Invoking astmkcatalog. Options to MakeCatalog.

* MakeNoise: (gnuastro)MakeNoise. Make (add) noise to an image.
* astmknoise: (gnuastro)Invoking astmknoise. Options to MakeNoise.

* MakeProfiles: (gnuastro)MakeProfiles. Make mock profiles.
* astmkprof: (gnuastro)Invoking astmkprof. Options to MakeProfiles.

* Match: (gnuastro)Match. Match two separate catalogs.
* astmatch: (gnuastro)Invoking astmatch. Options to Match.

* NoiseChisel: (gnuastro)NoiseChisel. Detect signal in noise.
* astnoisechisel: (gnuastro)Invoking astnoisechisel. Options to NoiseChisel.

* Segment: (gnuastro)Segment. Segment detections based on signal structure.
* astsegment: (gnuastro)Invoking astsegment. Options to Segment.

* Statistics: (gnuastro)Statistics. Get image Statistics.
* aststatistics: (gnuastro)Invoking aststatistics. Options to Statistics.

* Table: (gnuastro)Table. Read and write FITS binary or ASCII tables.
* asttable: (gnuastro)Invoking asttable. Options to Table.

* Warp: (gnuastro)Warp. Warp a dataset to a new grid.
* astwarp: (gnuastro)Invoking astwarp. Options to Warp.

* astscript-sort-by-night: (gnuastro)Invoking astscript-sort-by-night. Options to this script

END-INFO-DIR-ENTRY


File: gnuastro.info,  Node: Build and install,  Prev: Downloading the source,  Up: Installation

3.3 Build and install
=====================

This section is basically a longer explanation to the sequence of
commands given in *note Quick start::.  If you didn’t have any problems
during the *note Quick start:: steps, you want to have all the programs
of Gnuastro installed in your system, you don’t want to change the
executable names during or after installation, you have root access to
install the programs in the default system wide directory, the Letter
paper size of the print book is fine for you or as a summary you don’t
feel like going into the details when everything is working, you can
safely skip this section.

   If you have any of the above problems or you want to understand the
details for a better control over your build and install, read along.
The dependencies which you will need prior to configuring, building and
installing Gnuastro are explained in *note Dependencies::.  The first
three steps in *note Quick start:: need no extra explanation, so we will
skip them and start with an explanation of Gnuastro specific
configuration options and a discussion on the installation directory in
*note Configuring::, followed by some smaller subsections: *note
Tests::, *note A4 print book::, and *note Known issues:: which explains
the solutions to known problems you might encounter in the installation
steps and ways you can solve them.

* Menu:

* Configuring::                 Configure Gnuastro
* Separate build and source directories::  Keeping derivate/build files separate.
* Tests::                       Run tests to see if it is working.
* A4 print book::               Customize the print book.
* Known issues::                Issues you might encounter.


File: gnuastro.info,  Node: Configuring,  Next: Separate build and source directories,  Prev: Build and install,  Up: Build and install

3.3.1 Configuring
-----------------

The ‘$ ./configure’ step is the most important step in the build and
install process.  All the required packages, libraries, headers and
environment variables are checked in this step.  The behaviors of make
and make install can also be set through command line options to this
command.

   The configure script accepts various arguments and options which
enable the final user to highly customize whatever she is building.  The
options to configure are generally very similar to normal program
options explained in *note Arguments and options::.  Similar to all GNU
programs, you can get a full list of the options along with a short
explanation by running

     $ ./configure --help

A complete explanation is also included in the ‘INSTALL’ file.  Note
that this file was written by the authors of GNU Autoconf (which builds
the ‘configure’ script), therefore it is common for all programs which
use the ‘$ ./configure’ script for building and installing, not just
Gnuastro.  Here we only discuss cases where you don’t have super-user
access to the system and if you want to change the executable names.
But before that, a review of the options to configure that are
particular to Gnuastro are discussed.

* Menu:

* Gnuastro configure options::  Configure options particular to Gnuastro.
* Installation directory::      Specify the directory to install.
* Executable names::            Changing executable names.
* Configure and build in RAM::  For minimal use of HDD or SSD, and clean source.


File: gnuastro.info,  Node: Gnuastro configure options,  Next: Installation directory,  Prev: Configuring,  Up: Configuring

3.3.1.1 Gnuastro configure options
..................................

Most of the options to configure (which are to do with building) are
similar for every program which uses this script.  Here the options that
are particular to Gnuastro are discussed.  The next topics explain the
usage of other configure options which can be applied to any program
using the GNU build system (through the configure script).

‘--enable-debug’
     Compile/build Gnuastro with debugging information, no optimization
     and without shared libraries.

     In order to allow more efficient programs when using Gnuastro
     (after the installation), by default Gnuastro is built with a 3rd
     level (a very high level) optimization and no debugging
     information.  By default, libraries are also built for static _and_
     shared linking (see *note Linking::).  However, when there are
     crashes or unexpected behavior, these three features can hinder the
     process of localizing the problem.  This configuration option is
     identical to manually calling the configuration script with
     ‘CFLAGS="-g -O0" --disable-shared’.

     In the (rare) situations where you need to do your debugging on the
     shared libraries, don’t use this option.  Instead run the configure
     script by explicitly setting ‘CFLAGS’ like this:
          $ ./configure CFLAGS="-g -O0"

‘--enable-check-with-valgrind’
     Do the ‘make check’ tests through Valgrind.  Therefore, if any
     crashes or memory-related issues (segmentation faults in
     particular) occur in the tests, the output of Valgrind will also be
     put in the ‘tests/test-suite.log’ file without having to manually
     modify the check scripts.  This option will also activate
     Gnuastro’s debug mode (see the ‘--enable-debug’ configure-time
     option described above).

     Valgrind is free software.  It is a program for easy checking of
     memory-related issues in programs.  It runs a program within its
     own controlled environment and can thus identify the exact
     line-number in the program’s source where a memory-related issue
     occurs.  However, it can significantly slow-down the tests.  So
     this option is only useful when a segmentation fault is found
     during ‘make check’.

‘--enable-progname’
     Only build and install ‘progname’ along with any other program that
     is enabled in this fashion.  ‘progname’ is the name of the
     executable without the ‘ast’, for example ‘crop’ for Crop (with the
     executable name of ‘astcrop’).

     Note that by default all the programs will be installed.  This
     option (and the ‘--disable-progname’ options) are only relevant
     when you don’t want to install all the programs.  Therefore, if
     this option is called for any of the programs in Gnuastro, any
     program which is not explicitly enabled will not be built or
     installed.

‘--disable-progname’
‘--enable-progname=no’
     Do not build or install the program named ‘progname’.  This is very
     similar to the ‘--enable-progname’, but will build and install all
     the other programs except this one.

     *Note:* If some programs are enabled and some are disabled, it is
     equivalent to simply enabling those that were enabled.  Listing the
     disabled programs is redundant.

‘--enable-gnulibcheck’
     Enable checks on the GNU Portability Library (Gnulib).  Gnulib is
     used by Gnuastro to enable users of non-GNU based operating systems
     (that don’t use GNU C library or glibc) to compile and use the
     advanced features that this library provides.  We make extensive
     use of such functions.  If you give this option to ‘$ ./configure’,
     when you run ‘$ make check’, first the functions in Gnulib will be
     tested, then the Gnuastro executables.  If your operating system
     does not support glibc or has an older version of it and you have
     problems in the build process (‘$ make’), you can give this flag to
     configure to see if the problem is caused by Gnulib not supporting
     your operating system or Gnuastro, see *note Known issues::.

‘--disable-guide-message’
‘--enable-guide-message=no’
     Do not print a guiding message during the GNU Build process of
     *note Quick start::.  By default, after each step, a message is
     printed guiding the user what the next command should be.
     Therefore, after ‘./configure’, it will suggest running ‘make’.
     After ‘make’, it will suggest running ‘make check’ and so on.  If
     Gnuastro is configured with this option, for example
          $ ./configure --disable-guide-message
     Then these messages will not be printed after any step (like most
     programs).  For people who are not yet fully accustomed to this
     build system, these guidelines can be very useful and encouraging.
     However, if you find those messages annoying, use this option.

‘--without-libgit2’
     Build Gnuastro without libgit2 (for including Git commit hashes in
     output files), see *note Optional dependencies::.  libgit2 is an
     optional dependency, with this option, Gnuastro will ignore any
     possibly existing libgit2 that may already be on the system.

‘--without-libjpeg’
     Build Gnuastro without libjpeg (for reading/writing to JPEG files),
     see *note Optional dependencies::.  libjpeg is an optional
     dependency, with this option, Gnuastro will ignore any possibly
     existing libjpeg that may already be on the system.

‘--without-libtiff’
     Build Gnuastro without libtiff (for reading/writing to TIFF files),
     see *note Optional dependencies::.  libtiff is an optional
     dependency, with this option, Gnuastro will ignore any possibly
     existing libtiff that may already be on the system.

   The tests of some programs might depend on the outputs of the tests
of other programs.  For example MakeProfiles is one the first programs
to be tested when you run ‘$ make check’.  MakeProfiles’ test outputs
(FITS images) are inputs to many other programs (which in turn provide
inputs for other programs).  Therefore, if you don’t install
MakeProfiles for example, the tests for many the other programs will be
skipped.  To avoid this, in one run, you can install all the programs
and run the tests but not install.  If everything is working correctly,
you can run configure again with only the programs you want.  However,
don’t run the tests and directly install after building.


File: gnuastro.info,  Node: Installation directory,  Next: Executable names,  Prev: Gnuastro configure options,  Up: Configuring

3.3.1.2 Installation directory
..............................

One of the most commonly used options to ‘./configure’ is ‘--prefix’, it
is used to define the directory that will host all the installed files
(or the “prefix” in their final absolute file name).  For example, when
you are using a server and you don’t have administrator or root access.
In this example scenario, if you don’t use the ‘--prefix’ option, you
won’t be able to install the built files and thus access them from
anywhere without having to worry about where they are installed.
However, once you prepare your startup file to look into the proper
place (as discussed thoroughly below), you will be able to easily use
this option and benefit from any software you want to install without
having to ask the system administrators or install and use a different
version of a software that is already installed on the server.

   The most basic way to run an executable is to explicitly write its
full file name (including all the directory information) and run it.
One example is running the configuration script with the ‘$ ./configure’
command (see *note Quick start::).  By giving a specific directory (the
current directory or ‘./’), we are explicitly telling the shell to look
in the current directory for an executable file named ‘‘configure’’.
Directly specifying the directory is thus useful for executables in the
current (or nearby) directories.  However, when the program (an
executable file) is to be used a lot, specifying all those directories
will become a significant burden.  For example, the ‘ls’ executable
lists the contents in a given directory and it is (usually) installed in
the ‘/usr/bin/’ directory by the operating system maintainers.
Therefore, if using the full address was the only way to access an
executable, each time you wanted a listing of a directory, you would
have to run the following command (which is very inconvenient, both in
writing and in remembering the various directories).

     $ /usr/bin/ls

   To address this problem, we have the ‘PATH’ environment variable.  To
understand it better, we will start with a short introduction to the
shell variables.  Shell variable values are basically treated as strings
of characters.  For example, it doesn’t matter if the value is a name
(string of _alphabetic_ characters), or a number (string of _numeric_
characters), or both.  You can define a variable and a value for it by
running
     $ myvariable1=a_test_value
     $ myvariable2="a test value"
As you see above, if the value contains white space characters, you have
to put the whole value (including white space characters) in double
quotes (<">).  You can see the value it represents by running
     $ echo $myvariable1
     $ echo $myvariable2
If a variable has no value or it wasn’t defined, the last command will
only print an empty line.  A variable defined like this will be known as
long as this shell or terminal is running.  Other terminals will have no
idea it existed.  The main advantage of shell variables is that if they
are exported(1), subsequent programs that are run within that shell can
access their value.  So by changing their value, you can change the
“environment” of a program which uses them.  The shell variables which
are accessed by programs are therefore known as “environment
variables”(2).  You can see the full list of exported variables that
your shell recognizes by running:

     $ printenv

   ‘HOME’ is one commonly used environment variable, it is any user’s
(the one that is logged in) top directory.  Try finding it in the
command above.  It is used so often that the shell has a special
expansion (alternative) for it: ‘‘~’’.  Whenever you see file names
starting with the tilde sign, it actually represents the value to the
‘HOME’ environment variable, so ‘~/doc’ is the same as ‘$HOME/doc’.

   Another one of the most commonly used environment variables is
‘PATH’, it is a list of directories to search for executable names.  Its
value is a list of directories (separated by a colon, or ‘<:>’).  When
the address of the executable is not explicitly given (like
‘./configure’ above), the system will look for the executable in the
directories specified by ‘PATH’.  If you have a computer nearby, try
running the following command to see which directories your system will
look into when it is searching for executable (binary) files, one
example is printed here (notice how ‘/usr/bin’, in the ‘ls’ example
above, is one of the directories in ‘PATH’):

     $ echo $PATH
     /usr/local/sbin:/usr/local/bin:/usr/bin

   By default ‘PATH’ usually contains system-wide directories, which are
readable (but not writable) by all users, like the above example.
Therefore if you don’t have root (or administrator) access, you need to
add another directory to ‘PATH’ which you actually have write access to.
The standard directory where you can keep installed files (not just
executables) for your own user is the ‘~/.local/’ directory.  The names
of hidden files start with a ‘<.>’ (dot), so it will not show up in your
common command-line listings, or on the graphical user interface.  You
can use any other directory, but this is the most recognized.

   The top installation directory will be used to keep all the package’s
components: programs (executables), libraries, include (header) files,
shared data (like manuals), or configuration files (see *note Review of
library fundamentals:: for a thorough introduction to headers and
linking).  So it commonly has some of the following sub-directories for
each class of installed components respectively: ‘bin/’, ‘lib/’,
‘include/’ ‘man/’, ‘share/’, ‘etc/’.  Since the ‘PATH’ variable is only
used for executables, you can add the ‘~/.local/bin’ directory (which
keeps the executables/programs or more generally, “binary” files) to
‘PATH’ with the following command.  As defined below, first the existing
value of ‘PATH’ is used, then your given directory is added to its end
and the combined value is put back in ‘PATH’ (run ‘‘$ echo $PATH’’
afterwards to check if it was added).

     $ PATH=$PATH:~/.local/bin

   Any executable that you installed in ‘~/.local/bin’ will now be
usable without having to remember and write its full address.  However,
as soon as you leave/close your current terminal session, this modified
‘PATH’ variable will be forgotten.  Adding the directories which contain
executables to the ‘PATH’ environment variable each time you start a
terminal is also very inconvenient and prone to errors.  Fortunately,
there are standard ‘startup files’ defined by your shell precisely for
this (and other) purposes.  There is a special startup file for every
significant starting step:

‘/etc/profile’ and everything in ‘/etc/profile.d/’
     These startup scripts are called when your whole system starts (for
     example after you turn on your computer).  Therefore you need
     administrator or root privileges to access or modify them.

‘~/.bash_profile’
     If you are using (GNU) Bash as your shell, the commands in this
     file are run, when you log in to your account _through Bash_.  Most
     commonly when you login through the virtual console (where there is
     no graphic user interface).

‘~/.bashrc’
     If you are using (GNU) Bash as your shell, the commands here will
     be run each time you start a terminal and are already logged in.
     For example, when you open your terminal emulator in the graphic
     user interface.

   For security reasons, it is highly recommended to directly type in
your ‘HOME’ directory value by hand in startup files instead of using
variables.  So in the following, let’s assume your user name is ‘‘name’’
(so ‘~’ may be replaced with ‘/home/name’).  To add ‘~/.local/bin’ to
your ‘PATH’ automatically on any startup file, you have to “export” the
new value of ‘PATH’ in the startup file that is most relevant to you by
adding this line:

     export PATH=$PATH:/home/name/.local/bin

   Now that you know your system will look into ‘~/.local/bin’ for
executables, you can tell Gnuastro’s configure script to install
everything in the top ‘~/.local’ directory using the ‘--prefix’ option.
When you subsequently run ‘$ make install’, all the install-able files
will be put in their respective directory under ‘~/.local/’ (the
executables in ‘~/.local/bin’, the compiled library files in
‘~/.local/lib’, the library header files in ‘~/.local/include’ and so
on, to learn more about these different files, please see *note Review
of library fundamentals::).  Note that tilde (‘<~>’) expansion will not
happen if you put a ‘<=>’ between ‘--prefix’ and ‘~/.local’(3), so we
have avoided the <=> character here which is optional in GNU-style
options, see *note Options::.

     $ ./configure --prefix ~/.local

   You can install everything (including libraries like GSL, CFITSIO, or
WCSLIB which are Gnuastro’s mandatory dependencies, see *note Mandatory
dependencies::) locally by configuring them as above.  However, recall
that ‘PATH’ is only for executable files, not libraries and that
libraries can also depend on other libraries.  For example WCSLIB
depends on CFITSIO and Gnuastro needs both.  Therefore, when you
installed a library in a non-recognized directory, you have to guide the
program that depends on them to look into the necessary library and
header file directories.  To do that, you have to define the ‘LDFLAGS’
and ‘CPPFLAGS’ environment variables respectively.  This can be done
while calling ‘./configure’ as shown below:

     $ ./configure LDFLAGS=-L/home/name/.local/lib            \
                   CPPFLAGS=-I/home/name/.local/include       \
                   --prefix ~/.local

   It can be annoying/buggy to do this when configuring every software
that depends on such libraries.  Hence, you can define these two
variables in the most relevant startup file (discussed above).  The
convention on using these variables doesn’t include a colon to separate
values (as ‘PATH’-like variables do), they use white space characters
and each value is prefixed with a compiler option(4): note the ‘-L’ and
‘-I’ above (see *note Options::), for ‘-I’ see *note Headers::, and for
‘-L’, see *note Linking::.  Therefore we have to keep the value in
double quotation signs to keep the white space characters and adding the
following two lines to the startup file of choice:

     export LDFLAGS="$LDFLAGS -L/home/name/.local/lib"
     export CPPFLAGS="$CPPFLAGS -I/home/name/.local/include"

   Dynamic libraries are linked to the executable every time you run a
program that depends on them (see *note Linking:: to fully understand
this important concept).  Hence dynamic libraries also require a special
path variable called ‘LD_LIBRARY_PATH’ (same formatting as ‘PATH’).  To
use programs that depend on these libraries, you need to add
‘~/.local/lib’ to your ‘LD_LIBRARY_PATH’ environment variable by adding
the following line to the relevant start-up file:

     export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/name/.local/lib

   If you also want to access the Info (see *note Info::) and man pages
(see *note Man pages::) documentations add ‘~/.local/share/info’ and
‘~/.local/share/man’ to your ‘INFOPATH’(5) and ‘MANPATH’ environment
variables respectively.

   A final note is that order matters in the directories that are
searched for all the variables discussed above.  In the examples above,
the new directory was added after the system specified directories.  So
if the program, library or manuals are found in the system wide
directories, the user directory is no longer searched.  If you want to
search your local installation first, put the new directory before the
already existing list, like the example below.

     export LD_LIBRARY_PATH=/home/name/.local/lib:$LD_LIBRARY_PATH

This is good when a library, for example CFITSIO, is already present on
the system, but the system-wide install wasn’t configured with the
correct configuration flags (see *note CFITSIO::), or you want to use a
newer version and you don’t have administrator or root access to update
it on the whole system/server.  If you update ‘LD_LIBRARY_PATH’ by
placing ‘~/.local/lib’ first (like above), the linker will first find
the CFITSIO you installed for yourself and link with it.  It thus will
never reach the system-wide installation.

   There are important security problems with using local installations
first: all important system-wide executables and libraries (important
executables like ‘ls’ and ‘cp’, or libraries like the C library) can be
replaced by non-secure versions with the same file names and put in the
customized directory (‘~/.local’ in this example).  So if you choose to
search in your customized directory first, please _be sure_ to keep it
clean from executables or libraries with the same names as important
system programs or libraries.

*Summary:* When you are using a server which doesn’t give you
administrator/root access AND you would like to give priority to your
own built programs and libraries, not the version that is (possibly
already) present on the server, add these lines to your startup file.
See above for which startup file is best for your case and for a
detailed explanation on each.  Don’t forget to replace
‘‘/YOUR-HOME-DIR’’ with your home directory (for example
‘‘/home/your-id’’):

     export PATH="/YOUR-HOME-DIR/.local/bin:$PATH"
     export LDFLAGS="-L/YOUR-HOME-DIR/.local/lib $LDFLAGS"
     export MANPATH="/YOUR-HOME-DIR/.local/share/man/:$MANPATH"
     export CPPFLAGS="-I/YOUR-HOME-DIR/.local/include $CPPFLAGS"
     export INFOPATH="/YOUR-HOME-DIR/.local/share/info/:$INFOPATH"
     export LD_LIBRARY_PATH="/YOUR-HOME-DIR/.local/lib:$LD_LIBRARY_PATH"

Afterwards, you just need to add an extra
‘--prefix=/YOUR-HOME-DIR/.local’ to the ‘./configure’ command of the
software that you intend to install.  Everything else will be the same
as a standard build and install, see *note Quick start::.

   ---------- Footnotes ----------

   (1) By running ‘$ export myvariable=a_test_value’ instead of the
simpler case in the text

   (2) You can use shell variables for other actions too, for example to
temporarily keep some names or run loops on some files.

   (3) If you insist on using ‘<=>’, you can use
‘--prefix=$HOME/.local’.

   (4) These variables are ultimately used as options while building the
programs, so every value has be an option name followed be a value as
discussed in *note Options::.

   (5) Info has the following convention: “If the value of ‘INFOPATH’
ends with a colon [or it isn’t defined] ..., the initial list of
directories is constructed by appending the build-time default to the
value of ‘INFOPATH’.” So when installing in a non-standard directory and
if ‘INFOPATH’ was not initially defined, add a colon to the end of
‘INFOPATH’ as shown below, otherwise Info will not be able to find
system-wide installed documentation:
‘echo 'export INFOPATH=$INFOPATH:/home/name/.local/share/info:' >>
~/.bashrc’
Note that this is only an internal convention of Info, do not use it for
other ‘*PATH’ variables.


File: gnuastro.info,  Node: Executable names,  Next: Configure and build in RAM,  Prev: Installation directory,  Up: Configuring

3.3.1.3 Executable names
........................

At first sight, the names of the executables for each program might seem
to be uncommonly long, for example ‘astnoisechisel’ or ‘astcrop’.  We
could have chosen terse (and cryptic) names like most programs do.  We
chose this complete naming convention (something like the commands in
TeX) so you don’t have to spend too much time remembering what the name
of a specific program was.  Such complete names also enable you to
easily search for the programs.

   To facilitate typing the names in, we suggest using the shell
auto-complete.  With this facility you can find the executable you want
very easily.  It is very similar to file name completion in the shell.
For example, simply by typing the letters below (where <[TAB]> stands
for the Tab key on your keyboard)

     $ ast[TAB][TAB]

you will get the list of all the available executables that start with
‘ast’ in your ‘PATH’ environment variable directories.  So, all the
Gnuastro executables installed on your system will be listed.  Typing
the next letter for the specific program you want along with a Tab, will
limit this list until you get to your desired program.

   In case all of this does not convince you and you still want to type
short names, some suggestions are given below.  You should have in mind
though, that if you are writing a shell script that you might want to
pass on to others, it is best to use the standard name because other
users might not have adopted the same customization.  The long names
also serve as a form of documentation in such scripts.  A similar
reasoning can be given for option names in scripts: it is good practice
to always use the long formats of the options in shell scripts, see
*note Options::.

   The simplest solution is making a symbolic link to the actual
executable.  For example let’s assume you want to type ‘ic’ to run Crop
instead of ‘astcrop’.  Assuming you installed Gnuastro executables in
‘/usr/local/bin’ (default) you can do this simply by running the
following command as root:

     # ln -s /usr/local/bin/astcrop /usr/local/bin/ic

In case you update Gnuastro and a new version of Crop is installed, the
default executable name is the same, so your custom symbolic link still
works.

   The installed executable names can also be set using options to ‘$
./configure’, see *note Configuring::.  GNU Autoconf (which configures
Gnuastro for your particular system), allows the builder to change the
name of programs with the three options ‘--program-prefix’,
‘--program-suffix’ and ‘--program-transform-name’.  The first two are
for adding a fixed prefix or suffix to all the programs that will be
installed.  This will actually make all the names longer!  You can use
it to add versions of program names to the programs in order to
simultaneously have two executable versions of a program.

   The third configure option allows you to set the executable name at
install time using the SED program.  SED is a very useful ‘stream
editor’.  There are various resources on the internet to use it
effectively.  However, we should caution that using configure options
will change the actual executable name of the installed program and on
every re-install (an update for example), you have to also add this
option to keep the old executable name updated.  Also note that the
documentation or configuration files do not change from their standard
names either.

   For example, let’s assume that typing ‘ast’ on every invocation of
every program is really annoying you!  You can remove this prefix from
all the executables at configure time by adding this option:

     $ ./configure --program-transform-name='s/ast/ /'


File: gnuastro.info,  Node: Configure and build in RAM,  Prev: Executable names,  Up: Configuring

3.3.1.4 Configure and build in RAM
..................................

Gnuastro’s configure and build process (the GNU build system) involves
the creation, reading, and modification of a large number of files
(input/output, or I/O). Therefore file I/O issues can directly affect
the work of developers who need to configure and build Gnuastro numerous
times.  Some of these issues are listed below:

   • I/O will cause wear and tear on both the HDDs (mechanical failures)
     and SSDs (decreasing the lifetime).

   • Having the built files mixed with the source files can greatly
     affect backing up (synchronization) of source files (since it
     involves the management of a large number of small files that are
     regularly changed.  Backup software can of course be configured to
     ignore the built files and directories.  However, since the built
     files are mixed with the source files and can have a large variety,
     this will require a high level of customization.

   One solution to address both these problems is to use the tmpfs file
system (https://en.wikipedia.org/wiki/Tmpfs).  Any file in tmpfs is
actually stored in the RAM (and possibly SAWP), not on HDDs or SSDs.
The RAM is built for extensive and fast I/O. Therefore the large number
of file I/Os associated with configuring and building will not harm the
HDDs or SSDs.  Due to the volatile nature of RAM, files in the tmpfs
file-system will be permanently lost after a power-off.  Since all
configured and built files are derivative files (not files that have
been directly written by hand) there is no problem in this and this
feature can be considered as an automatic cleanup.

   The modern GNU C library (and thus the Linux kernel) defines the
‘/dev/shm’ directory for this purpose in the RAM (POSIX shared memory).
To build in it, you can use the GNU build system’s ability to build in a
separate directory (not necessarily in the source directory) as shown
below.  Just set ‘SRCDIR’ as the address of Gnuastro’s top source
directory (for example, the unpacked tarball).

     $ mkdir /dev/shm/tmp-gnuastro-build
     $ cd /dev/shm/tmp-gnuastro-build
     $ SRCDIR/configure --srcdir=SRCDIR
     $ make

   Gnuastro comes with a script to simplify this process of configuring
and building in a different directory (a “clean” build), for more see
*note Separate build and source directories::.


File: gnuastro.info,  Node: Separate build and source directories,  Next: Tests,  Prev: Configuring,  Up: Build and install

3.3.2 Separate build and source directories
-------------------------------------------

The simple steps of *note Quick start:: will mix the source and built
files.  This can cause inconvenience for developers or enthusiasts
following the the most recent work (see *note Version controlled
source::).  The current section is mainly focused on this later group of
Gnuastro users.  If you just install Gnuastro on major releases
(following *note Announcements::), you can safely ignore this section.

   When it is necessary to keep the source (which is under version
control), but not the derivative (built) files (after checking or
installing), the best solution is to keep the source and the built files
in separate directories.  One application of this is already discussed
in *note Configure and build in RAM::.

   To facilitate this process of configuring and building in a separate
directory, Gnuastro comes with the ‘developer-build’ script.  It is
available in the top source directory and is _not_ installed.  It will
make a directory under a given top-level directory (given to
‘--top-build-dir’) and build Gnuastro in there directory.  It thus keeps
the source completely separated from the built files.  For easy access
to the built files, it also makes a symbolic link to the built directory
in the top source files called ‘build’.

   When run without any options, default values will be used for its
configuration.  As with Gnuastro’s programs, you can inspect the default
values with ‘-P’ (or ‘--printparams’, the output just looks a little
different here).  The default top-level build directory is ‘/dev/shm’:
the shared memory directory in RAM on GNU/Linux systems as described in
*note Configure and build in RAM::.

   Besides these, it also has some features to facilitate the job of
developers or bleeding edge users like the ‘--debug’ option to do a fast
build, with debug information, no optimization, and no shared libraries.
Here is the full list of options you can feed to this script to
configure its operations.

*Not all Gnuastro’s common program behavior usable here:*
‘developer-build’ is just a non-installed script with a very limited
scope as described above.  It thus doesn’t have all the common option
behaviors or configuration files for example.

*White space between option and value:* ‘developer-build’ doesn’t accept
an <=> sign between the options and their values.  It also needs at
least one character between the option and its value.  Therefore ‘-n 4’
or ‘--numthreads 4’ are acceptable, while ‘-n4’, ‘-n=4’, or
‘--numthreads=4’ aren’t.  Finally multiple short option names cannot be
merged: for example you can say ‘-c -n 4’, but unlike Gnuastro’s
programs, ‘-cn4’ is not acceptable.

*Reusable for other packages:* This script can be used in any software
which is configured and built using the GNU Build System.  Just copy it
in the top source directory of that software and run it from there.

‘-b STR’
‘--top-build-dir STR’
     The top build directory to make a directory for the build.  If this
     option isn’t called, the top build directory is ‘/dev/shm’ (only
     available in GNU/Linux operating systems, see *note Configure and
     build in RAM::).

‘-V’
‘--version’
     Print the version string of Gnuastro that will be used in the
     build.  This string will be appended to the directory name
     containing the built files.

‘-a’
‘--autoreconf’
     Run ‘autoreconf -f’ before building the package.  In Gnuastro, this
     is necessary when a new commit has been made to the project
     history.  In Gnuastro’s build system, the Git description will be
     used as the version, see *note Version numbering:: and *note
     Synchronizing::.

‘-c’
‘--clean’
     Delete the contents of the build directory (clean it) before
     starting the configuration and building of this run.

     This is useful when you have recently pulled changes from the main
     Git repository, or committed a change your self and ran ‘autoreconf
     -f’, see *note Synchronizing::.  After running GNU Autoconf, the
     version will be updated and you need to do a clean build.

‘-d’
‘--debug’
     Build with debugging flags (for example to use in GNU Debugger,
     also known as GDB, or Valgrind), disable optimization and also the
     building of shared libraries.  Similar to running the configure
     script of below

          $ ./configure --enable-debug

     Besides all the debugging advantages of building with this option,
     it will also be significantly speed up the build (at the cost of
     slower built programs).  So when you are testing something small or
     working on the build system itself, it will be much faster to test
     your work with this option.

‘-v’
‘--valgrind’
     Build all ‘make check’ tests within Valgrind.  For more, see the
     description of ‘--enable-check-with-valgrind’ in *note Gnuastro
     configure options::.

‘-j INT’
‘--jobs INT’
     The maximum number of threads/jobs for Make to build at any moment.
     As the name suggests (Make has an identical option), the number
     given to this option is directly passed on to any call of Make with
     its ‘-j’ option.

‘-C’
‘--check’
     After finishing the build, also run ‘make check’.  By default,
     ‘make check’ isn’t run because the developer usually has their own
     checks to work on (for example defined in ‘tests/during-dev.sh’).

‘-i’
‘--install’
     After finishing the build, also run ‘make install’.

‘-D’
‘--dist’
     Run ‘make dist-lzip pdf’ to build a distribution tarball (in
     ‘.tar.lz’ format) and a PDF manual.  This can be useful for
     archiving, or sending to colleagues who don’t use Git for an easy
     build and manual.

‘-u STR’
‘--upload STR’
     Activate the ‘--dist’ (‘-D’) option, then use secure copy (‘scp’,
     part of the SSH tools) to copy the tarball and PDF to the ‘src’ and
     ‘pdf’ sub-directories of the specified server and its directory
     (value to this option).  For example ‘--upload my-server:dir’, will
     copy the tarball in the ‘dir/src’, and the PDF manual in ‘dir/pdf’
     of ‘my-server’ server.  It will then make a symbolic link in the
     top server directory to the tarball that is called
     ‘gnuastro-latest.tar.lz’.

‘-p’
‘--publish’
     Short for ‘--autoreconf --clean --debug --check --upload STR’.
     ‘--debug’ is added because it will greatly speed up the build.  It
     will have no effect on the produced tarball.  This is good when you
     have made a commit and are ready to publish it on your server (if
     nothing crashes).  Recall that if any of the previous steps fail
     the script aborts.

‘-I’
‘--install-archive’
     Short for ‘--autoreconf --clean --check --install --dist’.  This is
     useful when you actually want to install the commit you just made
     (if the build and checks succeed).  It will also produce a
     distribution tarball and PDF manual for easy access to the
     installed tarball on your system at a later time.

     Ideally, Gnuastro’s Git version history makes it easy for a
     prepared system to revert back to a different point in history.
     But Gnuastro also needs to bootstrap files and also your
     collaborators might (usually do!)  find it too much of a burden to
     do the bootstrapping themselves.  So it is convenient to have a
     tarball and PDF manual of the version you have installed (and are
     using in your research) handily available.

‘-h’
‘--help’
‘-P’
‘--printparams’
     Print a description of this script along with all the options and
     their current values.


File: gnuastro.info,  Node: Tests,  Next: A4 print book,  Prev: Separate build and source directories,  Up: Build and install

3.3.3 Tests
-----------

After successfully building (compiling) the programs with the ‘$ make’
command you can check the installation before installing.  To run the
tests, run

     $ make check

   For every program some tests are designed to check some possible
operations.  Running the command above will run those tests and give you
a final report.  If everything is OK and you have built all the
programs, all the tests should pass.  In case any of the tests fail,
please have a look at *note Known issues:: and if that still doesn’t fix
your problem, look that the ‘./tests/test-suite.log’ file to see if the
source of the error is something particular to your system or more
general.  If you feel it is general, please contact us because it might
be a bug.  Note that the tests of some programs depend on the outputs of
other program’s tests, so if you have not installed them they might be
skipped or fail.  Prior to releasing every distribution all these tests
are checked.  If you have a reasonably modern terminal, the outputs of
the successful tests will be colored green and the failed ones will be
colored red.

   These scripts can also act as a good set of examples for you to see
how the programs are run.  All the tests are in the ‘tests/’ directory.
The tests for each program are shell scripts (ending with ‘.sh’) in a
sub-directory of this directory with the same name as the program.  See
*note Test scripts:: for more detailed information about these scripts
in case you want to inspect them.


File: gnuastro.info,  Node: A4 print book,  Next: Known issues,  Prev: Tests,  Up: Build and install

3.3.4 A4 print book
-------------------

The default print version of this book is provided in the letter paper
size.  If you would like to have the print version of this book on paper
and you are living in a country which uses A4, then you can rebuild the
book.  The great thing about the GNU build system is that the book
source code which is in Texinfo is also distributed with the program
source code, enabling you to do such customization (hacking).

   In order to change the paper size, you will need to have GNU Texinfo
installed.  Open ‘doc/gnuastro.texi’ with any text editor.  This is the
source file that created this book.  In the first few lines you will see
this line:

     @c@afourpaper

In Texinfo, a line is commented with ‘@c’.  Therefore, un-comment this
line by deleting the first two characters such that it changes to:

     @afourpaper

Save the file and close it.  You can now run the following command

     $ make pdf

and the new PDF book will be available in ‘SRCdir/doc/gnuastro.pdf’.  By
changing the ‘pdf’ in ‘$ make pdf’ to ‘ps’ or ‘dvi’ you can have the
book in those formats.  Note that you can do this for any book that is
in Texinfo format, they might not have ‘@afourpaper’ line, so you can
add it close to the top of the Texinfo source file.


File: gnuastro.info,  Node: Known issues,  Prev: A4 print book,  Up: Build and install

3.3.5 Known issues
------------------

Depending on your operating system and the version of the compiler you
are using, you might confront some known problems during the
configuration (‘$ ./configure’), compilation (‘$ make’) and tests (‘$
make check’).  Here, their solutions are discussed.

   • ‘$ ./configure’: _Configure complains about not finding a library
     even though you have installed it._  The possible solution is based
     on how you installed the package:

        • From your distribution’s package manager.  Most probably this
          is because your distribution has separated the header files of
          a library from the library parts.  Please also install the
          ‘development’ packages for those libraries too.  Just add a
          ‘-dev’ or ‘-devel’ to the end of the package name and re-run
          the package manager.  This will not happen if you install the
          libraries from source.  When installed from source, the
          headers are also installed.

        • From source.  Then your linker is not looking where you
          installed the library.  If you followed the instructions in
          this chapter, all the libraries will be installed in
          ‘/usr/local/lib’.  So you have to tell your linker to look in
          this directory.  To do so, configure Gnuastro like this:

               $ ./configure LDFLAGS="-L/usr/local/lib"

          If you want to use the libraries for your other programming
          projects, then export this environment variable in a start-up
          script similar to the case for ‘LD_LIBRARY_PATH’ explained
          below, also see *note Installation directory::.

   • ‘$ make’: _Complains about an unknown function on a non-GNU based
     operating system._  In this case, please run ‘$ ./configure’ with
     the ‘--enable-gnulibcheck’ option to see if the problem is from the
     GNU Portability Library (Gnulib) not supporting your system or if
     there is a problem in Gnuastro, see *note Gnuastro configure
     options::.  If the problem is not in Gnulib and after all its tests
     you get the same complaint from ‘make’, then please contact us at
     ‘bug-gnuastro@gnu.org’.  The cause is probably that a function that
     we have used is not supported by your operating system and we
     didn’t included it along with the source tar ball.  If the function
     is available in Gnulib, it can be fixed immediately.

   • ‘$ make’: _Can’t find the headers (.h files) of installed
     libraries._  Your C pre-processor (CPP) isn’t looking in the right
     place.  To fix this, configure Gnuastro with an additional
     ‘CPPFLAGS’ like below (assuming the library is installed in
     ‘/usr/local/include’:

          $ ./configure CPPFLAGS="-I/usr/local/include"

     If you want to use the libraries for your other programming
     projects, then export this environment variable in a start-up
     script similar to the case for ‘LD_LIBRARY_PATH’ explained below,
     also see *note Installation directory::.

   • ‘$ make check’: _Only the first couple of tests pass, all the rest
     fail or get skipped._  It is highly likely that when searching for
     shared libraries, your system doesn’t look into the
     ‘/usr/local/lib’ directory (or wherever you installed Gnuastro or
     its dependencies).  To make sure it is added to the list of
     directories, add the following line to your ‘~/.bashrc’ file and
     restart your terminal.  Don’t forget to change ‘/usr/local/lib’ if
     the libraries are installed in other (non-standard) directories.

          export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:/usr/local/lib"

     You can also add more directories by using a colon ‘‘:’’ to
     separate them.  See *note Installation directory:: and *note
     Linking:: to learn more on the ‘PATH’ variables and dynamic linking
     respectively.

   • ‘$ make check’: _The tests relying on external programs (for
     example ‘fitstopdf.sh’ fail._)  This is probably due to the fact
     that the version number of the external programs is too old for the
     tests we have preformed.  Please update the program to a more
     recent version.  For example to create a PDF image, you will need
     GPL Ghostscript, but older versions do not work, we have
     successfully tested it on version 9.15.  Older versions might cause
     a failure in the test result.

   • ‘$ make pdf’: _The PDF book cannot be made._  To make a PDF book,
     you need to have the GNU Texinfo program (like any program, the
     more recent the better).  A working TeX program is also necessary,
     which you can get from Tex Live(1).

   • After ‘make check’: do not copy the programs’ executables to
     another (for example, the installation) directory manually (using
     ‘cp’, or ‘mv’ for example).  In the default configuration(2), the
     program binaries need to link with Gnuastro’s shared library which
     is also built and installed with the programs.  Therefore, to run
     successfully before and after installation, linking modifications
     need to be made by GNU Libtool at installation time.  ‘make
     install’ does this internally, but a simple copy might give linking
     errors when you run it.  If you need to copy the executables, you
     can do so after installation.

If your problem was not listed above, please file a bug report (*note
Report a bug::).

   ---------- Footnotes ----------

   (1) <https://www.tug.org/texlive/>

   (2) If you configure Gnuastro with the ‘--disable-shared’ option,
then the libraries will be statically linked to the programs and this
problem won’t exist, see *note Linking::.


File: gnuastro.info,  Node: Common program behavior,  Next: Data containers,  Prev: Installation,  Up: Top

4 Common program behavior
*************************

All the programs in Gnuastro share a set of common behavior mainly to do
with user interaction to facilitate their usage and development.  This
includes how to feed input datasets into the programs, how to configure
them, specifying the outputs, numerical data types, treating columns of
information in tables, etc.  This chapter is devoted to describing this
common behavior in all programs.  Because the behaviors discussed here
are common to several programs, they are not repeated in each program’s
description.

   In *note Command-line::, a very general description of running the
programs on the command-line is discussed, like difference between
arguments and options, as well as options that are common/shared between
all programs.  None of Gnuastro’s programs keep any internal
configuration value (values for their different operational steps), they
read their configuration primarily from the command-line, then from
specific files in directory, user, or system-wide settings.  Using these
configuration files can greatly help reproducible and robust usage of
Gnuastro, see *note Configuration files:: for more.

   It is not possible to always have the different options and
configurations of each program on the top of your head.  It is very
natural to forget the options of a program, their current default
values, or how it should be run and what it did.  Gnuastro’s programs
have multiple ways to help you refresh your memory in multiple levels
(just an option name, a short description, or fast access to the
relevant section of the manual.  See *note Getting help:: for more for
more on benefiting from this very convenient feature.

   Many of the programs use the multi-threaded character of modern CPUs,
in *note Multi-threaded operations:: we’ll discuss how you can configure
this behavior, along with some tips on making best use of them.  In
*note Numeric data types::, we’ll review the various types to store
numbers in your datasets: setting the proper type for the usage
context(1) can greatly improve the file size and also speed of reading,
writing or processing them.

   We’ll then look into the recognized table formats in *note Tables::
and how large datasets are broken into tiles, or mesh grid in *note
Tessellation::.  Finally, we’ll take a look at the behavior regarding
output files: *note Automatic output:: describes how the programs set a
default name for their output when you don’t give one explicitly (using
‘--output’).  When the output is a FITS file, all the programs also
store some very useful information in the header that is discussed in
*note Output FITS files::.

* Menu:

* Command-line::                How to use the command-line.
* Configuration files::         Values for unspecified variables.
* Getting help::                Getting more information on the go.
* Installed scripts::           Installed Bash scripts, not compiled programs.
* Multi-threaded operations::   How threads are managed in Gnuastro.
* Numeric data types::          Different types and how to specify them.
* Tables::                      Recognized table formats.
* Tessellation::                Tile the dataset into non-overlapping bins.
* Automatic output::            About automatic output names.
* Output FITS files::           Common properties when outputs are FITS.

   ---------- Footnotes ----------

   (1) For example if the values in your dataset can only be integers
between 0 or 65000, store them in a unsigned 16-bit type, not 64-bit
floating point type (which is the default in most systems).  It takes
four times less space and is much faster to process.


File: gnuastro.info,  Node: Command-line,  Next: Configuration files,  Prev: Common program behavior,  Up: Common program behavior

4.1 Command-line
================

Gnuastro’s programs are customized through the standard Unix-like
command-line environment and GNU style command-line options.  Both are
very common in many Unix-like operating system programs.  In *note
Arguments and options:: we’ll start with the difference between
arguments and options and elaborate on the GNU style of options.
Afterwards, in *note Common options::, we’ll go into the detailed list
of all the options that are common to all the programs in Gnuastro.

* Menu:

* Arguments and options::       Different ways to specify inputs and configuration.
* Common options::              Options that are shared between all programs.
* Standard input::              Using output of another program as input.


File: gnuastro.info,  Node: Arguments and options,  Next: Common options,  Prev: Command-line,  Up: Command-line

4.1.1 Arguments and options
---------------------------

When you type a command on the command-line, it is passed onto the shell
(a generic name for the program that manages the command-line) as a
string of characters.  As an example, see the “Invoking ProgramName”
sections in this manual for some examples of commands with each program,
like *note Invoking asttable::, *note Invoking astfits::, or *note
Invoking aststatistics::.

   The shell then brakes up your string into separate _tokens_ or
_words_ using any _metacharacters_ (like white-space, tab, ‘|’, ‘>’ or
‘;’) that are in the string.  On the command-line, the first thing you
usually enter is the name of the program you want to run.  After that,
you can specify two types of tokens: _arguments_ and _options_.  In the
GNU-style, arguments are those tokens that are not preceded by any
hyphens (‘-’, see *note Arguments::).  Here is one example:

     $ astcrop --center=53.162551,-27.789676 -w10/3600 --mode=wcs udf.fits

   In the example above, we are running *note Crop:: to crop a region of
width 10 arc-seconds centered at the given RA and Dec from the input
Hubble Ultra-Deep Field (UDF) FITS image.  Here, the argument is
‘udf.fits’.  Arguments are most commonly the input file names containing
your data.  Options start with one or two hyphens, followed by an
identifier for the option (the option’s name, for example, ‘--center’,
‘-w’, ‘--mode’ in the example above) and its value (anything after the
option name, or the optional <=> character).  Through options you can
configure how the program runs (interprets the data you provided).

   Arguments can be mandatory and optional and unlike options, they
don’t have any identifiers.  Hence, when there multiple arguments, their
order might also matter (for example in ‘cp’ which is used for copying
one file to another location).  The outputs of ‘--usage’ and ‘--help’
shows which arguments are optional and which are mandatory, see *note
--usage::.

   As their name suggests, _options_ can be considered to be optional
and most of the time, you don’t have to worry about what order you
specify them in.  When the order does matter, or the option can be
invoked multiple times, it is explicitly mentioned in the “Invoking
ProgramName” section of each program (this is a very important aspect of
an option).

   If there is only one such character, you can use a backslash (‘\’)
before it.  If there are multiple, it might be easier to simply put your
whole argument or option value inside of double quotes (‘"’).  In such
cases, everything inside the double quotes will be seen as one token or
word.

   For example, let’s say you want to specify the header data unit (HDU)
of your FITS file using a complex expression like ‘‘3; images(exposure >
100)’’.  If you simply add these after the ‘--hdu’ (‘-h’) option, the
programs in Gnuastro will read the value to the HDU option as ‘‘3’’ and
run.  Then, the shell will attempt to run a separate command
‘‘images(exposure > 100)’’ and complain about a syntax error.  This is
because the semicolon (‘;’) is an ‘end of command’ character in the
shell.  To solve this problem you can simply put double quotes around
the whole string you want to pass to ‘--hdu’ as seen below:
     $ astcrop --hdu="3; images(exposure > 100)" image.fits

* Menu:

* Arguments::                   For specifying the main input files/operations.
* Options::                     For configuring the behavior of the program.


File: gnuastro.info,  Node: Arguments,  Next: Options,  Prev: Arguments and options,  Up: Arguments and options

4.1.1.1 Arguments
.................

In Gnuastro, arguments are almost exclusively used as the input data
file names.  Please consult the first few paragraph of the “Invoking
ProgramName” section for each program for a description of what it
expects as input, how many arguments, or input data, it accepts, or in
what order.  Everything particular about how a program treats arguments,
is explained under the “Invoking ProgramName” section for that program.

   Generally, if there is a standard file name extension for a
particular format, that filename extension is used to separate the kinds
of arguments.  The list below shows the data formats that are recognized
in Gnuastro’s programs based on their file name endings.  Any argument
that doesn’t end with the specified extensions below is considered to be
a text file (usually catalogs, see *note Tables::).  In some cases, a
program can accept specific formats, for example *note ConvertType::
also accepts ‘.jpg’ images.

   • ‘.fits’: The standard file name ending of a FITS image.

   • ‘.fit’: Alternative (3 character) FITS suffix.

   • ‘.fits.Z’: A FITS image compressed with ‘compress’.

   • ‘.fits.gz’: A FITS image compressed with GNU zip (gzip).

   • ‘.fits.fz’: A FITS image compressed with ‘fpack’.

   • ‘.imh’: IRAF format image file.

   Through out this book and in the command-line outputs, whenever we
want to generalize all such astronomical data formats in a text place
holder, we will use ‘ASTRdata’, we will assume that the extension is
also part of this name.  Any file ending with these names is directly
passed on to CFITSIO to read.  Therefore you don’t necessarily have to
have these files on your computer, they can also be located on an FTP or
HTTP server too, see the CFITSIO manual for more information.

   CFITSIO has its own error reporting techniques, if your input file(s)
cannot be opened, or read, those errors will be printed prior to the
final error by Gnuastro.


File: gnuastro.info,  Node: Options,  Prev: Arguments,  Up: Arguments and options

4.1.1.2 Options
...............

Command-line options allow configuring the behavior of a program in all
GNU/Linux applications for each particular execution on a particular
input data.  A single option can be called in two ways: _long_ or
_short_.  All options in Gnuastro accept the long format which has two
hyphens an can have many characters (for example ‘--hdu’).  Short
options only have one hyphen (<->) followed by one character (for
example ‘-h’).  You can see some examples in the list of options in
*note Common options:: or those for each program’s “Invoking
ProgramName” section.  Both formats are shown for those which support
both.  First the short is shown then the long.

   Usually, the short options are for when you are writing on the
command-line and want to save keystrokes and time.  The long options are
good for shell scripts, where you aren’t usually rushing.  Long options
provide a level of documentation, since they are more descriptive and
less cryptic.  Usually after a few months of not running a program, the
short options will be forgotten and reading your previously written
script will not be easy.

   Some options need to be given a value if they are called and some
don’t.  You can think of the latter type of options as on/off options.
These two types of options can be distinguished using the output of the
‘--help’ and ‘--usage’ options, which are common to all GNU software,
see *note Getting help::.  In Gnuastro we use the following strings to
specify when the option needs a value and what format that value should
be in.  More specific tests will be done in the program and if the
values are out of range (for example negative when the program only
wants a positive value), an error will be reported.

‘INT’
     The value is read as an integer.

‘FLT’
     The value is read as a float.  There are generally two types,
     depending on the context.  If they are for fractions, they will
     have to be less than or equal to unity.

‘STR’
     The value is read as a string of characters (for example a file
     name) or other particular settings like a HDU name, see below.

To specify a value in the short format, simply put the value after the
option.  Note that since the short options are only one character long,
you don’t have to type anything between the option and its value.  For
the long option you either need white space or an ‘=’ sign, for example
‘-h2’, ‘-h 2’, ‘--hdu 2’ or ‘--hdu=2’ are all equivalent.

   The short format of on/off options (those that don’t need values) can
be concatenated for example these two hypothetical sequences of options
are equivalent: ‘-a -b -c4’ and ‘-abc4’.  As an example, consider the
following command to run Crop:
     $ astcrop -Dr3 --wwidth 3 catalog.txt --deccol=4 ASTRdata
The ‘$’ is the shell prompt, ‘astcrop’ is the program name.  There are
two arguments (‘catalog.txt’ and ‘ASTRdata’) and four options, two of
them given in short format (‘-D’, ‘-r’) and two in long format
(‘--width’ and ‘--deccol’).  Three of them require a value and one
(‘-D’) is an on/off option.

   If an abbreviation is unique between all the options of a program,
the long option names can be abbreviated.  For example, instead of
typing ‘--printparams’, typing ‘--print’ or maybe even ‘--pri’ will be
enough, if there are conflicts, the program will warn you and show you
the alternatives.  Finally, if you want the argument parser to stop
parsing arguments beyond a certain point, you can use two dashes: ‘--’.
No text on the command-line beyond these two dashes will be parsed.

   Gnuastro has two types of options with values, those that only take a
single value are the most common type.  If these options are repeated or
called more than once on the command-line, the value of the last time it
was called will be assigned to it.  This is very useful when you are
testing/experimenting.  Let’s say you want to make a small modification
to one option value.  You can simply type the option with a new value in
the end of the command and see how the script works.  If you are
satisfied with the change, you can remove the original option for human
readability.  If the change wasn’t satisfactory, you can remove the one
you just added and not worry about forgetting the original value.
Without this capability, you would have to memorize or save the original
value somewhere else, run the command and then change the value again
which is not at all convenient and is potentially cause lots of bugs.

   On the other hand, some options can be called multiple times in one
run of a program and can thus take multiple values (for example see the
‘--column’ option in *note Invoking asttable::.  In these cases, the
order of stored values is the same order that you specified on the
command-line.

   Gnuastro’s programs don’t keep any internal default values, so some
options are mandatory and if they don’t have a value, the program will
complain and abort.  Most programs have many such options and typing
them by hand on every call is impractical.  To facilitate the user
experience, after parsing the command-line, Gnuastro’s programs read
special configuration files to get the necessary values for the options
you haven’t identified on the command-line.  These configuration files
are fully described in *note Configuration files::.

*CAUTION:* In specifying a file address, if you want to use the shell’s
tilde expansion (‘~’) to specify your home directory, leave at least one
space between the option name and your value.  For example use ‘-o
~/test’, ‘--output ~/test’ or ‘--output= ~/test’.  Calling them with
‘-o~/test’ or ‘--output=~/test’ will disable shell expansion.
*CAUTION:* If you forget to specify a value for an option which requires
one, and that option is the last one, Gnuastro will warn you.  But if it
is in the middle of the command, it will take the text of the next
option or argument as the value which can cause undefined behavior.
*NOTE:* In some contexts Gnuastro’s counting starts from 0 and in others
1.  You can assume by default that counting starts from 1, if it starts
from 0 for a special option, it will be explicitly mentioned.


File: gnuastro.info,  Node: Common options,  Next: Standard input,  Prev: Arguments and options,  Up: Command-line

4.1.2 Common options
--------------------

To facilitate the job of the users and developers, all the programs in
Gnuastro share some basic command-line options for the options that are
common to many of the programs.  The full list is classified as *note
Input output options::, *note Processing options::, and *note Operating
mode options::.  In some programs, some of the options are irrelevant,
but still recognized (you won’t get an unrecognized option error, but
the value isn’t used).  Unless otherwise mentioned, these options are
identical between all programs.

* Menu:

* Input output options::        Common input/output options.
* Processing options::          Options for common processing steps.
* Operating mode options::      Common operating mode options.


File: gnuastro.info,  Node: Input output options,  Next: Processing options,  Prev: Common options,  Up: Common options

4.1.2.1 Input/Output options
............................

These options are to do with the input and outputs of the various
programs.

‘--stdintimeout’
     Number of micro-seconds to wait for writing/typing in the _first
     line_ of standard input from the command-line (see *note Standard
     input::).  This is only relevant for programs that also accept
     input from the standard input, _and_ you want to manually
     write/type the contents on the terminal.  When the standard input
     is already connected to a pipe (output of another program), there
     won’t be any waiting (hence no timeout, thus making this option
     redundant).

     If the first line-break (for example with the <ENTER> key) is not
     provided before the timeout, the program will abort with an error
     that no input was given.  Note that this time interval is _only_
     for the first line that you type.  Once the first line is given,
     the program will assume that more data will come and accept rest of
     your inputs without any time limit.  You need to specify the ending
     of the standard input, for example by pressing <CTRL-D> after a new
     line.

     Note that any input you write/type into a program on the
     command-line with Standard input will be discarded (lost) once the
     program is finished.  It is only recoverable manually from your
     command-line (where you actually typed) as long as the terminal is
     open.  So only use this feature when you are sure that you don’t
     need the dataset (or have a copy of it somewhere else).

‘-h STR/INT’
‘--hdu=STR/INT’
     The name or number of the desired Header Data Unit, or HDU, in the
     FITS image.  A FITS file can store multiple HDUs or extensions,
     each with either an image or a table or nothing at all (only a
     header).  Note that counting of the extensions starts from 0(zero),
     not 1(one).  Counting from 0 is forced on us by CFITSIO which
     directly reads the value you give with this option (see *note
     CFITSIO::).  When specifying the name, case is not important so
     ‘IMAGE’, ‘image’ or ‘ImAgE’ are equivalent.

     CFITSIO has many capabilities to help you find the extension you
     want, far beyond the simple extension number and name.  See CFITSIO
     manual’s “HDU Location Specification” section for a very complete
     explanation with several examples.  A ‘#’ is appended to the string
     you specify for the HDU(1) and the result is put in square brackets
     and appended to the FITS file name before calling CFITSIO to read
     the contents of the HDU for all the programs in Gnuastro.

‘-s STR’
‘--searchin=STR’
     Where to match/search for columns when the column identifier wasn’t
     a number, see *note Selecting table columns::.  The acceptable
     values are ‘name’, ‘unit’, or ‘comment’.  This option is only
     relevant for programs that take table columns as input.

‘-I’
‘--ignorecase’
     Ignore case while matching/searching column meta-data (in the field
     specified by the ‘--searchin’).  The FITS standard suggests to
     treat the column names as case insensitive, which is strongly
     recommended here also but is not enforced.  This option is only
     relevant for programs that take table columns as input.

     This option is not relevant to *note BuildProgram::, hence in that
     program the short option ‘-I’ is used for include directories, not
     to ignore case.

‘-o STR’
‘--output=STR’
     The name of the output file or directory.  With this option the
     automatic output names explained in *note Automatic output:: are
     ignored.

‘-T STR’
‘--type=STR’
     The data type of the output depending on the program context.  This
     option isn’t applicable to some programs like *note Fits:: and will
     be ignored by them.  The different acceptable values to this option
     are fully described in *note Numeric data types::.

‘-D’
‘--dontdelete’
     By default, if the output file already exists, Gnuastro’s programs
     will silently delete it and put their own outputs in its place.
     When this option is activated, if the output file already exists,
     the programs will not delete it, will warn you, and will abort.

‘-K’
‘--keepinputdir’
     In automatic output names, don’t remove the directory information
     of the input file names.  As explained in *note Automatic output::,
     if no output name is specified (with ‘--output’), then the output
     name will be made in the existing directory based on your input’s
     file name (ignoring the directory of the input).  If you call this
     option, the directory information of the input will be kept and the
     automatically generated output name will be in the same directory
     as the input (usually with a suffix added).  Note that his is only
     relevant if you are running the program in a different directory
     than the input data.

‘-t STR’
‘--tableformat=STR’
     The output table’s type.  This option is only relevant when the
     output is a table and its format cannot be deduced from its
     filename.  For example, if a name ending in ‘.fits’ was given to
     ‘--output’, then the program knows you want a FITS table.  But
     there are two types of FITS tables: FITS ASCII, and FITS binary.
     Thus, with this option, the program is able to identify which type
     you want.  The currently recognized values to this option are:

     ‘txt’
          A plain text table with white-space characters between the
          columns (see *note Gnuastro text table format::).
     ‘fits-ascii’
          A FITS ASCII table (see *note Recognized table formats::).
     ‘fits-binary’
          A FITS binary table (see *note Recognized table formats::).

   ---------- Footnotes ----------

   (1) With the ‘#’ character, CFITSIO will only read the desired HDU
into your memory, not all the existing HDUs in the fits file.


File: gnuastro.info,  Node: Processing options,  Next: Operating mode options,  Prev: Input output options,  Up: Common options

4.1.2.2 Processing options
..........................

Some processing steps are common to several programs, so they are
defined as common options to all programs.  Note that this class of
common options is thus necessarily less common between all the programs
than those described in *note Input output options::, or *note Operating
mode options:: options.  Also, if they are irrelevant for a program,
these options will not display in the ‘--help’ output of the program.

‘--minmapsize=INT’
     The minimum size (in bytes) to store the contents of each main
     processing array of a program as a file (on the non-volatile
     HDD/SSD), not in RAM. This can be very useful when you have limited
     RAM, but need to process large datasets which can be very memory
     intensive.  In such scenarios, without this option, the program
     will crash.

     A random filename is assigned to the array.  This file will keep
     the contents of the array as long as it is necessary and the
     program will delete it as soon as its not necessary any more.

     If the ‘.gnuastro_mmap’ directory exists and is writable, then the
     random file will be placed in there.  Otherwise, the randomly named
     file will be directly written in the current directory with the
     ‘.gnuastro_mmap_’ prefix.

     By default, the name of the created file, and its size (in bytes)
     is printed by the program when it is created and later, when its
     deleted/freed.  These messages are useful to the user who has
     enough RAM, but has forgot to increase the value to ‘--minmapsize’
     (this is often the case).  To suppress/disable such messages, use
     the ‘--quietmmap’ option.

     When this option has a value of ‘0’ (zero, strongly discouraged,
     see box below), all arrays that use this feature in a program will
     actually be placed in a file (not in RAM). When this option is
     larger than all the input datasets, all arrays will be definitely
     allocated in RAM and the program will run MUCH faster.

     Please note that using a non-volatile file (in the HDD/SDD) instead
     of RAM can significantly increase the program’s running time,
     especially on HDDs (where read/write is slower).  So it is best to
     give this option large values by default.  You can then decrease it
     for a specific program’s invocation on a large input after you see
     memory issues arise (for example an error, or the program not
     aborting and fully consuming your memory).

     The random file will be deleted once it is no longer needed by the
     program.  The ‘.gnuastro’ directory will also be deleted if it has
     no other contents (you may also have configuration files in this
     directory, see *note Configuration files::).  If you see randomly
     named files remaining in this directory when the program finishes
     normally, please send us a bug report so we address the problem,
     see *note Report a bug::.

     *Limited number of memory-mapped files:* The operating system
     kernels usually support a limited number of memory-mapped files.
     Therefore never set ‘--minmapsize’ to zero or a small number of
     bytes (so too many files are created).  If the kernel capacity is
     exceeded, the program will crash.

‘--quietmmap’
     Don’t print any message when an array is stored in non-volatile
     memory (HDD/SSD) and not RAM, see the description of ‘--minmapsize’
     (above) for more.

‘-Z INT[,INT[,...]]’
‘--tilesize=[,INT[,...]]’
     The size of regular tiles for tessellation, see *note
     Tessellation::.  For each dimension an integer length (in units of
     data-elements or pixels) is necessary.  If the number of input
     dimensions is different from the number of values given to this
     option, the program will stop with an error.  Values must be
     separated by commas (<,>) and can also be fractions (for example
     ‘4/2’).  If they are fractions, the result must be an integer,
     otherwise an error will be printed.

‘-M INT[,INT[,...]]’
‘--numchannels=INT[,INT[,...]]’
     The number of channels for larger input tessellation, see *note
     Tessellation::.  The number and types of acceptable values are
     similar to ‘--tilesize’.  The only difference is that instead of
     length, the integers values given to this option represent the
     _number_ of channels, not their size.

‘-F FLT’
‘--remainderfrac=FLT’
     The fraction of remainder size along all dimensions to add to the
     first tile.  See *note Tessellation:: for a complete description.
     This option is only relevant if ‘--tilesize’ is not exactly
     divisible by the input dataset’s size in a dimension.  If the
     remainder size is larger than this fraction (compared to
     ‘--tilesize’), then the remainder size will be added with one
     regular tile size and divided between two tiles at the start and
     end of the given dimension.

‘--workoverch’
     Ignore the channel borders for the high-level job of the given
     application.  As a result, while the channel borders are respected
     in defining the small tiles (such that no tile will cross a channel
     border), the higher-level program operation will ignore them, see
     *note Tessellation::.

‘--checktiles’
     Make a FITS file with the same dimensions as the input but each
     pixel is replaced with the ID of the tile that it is associated
     with.  Note that the tile IDs start from 0.  See *note
     Tessellation:: for more on Tiling an image in Gnuastro.

‘--oneelempertile’
     When showing the tile values (for example with ‘--checktiles’, or
     when the program’s output is tessellated) only use one element for
     each tile.  This can be useful when only the relative values given
     to each tile compared to the rest are important or need to be
     checked.  Since the tiles usually have a large number of pixels
     within them the output will be much smaller, and so easier to read,
     write, store, or send.

     Note that when the full input size in any dimension is not exactly
     divisible by the given ‘--tilesize’ in that dimension, the edge
     tile(s) will have different sizes (in units of the input’s size),
     see ‘--remainderfrac’.  But with this option, all displayed values
     are going to have the (same) size of one data-element.  Hence, in
     such cases, the image proportions are going to be slightly
     different with this option.

     If your input image is not exactly divisible by the tile size and
     you want one value per tile for some higher-level processing, all
     is not lost though.  You can see how many pixels were within each
     tile (for example to weight the values or discard some for later
     processing) with Gnuastro’s Statistics (see *note Statistics::) as
     shown below.  The output FITS file is going to have two extensions,
     one with the median calculated on each tile and one with the number
     of elements that each tile covers.  You can then use the ‘where’
     operator in *note Arithmetic:: to set the values of all tiles that
     don’t have the regular area to a blank value.

          $ aststatistics --median --number --ontile input.fits    \
                          --oneelempertile --output=o.fits
          $ REGULAR_AREA=1600    # Check second extension of `o.fits'.
          $ astarithmetic o.fits o.fits $REGULAR_AREA ne nan where \
                          -h1 -h2

     Note that if ‘input.fits’ also has blank values, then the median on
     tiles with blank values will also be ignored with the command above
     (which is desirable).

‘--inteponlyblank’
     When values are to be interpolated, only change the values of the
     blank elements, keep the non-blank elements untouched.

‘--interpmetric=STR’
     The metric to use for finding nearest neighbors.  Currently it only
     accepts the Manhattan (or taxicab) metric with ‘manhattan’, or the
     radial metric with ‘radial’.

     The Manhattan distance between two points is defined with
     $|\Delta{x}|+|\Delta{y}|$.  Thus the Manhattan metric has the
     advantage of being fast, but at the expense of being less accurate.
     The radial distance is the standard definition of distance in a
     Euclidean space: $\sqrt{\Delta{x}^2+\Delta{y}^2}$.  It is accurate,
     but the multiplication and square root can slow down the
     processing.

‘--interpnumngb=INT’
     The number of nearby non-blank neighbors to use for interpolation.


File: gnuastro.info,  Node: Operating mode options,  Prev: Processing options,  Up: Common options

4.1.2.3 Operating mode options
..............................

Another group of options that are common to all the programs in Gnuastro
are those to do with the general operation of the programs.  The
explanation for those that are not only limited to Gnuastro but are
common to all GNU programs start with (GNU option).

‘--’
     (GNU option) Stop parsing the command-line.  This option can be
     useful in scripts or when using the shell history.  Suppose you
     have a long list of options, and want to see if removing some of
     them (to read from configuration files, see *note Configuration
     files::) can give a better result.  If the ones you want to remove
     are the last ones on the command-line, you don’t have to delete
     them, you can just add ‘--’ before them and if you don’t get what
     you want, you can remove the ‘--’ and get the same initial result.

‘--usage’
     (GNU option) Only print the options and arguments and abort.  This
     is very useful for when you know the what the options do, and have
     just forgot their long/short identifiers, see *note --usage::.

‘-?’
‘--help’
     (GNU option) Print all options with an explanation and abort.
     Adding this option will print all the options in their short and
     long formats, also displaying which ones need a value if they are
     called (with an ‘=’ after the long format followed by a string
     specifying the format, see *note Options::).  A short explanation
     is also given for what the option is for.  The program will quit
     immediately after the message is printed and will not do any form
     of processing, see *note --help::.

‘-V’
‘--version’
     (GNU option) Print a short message, showing the full name, version,
     copyright information and program authors and abort.  On the first
     line, it will print the official name (not executable name) and
     version number of the program.  Following this is a blank line and
     a copyright information.  The program will not run.

‘-q’
‘--quiet’
     Don’t report steps.  All the programs in Gnuastro that have
     multiple major steps will report their steps for you to follow
     while they are operating.  If you do not want to see these reports,
     you can call this option and only error/warning messages will be
     printed.  If the steps are done very fast (depending on the
     properties of your input) disabling these reports will also
     decrease running time.

‘--cite’
     Print all necessary information to cite and acknowledge Gnuastro in
     your published papers.  With this option, the programs will print
     the BibTeX entry to include in your paper for Gnuastro in general,
     and the particular program’s paper (if that program comes with a
     separate paper).  It will also print the necessary acknowledgment
     statement to add in the respective section of your paper and it
     will abort.  For a more complete explanation, please see *note
     Acknowledgments::.

     Citations and acknowledgments are vital for the continued work on
     Gnuastro.  Gnuastro started, and is continued, based on separate
     research projects.  So if you find any of the tools offered in
     Gnuastro to be useful in your research, please use the output of
     this command to cite and acknowledge the program (and Gnuastro) in
     your research paper.  Thank you.

     Gnuastro is still new, there is no separate paper only devoted to
     Gnuastro yet.  Therefore currently the paper to cite for Gnuastro
     is the paper for NoiseChisel which is the first published paper
     introducing Gnuastro to the astronomical community.  Upon reaching
     a certain point, a paper completely devoted to describing
     Gnuastro’s many functionalities will be published, see *note GNU
     Astronomy Utilities 1.0::.

‘-P’
‘--printparams’
     With this option, Gnuastro’s programs will read your command-line
     options and all the configuration files.  If there is no problem
     (like a missing parameter or a value in the wrong format or range)
     and immediately before actually running, the programs will print
     the full list of option names, values and descriptions, sorted and
     grouped by context and abort.  They will also report the version
     number, the date they were configured on your system and the time
     they were reported.

     As an example, you can give your full command-line options and even
     the input and output file names and finally just add ‘-P’ to check
     if all the parameters are finely set.  If everything is OK, you can
     just run the same command (easily retrieved from the shell history,
     with the top arrow key) and simply remove the last two characters
     that showed this option.

     No program will actually start its processing when this option is
     called.  The otherwise mandatory arguments for each program (for
     example input image or catalog files) are no longer required when
     you call this option.

‘--config=STR’
     Parse ‘STR’ as a configuration file immediately when this option is
     confronted (see *note Configuration files::).  The ‘--config’
     option can be called multiple times in one run of any Gnuastro
     program on the command-line or in the configuration files.  In any
     case, it will be immediately read (before parsing the rest of the
     options on the command-line, or lines in a configuration file).

     Note that by definition, options on the command-line still take
     precedence over those in any configuration file, including the
     file(s) given to this option if they are called before it.  Also
     see ‘--lastconfig’ and ‘--onlyversion’ on how this option can be
     used for reproducible results.  You can use ‘--checkconfig’ (below)
     to check/confirm the parsing of configuration files.

‘--checkconfig’
     Print options and their values, within the command-line or
     configuration files, as they are parsed (see *note Configuration
     file precedence::).  If an option has already been set, or is
     ignored by the program, this option will also inform you with
     special values like ‘--ALREADY-SET--’.  Only options that are
     parsed after this option are printed, so to see the parsing of all
     input options, it is recommended to put this option immediately
     after the program name before any other options.

     This is a very good option to confirm where the value of each
     option is has been defined in scenarios where there are multiple
     configuration files (for debugging).

‘-S’
‘--setdirconf’
     Update the current directory configuration file for the Gnuastro
     program and quit.  The full set of command-line and configuration
     file options will be parsed and options with a value will be
     written in the current directory configuration file for this
     program (see *note Configuration files::).  If the configuration
     file or its directory doesn’t exist, it will be created.  If a
     configuration file exists it will be replaced (after it, and all
     other configuration files have been read).  In any case, the
     program will not run.

     This is the recommended method(1) to edit/set the configuration
     file for all future calls to Gnuastro’s programs.  It will
     internally check if your values are in the correct range and type
     and save them according to the configuration file format, see *note
     Configuration file format::.  So if there are unreasonable values
     to some options, the program will notify you and abort before
     writing the final configuration file.

     When this option is called, the otherwise mandatory arguments, for
     example input image or catalog file(s), are no longer mandatory
     (since the program will not run).

‘-U’
‘--setusrconf’
     Update the user configuration file and quit (see *note
     Configuration files::).  See explanation under ‘--setdirconf’ for
     more details.

‘--lastconfig’
     This is the last configuration file that must be read.  When this
     option is confronted in any stage of reading the options (on the
     command-line or in a configuration file), no other configuration
     file will be parsed, see *note Configuration file precedence:: and
     *note Current directory and User wide::.  Like all on/off options,
     on the command-line, this option doesn’t take any values.  But in a
     configuration file, it takes the values of ‘0’ or ‘1’, see *note
     Configuration file format::.  If it is present in a configuration
     file with a value of ‘0’, then all later occurrences of this option
     will be ignored.

‘--onlyversion=STR’
     Only run the program if Gnuastro’s version is exactly equal to
     ‘STR’ (see *note Version numbering::).  Note that it is not
     compared as a number, but as a string of characters, so ‘0’, or
     ‘0.0’ and ‘0.00’ are different.  If the running Gnuastro version is
     different, then this option will report an error and abort as soon
     as it is confronted on the command-line or in a configuration file.
     If the running Gnuastro version is the same as ‘STR’, then the
     program will run as if this option was not called.

     This is useful if you want your results to be exactly reproducible
     and not mistakenly run with an updated/newer or older version of
     the program.  Besides internal algorithmic/behavior changes in
     programs, the existence of options or their names might change
     between versions (especially in these earlier versions of
     Gnuastro).

     Hence, when using this option (probably in a script or in a
     configuration file), be sure to call it before other options.  The
     benefit is that, when the version differs, the other options won’t
     be parsed and you, or your collaborators/users, won’t get errors
     saying an option in your configuration doesn’t exist in the running
     version of the program.

     Here is one example of how this option can be used in conjunction
     with the ‘--lastconfig’ option.  Let’s assume that you were
     satisfied with the results of this command: ‘astnoisechisel
     image.fits --snquant=0.95’ (along with various options set in
     various configuration files).  You can save the state of
     NoiseChisel and reproduce that exact result on ‘image.fits’ later
     by following these steps (the extra spaces, and <\>, are only for
     easy readability, if you want to try it out, only one space between
     each token is enough).

          $ echo "onlyversion X.XX"             > reproducible.conf
          $ echo "lastconfig 1"                >> reproducible.conf
          $ astnoisechisel image.fits --snquant=0.95 -P            \
                                               >> reproducible.conf

     ‘--onlyversion’ was available from Gnuastro 0.0, so putting it
     immediately at the start of a configuration file will ensure that
     later, you (or others using different version) won’t get a
     non-recognized option error in case an option was added/removed.
     ‘--lastconfig’ will inform the installed NoiseChisel to not parse
     any other configuration files.  This is done because we don’t want
     the user’s user-wide or system wide option values affecting our
     results.  Finally, with the third command, which has a ‘-P’ (short
     for ‘--printparams’), NoiseChisel will print all the option values
     visible to it (in all the configuration files) and the shell will
     append them to ‘reproduce.conf’.  Hence, you don’t have to worry
     about remembering the (possibly) different options in the different
     configuration files.

     Afterwards, if you run NoiseChisel as shown below (telling it to
     read this configuration file with the ‘--config’ option).  You can
     be sure that there will either be an error (for version mismatch)
     or it will produce exactly the same result that you got before.

          $ astnoisechisel --config=reproducible.conf

‘--log’
     Some programs can generate extra information about their outputs in
     a log file.  When this option is called in those programs, the log
     file will also be printed.  If the program doesn’t generate a log
     file, this option is ignored.

     *‘--log’ isn’t thread-safe*: The log file usually has a fixed name.
     Therefore if two simultaneous calls (with ‘--log’) of a program are
     made in the same directory, the program will try to write to he
     same file.  This will cause problems like unreasonable log file,
     undefined behavior, or a crash.

‘-N INT’
‘--numthreads=INT’
     Use ‘INT’ CPU threads when running a Gnuastro program (see *note
     Multi-threaded operations::).  If the value is zero (‘0’), or this
     option is not given on the command-line or any configuration file,
     the value will be determined at run-time: the maximum number of
     threads available to the system when you run a Gnuastro program.

     Note that multi-threaded programming is only relevant to some
     programs.  In others, this option will be ignored.

   ---------- Footnotes ----------

   (1) Alternatively, you can use your favorite text editor.


File: gnuastro.info,  Node: Standard input,  Prev: Common options,  Up: Command-line

4.1.3 Standard input
--------------------

The most common way to feed the primary/first input dataset into a
program is to give its filename as an argument (discussed in *note
Arguments::).  When you want to run a series of programs in sequence,
this means that each will have to keep the output of each program in a
separate file and re-type that file’s name in the next command.  This
can be very slow and frustrating (mis-typing a file’s name).

   To solve the problem, the founders of Unix defined pipes to directly
feed the output of one program (its “Standard output” stream) into the
“standard input” of a next program.  This removes the need to make
temporary files between separate processes and became one of the best
demonstrations of the Unix-way, or Unix philosophy.

   Every program has three streams identifying where it reads/writes
non-file inputs/outputs: _Standard input_, _Standard output_, and
_Standard error_.  When a program is called alone, all three are
directed to the terminal that you are using.  If it needs an input, it
will prompt you for one and you can type it in.  Or, it prints its
results in the terminal for you to see.

   For example, say you have a FITS table/catalog containing the B and V
band magnitudes (‘MAG_B’ and ‘MAG_V’ columns) of a selection of galaxies
along with many other columns.  If you want to see only these two
columns in your terminal, can use Gnuastro’s *note Table:: program like
below:

     $ asttable cat.fits -cMAG_B,MAG_V

   Through the Unix pipe mechanism, when the shell confronts the pipe
character (<|>), it connects the standard output of the program before
the pipe, to the standard input of the program after it.  So it is
literally a “pipe”: everything that you would see printed by the first
program on the command (without any pipe), is now passed to the second
program (and not seen by you).

   To continue the previous example, let’s say you want to see the B-V
color.  To do this, you can pipe Table’s output to AWK (a wonderful tool
for processing things like plain text tables):

     $ asttable cat.fits -cMAG_B,MAG_V | awk '{print $1-$2}'

   But understanding the distribution by visually seeing all the numbers
under each other is not too useful!  You can therefore feed this single
column information into *note Statistics:: to give you a general feeling
of the distribution with the same command:

     $ asttable cat.fits -cMAG_B,MAG_V | awk '{print $1-$2}' | aststatistics

   Gnuastro’s programs that accept input from standard input, only look
into the Standard input stream if there is no first argument.  In other
words, arguments take precedence over Standard input.  When no argument
is provided, the programs check if the standard input stream is already
full or not (output from another program is waiting to be used).  If
data is present in the standard input stream, it is used.

   When the standard input is empty, the program will wait
‘--stdintimeout’ micro-seconds for you to manually enter the first line
(ending with a new-line character, or the <ENTER> key, see *note Input
output options::).  If it detects the first line in this time, there is
no more time limit, and you can manually write/type all the lines for as
long as it takes.  To inform the program that Standard input has
finished, press <CTRL-D> after a new line.  If the program doesn’t catch
the first line before the time-out finishes, it will abort with an error
saying that no input was provided.

*Manual input in Standard input is discarded:* Be careful that when you
manually fill the Standard input, the data will be discarded once the
program finishes and reproducing the result will be impossible.
Therefore this form of providing input is only good for temporary tests.

*Standard input currently only for plain text:* Currently Standard input
only works for plain text inputs like the example above.  We will later
allow FITS files into the programs through standard input also.


File: gnuastro.info,  Node: Configuration files,  Next: Getting help,  Prev: Command-line,  Up: Common program behavior

4.2 Configuration files
=======================

Each program needs a certain number of parameters to run.  Supplying all
the necessary parameters each time you run the program is very
frustrating and prone to errors.  Therefore all the programs read the
values for the necessary options you have not given in the command line
from one of several plain text files (which you can view and edit with
any text editor).  These files are known as configuration files and are
usually kept in a directory named ‘etc/’ according to the file system
hierarchy standard(1).

   The thing to have in mind is that none of the programs in Gnuastro
keep any internal default value.  All the values must either be stored
in one of the configuration files or explicitly called in the
command-line.  In case the necessary parameters are not given through
any of these methods, the program will print a missing option error and
abort.  The only exception to this is ‘--numthreads’, whose default
value is determined at run-time using the number of threads available to
your system, see *note Multi-threaded operations::.  Of course, you can
still provide a default value for the number of threads at any of the
levels below, but if you don’t, the program will not abort.  Also note
that through automatic output name generation, the value to the
‘--output’ option is also not mandatory on the command-line or in the
configuration files for all programs which don’t rely on that value as
an input(2), see *note Automatic output::.

* Menu:

* Configuration file format::   ASCII format of configuration file.
* Configuration file precedence::  Precedence of configuration files.
* Current directory and User wide::  Local and user configuration files.
* System wide::                 System wide configuration files.

   ---------- Footnotes ----------

   (1) <http://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard>

   (2) One example of a program which uses the value given to ‘--output’
as an input is ConvertType, this value specifies the type of the output
through the value to ‘--output’, see *note Invoking astconvertt::.


File: gnuastro.info,  Node: Configuration file format,  Next: Configuration file precedence,  Prev: Configuration files,  Up: Configuration files

4.2.1 Configuration file format
-------------------------------

The configuration files for each program have the standard program
executable name with a ‘‘.conf’’ suffix.  When you download the source
code, you can find them in the same directory as the source code of each
program, see *note Program source::.

   Any line in the configuration file whose first non-white character is
a <#> is considered to be a comment and is ignored.  An empty line is
also similarly ignored.  The long name of the option should be used as
an identifier.  The parameter name and parameter value have to be
separated by any number of ‘white-space’ characters: space, tab or
vertical tab.  By default several space characters are used.  If the
value of an option has space characters (most commonly for the ‘hdu’
option), then the full value can be enclosed in double quotation signs
(<">, similar to the example in *note Arguments and options::).  If it
is an option without a value in the ‘--help’ output (on/off option, see
*note Options::), then the value should be ‘1’ if it is to be ‘on’ and
‘0’ otherwise.

   In each non-commented and non-blank line, any text after the first
two words (option identifier and value) is ignored.  If an option
identifier is not recognized in the configuration file, the name of the
file, the line number of the unrecognized option, and the unrecognized
identifier name will be reported and the program will abort.  If a
parameter is repeated more more than once in the configuration files,
accepts only one value, and is not set on the command-line, then only
the first value will be used, the rest will be ignored.

   You can build or edit any of the directories and the configuration
files yourself using any text editor.  However, it is recommended to use
the ‘--setdirconf’ and ‘--setusrconf’ options to set default values for
the current directory or this user, see *note Operating mode options::.
With these options, the values you give will be checked before writing
in the configuration file.  They will also print a set of commented
lines guiding the reader and will also classify the options based on
their context and write them in their logical order to be more
understandable.


File: gnuastro.info,  Node: Configuration file precedence,  Next: Current directory and User wide,  Prev: Configuration file format,  Up: Configuration files

4.2.2 Configuration file precedence
-----------------------------------

The option values in all the programs of Gnuastro will be filled in the
following order.  If an option only takes one value which is given in an
earlier step, any value for that option in a later step will be ignored.
Note that if the ‘lastconfig’ option is specified in any step below, no
other configuration files will be parsed (see *note Operating mode
options::).

  1. Command-line options, for a particular run of ProgramName.

  2. ‘.gnuastro/astprogname.conf’ is parsed by ProgramName in the
     current directory.

  3. ‘.gnuastro/gnuastro.conf’ is parsed by all Gnuastro programs in the
     current directory.

  4. ‘$HOME/.local/etc/astprogname.conf’ is parsed by ProgramName in the
     user’s home directory (see *note Current directory and User
     wide::).

  5. ‘$HOME/.local/etc/gnuastro.conf’ is parsed by all Gnuastro programs
     in the user’s home directory (see *note Current directory and User
     wide::).

  6. ‘prefix/etc/astprogname.conf’ is parsed by ProgramName in the
     system-wide installation directory (see *note System wide:: for
     ‘prefix’).

  7. ‘prefix/etc/gnuastro.conf’ is parsed by all Gnuastro programs in
     the system-wide installation directory (see *note System wide:: for
     ‘prefix’).

   The basic idea behind setting this progressive state of checking for
parameter values is that separate users of a computer or separate
folders in a user’s file system might need different values for some
parameters.

*Checking the order:* You can confirm/check the order of parsing
configuration files using the ‘--checkconfig’ option with any Gnuastro
program, see *note Operating mode options::.  Just be sure to place this
option immediately after the program name, before any other option.

   As you see above, there can also be a configuration file containing
the common options in all the programs: ‘gnuastro.conf’ (see *note
Common options::).  If options specific to one program are specified in
this file, there will be unrecognized option errors, or unexpected
behavior if the option has different behavior in another program.  On
the other hand, there is no problem with ‘astprogname.conf’ containing
common options(1).

*Manipulating the order:* You can manipulate this order or add new files
with the following two options which are fully described in *note
Operating mode options:::
‘--config’
     Allows you to define any file to be parsed as a configuration file
     on the command-line or within the any other configuration file.
     Recall that the file given to ‘--config’ is parsed immediately when
     this option is confronted (on the command-line or in a
     configuration file).

‘--lastconfig’
     Allows you to stop the parsing of subsequent configuration files.
     Note that if this option is given in a configuration file, it will
     be fully read, so its position in the configuration doesn’t matter
     (unlike ‘--config’).

   One example of benefiting from these configuration files can be this:
raw telescope images usually have their main image extension in the
second FITS extension, while processed FITS images usually only have one
extension.  If your system-wide default input extension is 0 (the
first), then when you want to work with the former group of data you
have to explicitly mention it to the programs every time.  With this
progressive state of default values to check, you can set different
default values for the different directories that you would like to run
Gnuastro in for your different purposes, so you won’t have to worry
about this issue any more.

   The same can be said about the ‘gnuastro.conf’ files: by specifying a
behavior in this single file, all Gnuastro programs in the respective
directory, user, or system-wide steps will behave similarly.  For
example to keep the input’s directory when no specific output is given
(see *note Automatic output::), or to not delete an existing file if it
has the same name as a given output (see *note Input output options::).

   ---------- Footnotes ----------

   (1) As an example, the ‘--setdirconf’ and ‘--setusrconf’ options will
also write the common options they have read in their produced
‘astprogname.conf’.


File: gnuastro.info,  Node: Current directory and User wide,  Next: System wide,  Prev: Configuration file precedence,  Up: Configuration files

4.2.3 Current directory and User wide
-------------------------------------

For the current (local) and user-wide directories, the configuration
files are stored in the hidden sub-directories named ‘.gnuastro/’ and
‘$HOME/.local/etc/’ respectively.  Unless you have changed it, the
‘$HOME’ environment variable should point to your home directory.  You
can check it by running ‘$ echo $HOME’.  Each time you run any of the
programs in Gnuastro, this environment variable is read and placed in
the above address.  So if you suddenly see that your home configuration
files are not being read, probably you (or some other program) has
changed the value of this environment variable.

   Although it might cause confusions like above, this dependence on the
‘HOME’ environment variable enables you to temporarily use a different
directory as your home directory.  This can come in handy in complicated
situations.  To set the user or current directory configuration files
based on your command-line input, you can use the ‘--setdirconf’ or
‘--setusrconf’, see *note Operating mode options::.


File: gnuastro.info,  Node: System wide,  Prev: Current directory and User wide,  Up: Configuration files

4.2.4 System wide
-----------------

When Gnuastro is installed, the configuration files that are shipped
with the distribution are copied into the (possibly system wide)
‘prefix/etc/’ directory.  For more details on ‘prefix’, see *note
Installation directory:: (by default it is: ‘/usr/local’).  This
directory is the final place (with the lowest priority) that the
programs in Gnuastro will check to retrieve parameter values.

   If you remove an option and its value from the system wide
configuration files, you either have to specify it in more immediate
configuration files or set it each time in the command-line.  Recall
that none of the programs in Gnuastro keep any internal default values
and will abort if they don’t find a value for the necessary parameters
(except the number of threads and output file name).  So even though you
might never expect to use an optional option, it safe to have it
available in this system-wide configuration file even if you don’t
intend to use it frequently.

   Note that in case you install Gnuastro from your distribution’s
repositories, ‘prefix’ will either be set to ‘/’ (the root directory) or
‘/usr’, so you can find the system wide configuration variables in
‘/etc/’ or ‘/usr/etc/’.  The prefix of ‘/usr/local/’ is conventionally
used for programs you install from source by your self as in *note Quick
start::.


File: gnuastro.info,  Node: Getting help,  Next: Installed scripts,  Prev: Configuration files,  Up: Common program behavior

4.3 Getting help
================

Probably the first time you read this book, it is either in the PDF or
HTML formats.  These two formats are very convenient for when you are
not actually working, but when you are only reading.  Later on, when you
start to use the programs and you are deep in the middle of your work,
some of the details will inevitably be forgotten.  Going to find the PDF
file (printed or digital) or the HTML webpage is a major distraction.

   GNU software have a very unique set of tools for aiding your memory
on the command-line, where you are working, depending how much of it you
need to remember.  In the past, such command-line help was known as
“online” help, because they were literally provided to you ‘on’ the
command ‘line’.  However, nowadays the word “online” refers to something
on the internet, so that term will not be used.  With this type of help,
you can resume your exciting research without taking your hands off the
keyboard.

   Another major advantage of such command-line based help routines is
that they are installed with the software in your computer, therefore
they are always in sync with the executable you are actually running.
Three of them are actually part of the executable.  You don’t have to
worry about the version of the book or program.  If you rely on external
help (a PDF in your personal print or digital archive or HTML from the
official webpage) you have to check to see if their versions fit with
your installed program.

   If you only need to remember the short or long names of the options,
‘--usage’ is advised.  If it is what the options do, then ‘--help’ is a
great tool.  Man pages are also provided for those who are use to this
older system of documentation.  This full book is also available to you
on the command-line in Info format.  If none of these seems to resolve
the problems, there is a mailing list which enables you to get in touch
with experienced Gnuastro users.  In the subsections below each of these
methods are reviewed.

* Menu:

* --usage::                     View option names and value formats.
* --help::                      List all options with description.
* Man pages::                   Man pages generated from –help.
* Info::                        View complete book in terminal.
* help-gnuastro mailing list::  Contacting experienced users.


File: gnuastro.info,  Node: --usage,  Next: --help,  Prev: Getting help,  Up: Getting help

4.3.1 ‘--usage’
---------------

If you give this option, the program will not run.  It will only print a
very concise message showing the options and arguments.  Everything
within square brackets (‘[]’) is optional.  For example here are the
first and last two lines of Crop’s ‘--usage’ is shown:

     $ astcrop --usage
     Usage: astcrop [-Do?IPqSVW] [-d INT] [-h INT] [-r INT] [-w INT]
                 [-x INT] [-y INT] [-c INT] [-p STR] [-N INT] [--deccol=INT]
                 ....
                 [--setusrconf] [--usage] [--version] [--wcsmode]
                 [ASCIIcatalog] FITSimage(s).fits

   There are no explanations on the options, just their short and long
names shown separately.  After the program name, the short format of all
the options that don’t require a value (on/off options) is displayed.
Those that do require a value then follow in separate brackets, each
displaying the format of the input they want, see *note Options::.
Since all options are optional, they are shown in square brackets, but
arguments can also be optional.  For example in this example, a catalog
name is optional and is only required in some modes.  This is a standard
method of displaying optional arguments for all GNU software.


File: gnuastro.info,  Node: --help,  Next: Man pages,  Prev: --usage,  Up: Getting help

4.3.2 ‘--help’
--------------

If the command-line includes this option, the program will not be run.
It will print a complete list of all available options along with a
short explanation.  The options are also grouped by their context.
Within each context, the options are sorted alphabetically.  Since the
options are shown in detail afterwards, the first line of the ‘--help’
output shows the arguments and if they are optional or not, similar to
*note --usage::.

   In the ‘--help’ output of all programs in Gnuastro, the options for
each program are classified based on context.  The first two contexts
are always options to do with the input and output respectively.  For
example input image extensions or supplementary input files for the
inputs.  The last class of options is also fixed in all of Gnuastro, it
shows operating mode options.  Most of these options are already
explained in *note Operating mode options::.

   The help message will sometimes be longer than the vertical size of
your terminal.  If you are using a graphical user interface terminal
emulator, you can scroll the terminal with your mouse, but we promised
no mice distractions!  So here are some suggestions:

   • <Shift + PageUP> to scroll up and <Shift + PageDown> to scroll
     down.  For most help output this should be enough.  The problem is
     that it is limited by the number of lines that your terminal keeps
     in memory and that you can’t scroll by lines, only by whole
     screens.

   • Pipe to ‘less’.  A pipe is a form of shell re-direction.  The
     ‘less’ tool in Unix-like systems was made exactly for such outputs
     of any length.  You can pipe (‘|’) the output of any program that
     is longer than the screen to it and then you can scroll through (up
     and down) with its many tools.  For example:
          $ astnoisechisel --help | less
     Once you have gone through the text, you can quit ‘less’ by
     pressing the <q> key.

   • Redirect to a file.  This is a less convenient way, because you
     will then have to open the file in a text editor!  You can do this
     with the shell redirection tool (‘>’):
          $ astnoisechisel --help > filename.txt

   In case you have a special keyword you are looking for in the help,
you don’t have to go through the full list.  GNU Grep is made for this
job.  For example if you only want the list of options whose ‘--help’
output contains the word “axis” in Crop, you can run the following
command:

     $ astcrop --help | grep axis

   If the output of this option does not fit nicely within the confines
of your terminal, GNU does enable you to customize its output through
the environment variable ‘ARGP_HELP_FMT’, you can set various parameters
which specify the formatting of the help messages.  For example if your
terminals are wider than 70 spaces (say 100) and you feel there is too
much empty space between the long options and the short explanation, you
can change these formats by giving values to this environment variable
before running the program with the ‘--help’ output.  You can define
this environment variable in this manner:
     $ export ARGP_HELP_FMT=rmargin=100,opt-doc-col=20
   This will affect all GNU programs using GNU C library’s ‘argp.h’
facilities as long as the environment variable is in memory.  You can
see the full list of these formatting parameters in the “Argp User
Customization” part of the GNU C library manual.  If you are more
comfortable to read the ‘--help’ outputs of all GNU software in your
customized format, you can add your customization (similar to the line
above, without the ‘$’ sign) to your ‘~/.bashrc’ file.  This is a
standard option for all GNU software.


File: gnuastro.info,  Node: Man pages,  Next: Info,  Prev: --help,  Up: Getting help

4.3.3 Man pages
---------------

Man pages were the Unix method of providing command-line documentation
to a program.  With GNU Info, see *note Info:: the usage of this method
of documentation is highly discouraged.  This is because Info provides a
much more easier to navigate and read environment.

   However, some operating systems require a man page for packages that
are installed and some people are still used to this method of command
line help.  So the programs in Gnuastro also have Man pages which are
automatically generated from the outputs of ‘--version’ and ‘--help’
using the GNU help2man program.  So if you run
     $ man programname
You will be provided with a man page listing the options in the standard
manner.


File: gnuastro.info,  Node: Info,  Next: help-gnuastro mailing list,  Prev: Man pages,  Up: Getting help

4.3.4 Info
----------

Info is the standard documentation format for all GNU software.  It is a
very useful command-line document viewing format, fully equipped with
links between the various pages and menus and search capabilities.  As
explained before, the best thing about it is that it is available for
you the moment you need to refresh your memory on any command-line tool
in the middle of your work without having to take your hands off the
keyboard.  This complete book is available in Info format and can be
accessed from anywhere on the command-line.

   To open the Info format of any installed programs or library on your
system which has an Info format book, you can simply run the command
below (change ‘executablename’ to the executable name of the program or
library):

     $ info executablename

In case you are not already familiar with it, run ‘$ info info’.  It
does a fantastic job in explaining all its capabilities its self.  It is
very short and you will become sufficiently fluent in about half an
hour.  Since all GNU software documentation is also provided in Info,
your whole GNU/Linux life will significantly improve.

   Once you’ve become an efficient navigator in Info, you can go to any
part of this book or any other GNU software or library manual, no matter
how long it is, in a matter of seconds.  It also blends nicely with GNU
Emacs (a text editor) and you can search manuals while you are writing
your document or programs without taking your hands off the keyboard,
this is most useful for libraries like the GNU C library.  To be able to
access all the Info manuals installed in your GNU/Linux within Emacs,
type <Ctrl-H + i>.

   To see this whole book from the beginning in Info, you can run

     $ info gnuastro

If you run Info with the particular program executable name, for example
‘astcrop’ or ‘astnoisechisel’:

     $ info astprogramname

you will be taken to the section titled “Invoking ProgramName” which
explains the inputs and outputs along with the command-line options for
that program.  Finally, if you run Info with the official program name,
for example Crop or NoiseChisel:

     $ info ProgramName

you will be taken to the top section which introduces the program.  Note
that in all cases, Info is not case sensitive.


File: gnuastro.info,  Node: help-gnuastro mailing list,  Prev: Info,  Up: Getting help

4.3.5 help-gnuastro mailing list
--------------------------------

Gnuastro maintains the help-gnuastro mailing list for users to ask any
questions related to Gnuastro.  The experienced Gnuastro users and some
of its developers are subscribed to this mailing list and your email
will be sent to them immediately.  However, when contacting this mailing
list please have in mind that they are possibly very busy and might not
be able to answer immediately.

   To ask a question from this mailing list, send a mail to
‘help-gnuastro@gnu.org’.  Anyone can view the mailing list archives at
<http://lists.gnu.org/archive/html/help-gnuastro/>.  It is best that
before sending a mail, you search the archives to see if anyone has
asked a question similar to yours.  If you want to make a suggestion or
report a bug, please don’t send a mail to this mailing list.  We have
other mailing lists and tools for those purposes, see *note Report a
bug:: or *note Suggest new feature::.


File: gnuastro.info,  Node: Installed scripts,  Next: Multi-threaded operations,  Prev: Getting help,  Up: Common program behavior

4.4 Installed scripts
=====================

Gnuastro’s programs (introduced in previous chapters) are designed to be
highly modular and thus mainly contain lower-level operations on the
data.  However, in many contexts, higher-level operations (for example a
sequence of calls to multiple Gnuastro programs, or a special way of
running a program and using the outputs) are also very similar between
various projects.

   To facilitate data analysis on these higher-level steps also,
Gnuastro also installs some scripts on your system with the
(‘astscript-’) prefix (in contrast to the other programs that only have
the ‘ast’ prefix).

   Like all of Gnuastro’s source code, these scripts are also heavily
commented.  They are written in GNU Bash, which doesn’t need
compilation.  Therefore, if you open the installed scripts in a text
editor, you can actually read them(1).  Bash is the same language that
is mainly used when typing on the command-line.  Because of these
factors, Bash is much more widely known and used than C (the language of
other Gnuastro programs).  Gnuastro’s installed scripts also do
higher-level operations, so customizing these scripts for a special
project will be more common than the programs.  You can always inspect
them (to customize, check, or educate your self) with this command (just
replace ‘emacs’ with your favorite text editor):

     $ emacs $(which astscript-NAME)

   These scripts also accept options and are in many ways similar to the
programs (see *note Common options::) with some minor differences:

   • Currently they don’t accept configuration files themselves.
     However, the configuration files of the Gnuastro programs they call
     are indeed parsed and used by those programs.

     As a result, they don’t have the following options:
     ‘--checkconfig’, ‘--config’, ‘--lastconfig’, ‘--onlyversion’,
     ‘--printparams’, ‘--setdirconf’ and ‘--setusrconf’.

   • They don’t directly allocate any memory, so there is no
     ‘--minmapsize’.

   • They don’t have an independent ‘--usage’ option: when called with
     ‘--usage’, they just recommend running ‘--help’.

   • The output of ‘--help’ is not configurable like the programs (see
     *note --help::).

   • The scripts will commonly use your installed Bash and other basic
     command-line tools (for example AWK or SED). Different systems have
     different versions and implementations of these basic tools (for
     example GNU/Linux systems use GNU AWK and GNU SED which are far
     more advanced and up to date then the minimalist AWK and SED of
     most other systems).  Therefore, unexpected errors in these tools
     might come up when you run these scripts.  We will try our best to
     write these scripts in a portable way.  However, if you do confront
     such strange errors, please submit a bug report so we fix it (see
     *note Report a bug::).

   ---------- Footnotes ----------

   (1) Gnuastro’s installed programs (those only starting with ‘ast’)
aren’t human-readable.  They are written in C and are thus compiled
(optimized in binary CPU instructions that will be given directly to
your CPU). Because they don’t need an interpreter like Bash on every
run, they are much faster and more independent than scripts.  To read
the source code of the programs, look into the ‘bin/progname’ directory
of Gnuastro’s source (*note Downloading the source::).  If you would
like to read more about why C was chosen for the programs, please see
*note Why C::.


File: gnuastro.info,  Node: Multi-threaded operations,  Next: Numeric data types,  Prev: Installed scripts,  Up: Common program behavior

4.5 Multi-threaded operations
=============================

Some of the programs benefit significantly when you use all the threads
your computer’s CPU has to offer to your operating system.  The number
of threads available can be larger than the number of physical
(hardware) cores in the CPU (also known as Simultaneous multithreading).
For example, in Intel’s CPUs (those that implement its Hyper-threading
technology) the number of threads is usually double the number of
physical cores in your CPU. On a GNU/Linux system, the number of threads
available can be found with the command ‘$ nproc’ command (part of GNU
Coreutils).

   Gnuastro’s programs can find the number of threads available to your
system internally at run-time (when you execute the program).  However,
if a value is given to the ‘--numthreads’ option, the given number will
be used, see *note Operating mode options:: and *note Configuration
files:: for ways to use this option.  Thus ‘--numthreads’ is the only
common option in Gnuastro’s programs with a value that doesn’t have to
be specified anywhere on the command-line or in the configuration files.

* Menu:

* A note on threads::           Caution and suggestion on using threads.
* How to run simultaneous operations::  How to run things simultaneously.


File: gnuastro.info,  Node: A note on threads,  Next: How to run simultaneous operations,  Prev: Multi-threaded operations,  Up: Multi-threaded operations

4.5.1 A note on threads
-----------------------

Spinning off threads is not necessarily the most efficient way to run an
application.  Creating a new thread isn’t a cheap operation for the
operating system.  It is most useful when the input data are fixed and
you want the same operation to be done on parts of it.  For example one
input image to Crop and multiple crops from various parts of it.  In
this fashion, the image is loaded into memory once, all the crops are
divided between the number of threads internally and each thread cuts
out those parts which are assigned to it from the same image.  On the
other hand, if you have multiple images and you want to crop the same
region(s) out of all of them, it is much more efficient to set
‘--numthreads=1’ (so no threads spin off) and run Crop multiple times
simultaneously, see *note How to run simultaneous operations::.

   You can check the boost in speed by first running a program on one of
the data sets with the maximum number of threads and another time (with
everything else the same) and only using one thread.  You will notice
that the wall-clock time (reported by most programs at their end) in the
former is longer than the latter divided by number of physical CPU cores
(not threads) available to your operating system.  Asymptotically these
two times can be equal (most of the time they aren’t).  So limiting the
programs to use only one thread and running them independently on the
number of available threads will be more efficient.

   Note that the operating system keeps a cache of recently processed
data, so usually, the second time you process an identical data set
(independent of the number of threads used), you will get faster
results.  In order to make an unbiased comparison, you have to first
clean the system’s cache with the following command between the two
runs.

     $ sync; echo 3 | sudo tee /proc/sys/vm/drop_caches

*SUMMARY: Should I use multiple threads?*  Depends:
   • If you only have *one* data set (image in most cases!), then yes,
     the more threads you use (with a maximum of the number of threads
     available to your OS) the faster you will get your results.

   • If you want to run the same operation on *multiple* data sets, it
     is best to set the number of threads to 1 and use Make, or GNU
     Parallel, as explained in *note How to run simultaneous
     operations::.


File: gnuastro.info,  Node: How to run simultaneous operations,  Prev: A note on threads,  Up: Multi-threaded operations

4.5.2 How to run simultaneous operations
----------------------------------------

There are two(1) approaches to simultaneously execute a program: using
GNU Parallel or Make (GNU Make is the most common implementation).  The
first is very useful when you only want to do one job multiple times and
want to get back to your work without actually keeping the command you
ran.  The second is usually for more important operations, with lots of
dependencies between the different products (for example a full
scientific research).

GNU Parallel
     When you only want to run multiple instances of a command on
     different threads and get on with the rest of your work, the best
     method is to use GNU parallel.  Surprisingly GNU Parallel is one of
     the few GNU packages that has no Info documentation but only a Man
     page, see *note Info::.  So to see the documentation after
     installing it please run

          $ man parallel
     As an example, let’s assume we want to crop a region fixed on the
     pixels (500, 600) with the default width from all the FITS images
     in the ‘./data’ directory ending with ‘sci.fits’ to the current
     directory.  To do this, you can run:

          $ parallel astcrop --numthreads=1 --xc=500 --yc=600 ::: \
            ./data/*sci.fits

     GNU Parallel can help in many more conditions, this is one of the
     simplest, see the man page for lots of other examples.  For
     absolute beginners: the backslash (‘\’) is only a line breaker to
     fit nicely in the page.  If you type the whole command in one line,
     you should remove it.

Make
     Make is a program for building “targets” (e.g., files) using
     “recipes” (a set of operations) when their known “prerequisites”
     (other files) have been updated.  It elegantly allows you to define
     dependency structures for building your final output and updating
     it efficiently when the inputs change.  It is the most common
     infra-structure to build software today.

     Scientific research methodology is very similar to software
     development: you start by testing a hypothesis on a small sample of
     objects/targets with a simple set of steps.  As you are able to get
     promising results, you improve the method and use it on a larger,
     more general, sample.  In the process, you will confront many
     issues that have to be corrected (bugs in software development
     jargon).  Make a wonderful tool to manage this style of
     development.  It has been used to make reproducible papers, for
     example see the reproduction pipeline
     (https://gitlab.com/makhlaghi/NoiseChisel-paper) of the paper
     introducing *note NoiseChisel:: (one of Gnuastro’s programs).

     GNU Make(2) is the most common implementation which (similar to
     nearly all GNU programs, comes with a wonderful manual(3)).  Make
     is very basic and simple, and thus the manual is short (the most
     important parts are in the first roughly 100 pages) and easy to
     read/understand.

     Make comes with a ‘--jobs’ (‘-j’) option which allows you to
     specify the maximum number of jobs that can be done simultaneously.
     For example if you have 8 threads available to your operating
     system.  You can run:

          $ make -j8

     With this command, Make will process your ‘Makefile’ and create all
     the targets (can be thousands of FITS images for example)
     simultaneously on 8 threads, while fully respecting their
     dependencies (only building a file/target when its prerequisites
     are successfully built).  Make is thus strongly recommended for
     managing scientific research where robustness, archiving,
     reproducibility and speed(4) are important.

   ---------- Footnotes ----------

   (1) A third way would be to open multiple terminal emulator windows
in your GUI, type the commands separately on each and press <Enter> once
on each terminal, but this is far too frustrating, tedious and prone to
errors.  It’s therefore not a realistic solution when tens, hundreds or
thousands of operations (your research targets, multiplied by the
operations you do on each) are to be done.

   (2) <https://www.gnu.org/software/make/>

   (3) <https://www.gnu.org/software/make/manual/>

   (4) Besides its multi-threaded capabilities, Make will only re-build
those targets that depend on a change you have made, not the whole work.
For example, if you have set the prerequisites properly, you can easily
test the changing of a parameter on your paper’s results without having
to re-do everything (which is much faster).  This allows you to be much
more productive in easily checking various ideas/assumptions of the
different stages of your research and thus produce a more robust result
for your exciting science.


File: gnuastro.info,  Node: Numeric data types,  Next: Tables,  Prev: Multi-threaded operations,  Up: Common program behavior

4.6 Numeric data types
======================

At the lowest level, the computer stores everything in terms of ‘1’ or
‘0’.  For example, each program in Gnuastro, or each astronomical image
you take with the telescope is actually a string of millions of these
zeros and ones.  The space required to keep a zero or one is the
smallest unit of storage, and is known as a _bit_.  However,
understanding and manipulating this string of bits is extremely hard for
most people.  Therefore, different standards are defined to package the
bits into separate _type_s with a fixed interpretation of the bits in
each package.

   To store numbers, the most basic standard/type is for integers ($...,
-2, -1, 0, 1, 2, ...$).  The common integer types are 8, 16, 32, and 64
bits wide (more bits will give larger limits).  Each bit corresponds to
a power of 2 and they are summed to create the final number.  In the
integer types, for each width there are two standards for reading the
bits: signed and unsigned.  In the ‘signed’ convention, one bit is
reserved for the sign (stating that the integer is positive or
negative).  The ‘unsigned’ integers use that bit in the actual number
and thus contain only positive numbers (starting from zero).

   Therefore, at the same number of bits, both signed and unsigned
integers can allow the same number of integers, but the positive limit
of the ‘unsigned’ types is double their ‘signed’ counterparts with the
same width (at the expense of not having negative numbers).  When the
context of your work doesn’t involve negative numbers (for example
counting, where negative is not defined), it is best to use the
‘unsigned’ types.  For the full numerical range of all integer types,
see below.

   Another standard of converting a given number of bits to numbers is
the floating point standard, this standard can _approximately_ store any
real number with a given precision.  There are two common floating point
types: 32-bit and 64-bit, for single and double precision floating point
numbers respectively.  The former is sufficient for data with less than
8 significant decimal digits (most astronomical data), while the latter
is good for less than 16 significant decimal digits.  The representation
of real numbers as bits is much more complex than integers.  If you are
interested to learn more about it, you can start with the Wikipedia
article (https://en.wikipedia.org/wiki/Floating_point).

   Practically, you can use Gnuastro’s Arithmetic program to
convert/change the type of an image/datacube (see *note Arithmetic::),
or Gnuastro Table program to convert a table column’s data type (see
*note Column arithmetic::).  Conversion of a dataset’s type is necessary
in some contexts.  For example the program/library, that you intend to
feed the data into, only accepts floating point values, but you have an
integer image/column.  Another situation that conversion can be helpful
is when you know that your data only has values that fit within ‘int8’
or ‘uint16’.  However it is currently formatted in the ‘float64’ type.

   The important thing to consider is that operations involving wider,
floating point, or signed types can be significantly slower than
smaller-width, integer, or unsigned types respectively.  Note that
besides speed, a wider type also requires much more storage space (by 4
or 8 times).  Therefore, when you confront such situations that can be
optimized and want to store/archive/transfer the data, it is best to use
the most efficient type.  For example if your dataset (image or table
column) only has positive integers less than 65535, store it as an
unsigned 16-bit integer for faster processing, faster transfer, and less
storage space.

   The short and long names for the recognized numeric data types in
Gnuastro are listed below.  Both short and long names can be used when
you want to specify a type.  For example, as a value to the common
option ‘--type’ (see *note Input output options::), or in the
information comment lines of *note Gnuastro text table format::.  The
ranges listed below are inclusive.

‘u8’
‘uint8’
     8-bit unsigned integers, range:
     $[0\rm{\ to\ }2^8-1]$ or $[0\rm{\ to\ }255]$.

‘i8’
‘int8’
     8-bit signed integers, range:
     $[-2^7\rm{\ to\ }2^7-1]$ or $[-128\rm{\ to\ }127]$.

‘u16’
‘uint16’
     16-bit unsigned integers, range:
     $[0\rm{\ to\ }2^{16}-1]$ or $[0\rm{\ to\ }65535]$.

‘i16’
‘int16’
     16-bit signed integers, range:
     $[-2^{15}\rm{\ to\ }2^{15}-1]$ or $[-32768\rm{\ to\ }32767]$.

‘u32’
‘uint32’
     32-bit unsigned integers, range:
     $[0\rm{\ to\ }2^{32}-1]$ or $[0\rm{\ to\ }4294967295]$.

‘i32’
‘int32’
     32-bit signed integers, range:
     $[-2^{31}\rm{\ to\ }2^{31}-1]$ or $[-2147483648\rm{\ to\
     }2147483647]$.

‘u64’
‘uint64’
     64-bit unsigned integers, range
     $[0\rm{\ to\ }2^{64}-1]$ or $[0\rm{\ to\ }18446744073709551615]$.

‘i64’
‘int64’
     64-bit signed integers, range:
     $[-2^{63}\rm{\ to\ }2^{63}-1]$ or $[-9223372036854775808\rm{\ to\
     }9223372036854775807]$.

‘f32’
‘float32’
     32-bit (single-precision) floating point types.  The maximum
     (minimum is its negative) possible value is
     $3.402823\times10^{38}$.  Single-precision floating points can
     accurately represent a floating point number up to $\sim7.2$
     significant decimals.  Given the heavy noise in astronomical data,
     this is usually more than sufficient for storing results.

‘f64’
‘float64’
     64-bit (double-precision) floating point types.  The maximum
     (minimum is its negative) possible value is $\sim10^{308}$.
     Double-precision floating points can accurately represent a
     floating point number $\sim15.9$ significant decimals.  This is
     usually good for processing (mixing) the data internally, for
     example a sum of single precision data (and later storing the
     result as ‘float32’).

*Some file formats don’t recognize all types.*  For example the FITS
standard (see *note Fits::) does not define ‘uint64’ in binary tables or
images.  When a type is not acceptable for output into a given file
format, the respective Gnuastro program or library will let you know and
abort.  On the command-line, you can convert the numerical type of an
image, or table column into another type with *note Arithmetic:: or
*note Table:: respectively.  If you are writing your own program, you
can use the ‘gal_data_copy_to_new_type()’ function in Gnuastro’s
library, see *note Copying datasets::.


File: gnuastro.info,  Node: Tables,  Next: Tessellation,  Prev: Numeric data types,  Up: Common program behavior

4.7 Tables
==========

“A table is a collection of related data held in a structured format
within a database.  It consists of columns, and rows.” (from Wikipedia).
Each column in the table contains the values of one property and each
row is a collection of properties (columns) for one target object.  For
example, let’s assume you have just ran MakeCatalog (see *note
MakeCatalog::) on an image to measure some properties for the labeled
regions (which might be detected galaxies for example) in the image.
For each labeled region (detected galaxy), there will be a _row_ which
groups its measured properties as _columns_, one column for each
property.  One such property can be the object’s magnitude, which is the
sum of pixels with that label, or its center can be defined as the
light-weighted average value of those pixels.  Many such properties can
be derived from the raw pixel values and their position, see *note
Invoking astmkcatalog:: for a long list.

   As a summary, for each labeled region (or, galaxy) we have one _row_
and for each measured property we have one _column_.  This high-level
structure is usually the first step for higher-level analysis, for
example finding the stellar mass or photometric redshift from magnitudes
in multiple colors.  Thus, tables are not just outputs of programs, in
fact it is much more common for tables to be inputs of programs.  For
example, to make a mock galaxy image, you need to feed in the properties
of each galaxy into *note MakeProfiles:: for it do the inverse of the
process above and make a simulated image from a catalog, see *note Sufi
simulates a detection::.  In other cases, you can feed a table into
*note Crop:: and it will crop out regions centered on the positions
within the table, see *note Finding reddest clumps and visual
inspection::.  So to end this relatively long introduction, tables play
a very important role in astronomy, or generally all branches of data
analysis.

   In *note Recognized table formats:: the currently recognized table
formats in Gnuastro are discussed.  You can use any of these tables as
input or ask for them to be built as output.  The most common type of
table format is a simple plain text file with each row on one line and
columns separated by white space characters, this format is easy to
read/write by eye/hand.  To give it the full functionality of more
specific table types like the FITS tables, Gnuastro has a special
convention which you can use to give each column a name, type, unit, and
comments, while still being readable by other plain text table readers.
This convention is described in *note Gnuastro text table format::.

   When tables are input to a program, the program reading it needs to
know which column(s) it should use for its desired purposes.  Gnuastro’s
programs all follow a similar convention, on the way you can select
columns in a table.  They are thoroughly discussed in *note Selecting
table columns::.

* Menu:

* Recognized table formats::    Table formats that are recognized in Gnuastro.
* Gnuastro text table format::  Gnuastro’s convention plain text tables.
* Selecting table columns::     Identify/select certain columns from a table


File: gnuastro.info,  Node: Recognized table formats,  Next: Gnuastro text table format,  Prev: Tables,  Up: Tables

4.7.1 Recognized table formats
------------------------------

The list of table formats that Gnuastro can currently read from and
write to are described below.  Each has their own advantage and
disadvantages, so a short review of the format is also provided to help
you make the best choice based on how you want to define your input
tables or later use your output tables.

Plain text table
     This is the most basic and simplest way to create, view, or edit
     the table by hand on a text editor.  The other formats described
     below are less eye-friendly and have a more formal structure (for
     easier computer readability).  It is fully described in *note
     Gnuastro text table format::.

FITS ASCII tables
     The FITS ASCII table extension is fully in ASCII encoding and thus
     easily readable on any text editor (assuming it is the only
     extension in the FITS file).  If the FITS file also contains binary
     extensions (for example an image or binary table extensions), then
     there will be many hard to print characters.  The FITS ASCII format
     doesn’t have new line characters to separate rows.  In the FITS
     ASCII table standard, each row is defined as a fixed number of
     characters (value to the ‘NAXIS1’ keyword), so to visually inspect
     it properly, you would have to adjust your text editor’s width to
     this value.  All columns start at given character positions and
     have a fixed width (number of characters).

     Numbers in a FITS ASCII table are printed into ASCII format, they
     are not in binary (that the CPU uses).  Hence, they can take a
     larger space in memory, loose their precision, and take longer to
     read into memory.  If you are dealing with integer type columns
     (see *note Numeric data types::), another issue with FITS ASCII
     tables is that the type information for the column will be lost
     (there is only one integer type in FITS ASCII tables).  One problem
     with the binary format on the other hand is that it isn’t portable
     (different CPUs/compilers) have different standards for translating
     the zeros and ones.  But since ASCII characters are defined on a
     byte and are well recognized, they are better for portability on
     those various systems.  Gnuastro’s plain text table format
     described below is much more portable and easier to
     read/write/interpret by humans manually.

     Generally, as the name implies, this format is useful for when your
     table mainly contains ASCII columns (for example file names, or
     descriptions).  They can be useful when you need to include columns
     with structured ASCII information along with other extensions in
     one FITS file.  In such cases, you can also consider header
     keywords (see *note Fits::).

FITS binary tables
     The FITS binary table is the FITS standard’s solution to the issues
     discussed with keeping numbers in ASCII format as described under
     the FITS ASCII table title above.  Only columns defined as a string
     type (a string of ASCII characters) are readable in a text editor.
     The portability problem with binary formats discussed above is
     mostly solved thanks to the portability of CFITSIO (see *note
     CFITSIO::) and the very long history of the FITS format which has
     been widely used since the 1970s.

     In the case of most numbers, storing them in binary format is more
     memory efficient than ASCII format.  For example, to store
     ‘-25.72034’ in ASCII format, you need 9 bytes/characters.  But if
     you keep this same number (to the approximate precision possible)
     as a 4-byte (32-bit) floating point number, you can keep/transmit
     it with less than half the amount of memory.  When catalogs contain
     thousands/millions of rows in tens/hundreds of columns, this can
     lead to significant improvements in memory/band-width usage.
     Moreover, since the CPU does its operations in the binary formats,
     reading the table in and writing it out is also much faster than an
     ASCII table.

     When you are dealing with integer numbers, the compression ratio
     can be even better, for example if you know all of the values in a
     column are positive and less than ‘255’, you can use the ‘unsigned
     char’ type which only takes one byte!  If they are between ‘-128’
     and ‘127’, then you can use the (signed) ‘char’ type.  So if you
     are thoughtful about the limits of your integer columns, you can
     greatly reduce the size of your file and also the speed at which it
     is read/written.  This can be very useful when sharing your results
     with collaborators or publishing them.  To decrease the file size
     even more you can name your output as ending in ‘.fits.gz’ so it is
     also compressed after creation.  Just note that
     compression/decompressing is CPU intensive and can slow down the
     writing/reading of the file.

     Fortunately the FITS Binary table format also accepts ASCII strings
     as column types (along with the various numerical types).  So your
     dataset can also contain non-numerical columns.

* Menu:

* Gnuastro text table format::  Reading plain text tables


File: gnuastro.info,  Node: Gnuastro text table format,  Next: Selecting table columns,  Prev: Recognized table formats,  Up: Tables

4.7.2 Gnuastro text table format
--------------------------------

Plain text files are the most generic, portable, and easiest way to
(manually) create, (visually) inspect, or (manually) edit a table.  In
this format, the ending of a row is defined by the new-line character (a
line on a text editor).  So when you view it on a text editor, every row
will occupy one line.  The delimiters (or characters separating the
columns) are white space characters (space, horizontal tab, vertical
tab) and a comma (<,>).  The only further requirement is that all
rows/lines must have the same number of columns.

   The columns don’t have to be exactly under each other and the rows
can be arbitrarily long with different lengths.  For example the
following contents in a file would be interpreted as a table with 4
columns and 2 rows, with each element interpreted as a ‘double’ type
(see *note Numeric data types::).

     1     2.234948   128   39.8923e8
     2 , 4.454        792     72.98348e7

   However, the example above has no other information about the columns
(it is just raw data, with no meta-data).  To use this table, you have
to remember what the numbers in each column represent.  Also, when you
want to select columns, you have to count their position within the
table.  This can become frustrating and prone to bad errors (getting the
columns wrong) especially as the number of columns increase.  It is also
bad for sending to a colleague, because they will find it hard to
remember/use the columns properly.

   To solve these problems in Gnuastro’s programs/libraries you aren’t
limited to using the column’s number, see *note Selecting table
columns::.  If the columns have names, units, or comments you can also
select your columns based on searches/matches in these fields, for
example see *note Table::.  Also, in this manner, you can’t guide the
program reading the table on how to read the numbers.  As an example,
the first and third columns above can be read as integer types: the
first column might be an ID and the third can be the number of pixels an
object occupies in an image.  So there is no need to read these to
columns as a ‘double’ type (which takes more memory, and is slower).

   In the bare-minimum example above, you also can’t use strings of
characters, for example the names of filters, or some other identifier
that includes non-numerical characters.  In the absence of any
information, only numbers can be read robustly.  Assuming we read
columns with non-numerical characters as string, there would still be
the problem that the strings might contain space (or any delimiter)
character for some rows.  So, each ‘word’ in the string will be
interpreted as a column and the program will abort with an error that
the rows don’t have the same number of columns.

   To correct for these limitations, Gnuastro defines the following
convention for storing the table meta-data along with the raw data in
one plain text file.  The format is primarily designed for ease of
reading/writing by eye/fingers, but is also structured enough to be read
by a program.

   When the first non-white character in a line is <#>, or there are no
non-white characters in it, then the line will not be considered as a
row of data in the table (this is a pretty standard convention in many
programs, and higher level languages).  In the former case, the line is
interpreted as a _comment_.  If the comment line starts with ‘‘# Column
N:’’, then it is assumed to contain information about column ‘N’ (a
number, counting from 1).  Comment lines that don’t start with this
pattern are ignored and you can use them to include any further
information you want to store with the table in the text file.  A column
information comment is assumed to have the following format:

     # Column N: NAME [UNIT, TYPE, BLANK] COMMENT

Any sequence of characters between ‘<:>’ and ‘<[>’ will be interpreted
as the column name (so it can contain anything except the ‘<[>’
character).  Anything between the ‘<]>’ and the end of the line is
defined as a comment.  Within the brackets, anything before the first
‘<,>’ is the units (physical units, for example km/s, or erg/s),
anything before the second ‘<,>’ is the short type identifier (see
below, and *note Numeric data types::).  Finally (still within the
brackets), any non-white characters after the second ‘<,>’ are
interpreted as the blank value for that column (see *note Blank
pixels::).  Note that blank values will be stored in the same type as
the column, not as a string(1).

   When a formatting problem occurs (for example you have specified the
wrong type code, see below), or the column was already given meta-data
in a previous comment, or the column number is larger than the actual
number of columns in the table (the non-commented or empty lines), then
the comment information line will be ignored.

   When a comment information line can be used, the leading and trailing
white space characters will be stripped from all of the elements.  For
example in this line:

     # Column 5:  column name   [km/s,    f32,-99] Redshift as speed

   The ‘NAME’ field will be ‘‘column name’’ and the ‘TYPE’ field will be
‘‘f32’’.  Note how all the white space characters before and after
strings are not used, but those in the middle remained.  Also, white
space characters aren’t mandatory.  Hence, in the example above, the
‘BLANK’ field will be given the value of ‘‘-99’’.

   Except for the column number (‘N’), the rest of the fields are
optional.  Also, the column information comments don’t have to be in
order.  In other words, the information for column $N+m$ ($m>0$) can be
given in a line before column $N$.  Also, you don’t have to specify
information for all columns.  Those columns that don’t have this
information will be interpreted with the default settings (like the case
above: values are double precision floating point, and the column has no
name, unit, or comment).  So these lines are all acceptable for any
table (the first one, with nothing but the column number is redundant):

     # Column 5:
     # Column 1: ID [,i8] The Clump ID.
     # Column 3: mag_f160w [AB mag, f32] Magnitude from the F160W filter

The data type of the column should be specified with one of the
following values:

   • For a numeric column, you can use any of the numeric types (and
     their recognized identifiers) described in *note Numeric data
     types::.
   • ‘‘strN’’: for strings.  The ‘N’ value identifies the length of the
     string (how many characters it has).  The start of the string on
     each row is the first non-delimiter character of the column that
     has the string type.  The next ‘N’ characters will be interpreted
     as a string and all leading and trailing white space will be
     removed.

     If the next column’s characters, are closer than ‘N’ characters to
     the start of the string column in that line/row, they will be
     considered part of the string column.  If there is a new-line
     character before the ending of the space given to the string column
     (in other words, the string column is the last column), then
     reading of the string will stop, even if the ‘N’ characters are not
     complete yet.  See ‘tests/table/table.txt’ for one example.
     Therefore, the only time you have to pay attention to the
     positioning and spaces given to the string column is when it is not
     the last column in the table.

     The only limitation in this format is that trailing and leading
     white space characters will be removed from the columns that are
     read.  In most cases, this is the desired behavior, but if trailing
     and leading white-spaces are critically important to your analysis,
     define your own starting and ending characters and remove them
     after the table has been read.  For example in the sample table
     below, the two ‘<|>’ characters (which are arbitrary) will remain
     in the value of the second column and you can remove them manually
     later.  If only one of the leading or trailing white spaces is
     important for your work, you can only use one of the ‘<|>’s.

          # Column 1: ID [label, u8]
          # Column 2: Notes [no unit, str50]
          1    leading and trailing white space is ignored here    2.3442e10
          2   |         but they will be preserved here        |   8.2964e11

   Note that the FITS binary table standard does not define the
‘unsigned int’ and ‘unsigned long’ types, so if you want to convert your
tables to FITS binary tables, use other types.  Also, note that in the
FITS ASCII table, there is only one integer type (‘long’).  So if you
convert a Gnuastro plain text table to a FITS ASCII table with the *note
Table:: program, the type information for integers will be lost.
Conversely if integer types are important for you, you have to manually
set them when reading a FITS ASCII table (for example with the Table
program when reading/converting into a file, or with the
‘gnuastro/table.h’ library functions when reading into memory).

   ---------- Footnotes ----------

   (1) For floating point types, the ‘nan’, or ‘inf’ strings (both not
case-sensitive) refer to IEEE NaN (not a number) and infinity values
respectively and will be stored as a floating point, so they are
acceptable.


File: gnuastro.info,  Node: Selecting table columns,  Prev: Gnuastro text table format,  Up: Tables

4.7.3 Selecting table columns
-----------------------------

At the lowest level, the only defining aspect of a column in a table is
its number, or position.  But selecting columns purely by number is not
very convenient and, especially when the tables are large it can be very
frustrating and prone to errors.  Hence, table file formats (for example
see *note Recognized table formats::) have ways to store additional
information about the columns (meta-data).  Some of the most common
pieces of information about each column are its _name_, the _units_ of
data in the it, and a _comment_ for longer/informal description of the
column’s data.

   To facilitate research with Gnuastro, you can select columns by
matching, or searching in these three fields, besides the low-level
column number.  To view the full list of information on the columns in
the table, you can use the Table program (see *note Table::) with the
command below (replace ‘table-file’ with the filename of your table, if
its FITS, you might also need to specify the HDU/extension which
contains the table):

     $ asttable --information table-file

   Gnuastro’s programs need the columns for different purposes, for
example in Crop, you specify the columns containing the central
coordinates of the crop centers with the ‘--coordcol’ option (see *note
Crop options::).  On the other hand, in MakeProfiles, to specify the
column containing the profile position angles, you must use the ‘--pcol’
option (see *note MakeProfiles catalog::).  Thus, there can be no
unified common option name to select columns for all programs (different
columns have different purposes).  However, when the program expects a
column for a specific context, the option names end in the ‘col’ suffix
like the examples above.  These options accept values in integer (column
number), or string (metadata match/search) format.

   If the value can be parsed as a positive integer, it will be seen as
the low-level column number.  Note that column counting starts from 1,
so if you ask for column 0, the respective program will abort with an
error.  When the value can’t be interpreted as an a integer number, it
will be seen as a string of characters which will be used to
match/search in the table’s meta-data.  The meta-data field which the
value will be compared with can be selected through the ‘--searchin’
option, see *note Input output options::.  ‘--searchin’ can take three
values: ‘name’, ‘unit’, ‘comment’.  The matching will be done following
this convention:

   • If the value is enclosed in two slashes (for example ‘-x/RA_/’, or
     ‘--coordcol=/RA_/’, see *note Crop options::), then it is assumed
     to be a regular expression with the same convention as GNU AWK. GNU
     AWK has a very well written chapter
     (https://www.gnu.org/software/gawk/manual/html_node/Regexp.html)
     describing regular expressions, so we we will not continue
     discussing them here.  Regular expressions are a very powerful tool
     in matching text and useful in many contexts.  We thus strongly
     encourage reviewing this chapter for greatly improving the quality
     of your work in many cases, not just for searching column meta-data
     in Gnuastro.

   • When the string isn’t enclosed between ‘</>’s, any column that
     exactly matches the given value in the given field will be
     selected.

   Note that in both cases, you can ignore the case of alphabetic
characters with the ‘--ignorecase’ option, see *note Input output
options::.  Also, in both cases, multiple columns may be selected with
one call to this function.  In this case, the order of the selected
columns (with one call) will be the same order as they appear in the
table.


File: gnuastro.info,  Node: Tessellation,  Next: Automatic output,  Prev: Tables,  Up: Common program behavior

4.8 Tessellation
================

It is sometimes necessary to classify the elements in a dataset (for
example pixels in an image) into a grid of individual, non-overlapping
tiles.  For example when background sky gradients are present in an
image, you can define a tile grid over the image.  When the tile sizes
are set properly, the background’s variation over each tile will be
negligible, allowing you to measure (and subtract) it.  In other cases
(for example spatial domain convolution in Gnuastro, see *note
Convolve::), it might simply be for speed of processing: each tile can
be processed independently on a separate CPU thread.  In the arts and
mathematics, this process is formally known as tessellation
(https://en.wikipedia.org/wiki/Tessellation).

   The size of the regular tiles (in units of data-elements, or pixels
in an image) can be defined with the ‘--tilesize’ option.  It takes
multiple numbers (separated by a comma) which will be the length along
the respective dimension (in FORTRAN/FITS dimension order).  Divisions
are also acceptable, but must result in an integer.  For example
‘--tilesize=30,40’ can be used for an image (a 2D dataset).  The regular
tile size along the first FITS axis (horizontal when viewed in SAO ds9)
will be 30 pixels and along the second it will be 40 pixels.  Ideally,
‘--tilesize’ should be selected such that all tiles in the image have
exactly the same size.  In other words, that the dataset length in each
dimension is divisible by the tile size in that dimension.

   However, this is not always possible: the dataset can be any size and
every pixel in it is valuable.  In such cases, Gnuastro will look at the
significance of the remainder length, if it is not significant (for
example one or two pixels), then it will just increase the size of the
first tile in the respective dimension and allow the rest of the tiles
to have the required size.  When the remainder is significant (for
example one pixel less than the size along that dimension), the
remainder will be added to one regular tile’s size and the large tile
will be cut in half and put in the two ends of the grid/tessellation.
In this way, all the tiles in the central regions of the dataset will
have the regular tile sizes and the tiles on the edge will be slightly
larger/smaller depending on the remainder significance.  The fraction
which defines the remainder significance along all dimensions can be set
through ‘--remainderfrac’.

   The best tile size is directly related to the spatial properties of
the property you want to study (for example, gradient on the image).  In
practice we assume that the gradient is not present over each tile.  So
if there is a strong gradient (for example in long wavelength ground
based images) or the image is of a crowded area where there isn’t too
much blank area, you have to choose a smaller tile size.  A larger mesh
will give more pixels and and so the scatter in the results will be less
(better statistics).

   For raw image processing, a single tessellation/grid is not
sufficient.  Raw images are the unprocessed outputs of the camera
detectors.  Modern detectors usually have multiple readout channels each
with its own amplifier.  For example the Hubble Space Telescope Advanced
Camera for Surveys (ACS) has four amplifiers over its full detector area
dividing the square field of view to four smaller squares.  Ground based
image detectors are not exempt, for example each CCD of Subaru
Telescope’s Hyper Suprime-Cam camera (which has 104 CCDs) has four
amplifiers, but they have the same height of the CCD and divide the
width by four parts.

   The bias current on each amplifier is different, and initial bias
subtraction is not perfect.  So even after subtracting the measured bias
current, you can usually still identify the boundaries of different
amplifiers by eye.  See Figure 11(a) in Akhlaghi and Ichikawa (2015) for
an example.  This results in the final reduced data to have non-uniform
amplifier-shaped regions with higher or lower background flux values.
Such systematic biases will then propagate to all subsequent
measurements we do on the data (for example photometry and subsequent
stellar mass and star formation rate measurements in the case of
galaxies).

   Therefore an accurate analysis requires a two layer tessellation: the
top layer contains larger tiles, each covering one amplifier channel.
For clarity we’ll call these larger tiles “channels”.  The number of
channels along each dimension is defined through the ‘--numchannels’.
Each channel is then covered by its own individual smaller tessellation
(with tile sizes determined by the ‘--tilesize’ option).  This will
allow independent analysis of two adjacent pixels from different
channels if necessary.  If the image is processed or the detector only
has one amplifier, you can set the number of channels in both dimension
to 1.

   The final tessellation can be inspected on the image with the
‘--checktiles’ option that is available to all programs which use
tessellation for localized operations.  When this option is called, a
FITS file with a ‘_tiled.fits’ suffix will be created along with the
outputs, see *note Automatic output::.  Each pixel in this image has the
number of the tile that covers it.  If the number of channels in any
dimension are larger than unity, you will notice that the tile IDs are
defined such that the first channels is covered first, then the second
and so on.  For the full list of processing-related common options
(including tessellation options), please see *note Processing options::.


File: gnuastro.info,  Node: Automatic output,  Next: Output FITS files,  Prev: Tessellation,  Up: Common program behavior

4.9 Automatic output
====================

All the programs in Gnuastro are designed such that specifying an output
file or directory (based on the program context) is optional.  When no
output name is explicitly given (with ‘--output’, see *note Input output
options::), the programs will automatically set an output name based on
the input name(s) and what the program does.  For example when you are
using ConvertType to save FITS image named ‘dataset.fits’ to a JPEG
image and don’t specify a name for it, the JPEG output file will be name
‘dataset.jpg’.  When the input is from the standard input (for example a
pipe, see *note Standard input::), and ‘--output’ isn’t given, the
output name will be the program’s name (for example ‘converttype.jpg’).

   Another very important part of the automatic output generation is
that all the directory information of the input file name is stripped
off of it.  This feature can be disabled with the ‘--keepinputdir’
option, see *note Input output options::.  It is the default because
astronomical data are usually very large and organized specially with
special file names.  In some cases, the user might not have write
permissions in those directories(1).

   Let’s assume that we are working on a report and want to process the
FITS images from two projects (ABC and DEF), which are stored in the
sub-directories named ‘ABCproject/’ and ‘DEFproject/’ of our top data
directory (‘/mnt/data’).  The following shell commands show how one
image from the former is first converted to a JPEG image through
ConvertType and then the objects from an image in the latter project are
detected using NoiseChisel.  The text after the ‘#’ sign are comments
(not typed!).

     $ pwd                                               # Current location
     /home/usrname/research/report
     $ ls                                         # List directory contents
     ABC01.jpg
     $ ls /mnt/data/ABCproject                                  # Archive 1
     ABC01.fits ABC02.fits ABC03.fits
     $ ls /mnt/data/DEFproject                                  # Archive 2
     DEF01.fits DEF02.fits DEF03.fits
     $ astconvertt /mnt/data/ABCproject/ABC02.fits --output=jpg    # Prog 1
     $ ls
     ABC01.jpg ABC02.jpg
     $ astnoisechisel /mnt/data/DEFproject/DEF01.fits              # Prog 2
     $ ls
     ABC01.jpg ABC02.jpg DEF01_detected.fits

   ---------- Footnotes ----------

   (1) In fact, even if the data is stored on your own computer, it is
advised to only grant write permissions to the super user or root.  This
way, you won’t accidentally delete or modify your valuable data!


File: gnuastro.info,  Node: Output FITS files,  Prev: Automatic output,  Up: Common program behavior

4.10 Output FITS files
======================

The output of many of Gnuastro’s programs are (or can be) FITS files.
The FITS format has many useful features for storing scientific datasets
(cubes, images and tables) along with a robust features for
archivability.  For more on this standard, please see *note Fits::.

   As a community convention described in *note Fits::, the first
extension of all FITS files produced by Gnuastro’s programs only
contains the meta-data that is intended for the file’s extension(s).
For a Gnuastro program, this generic meta-data (that is stored as FITS
keyword records) is its configuration when it produced this dataset:
file name(s) of input(s) and option names, values and comments.  Note
that when the configuration is too trivial (only input filename, for
example the program *note Table::) no meta-data is written in this
extension.

   FITS keywords have the following limitations in regards to generic
option names and values which are described below:

   • If a keyword (option name) is longer than 8 characters, the first
     word in the record (80 character line) is ‘HIERARCH’ which is
     followed by the keyword name.

   • Values can be at most 75 characters, but for strings, this changes
     to 73 (because of the two extra <'> characters that are necessary).
     However, if the value is a file name, containing slash (</>)
     characters to separate directories, Gnuastro will break the value
     into multiple keywords.

   • Keyword names ignore case, therefore they are all in capital
     letters.  Therefore, if you want to use Grep to inspect these
     keywords, use the ‘-i’ option, like the example below.

          $ astfits image_detected.fits -h0 | grep -i snquant

   The keywords above are classified (separated by an empty line and
title) as a group titled “ProgramName configuration”.  This meta-data
extension, as well as all the other extensions (which contain data),
also contain have final group of keywords to keep the basic date and
version information of Gnuastro, its dependencies and the pipeline that
is using Gnuastro (if its under version control).

‘DATE’
     The creation time of the FITS file.  This date is written directly
     by CFITSIO and is in UT format.

‘COMMIT’
     Git’s commit description from the running directory of Gnuastro’s
     programs.  If the running directory is not version controlled or
     ‘libgit2’ isn’t installed (see *note Optional dependencies::) then
     this keyword will not be present.  The printed value is equivalent
     to the output of the following command:

          git describe --dirty --always

     If the running directory contains non-committed work, then the
     stored value will have a ‘‘-dirty’’ suffix.  This can be very
     helpful to let you know that the data is not ready to be shared
     with collaborators or submitted to a journal.  You should only
     share results that are produced after all your work is committed
     (safely stored in the version controlled history and thus
     reproducible).

     At first sight, version control appears to be mainly a tool for
     software developers.  However progress in a scientific research is
     almost identical to progress in software development: first you
     have a rough idea that starts with handful of easy steps.  But as
     the first results appear to be promising, you will have to extend,
     or generalize, it to make it more robust and work in all the
     situations your research covers, not just your first test samples.
     Slowly you will find wrong assumptions or bad implementations that
     need to be fixed (‘bugs’ in software development parlance).
     Finally, when you submit the research to your collaborators or a
     journal, many comments and suggestions will come in, and you have
     to address them.

     Software developers have created version control systems precisely
     for this kind of activity.  Each significant moment in the
     project’s history is called a “commit”, see *note Version
     controlled source::.  A snapshot of the project in each “commit” is
     safely stored away, so you can revert back to it at a later time,
     or check changes/progress.  This way, you can be sure that your
     work is reproducible and track the progress and history.  With
     version control, experimentation in the project’s analysis is
     greatly facilitated, since you can easily revert back if a
     brainstorm test procedure fails.

     One important feature of version control is that the research
     result (FITS image, table, report or paper) can be stamped with the
     unique commit information that produced it.  This information will
     enable you to exactly reproduce that same result later, even if you
     have made changes/progress.  For one example of a research paper’s
     reproduction pipeline, please see the reproduction pipeline
     (https://gitlab.com/makhlaghi/NoiseChisel-paper) of the paper
     (https://arxiv.org/abs/1505.01664) describing *note NoiseChisel::.

‘CFITSIO’
     The version of CFITSIO used (see *note CFITSIO::).

‘WCSLIB’
     The version of WCSLIB used (see *note WCSLIB::).  Note that older
     versions of WCSLIB do not report the version internally.  So this
     is only available if you are using more recent WCSLIB versions.

‘GSL’
     The version of GNU Scientific Library that was used, see *note GNU
     Scientific Library::.

‘GNUASTRO’
     The version of Gnuastro used (see *note Version numbering::).

   Here is one example of the last few lines of an example output.

                   / Versions and date
     DATE    = '...'                / file creation date
     COMMIT  = 'v0-8-g547f6eb'      / Commit description in running dir.
     CFITSIO = '3.45    '           / CFITSIO version.
     WCSLIB  = '5.19    '           / WCSLIB version.
     GSL     = '2.5     '           / GNU Scientific Library version.
     GNUASTRO= '0.7     '           / GNU Astronomy Utilities version.
     END


File: gnuastro.info,  Node: Data containers,  Next: Data manipulation,  Prev: Common program behavior,  Up: Top

5 Data containers
*****************

The most low-level and basic property of a dataset is how it is stored.
To process, archive and transmit the data, you need a container to store
it first.  From the start of the computer age, different formats have
been defined to store data, optimized for particular applications.  One
format/container can never be useful for all applications: the storage
defines the application and vice-versa.  In astronomy, the Flexible
Image Transport System (FITS) standard has become the most common format
of data storage and transmission.  It has many useful features, for
example multiple sub-containers (also known as extensions or header data
units, HDUs) within one file, or support for tables as well as images.
Each HDU can store an independent dataset and its corresponding
meta-data.  Therefore, Gnuastro has one program (see *note Fits::)
specifically designed to manipulate FITS HDUs and the meta-data (header
keywords) in each HDU.

   Your astronomical research does not just involve data analysis (where
the FITS format is very useful).  For example you want to demonstrate
your raw and processed FITS images or spectra as figures within slides,
reports, or papers.  The FITS format is not defined for such
applications.  Thus, Gnuastro also comes with the ConvertType program
(see *note ConvertType::) which can be used to convert a FITS image to
and from (where possible) other formats like plain text and JPEG (which
allow two way conversion), along with EPS and PDF (which can only be
created from FITS, not the other way round).

   Finally, the FITS format is not just for images, it can also store
tables.  Binary tables in particular can be very efficient in storing
catalogs that have more than a few tens of columns and rows.  However,
unlike images (where all elements/pixels have one data type), tables
contain multiple columns and each column can have different properties:
independent data types (see *note Numeric data types::) and meta-data.
In practice, each column can be viewed as a separate container that is
grouped with others in the table.  The only shared property of the
columns in a table is thus the number of elements they contain.  To
allow easy inspection/manipulation of table columns, Gnuastro has the
Table program (see *note Table::).  It can be used to select certain
table columns in a FITS table and see them as a human readable output on
the command-line, or to save them into another plain text or FITS table.

* Menu:

* Fits::                        View and manipulate extensions and keywords.
* Sort FITS files by night::    Installed script to sort FITS files by obs night.
* ConvertType::                 Convert data to various formats.
* Table::                       Read and Write FITS tables to plain text.


File: gnuastro.info,  Node: Fits,  Next: Sort FITS files by night,  Prev: Data containers,  Up: Data containers

5.1 Fits
========

The “Flexible Image Transport System”, or FITS, is by far the most
common data container format in astronomy and in constant use since the
1970s.  Archiving (future usage, simplicity) has been one of the primary
design principles of this format.  In the last few decades it has proved
so useful and robust that the Vatican Library has also chosen FITS for
its “long-term digital preservation” project(1).

   Although the full name of the standard invokes the idea that it is
only for images, it also contains complete and robust features for
tables.  It started off in the 1970s and was formally published as a
standard in 1981, it was adopted by the International Astronomical Union
(IAU) in 1982 and an IAU working group to maintain its future was
defined in 1988.  The FITS 2.0 and 3.0 standards were approved in 2000
and 2008 respectively, and the 4.0 draft has also been released
recently, please see the FITS standard document webpage
(https://fits.gsfc.nasa.gov/fits_standard.html) for the full text of all
versions.  Also see the FITS 3.0 standard paper
(https://doi.org/10.1051/0004-6361/201015362) for a nice introduction
and history along with the full standard.

   Many common image formats, for example a JPEG, only have one
image/dataset per file, however one great advantage of the FITS standard
is that it allows you to keep multiple datasets (images or tables along
with their separate meta-data) in one file.  In the FITS standard, each
data + metadata is known as an extension, or more formally a header data
unit or HDU. The HDUs in a file can be completely independent: you can
have multiple images of different dimensions/sizes or tables as separate
extensions in one file.  However, while the standard doesn’t impose any
constraints on the relation between the datasets, it is strongly
encouraged to group data that are contextually related with each other
in one file.  For example an image and the table/catalog of objects and
their measured properties in that image.  Other examples can be images
of one patch of sky in different colors (filters), or one raw telescope
image along with its calibration data (tables or images).

   As discussed above, the extensions in a FITS file can be completely
independent.  To keep some information (meta-data) about the group of
extensions in the FITS file, the community has adopted the following
convention: put no data in the first extension, so it is just meta-data.
This extension can thus be used to store Meta-data regarding the whole
file (grouping of extensions).  Subsequent extensions may contain data
along with their own separate meta-data.  All of Gnuastro’s programs
also follow this convention: the main output dataset(s) are placed in
the second (or later) extension(s).  The first extension contains no
data the program’s configuration (input file name, along with all its
option values) are stored as its meta-data, see *note Output FITS
files::.

   The meta-data contain information about the data, for example which
region of the sky an image corresponds to, the units of the data, what
telescope, camera, and filter the data were taken with, it observation
date, or the software that produced it and its configuration.  Without
the meta-data, the raw dataset is practically just a collection of
numbers and really hard to understand, or connect with the real world
(other datasets).  It is thus strongly encouraged to supplement your
data (at any level of processing) with as much meta-data about your
processing/science as possible.

   The meta-data of a FITS file is in ASCII format, which can be easily
viewed or edited with a text editor or on the command-line.  Each
meta-data element (known as a keyword generally) is composed of a name,
value, units and comments (the last two are optional).  For example
below you can see three FITS meta-data keywords for specifying the world
coordinate system (WCS, or its location in the sky) of a dataset:

     LATPOLE =           -27.805089 / [deg] Native latitude of celestial pole
     RADESYS = 'FK5'                / Equatorial coordinate system
     EQUINOX =               2000.0 / [yr] Equinox of equatorial coordinates

   However, there are some limitations which discourage viewing/editing
the keywords with text editors.  For example there is a fixed length of
80 characters for each keyword (its name, value, units and comments) and
there are no new-line characters, so on a text editor all the keywords
are seen in one line.  Also, the meta-data keywords are immediately
followed by the data which are commonly in binary format and will show
up as strange looking characters on a text editor, and significantly
slowing down the processor.

   Gnuastro’s Fits program was designed to allow easy manipulation of
FITS extensions and meta-data keywords on the command-line while
conforming fully with the FITS standard.  For example you can copy or
cut (copy and remove) HDUs/extensions from one FITS file to another, or
completely delete them.  It also has features to delete, add, or edit
meta-data keywords within one HDU.

* Menu:

* Invoking astfits::            Arguments and options to Header.

   ---------- Footnotes ----------

   (1) <https://www.vaticanlibrary.va/home.php?pag=progettodigit>


File: gnuastro.info,  Node: Invoking astfits,  Prev: Fits,  Up: Fits

5.1.1 Invoking Fits
-------------------

Fits can print or manipulate the FITS file HDUs (extensions), meta-data
keywords in a given HDU. The executable name is ‘astfits’ with the
following general template

     $ astfits [OPTION...] ASTRdata

One line examples:

     ## View general information about every extension:
     $ astfits image.fits

     ## Print the header keywords in the second HDU (counting from 0):
     $ astfits image.fits -h1

     ## Only print header keywords that contain `NAXIS':
     $ astfits image.fits -h1 | grep NAXIS

     ## Only print the WCS standard PC matrix elements
     $ astfits image.fits -h1 | grep 'PC._.'

     ## Copy a HDU from input.fits to out.fits:
     $ astfits input.fits --copy=hdu-name --output=out.fits

     ## Update the OLDKEY keyword value to 153.034:
     $ astfits --update=OLDKEY,153.034,"Old keyword comment"

     ## Delete one COMMENT keyword and add a new one:
     $ astfits --delete=COMMENT --comment="Anything you like ;-)."

     ## Write two new keywords with different values and comments:
     $ astfits --write=MYKEY1,20.00,"An example keyword" --write=MYKEY2,fd

   When no action is requested (and only a file name is given), Fits
will print a list of information about the extension(s) in the file.
This information includes the HDU number, HDU name (‘EXTNAME’ keyword),
type of data (see *note Numeric data types::, and the number of data
elements it contains (size along each dimension for images and table
rows and columns).  You can use this to get a general idea of the
contents of the FITS file and what HDU to use for further processing,
either with the Fits program or any other Gnuastro program.

   Here is one example of information about a FITS file with four
extensions: the first extension has no data, it is a purely meta-data
HDU (commonly used to keep meta-data about the whole file, or grouping
of extensions, see *note Fits::).  The second extension is an image with
name ‘IMAGE’ and single precision floating point type (‘float32’, see
*note Numeric data types::), it has 4287 pixels along its first
(horizontal) axis and 4286 pixels along its second (vertical) axis.  The
third extension is also an image with name ‘MASK’.  It is in 2-byte
integer format (‘int16’) which is commonly used to keep information
about pixels (for example to identify which ones were saturated, or
which ones had cosmic rays and so on), note how it has the same size as
the ‘IMAGE’ extension.  The third extension is a binary table called
‘CATALOG’ which has 12371 rows and 5 columns (it probably contains
information about the sources in the image).

     GNU Astronomy Utilities X.X
     Run on Day Month DD HH:MM:SS YYYY
     -----
     HDU (extension) information: `image.fits'.
      Column 1: Index (counting from 0).
      Column 2: Name (`EXTNAME' in FITS standard).
      Column 3: Image data type or `table' format (ASCII or binary).
      Column 4: Size of data in HDU.
     -----
     0      n/a             uint8           0
     1      IMAGE           float32         4287x4286
     2      MASK            int16           4287x4286
     3      CATALOG         table_binary    12371x5

   If a specific HDU is identified on the command-line with the ‘--hdu’
(or ‘-h’ option) and no operation requested, then the full list of
header keywords in that HDU will be printed (as if the ‘--printallkeys’
was called, see below).  It is important to remember that this only
occurs when ‘--hdu’ is given on the command-line.  The ‘--hdu’ value
given in a configuration file will only be used when a specific
operation on keywords requested.  Therefore as described in the
paragraphs above, when no explicit call to the ‘--hdu’ option is made on
the command-line and no operation is requested (on the command-line or
configuration files), the basic information of each HDU/extension is
printed.

   The operating mode and input/output options to Fits are similar to
the other programs and fully described in *note Common options::.  The
options particular to Fits can be divided into two groups: 1) those
related to modifying HDUs or extensions (see *note HDU manipulation::),
and 2) those related to viewing/modifying meta-data keywords (see *note
Keyword manipulation::).  These two classes of options cannot be called
together in one run: you can either work on the extensions or meta-data
keywords in any instance of Fits.

* Menu:

* HDU manipulation::            Manipulate HDUs within a FITS file.
* Keyword manipulation::        Manipulate metadata keywords in a HDU


File: gnuastro.info,  Node: HDU manipulation,  Next: Keyword manipulation,  Prev: Invoking astfits,  Up: Invoking astfits

5.1.1.1 HDU manipulation
........................

Each header data unit, or HDU (also known as an extension), in a FITS
file is an independent dataset (data + meta-data).  Multiple HDUs can be
stored in one FITS file, see *note Fits::.  The HDU modifying options to
the Fits program are listed below.

   These options may be called multiple times in one run.  If so, the
extensions will be copied from the input FITS file to the output FITS
file in the given order (on the command-line and also in configuration
files, see *note Configuration file precedence::).  If the separate
classes are called together in one run of Fits, then first ‘--copy’ is
run (on all specified HDUs), followed by ‘--cut’ (again on all specified
HDUs), and then ‘--remove’ (on all specified HDUs).

   The ‘--copy’ and ‘--cut’ options need an output FITS file (specified
with the ‘--output’ option).  If the output file exists, then the
specified HDU will be copied following the last extension of the output
file (the existing HDUs in it will be untouched).  Thus, after Fits
finishes, the copied HDU will be the last HDU of the output file.  If no
output file name is given, then automatic output will be used to store
the HDUs given to this option (see *note Automatic output::).

‘-n’
‘--numhdus’
     Print the number of extensions/HDUs in the given file.  Note that
     this option must be called alone and will only print a single
     number.  It is thus useful in scripts, for example when you need to
     do check the number of extensions in a FITS file.

     For a complete list of basic meta-data on the extensions in a FITS
     file, don’t use any of the options in this section or in *note
     Keyword manipulation::.  For more, see *note Invoking astfits::.

‘--datasum’
     Calculate and print the given HDU’s "datasum" to stdout.  The given
     HDU is specified with the ‘--hdu’ (or ‘-h’) option.  This number is
     calculated by parsing all the bytes of the given HDU’s data records
     (excluding keywords).  This option ignores any possibly existing
     ‘DATASUM’ keyword in the HDU. For more on the datasum feature of
     the FITS standard, see *note Keyword manipulation:: (under the
     ‘checksum’ component of ‘--write’).

     You can use this option to confirm that the data in two different
     HDUs (possibly with different keywords) is identical.  Its
     advantage over ‘--write=datasum’ (which writes the ‘DATASUM’
     keyword into the given HDU) is that it doesn’t require write
     permissions.

‘-C STR’
‘--copy=STR’
     Copy the specified extension into the output file, see explanations
     above.

‘-k STR’
‘--cut=STR’
     Cut (copy to output, remove from input) the specified extension
     into the output file, see explanations above.

‘-R STR’
‘--remove=STR’
     Remove the specified HDU from the input file.

     The first (zero-th) HDU cannot be removed with this option.
     Consider using ‘--copy’ or ‘--cut’ in combination with
     ‘primaryimghdu’ to not have an empty zero-th HDU. From CFITSIO: “In
     the case of deleting the primary array (the first HDU in the file)
     then [it] will be replaced by a null primary array containing the
     minimum set of required keywords and no data.”.  So in practice,
     any existing data (array) and meta-data in the first extension will
     be removed, but the number of extensions in the file won’t change.
     This is because of the unique position the first FITS extension has
     in the FITS standard (for example it cannot be used to store
     tables).

‘--primaryimghdu’
     Copy or cut an image HDU to the zero-th HDU/extension a file that
     doesn’t yet exist.  This option is thus irrelevant if the output
     file already exists or the copied/cut extension is a FITS table.
     For example with the commands below, first we make sure that
     ‘out.fits’ doesn’t exist, then we copy the first extension of
     ‘in.fits’ to the zero-th extension of ‘out.fits’.

          $ rm -f out.fits
          $ astfits in.fits --copy=1 --primaryimghdu --output=out.fits

     If we hadn’t used ‘--primaryimghdu’, then the zero-th extension of
     ‘out.fits’ would have no data, and its second extension would host
     the copied image (just like any other output of Gnuastro).


File: gnuastro.info,  Node: Keyword manipulation,  Prev: HDU manipulation,  Up: Invoking astfits

5.1.1.2 Keyword manipulation
............................

The meta-data in each header data unit, or HDU (also known as extension,
see *note Fits::) is stored as “keyword”s.  Each keyword consists of a
name, value, unit, and comments.  The Fits program (see *note Fits::)
options related to viewing and manipulating keywords in a FITS HDU are
described below.

   To see the full list of keywords in a FITS HDU, you can use the
‘--printallkeys’ option.  If any of the keywords are to be modified, the
headers of the input file will be changed.  If you want to keep the
original FITS file or HDU, it is easiest to create a copy first and then
run Fits on that.  In the FITS standard, keywords are always uppercase.
So case does not matter in the input or output keyword names you
specify.

   Most of the options can accept multiple instances in one command.
For example you can add multiple keywords to delete by calling
‘--delete’ multiple times, since repeated keywords are allowed, you can
even delete the same keyword multiple times.  The action of such options
will start from the top most keyword.

   The precedence of operations are described below.  Note that while
the order within each class of actions is preserved, the order of
individual actions is not.  So irrespective of what order you called
‘--delete’ and ‘--update’.  First, all the delete operations are going
to take effect then the update operations.
  1. ‘--delete’
  2. ‘--rename’
  3. ‘--update’
  4. ‘--write’
  5. ‘--asis’
  6. ‘--history’
  7. ‘--comment’
  8. ‘--date’
  9. ‘--printallkeys’
  10. ‘--verify’
  11. ‘--copykeys’
All possible syntax errors will be reported before the keywords are
actually written.  FITS errors during any of these actions will be
reported, but Fits won’t stop until all the operations are complete.  If
‘--quitonerror’ is called, then Fits will immediately stop upon the
first error.

   If you want to inspect only a certain set of header keywords, it is
easiest to pipe the output of the Fits program to GNU Grep.  Grep is a
very powerful and advanced tool to search strings which is precisely
made for such situations.  For example if you only want to check the
size of an image FITS HDU, you can run:

     $ astfits input.fits | grep NAXIS

*FITS STANDARD KEYWORDS:* Some header keywords are necessary for later
operations on a FITS file, for example BITPIX or NAXIS, see the FITS
standard for their full list.  If you modify (for example remove or
rename) such keywords, the FITS file extension might not be usable any
more.  Also be careful for the world coordinate system keywords, if you
modify or change their values, any future world coordinate system (like
RA and Dec) measurements on the image will also change.

The keyword related options to the Fits program are fully described
below.

‘-a STR’
‘--asis=STR’
     Write ‘STR’ exactly into the FITS file header with no
     modifications.  If it does not conform to the FITS standards, then
     it might cause trouble, so please be very careful with this option.
     If you want to define the keyword from scratch, it is best to use
     the ‘--write’ option (see below) and let CFITSIO worry about the
     standards.  The best way to use this option is when you want to add
     a keyword from one FITS file to another unchanged and untouched.
     Below is an example of such a case that can be very useful
     sometimes (on the command-line or in scripts):

          $ key=$(astfits firstimage.fits | grep KEYWORD)
          $ astfits --asis="$key" secondimage.fits

     In particular note the double quotation signs (<">) around the
     reference to the ‘key’ shell variable (‘$key’).  FITS keywords
     usually have lots of space characters, if this variable is not
     quoted, the shell will only give the first word in the full keyword
     to this option, which will definitely be a non-standard FITS
     keyword and will make it hard to work on the file afterwords.  See
     the “Quoting” section of the GNU Bash manual for more information
     if your keyword has the special characters <$>, <`>, or <\>.

‘-d STR’
‘--delete=STR’
     Delete one instance of the ‘STR’ keyword from the FITS header.
     Multiple instances of ‘--delete’ can be given (possibly even for
     the same keyword, when its repeated in the meta-data).  All
     keywords given will be removed from the headers in the same given
     order.  If the keyword doesn’t exist, Fits will give a warning and
     return with a non-zero value, but will not stop.  To stop as soon
     as an error occurs, run with ‘--quitonerror’.

‘-r STR’
‘--rename=STR’
     Rename a keyword to a new value.  ‘STR’ contains both the existing
     and new names, which should be separated by either a comma (<,>) or
     a space character.  Note that if you use a space character, you
     have to put the value to this option within double quotation marks
     (<">) so the space character is not interpreted as an option
     separator.  Multiple instances of ‘--rename’ can be given in one
     command.  The keywords will be renamed in the specified order.  If
     the keyword doesn’t exist, Fits will give a warning and return with
     a non-zero value, but will not stop.  To stop as soon as an error
     occurs, run with ‘--quitonerror’.

‘-u STR’
‘--update=STR’
     Update a keyword, its value, its comments and its units in the
     format described below.  If there are multiple instances of the
     keyword in the header, they will be changed from top to bottom
     (with multiple ‘--update’ options).

     The format of the values to this option can best be specified with
     an example:

          --update=KEYWORD,value,"comments for this keyword",unit

     If there is a writing error, Fits will give a warning and return
     with a non-zero value, but will not stop.  To stop as soon as an
     error occurs, run with ‘--quitonerror’.

     The value can be any numerical or string value(1).  Other than the
     ‘KEYWORD’, all the other values are optional.  To leave a given
     token empty, follow the preceding comma (<,>) immediately with the
     next.  If any space character is present around the commas, it will
     be considered part of the respective token.  So if more than one
     token has space characters within it, the safest method to specify
     a value to this option is to put double quotation marks around each
     individual token that needs it.  Note that without double quotation
     marks, space characters will be seen as option separators and can
     lead to undefined behavior.

‘-w STR’
‘--write=STR’
     Write a keyword to the header.  For the possible value input
     formats, comments and units for the keyword, see the ‘--update’
     option above.  The special names (first string) below will cause a
     special behavior:

     ‘/’
          Write a “title” to the list of keywords.  A title consists of
          one blank line and another which is blank for several spaces
          and starts with a slash (</>).  The second string given to
          this option is the “title” or string printed after the slash.
          For example with the command below you can add a “title” of
          ‘My keywords’ after the existing keywords and add the
          subsequent ‘K1’ and ‘K2’ keywords under it (note that keyword
          names are not case sensitive).

               $ astfits test.fits -h1 --write=/,"My keywords" \
                         --write=k1,1.23,"My first keyword"    \
                         --write=k2,4.56,"My second keyword"
               $ astfits test.fits -h1
               [[[ ... truncated ... ]]]

                                     / My keywords
               K1      =                 1.23 / My first keyword
               K2      =                 4.56 / My second keyword
               END

          Adding a “title” before each contextually separate group of
          header keywords greatly helps in readability and visual
          inspection of the keywords.  So generally, when you want to
          add new FITS keywords, its good practice to also add a title
          before them.

          The reason you need to use </> as the keyword name for setting
          a title is that </> is the first non-white character.

          The title(s) is(are) written into the FITS with the same order
          that ‘--write’ is called.  Therefore in one run of the Fits
          program, you can specify many different titles (with their own
          keywords under them).  For example the command below that
          builds on the previous example and adds another group of
          keywords named ‘A1’ and ‘A2’.

               $ astfits test.fits -h1 --write=/,"My keywords"   \
                         --write=k1,1.23,"My first keyword"      \
                         --write=k2,4.56,"My second keyword"     \
                         --write=/,"My second group of keywords" \
                         --write=a1,7.89,"First keyword"         \
                         --write=a2,0.12,"Second keyword"

     ‘checksum’
          When nothing is given afterwards, the header integrity
          keywords ‘DATASUM’ and ‘CHECKSUM’ will be calculated and
          written/updated.  This is calculation and writing is done
          fully by CFITSIO. They thus comply with the FITS standard
          4.0(2) that defines these keywords (its Appendix J).

          If a value is given (e.g., ‘--write=checksum,MyOwnCheckSum’),
          then CFITSIO won’t be called to calculate these two keywords
          and the value (as well as possible comment and unit) will be
          written just like any other keyword.  This is generally not
          recommended, but necessary in special circumstances (for
          example when the checksum needs to be manually updated).

          ‘DATASUM’ only depends on the data section of the
          HDU/extension, so it is not changed when you update the
          keywords.  But ‘CHECKSUM’ also depends on the header and will
          not be valid if you make any further changes to the header.
          This includes any further keyword modification options in the
          same call to the Fits program.  Therefore it is recommended to
          write these keywords as the last keywords that are
          written/modified in the extension.  You can use the ‘--verify’
          option (described below) to verify the values of these two
          keywords.

     ‘datasum’
          Similar to ‘checksum’, but only write the ‘DATASUM’ keyword
          (that doesn’t depend on the header keywords, only the data).

‘-H STR’
‘--history STR’
     Add a ‘HISTORY’ keyword to the header with the given value.  A new
     ‘HISTORY’ keyword will be created for every instance of this
     option.  If the string given to this option is longer than 70
     characters, it will be separated into multiple keyword cards.  If
     there is an error, Fits will give a warning and return with a
     non-zero value, but will not stop.  To stop as soon as an error
     occurs, run with ‘--quitonerror’.

‘-c STR’
‘--comment STR’
     Add a ‘COMMENT’ keyword to the header with the given value.
     Similar to the explanation for ‘--history’ above.

‘-t’
‘--date’
     Put the current date and time in the header.  If the ‘DATE’ keyword
     already exists in the header, it will be updated.  If there is a
     writing error, Fits will give a warning and return with a non-zero
     value, but will not stop.  To stop as soon as an error occurs, run
     with ‘--quitonerror’.

‘-p’
‘--printallkeys’
     Print all the keywords in the specified FITS extension (HDU) on the
     command-line.  If this option is called along with any of the other
     keyword editing commands, as described above, all other editing
     commands take precedence to this.  Therefore, it will print the
     final keywords after all the editing has been done.

‘-v’
‘--verify’
     Verify the ‘DATASUM’ and ‘CHECKSUM’ data integrity keywords of the
     FITS standard.  See the description under the ‘checksum’ (under
     ‘--write’, above) for more on these keywords.

     This option will print ‘Verified’ for both keywords if they can be
     verified.  Otherwise, if they don’t exist in the given
     HDU/extension, it will print ‘NOT-PRESENT’, and if they cannot be
     verified it will print ‘INCORRECT’.  In the latter case (when the
     keyword values exist but can’t be verified), the Fits program will
     also return with a failure.

     By default this function will also print a short description of the
     ‘DATASUM’ AND ‘CHECKSUM’ keywords.  You can suppress this extra
     information with ‘--quiet’ option.

‘--copykeys=INT:INT’
     Copy the input’s keyword records in the given range (inclusive) to
     the output HDU (specified with the ‘--output’ and ‘--outhdu’
     options, for the filename and HDU/extension respectively).

     The given string to this option must be two integers separated by a
     colon (<:>).  The first integer must be positive (counting of the
     keyword records starts from 1).  The second integer may be negative
     (zero is not acceptable) or an integer larger than the first.

     A negative second integer means counting from the end.  So ‘-1’ is
     the last copy-able keyword (not including the ‘END’ keyword).

     To see the header keywords of the input with a number before them,
     you can pipe the output of the FITS program (when it prints all the
     keywords in an extension) into the ‘cat’ program like below:

          $ astfits input.fits -h1 | cat -n

‘--outhdu’
     The HDU/extension to write the output keywords of ‘--copykeys’.

‘-Q’
‘--quitonerror’
     Quit if any of the operations above are not successful.  By default
     if an error occurs, Fits will warn the user of the faulty keyword
     and continue with the rest of actions.

‘-s STR’
‘--datetosec STR’
     Interpret the value of the given keyword in the FITS date format
     (most generally: ‘YYYY-MM-DDThh:mm:ss.ddd...’) and return the
     corresponding Unix epoch time (number of seconds that have passed
     since 00:00:00 Thursday, January 1st, 1970).  The
     ‘Thh:mm:ss.ddd...’ section (specifying the time of day), and also
     the ‘.ddd...’ (specifying the fraction of a second) are optional.
     The value to this option must be the FITS keyword name that
     contains the requested date, for example ‘--datetosec=DATE-OBS’.

     This option can also interpret the older FITS date format
     (‘DD/MM/YYThh:mm:ss.ddd...’) where only two characters are given to
     the year.  In this case (following the GNU C Library), this option
     will make the following assumption: values 68 to 99 correspond to
     the years 1969 to 1999, and values 0 to 68 as the years 2000 to
     2068.

     This is a very useful option for operations on the FITS date
     values, for example sorting FITS files by their dates, or finding
     the time difference between two FITS files.  The advantage of
     working with the Unix epoch time is that you don’t have to worry
     about calendar details (for example the number of days in different
     months, or leap years, etc).

   ---------- Footnotes ----------

   (1) Some tricky situations arise with values like ‘‘87095e5’’, if
this was intended to be a number it will be kept in the header as
‘8709500000’ and there is no problem.  But this can also be a shortened
Git commit hash.  In the latter case, it should be treated as a string
and stored as it is written.  Commit hashes are very important in
keeping the history of a file during your research and such values might
arise without you noticing them in your reproduction pipeline.  One
solution is to use ‘git describe’ instead of the short hash alone.  A
less recommended solution is to add a space after the commit hash and
Fits will write the value as ‘‘87095e5 ’’ in the header.  If you later
compare the strings on the shell, the space character will be ignored by
the shell in the latter solution and there will be no problem.

   (2) <https://fits.gsfc.nasa.gov/standard40/fits_standard40aa-le.pdf>


File: gnuastro.info,  Node: Sort FITS files by night,  Next: ConvertType,  Prev: Fits,  Up: Data containers

5.2 Sort FITS files by night
============================

FITS images usually contain (several) keywords for preserving important
dates.  In particular, for lower-level data, this is usually the
observation date and time (for example, stored in the ‘DATE-OBS’ keyword
value).  When analyzing observed datasets, many calibration steps (like
the dark, bias or flat-field), are commonly calculated on a
per-observing-night basis.

   However, the FITS standard’s date format (‘YYYY-MM-DDThh:mm:ss.ddd’)
is based on the western (Gregorian) calendar.  Dates that are stored in
this format are complicated for automatic processing: a night starts in
the final hours of one calendar day, and extends to the early hours of
the next calendar day.  As a result, to identify datasets from one
night, we commonly need to search for two dates.  However calendar
peculiarities can make this identification very difficult.  For example
when an observation is done on the night separating two months (like the
night starting on March 31st and going into April 1st), or two years
(like the night starting on December 31st 2018 and going into January
1st, 2019).  To account for such situations, it is necessary to keep
track of how many days are in a month, and leap years, etc.

   Gnuastro’s ‘astscript-sort-by-night’ script is created to help in
such important scenarios.  It uses *note Fits:: to convert the FITS date
format into the Unix epoch time (number of seconds since 00:00:00 of
January 1st, 1970), using the ‘--datetosec’ option.  The Unix epoch time
is a single number (integer, if not given in sub-second precision),
enabling easy comparison and sorting of dates after January 1st, 1970.

   You can use this script as a basis for making a much more highly
customized sorting script.  Here are some examples

   • If you need to copy the files, but only need a single extension
     (not the whole file), you can add a step just before the making of
     the symbolic links, or copies, and change it to only copy a certain
     extension of the FITS file using the Fits program’s ‘--copy’
     option, see *note HDU manipulation::.

   • If you need to classify the files with finer detail (for example
     the purpose of the dataset), you can add a step just before the
     making of the symbolic links, or copies, to specify a file-name
     prefix based on other certain keyword values in the files.  For
     example when the FITS files have a keyword to specify if the
     dataset is a science, bias, or flat-field image.  You can read it
     and to add a ‘sci-’, ‘bias-’, or ‘flat-’ to the created file (after
     the ‘--prefix’) automatically.

     For example, let’s assume the observing mode is stored in the
     hypothetical ‘MODE’ keyword, which can have three values of
     ‘BIAS-IMAGE’, ‘SCIENCE-IMAGE’ and ‘FLAT-EXP’.  With the step below,
     you can generate a mode-prefix, and add it to the generated
     link/copy names (just correct the filename and extension of the
     first line to the script’s variables):

          modepref=$(astfits infile.fits -h1 \
                             | sed -e"s/'/ /g" \
                             | awk '$1=="MODE"{ \
                                 if($3=="BIAS-IMAGE") print "bias-"; \
                                 else if($3=="SCIENCE-IMAGE") print "sci-"; \
                                 else if($3==FLAT-EXP) print "flat-"; \
                                 else print $3, "NOT recognized"; exit 1}')

     Here is a description of it.  We first use ‘astfits’ to print all
     the keywords in extension ‘1’ of ‘infile.fits’.  In the FITS
     standard, string values (that we are assuming here) are placed in
     single quotes (<'>) which are annoying in this context/use-case.
     Therefore, we pipe the output of ‘astfits’ into ‘sed’ to remove all
     such quotes (substituting them with a blank space).  The result is
     then piped to AWK for giving us the final mode-prefix: with
     ‘$1=="MODE"’, we ask AWK to only consider the line where the first
     column is ‘MODE’.  There is an equal sign between the key name and
     value, so the value is the third column (‘$3’ in AWK). We thus use
     a simple ‘if-else’ structure to look into this value and print our
     custom prefix based on it.  The output of AWK is then stored in the
     ‘modepref’ shell variable which you can add to the link/copy name.

     With the solution above, the increment of the file counter for each
     night will be independent of the mode.  If you want the counter to
     be mode-dependent, you can add a different counter for each mode
     and use that counter instead of the generic counter for each night
     (based on the value of ‘modepref’).  But we’ll leave the
     implementation of this step to you as an exercise.

* Menu:

* Invoking astscript-sort-by-night::  Inputs and outputs to this script.


File: gnuastro.info,  Node: Invoking astscript-sort-by-night,  Prev: Sort FITS files by night,  Up: Sort FITS files by night

5.2.1 Invoking astscript-sort-by-night
--------------------------------------

This installed script will read a FITS date formatted value from the
given keyword, and classify the input FITS files into individual nights.
For more on installed scripts please see (see *note Installed
scripts::).  This script can be used with the following general
template:

     $ astscript-sort-by-night [OPTION...] FITS-files

One line examples:

     ## Use the DATE-OBS keyword
     $ astscript-sort-by-night --key=DATE-OBS /path/to/data/*.fits

     ## Make links to the input files with the `img-' prefix
     $ astscript-sort-by-night --link --prefix=img- /path/to/data/*.fits

   This script will look into a HDU/extension (‘--hdu’) for a keyword
(‘--key’) in the given FITS files and interpret the value as a date.
The inputs will be separated by "night"s (9:00a.m to next day’s
8:59:59a.m, spanning two calendar days, exact hour can be set with
‘--hour’).

   The default output is a list of all the input files along with the
following two columns: night number and file number in that night
(sorted by time).  With ‘--link’ a symbolic link will be made (one for
each input) that contains the night number, and number of file in that
night (sorted by time), see the description of ‘--link’ for more.  When
‘--copy’ is used instead of a link, a copy of the inputs will be made
instead of symbolic link.

   Below you can see one example where all the ‘target-*.fits’ files in
the ‘data’ directory should be separated by observing night according to
the ‘DATE-OBS’ keyword value in their second extension (number ‘1’,
recall that HDU counting starts from 0).  You can see the output after
the ‘ls’ command.

     $ astscript-sort-by-night -pimg- -h1 -kDATE-OBS data/target-*.fits
     $ ls
     img-n1-1.fits img-n1-2.fits img-n2-1.fits ...

   The outputs can be placed in a different (already existing) directory
by including that directory’s name in the ‘--prefix’ value, for example
‘--prefix=sorted/img-’ will put them all under the ‘sorted’ directory.

   This script can be configured like all Gnuastro’s programs (through
command-line options, see *note Common options::), with some minor
differences that are described in *note Installed scripts::.  The
particular options to this script are listed below:

‘-h STR’
‘--hdu=STR’
     The HDU/extension to use in all the given FITS files.  All of the
     given FITS files must have this extension.

‘-k STR’
‘--key=STR’
     The keyword name that contains the FITS date format to
     classify/sort by.

‘-H FLT’
‘--hour=FLT’
     The hour that defines the next “night”.  By default, all times
     before 9:00a.m are considered to belong to the previous calendar
     night.  If a sub-hour value is necessary, it should be given in
     units of hours, for example ‘--hour=9.5’ corresponds to 9:30a.m.

     *Dealing with time zones:* The time that is recorded in ‘--key’ may
     be in UTC (Universal Time Coordinate).  However, the organization
     of the images taken during the night depends on the local time.  It
     is possible to take this into account by setting the ‘--hour’
     option to the local time in UTC.

     For example, consider a set of images taken in Auckland (New
     Zealand, UTC+12) during different nights.  If you want to classify
     these images by night, you have to know at which time (in UTC time)
     the Sun rises (or any other separator/definition of a different
     night).  In this particular example, you can use ‘--hour=21’.
     Because in Auckland, a night finishes (roughly) at the local time
     of 9:00, which corresponds to 21:00 UTC.

‘-l’
‘--link’
     Create a symbolic link for each input FITS file.  This option
     cannot be used with ‘--copy’.  The link will have a standard name
     in the following format (variable parts are written in ‘CAPITAL’
     letters and described after it):

          PnN-I.fits

     ‘P’
          This is the value given to ‘--prefix’.  By default, its value
          is ‘./’ (to store the links in the directory this script was
          run in).  See the description of ‘--prefix’ for more.
     ‘N’
          This is the night-counter: starting from 1.  ‘N’ is just
          incremented by 1 for the next night, no matter how many nights
          (without any dataset) there are between two subsequent
          observing nights (its just an identifier for each night which
          you can easily map to different calendar nights).
     ‘I’
          File counter in that night, sorted by time.

‘-c’
‘--copy’
     Make a copy of each input FITS file with the standard naming
     convention described in ‘--link’.  With this option, instead of
     making a link, a copy is made.  This option cannot be used with
     ‘--link’.

‘-p STR’
‘--prefix=STR’
     Prefix to append before the night-identifier of each newly created
     link or copy.  This option is thus only relevant with the ‘--copy’
     or ‘--link’ options.  See the description of ‘--link’ for how its
     used.  For example, with ‘--prefix=img-’, all the created file
     names in the current directory will start with ‘img-’, making
     outputs like ‘img-n1-1.fits’ or ‘img-n3-42.fits’.

     ‘--prefix’ can also be used to store the links/copies in another
     directory relative to the directory this script is being run (it
     must already exist).  For example
     ‘--prefix=/path/to/processing/img-’ will put all the links/copies
     in the ‘/path/to/processing’ directory, and the files (in that
     directory) will all start with ‘img-’.


File: gnuastro.info,  Node: ConvertType,  Next: Table,  Prev: Sort FITS files by night,  Up: Data containers

5.3 ConvertType
===============

The FITS format used in astronomy was defined mainly for archiving,
transmission, and processing.  In other situations, the data might be
useful in other formats.  For example, when you are writing a paper or
report, or if you are making slides for a talk, you can’t use a FITS
image.  Other image formats should be used.  In other cases you might
want your pixel values in a table format as plain text for input to
other programs that don’t recognize FITS. ConvertType is created for
such situations.  The various types will increase with future updates
and based on need.

   The conversion is not only one way (from FITS to other formats), but
two ways (except the EPS and PDF formats(1)).  So you can also convert a
JPEG image or text file into a FITS image.  Basically, other than
EPS/PDF, you can use any of the recognized formats as different color
channel inputs to get any of the recognized outputs.  So before
explaining the options and arguments (in *note Invoking astconvertt::),
we’ll start with a short description of the recognized files types in
*note Recognized file formats::, followed a short introduction to
digital color in *note Color::.

* Menu:

* Recognized file formats::     Recognized file formats
* Color::                       Some explanations on color.
* Invoking astconvertt::        Options and arguments to ConvertType.

   ---------- Footnotes ----------

   (1) Because EPS and PDF are vector, not raster/pixelated formats


File: gnuastro.info,  Node: Recognized file formats,  Next: Color,  Prev: ConvertType,  Up: ConvertType

5.3.1 Recognized file formats
-----------------------------

The various standards and the file name extensions recognized by
ConvertType are listed below.  Currently Gnuastro uses the file name’s
suffix to identify the format.

FITS or IMH
     Astronomical data are commonly stored in the FITS format (or the
     older data IRAF ‘.imh’ format), a list of file name suffixes which
     indicate that the file is in this format is given in *note
     Arguments::.

     Each image extension of a FITS file only has one value per
     pixel/element.  Therefore, when used as input, each input FITS
     image contributes as one color channel.  If you want multiple
     extensions in one FITS file for different color channels, you have
     to repeat the file name multiple times and use the ‘--hdu’,
     ‘--hdu2’, ‘--hdu3’ or ‘--hdu4’ options to specify the different
     extensions.

JPEG
     The JPEG standard was created by the Joint photographic experts
     group.  It is currently one of the most commonly used image
     formats.  Its major advantage is the compression algorithm that is
     defined by the standard.  Like the FITS standard, this is a raster
     graphics format, which means that it is pixelated.

     A JPEG file can have 1 (for gray-scale), 3 (for RGB) and 4 (for
     CMYK) color channels.  If you only want to convert one JPEG image
     into other formats, there is no problem, however, if you want to
     use it in combination with other input files, make sure that the
     final number of color channels does not exceed four.  If it does,
     then ConvertType will abort and notify you.

     The file name endings that are recognized as a JPEG file for input
     are: ‘.jpg’, ‘.JPG’, ‘.jpeg’, ‘.JPEG’, ‘.jpe’, ‘.jif’, ‘.jfif’ and
     ‘.jfi’.

TIFF
     TIFF (or Tagged Image File Format) was originally designed as a
     common format for scanners in the early 90s and since then it has
     grown to become very general.  In many aspects, the TIFF standard
     is similar to the FITS image standard: it can allow data of many
     types (see *note Numeric data types::), and also allows multiple
     images to be stored in a single file (each image in the file is
     called a ‘directory’ in the TIFF standard).  However, unlike FITS,
     it can only store images, it has no constructs for tables.  Another
     (inconvenient) difference with the FITS standard is that keyword
     names are stored as numbers, not human-readable text.

     However, outside of astronomy, because of its support of different
     numeric data types, many fields use TIFF images for accurate (for
     example 16-bit integer or floating point for example) imaging data.

     Currently ConvertType can only read TIFF images, if you are
     interested in writing TIFF images, please get in touch with us.

EPS
     The Encapsulated PostScript (EPS) format is essentially a one page
     PostScript file which has a specified size.  PostScript also
     includes non-image data, for example lines and texts.  It is a
     fully functional programming language to describe a document.
     Therefore in ConvertType, EPS is only an output format and cannot
     be used as input.  Contrary to the FITS or JPEG formats, PostScript
     is not a raster format, but is categorized as vector graphics.

     The Portable Document Format (PDF) is currently the most common
     format for documents.  Some believe that PDF has replaced
     PostScript and that PostScript is now obsolete.  This view is
     wrong, a PostScript file is an actual plain text file that can be
     edited like any program source with any text editor.  To be able to
     display its programmed content or print, it needs to pass through a
     processor or compiler.  A PDF file can be thought of as the
     processed output of the compiler on an input PostScript file.
     PostScript, EPS and PDF were created and are registered by Adobe
     Systems.

     With these features in mind, you can see that when you are
     compiling a document with TeX or LaTeX, using an EPS file is much
     more low level than a JPEG and thus you have much greater control
     and therefore quality.  Since it also includes vector graphic lines
     we also use such lines to make a thin border around the image to
     make its appearance in the document much better.  No matter the
     resolution of the display or printer, these lines will always be
     clear and not pixelated.  In the future, addition of text might be
     included (for example labels or object IDs) on the EPS output.
     However, this can be done better with tools within TeX or LaTeX
     such as PGF/Tikz(1).

     If the final input image (possibly after all operations on the flux
     explained below) is a binary image or only has two colors of black
     and white (in segmentation maps for example), then PostScript has
     another great advantage compared to other formats.  It allows for 1
     bit pixels (pixels with a value of 0 or 1), this can decrease the
     output file size by 8 times.  So if a gray-scale image is binary,
     ConvertType will exploit this property in the EPS and PDF (see
     below) outputs.

     The standard formats for an EPS file are ‘.eps’, ‘.EPS’, ‘.epsf’
     and ‘.epsi’.  The EPS outputs of ConvertType have the ‘.eps’
     suffix.

PDF
     As explained above, a PDF document is a static document description
     format, viewing its result is therefore much faster and more
     efficient than PostScript.  To create a PDF output, ConvertType
     will make a PostScript page description and convert that to PDF
     using GPL Ghostscript.  The suffixes recognized for a PDF file are:
     ‘.pdf’, ‘.PDF’.  If GPL Ghostscript cannot be run on the PostScript
     file, it will remain and a warning will be printed.

‘blank’
     This is not actually a file type!  But can be used to fill one
     color channel with a blank value.  If this argument is given for
     any color channel, that channel will not be used in the output.

Plain text
     Plain text files have the advantage that they can be viewed with
     any text editor or on the command-line.  Most programs also support
     input as plain text files.  As input, each plain text file is
     considered to contain one color channel.

     In ConvertType, the recognized extensions for plain text files are
     ‘.txt’ and ‘.dat’.  As described in *note Invoking astconvertt::,
     if you just give these extensions, (and not a full filename) as
     output, then automatic output will be preformed to determine the
     final output name (see *note Automatic output::).  Besides these,
     when the format of a file cannot be recognized from its name,
     ConvertType will fall back to plain text mode.  So you can use any
     name (even without an extension) for a plain text input or output.
     Just note that when the suffix is not recognized, automatic output
     will not be preformed.

     The basic input/output on plain text images is very similar to how
     tables are read/written as described in *note Gnuastro text table
     format::.  Simply put, the restrictions are very loose, and there
     is a convention to define a name, units, data type (see *note
     Numeric data types::), and comments for the data in a commented
     line.  The only difference is that as a table, a text file can
     contain many datasets (columns), but as a 2D image, it can only
     contain one dataset.  As a result, only one information comment
     line is necessary for a 2D image, and instead of the starting ‘‘#
     Column N’’ (‘N’ is the column number), the information line for a
     2D image must start with ‘‘# Image 1’’.  When ConvertType is asked
     to output to plain text file, this information comment line is
     written before the image pixel values.

     When converting an image to plain text, consider the fact that if
     the image is large, the number of columns in each line will become
     very large, possibly making it very hard to open in some text
     editors.

Standard output (command-line)
     This is very similar to the plain text output, but instead of
     creating a file to keep the printed values, they are printed on the
     command line.  This can be very useful when you want to redirect
     the results directly to another program in one command with no
     intermediate file.  The only difference is that only the pixel
     values are printed (with no information comment line).  To print to
     the standard output, set the output name to ‘‘stdout’’.

   ---------- Footnotes ----------

   (1) <http://sourceforge.net/projects/pgf/>


File: gnuastro.info,  Node: Color,  Next: Invoking astconvertt,  Prev: Recognized file formats,  Up: ConvertType

5.3.2 Color
-----------

Color is defined by mixing various measurements/filters.  In digital
monitors or common digital cameras, colors are displayed/stored by
mixing the three basic colors of red, green and blue (RGB) with various
proportions.  When printing on paper, standard printers use the cyan,
magenta, yellow and key (CMYK, key=black) color space.  In other words,
for each displayed/printed pixel of a color image, the dataset/image has
three or four values.

   To store/show the three values for each pixel, cameras and monitors
allocate a certain fraction of each pixel’s area to red, green and blue
filters.  These three filters are thus built into the hardware at the
pixel level.  However, because measurement accuracy is very important in
scientific instruments, and we want to do measurements (take images)
with various/custom filters (without having to order a new expensive
detector!), scientific detectors use the full area of the pixel to store
one value for it in a single/mono channel dataset.  To make measurements
in different filters, we just place a filter in the light path before
the detector.  Therefore, the FITS format that is used to store
astronomical datasets is inherently a mono-channel format (see *note
Recognized file formats:: or *note Fits::).

   When a subject has been imaged in multiple filters, you can feed each
different filter into the red, green and blue channels and obtain a
colored visualization.  In ConvertType, you can do this by giving each
separate single-channel dataset (for example in the FITS image format)
as an argument (in the proper order), then asking for the output in a
format that supports multi-channel datasets (for example JPEG or PDF,
see the examples in *note Invoking astconvertt::).

   As discussed above, color is not defined when a dataset/image
contains a single value for each pixel.  However, we interact with
scientific datasets through monitors or printers (which allow multiple
values per pixel and produce color with them).  As a result, there is a
lot of freedom in visualizing a single-channel dataset.  The most basic
is to use shades of black (because of its strong contrast with white).
This scheme is called grayscale.  To help in visualization, more complex
mappings can be defined.  For example, the values can be scaled to a
range of 0 to 360 and used as the “Hue” term of the Hue-Saturation-Value
(https://en.wikipedia.org/wiki/HSL_and_HSV) (HSV) color space (while
fixing the “Saturation” and “Value” terms).  In ConvertType, you can use
the ‘--colormap’ option to choose between different mappings of
mono-channel inputs, see *note Invoking astconvertt::.

   Since grayscale is a commonly used mapping of single-valued datasets,
we’ll continue with a closer look at how it is stored.  One way to
represent a gray-scale image in different color spaces is to use the
same proportions of the primary colors in each pixel.  This is the
common way most FITS image viewers work: for each pixel, they fill all
the channels with the single value.  While this is necessary for
displaying a dataset, there are downsides when storing/saving this type
of grayscale visualization (for example in a paper).

   • Three (for RGB) or four (for CMYK) values have to be stored for
     every pixel, this makes the output file very heavy (in terms of
     bytes).

   • If printing, the printing errors of each color channel can make the
     printed image slightly more blurred than it actually is.

   To solve both these problems when storing grayscale visualization,
the best way is to save a single-channel dataset into the black channel
of the CMYK color space.  The JPEG standard is the only common standard
that accepts CMYK color space.

   The JPEG and EPS standards set two sizes for the number of bits in
each channel: 8-bit and 12-bit.  The former is by far the most common
and is what is used in ConvertType.  Therefore, each channel should have
values between 0 to 2^8-1=255.  From this we see how each pixel in a
gray-scale image is one byte (8 bits) long, in an RGB image, it is 3
bytes long and in CMYK it is 4 bytes long.  But thanks to the JPEG
compression algorithms, when all the pixels of one channel have the same
value, that channel is compressed to one pixel.  Therefore a Grayscale
image and a CMYK image that has only the K-channel filled are
approximately the same file size.


File: gnuastro.info,  Node: Invoking astconvertt,  Prev: Color,  Up: ConvertType

5.3.3 Invoking ConvertType
--------------------------

ConvertType will convert any recognized input file type to any specified
output type.  The executable name is ‘astconvertt’ with the following
general template

     $ astconvertt [OPTION...] InputFile [InputFile2] ... [InputFile4]

One line examples:

     ## Convert an image in FITS to PDF:
     $ astconvertt image.fits --output=pdf

     ## Similar to before, but use the Viridis color map:
     $ astconvertt image.fits --colormap=viridis --output=pdf

     ## Convert an image in JPEG to FITS (with multiple extensions
     ## if its color):
     $ astconvertt image.jpg -oimage.fits

     ## Use three plain text 2D arrays to create an RGB JPEG output:
     $ astconvertt f1.txt f2.txt f3.fits -o.jpg

     ## Use two images and one blank for an RGB EPS output:
     $ astconvertt M31_r.fits M31_g.fits blank -oeps

     ## Directly pass input from output of another program through Standard
     ## input (not a file).
     $ cat 2darray.txt | astconvertt -oimg.fits

The output’s file format will be interpreted from the value given to the
‘--output’ option.  It can either be given on the command-line or in any
of the configuration files (see *note Configuration files::).  Note that
if the output suffix is not recognized, it will default to plain text
format, see *note Recognized file formats::.

   At most four input files (one for each color channel for formats that
allow it) are allowed in ConvertType.  The first input dataset can
either be a file or come from Standard input (see *note Standard
input::).  The order of multiple input files is important.  After
reading the input file(s) the number of color channels in all the inputs
will be used to define which color space to use for the outputs and how
each color channel is interpreted.

   Some formats can allow more than one color channel (for example in
the JPEG format, see *note Recognized file formats::).  If there is one
input dataset (color channel) the output will be gray-scale, if three
input datasets (color channels) are given, they are respectively
considered to be the red, green and blue color channels.  Finally, if
there are four color channels they will be be cyan, magenta, yellow and
black (CMYK colors).

   The value to ‘--output’ (or ‘-o’) can be either a full file name or
just the suffix of the desired output format.  In the former case, it
will used for the output.  In the latter case, the name of the output
file will be set based on the automatic output guidelines, see *note
Automatic output::.  Note that the suffix name can optionally start a
‘.’ (dot), so for example ‘--output=.jpg’ and ‘--output=jpg’ are
equivalent.  See *note Recognized file formats::.

   Besides the common set of options explained in *note Common
options::, the options to ConvertType can be classified into input,
output and flux related options.  The majority of the options are to do
with the flux range.  Astronomical data usually have a very large
dynamic range (difference between maximum and minimum value) and
different subjects might be better demonstrated with a limited flux
range.

Input:
‘-h STR/INT’
‘--hdu=STR/INT’
     In ConvertType, it is possible to call the HDU option multiple
     times for the different input FITS or TIFF files in the same order
     that they are called on the command-line.  Note that in the TIFF
     standard, one ‘directory’ (similar to a FITS HDU) may contain
     multiple color channels (for example when the image is in RGB).

     Except for the fact that multiple calls are possible, this option
     is identical to the common ‘--hdu’ in *note Input output options::.
     The number of calls to this option cannot be less than the number
     of input FITS or TIFF files, but if there are more, the extra HDUs
     will be ignored, note that they will be read in the order described
     in *note Configuration file precedence::.

     Unlike CFITSIO, libtiff (which is used to read TIFF files) only
     recognizes numbers (counting from zero, similar to CFITSIO) for
     ‘directory’ identification.  Hence the concept of names is not
     defined for the directories and the values to this option for TIFF
     files must be numbers.

Output:

‘-w FLT’
‘--widthincm=FLT’
     The width of the output in centimeters.  This is only relevant for
     those formats that accept such a width (not plain text for
     example).  For most digital purposes, the number of pixels is far
     more important than the value to this parameter because you can
     adjust the absolute width (in inches or centimeters) in your
     document preparation program.

‘-b INT’
‘--borderwidth=INT’
     The width of the border to be put around the EPS and PDF outputs in
     units of PostScript points.  There are 72 or 28.35 PostScript
     points in an inch or centimeter respectively.  In other words,
     there are roughly 3 PostScript points in every millimeter.  If you
     are planning on adding a border, its significance is highly
     correlated with the value you give to the ‘--widthincm’ parameter.

     Unfortunately in the document structuring convention of the
     PostScript language, the “bounding box” has to be in units of
     PostScript points with no fractions allowed.  So the border values
     only have to be specified in integers.  To have a final border that
     is thinner than one PostScript point in your document, you can ask
     for a larger width in ConvertType and then scale down the output
     EPS or PDF file in your document preparation program.  For example
     by setting ‘width’ in your ‘includegraphics’ command in TeX or
     LaTeX.  Since it is vector graphics, the changes of size have no
     effect on the quality of your output quality (pixels don’t get
     different values).

‘-x’
‘--hex’
     Use Hexadecimal encoding in creating EPS output.  By default the
     ASCII85 encoding is used which provides a much better compression
     ratio.  When converted to PDF (or included in TeX or LaTeX which is
     finally saved as a PDF file), an efficient binary encoding is used
     which is far more efficient than both of them.  The choice of EPS
     encoding will thus have no effect on the final PDF.

     So if you want to transfer your EPS files (for example if you want
     to submit your paper to arXiv or journals in PostScript), their
     storage might become important if you have large images or lots of
     small ones.  By default ASCII85 encoding is used which offers a
     much better compression ratio (nearly 40 percent) compared to
     Hexadecimal encoding.

‘-u INT’
‘--quality=INT’
     The quality (compression) of the output JPEG file with values from
     0 to 100 (inclusive).  For other formats the value to this option
     is ignored.  Note that only in gray-scale (when one input color
     channel is given) will this actually be the exact quality (each
     pixel will correspond to one input value).  If it is in color mode,
     some degradation will occur.  While the JPEG standard does support
     loss-less graphics, it is not commonly supported.

‘--colormap=STR[,FLT,...]’
     The color map to visualize a single channel.  The first value given
     to this option is the name of the color map, which is shown below.
     Some color maps can be configured.  In this case, the configuration
     parameters are optionally given as numbers following the name of
     the color map for example see ‘hsv’.  The table below contains the
     usable names of the color maps that are currently supported:

     ‘gray’
     ‘grey’
          Grayscale color map.  This color map doesn’t have any
          parameters.  The full dataset range will be scaled to 0 and
          $2^8-1=255$ to be stored in the requested format.

     ‘hsv’
          Hue, Saturation, Value(1) color map.  If no values are given
          after the name (‘--colormap=hsv’), the dataset will be scaled
          to 0 and 360 for hue covering the full spectrum of colors.
          However, you can limit the range of hue (to show only a
          special color range) by explicitly requesting them after the
          name (for example ‘--colormap=hsv,20,240’).

          The mapping of a single-channel dataset to HSV is done through
          the Hue and Value elements: Lower dataset elements have lower
          “value” _and_ lower “hue”.  This creates darker colors for
          fainter parts, while also respecting the range of colors.

     ‘viridis’
          Viridis is the default colormap of the popular Matplotlib
          module of Python and available in many other visualization
          tools like PGFPlots.

     ‘sls’
          The SLS color range, taken from the commonly used SAO DS9
          (http://ds9.si.edu).  The advantage of this color range is
          that it ranges from black to dark blue, and finishes with red
          and white.  So unlike the HSV color range, it includes black
          and white and brighter colors (like yellow, red and white)
          show the larger values.

‘--rgbtohsv’
     When there are three input channels and the output is in the FITS
     format, interpret the three input channels as red, green and blue
     channels (RGB) and convert them to the hue, saturation, value (HSV)
     color space.

     The currently supported output formats of ConvertType don’t have
     native support for HSV. Therefore this option is only supported
     when the output is in FITS format and each of the hue, saturation
     and value arrays can be saved as one FITS extension in the output
     for further analysis (for example to select a certain color).

Flux range:

‘-c STR’
‘--change=STR’
     (‘=STR’) Change pixel values with the following format ‘"from1:to1,
     from2:to2,..."’.  This option is very useful in displaying labeled
     pixels (not actual data images which have noise) like segmentation
     maps.  In labeled images, usually a group of pixels have a fixed
     integer value.  With this option, you can manipulate the labels
     before the image is displayed to get a better output for print or
     to emphasize on a particular set of labels and ignore the rest.
     The labels in the images will be changed in the same order given.
     By default first the pixel values will be converted then the pixel
     values will be truncated (see ‘--fluxlow’ and ‘--fluxhigh’).

     You can use any number for the values irrespective of your final
     output, your given values are stored and used in the double
     precision floating point format.  So for example if your input
     image has labels from 1 to 20000 and you only want to display those
     with labels 957 and 11342 then you can run ConvertType with these
     options:

          $ astconvertt --change=957:50000,11342:50001 --fluxlow=5e4 \
             --fluxhigh=1e5 segmentationmap.fits --output=jpg

     While the output JPEG format is only 8 bit, this operation is done
     in an intermediate step which is stored in double precision
     floating point.  The pixel values are converted to 8-bit after all
     operations on the input fluxes have been complete.  By placing the
     value in double quotes you can use as many spaces as you like for
     better readability.

‘-C’
‘--changeaftertrunc’
     Change pixel values (with ‘--change’) after truncation of the flux
     values, by default it is the opposite.

‘-L FLT’
‘--fluxlow=FLT’
     The minimum flux (pixel value) to display in the output image, any
     pixel value below this value will be set to this value in the
     output.  If the value to this option is the same as ‘--fluxhigh’,
     then no flux truncation will be applied.  Note that when multiple
     channels are given, this value is used for all the color channels.

‘-H FLT’
‘--fluxhigh=FLT’
     The maximum flux (pixel value) to display in the output image, see
     ‘--fluxlow’.

‘-m INT’
‘--maxbyte=INT’
     This is only used for the JPEG and EPS output formats which have an
     8-bit space for each channel of each pixel.  The maximum value in
     each pixel can therefore be $2^8-1=255$.  With this option you can
     change (decrease) the maximum value.  By doing so you will decrease
     the dynamic range.  It can be useful if you plan to use those
     values for other purposes.

‘-A INT’
‘--forcemin=INT’
     Enforce the value of ‘--fluxlow’ (when its given), even if its
     smaller than the minimum of the dataset and the output is format
     supporting color.  This is particularly useful when you are
     converting a number of images to a common image format like JPEG or
     PDF with a single command and want them all to have the same range
     of colors, independent of the contents of the dataset.  Note that
     if the minimum value is smaller than ‘--fluxlow’, then this option
     is redundant.

     By default, when the dataset only has two values, _and_ the output
     format is PDF or EPS, ConvertType will use the PostScript
     optimization that allows setting the pixel values per bit, not byte
     (*note Recognized file formats::).  This can greatly help reduce
     the file size.  However, when ‘--fluxlow’ or ‘--fluxhigh’ are
     called, this optimization is disabled: even though there are only
     two values (is binary), the difference between them does not
     correspond to the full contrast of black and white.

‘-B INT’
‘--forcemax=INT’
     Similar to ‘--forcemin’, but for the maximum.

‘-i’
‘--invert’
     For 8-bit output types (JPEG, EPS, and PDF for example) the final
     value that is stored is inverted so white becomes black and vice
     versa.  The reason for this is that astronomical images usually
     have a very large area of blank sky in them.  The result will be
     that a large are of the image will be black.  Note that this
     behavior is ideal for gray-scale images, if you want a color image,
     the colors are going to be mixed up.

   ---------- Footnotes ----------

   (1) <https://en.wikipedia.org/wiki/HSL_and_HSV>


File: gnuastro.info,  Node: Table,  Prev: ConvertType,  Up: Data containers

5.4 Table
=========

Tables are the products of processing astronomical images and spectra.
For example in Gnuastro, MakeCatalog will process the defined pixels
over an object and produce a catalog (see *note MakeCatalog::).  For
each identified object, MakeCatalog can print its position on the image
or sky, its total brightness and many other information that is
deducible from the given image.  Each one of these properties is a
column in its output catalog (or table) and for each input object, we
have a row.

   When there are only a small number of objects (rows) and not too many
properties (columns), then a simple plain text file is mainly enough to
store, transfer, or even use the produced data.  However, to be more
efficient in all these aspects, astronomers have defined the FITS binary
table standard to store data in a binary (0 and 1) format, not plain
text.  This can offer major advantages in all those aspects: the file
size will be greatly reduced and the reading and writing will be faster
(because the RAM and CPU also work in binary).

   The FITS standard also defines a standard for ASCII tables, where the
data are stored in the human readable ASCII format, but within the FITS
file structure.  These are mainly useful for keeping ASCII data along
with images and possibly binary data as multiple (conceptually related)
extensions within a FITS file.  The acceptable table formats are fully
described in *note Tables::.

   Binary tables are not easily readable by human eyes.  There is no
fixed/unified standard on how the zero and ones should be interpreted.
The Unix-like operating systems have flourished because of a simple
fact: communication between the various tools is based on human readable
characters(1).  So while the FITS table standards are very beneficial
for the tools that recognize them, they are hard to use in the vast
majority of available software.  This creates limitations for their
generic use.

   ‘Table’ is Gnuastro’s solution to this problem.  With Table, FITS
tables (ASCII or binary) are directly accessible to the Unix-like
operating systems power-users (those working the command-line or shell,
see *note Command-line interface::).  With Table, a FITS table (in
binary or ASCII formats) is only one command away from AWK (or any other
tool you want to use).  Just like a plain text file that you read with
the ‘cat’ command.  You can pipe the output of Table into any other tool
for higher-level processing, see the examples in *note Invoking
asttable:: for some simple examples.

* Menu:

* Column arithmetic::           How to do operations on table columns.
* Invoking asttable::           Options and arguments to Table.

   ---------- Footnotes ----------

   (1) In “The art of Unix programming”, Eric Raymond makes this
suggestion to programmers: “When you feel the urge to design a complex
binary file format, or a complex binary application protocol, it is
generally wise to lie down until the feeling passes.”.  This is a great
book and strongly recommended, give it a look if you want to truly enjoy
your work/life in this environment.


File: gnuastro.info,  Node: Column arithmetic,  Next: Invoking asttable,  Prev: Table,  Up: Table

5.4.1 Column arithmetic
-----------------------

After reading the requested columns from the input table, you can also
do operations/arithmetic on the columns and save the resulting values as
new column(s) in the output table (possibly in between other requested
columns).  To enable column arithmetic, the first 6 characters of the
value to ‘--column’ (‘-c’) should be the arithmetic activation word
‘‘arith ’’ (note the space character in the end, after ‘‘arith’’).

   After the activation word, you can use the reverse polish notation to
identify the operators and their operands, see *note Reverse polish
notation::.  Just note that white-space characters are used between the
tokens of the arithmetic expression and that they are meaningful to the
command-line environment.  Therefore the whole expression (including the
activation word) has to be quoted on the command-line or in a shell
script (see the examples below).

   To identify a column you can directly use its name, or specify its
number (counting from one, see *note Selecting table columns::).  When
you are giving a column number, it is necessary to prefix the number
with a ‘$’, similar to AWK. Otherwise the number is not distinguishable
from a constant number to use in the arithmetic operation.

   For example with the command below, the first two columns of
‘table.fits’ will be printed along with a third column that is the
result of multiplying the first column with $10^{10}$ (for example to
convert wavelength from Meters to Angstroms).  Note that without the
‘<$>’, it is not possible to distinguish between “1” as a
column-counter, or as a constant number to use in the arithmetic
operation.  Also note that because of the significance of <$> for the
command-line environment, the single-quotes are used here (as in an AWK
expression), not double-quotes.

     $ asttable table.fits -c1,2 -c'arith $1 1e10 x'

*Single quotes when string contains <$>*: On the command-line, or in
shell-scripts, <$> is used to expand variables, for example ‘echo $PATH’
prints the value (a string of characters) in the variable ‘PATH’, it
will not simply print ‘$PATH’.  This operation is also permitted within
double quotes, so ‘echo "$PATH"’ will produce the same output.  This is
good when printing values, for example in the command below, ‘$PATH’
will expand to the value within it.

     $ echo "My path is: $PATH"

   If you actually want to return the literal string ‘$PATH’, not the
value in the ‘PATH’ variable (like the scenario here in column
arithmetic), you should put it in single quotes like below.  The printed
value here will include the ‘$’, please try it to see for your self and
compare to above.

     $ echo 'My path is: $PATH'

   Therefore, when your column arithmetic involves the <$> sign (to
specify columns by number), quote your ‘arith ’ string with a single
quotation mark.  Otherwise you can use both single or double quotes.

   Alternatively, if the columns have meta-data and the first two are
respectively called ‘AWAV’ and ‘SPECTRUM’, the command above is
equivalent to the command below.  Note that the character ‘<$>’ is no
longer necessary in this scenario (because names will not be confused
with numbers):

     $ asttable table.fits -cAWAV,SPECTRUM -c'arith AWAV 1e10 x'

   Comparison of the two commands above clearly shows why it is
recommended to use column names instead of numbers.  When the columns
have descriptive names, the command/script actually becomes much more
readable, describing the intent of the operation.  It is also
independent of the low-level table structure: for the second command,
the position of the ‘AWAV’ and ‘SPECTRUM’ columns in ‘table.fits’ is
irrelevant.

   Finally, since the arithmetic expressions are a value to ‘--column’,
it doesn’t necessarily have to be a separate option, so the commands
above are also identical to the command below (note that this only has
one ‘-c’ option).  Just be very careful with the quoting!

     $ asttable table.fits -cAWAV,SPECTRUM,'arith AWAV 1e10 x'

   Almost all the arithmetic operators of *note Arithmetic operators::
are also supported for column arithmetic in Table.  In particular, the
few that are not present in the Gnuastro library aren’t yet supported.
For a list of the Gnuastro library arithmetic operators, please see the
macros starting with ‘GAL_ARITHMETIC_OP’ and ending with the operator
name in *note Arithmetic on datasets::.  Besides the operators in *note
Arithmetic operators::, several operators are only available in Table to
use on table columns.

‘wcstoimg’
     Convert the given WCS positions to image/dataset coordinates based
     on the number of dimensions in the WCS structure of ‘--wcshdu’
     extension/HDU in ‘--wcsfile’.  It will output the same number of
     columns.  The first popped operand is the last FITS dimension.

     For example the two commands below (which have the same output)
     will produce 5 columns.  The first three columns are the input
     table’s ID, RA and Dec columns.  The fourth and fifth columns will
     be the pixel positions in ‘image.fits’ that correspond to each RA
     and Dec.

          $ asttable table.fits -cID,RA,DEC,'arith RA DEC wcstoimg' \
                     --wcsfile=image.fits
          $ asttable table.fits -cID,RA -cDEC \
                     -c'arith RA DEC wcstoimg' --wcsfile=image.fits

‘imgtowcs’
     Similar to ‘wcstoimg’, except that image/dataset coordinates are
     converted to WCS coordinates.

‘distance-flat’
     Return the distance between two points assuming they are on a flat
     surface.  Note that each point needs two coordinates, so this
     operator needs four operands (currently it only works for 2D
     spaces).  The first and second popped operands are considered to
     belong to one point and the third and fourth popped operands to the
     second point.

     Each of the input points can be a single coordinate or a full table
     column (containing many points).  In other words, the following
     commands are all valid:

          $ asttable table.fits \
                     -c'arith X1 Y1 X2 Y2 distance-flat'
          $ asttable table.fits \
                     -c'arith X Y 12.345 6.789 distance-flat'
          $ asttable table.fits \
                     -c'arith 12.345 6.789 X Y distance-flat'

     In the first case we are assuming that ‘table.fits’ has the
     following four columns ‘X1’, ‘Y1’, ‘X2’, ‘Y2’.  The returned column
     by this operator will be the difference between two points in each
     row with coordinates like the following (‘X1’, ‘Y1’) and (‘X2’,
     ‘Y2’).  In other words, for each row, the distance between
     different points is calculated.  In the second and third cases
     (which are identical), it is assumed that ‘table.fits’ has the two
     columns ‘X’ and ‘Y’.  The returned column by this operator will be
     the difference of each row with the fixed point at (12.345, 6.789).

‘distance-on-sphere’
     Return the spherical angular distance (along a great circle, in
     degrees) between the given two points.  Note that each point needs
     two coordinates (in degrees), so this operator needs four operands.
     The first and second popped operands are considered to belong to
     one point and the third and fourth popped operands to the second
     point.

     Each of the input points can be a single coordinate or a full table
     column (containing many points).  In other words, the following
     commands are all valid:

          $ asttable table.fits \
                     -c'arith RA1 DEC1 RA2 DEC2 distance-on-sphere'
          $ asttable table.fits \
                     -c'arith RA DEC 9.876 5.432 distance-on-sphere'
          $ asttable table.fits \
                     -c'arith 9.876 5.432 RA DEC distance-on-sphere'

     In the first case we are assuming that ‘table.fits’ has the
     following four columns ‘RA1’, ‘DEC1’, ‘RA2’, ‘DEC2’.  The returned
     column by this operator will be the difference between two points
     in each row with coordinates like the following (‘RA1’, ‘DEC1’) and
     (‘RA2’, ‘DEC2’).  In other words, for each row, the angular
     distance between different points is calculated.  In the second and
     third cases (which are identical), it is assumed that ‘table.fits’
     has the two columns ‘RA’ and ‘DEC’.  The returned column by this
     operator will be the difference of each row with the fixed point at
     (9.876, 5.432).

     The distance (along a great circle) on a sphere between two points
     is calculated with the equation below, where $r_1$, $r_2$, $d_1$
     and $d_2$ are the right ascensions and declinations of points 1 and
     2.

    $$\cos(d)=\sin(d_1)\sin(d_2)+\cos(d_1)\cos(d_2)\cos(r_1-r_2)$$

‘ra-to-degree’
     Convert the hour-wise Right Ascension (RA) string, in the format of
     ‘HH:MM:SS’, to degrees.  Note that the input column has to be an
     string format.  In FITS tables, string columns are well-defined.
     For plain-text tables, please follow the standards defined in *note
     Gnuastro text table format::, otherwise the string column won’t be
     read.
          $ asttable catalog.fits -c'arith RA ra-to-degree'
          $ asttable catalog.fits -c'arith $5 ra-to-degree'

‘dec-to-degree’
     Convert the Declination (Dec) string, in the format of ‘DD:MM:SS’,
     to degrees (a single floating point number).  For more details
     please see the ‘ra-to-degree’ operator.

‘degree-to-ra’
     Convert degrees (a column with a single floating point number) to
     the Right Ascension, RA, string (in the format of ‘HH:MM:SS’).  The
     output will be a string column so no further mathematical
     operations can be done on it.  The output can be in any format (for
     example FITS or plain-text).  If its plain-text, the string column
     will be written following the standards described in *note Gnuastro
     text table format::.

‘degree-to-dec’
     Convert degrees (a column with a single floating point number) to
     the Declination, Dec, string (in the format of ‘DD:MM:SS’).  See
     the ‘degree-to-ra’ for more on the format of the output.


File: gnuastro.info,  Node: Invoking asttable,  Prev: Column arithmetic,  Up: Table

5.4.2 Invoking Table
--------------------

Table will read/write, select, convert, or show the information of the
columns in FITS ASCII table, FITS binary table and plain text table
files, see *note Tables::.  Output columns can also be determined by
number or regular expression matching of column names, units, or
comments.  The executable name is ‘asttable’ with the following general
template

     $ asttable [OPTION...] InputFile

One line examples:

     ## Get the table column information (name, data type, or units):
     $ asttable bintab.fits --information

     ## Print columns named RA and DEC, followed by all the columns where
     ## the name starts with "MAG_":
     $ asttable bintab.fits --column=RA --column=DEC --column=/^MAG_/

     ## Similar to the above, but with one call to `--column' (or `-c'),
     ## also sort the rows by the input's photometric redshift (`Z_PHOT')
     ## column. To confirm the sort, you can add `Z_PHOT' to the columns
     ## to print.
     $ asttable bintab.fits -cRA,DEC,/^MAG_/ --sort=Z_PHOT

     ## Similar to the above, but only print rows that have a photometric
     ## redshift between 2 and 3.
     $ asttable bintab.fits -cRA,DEC,/^MAG_/ --range=Z_PHOT,2:3

     ## Only print rows with a value in the 10th column above 100000:
     $ asttable bintab.fits --range=10,10e5,inf

     ## Only print the 2nd column, and the third column multiplied by 5,
     ## Save the resulting two columns in `table.txt'
     $ asttable bintab.fits -c2,'arith $2 5 x' -otable.fits

     ## Sort the output columns by the third column, save output:
     $ asttable bintab.fits --sort=3 -ooutput.txt

     ## Subtract the first column from the second in `cat.fits' (can also
     ## be a text table) and keep the third and fourth columns.
     $ asttable cat.txt -c'arith $2 $1 -',3,4 -ocat.fits

   Table’s input dataset can be given either as a file or from Standard
input (see *note Standard input::).  In the absence of selected columns,
all the input’s columns and rows will be written to the output.  If any
output file is explicitly requested (with ‘--output’) the output table
will be written in it.  When no output file is explicitly requested the
output table will be written to the standard output.

   If the specified output is a FITS file, the type of FITS table
(binary or ASCII) will be determined from the ‘--tabletype’ option.  If
the output is not a FITS file, it will be printed as a plain text table
(with space characters between the columns).  When the columns are
accompanied by meta-data (like column name, units, or comments), this
information will also printed in the plain text file before the table,
as described in *note Gnuastro text table format::.

   For the full list of options common to all Gnuastro programs please
see *note Common options::.  Options can also be stored in directory,
user or system-wide configuration files to avoid repeating on the
command-line, see *note Configuration files::.  Table does not follow
Automatic output that is common in most Gnuastro programs, see *note
Automatic output::.  Thus, in the absence of an output file, the
selected columns will be printed on the command-line with no column
information, ready for redirecting to other tools like AWK or sort,
similar to the examples above.

‘-i’
‘--information’
     Only print the column information in the specified table on the
     command-line and exit.  Each column’s information (number, name,
     units, data type, and comments) will be printed as a row on the
     command-line.  Note that the FITS standard only requires the data
     type (see *note Numeric data types::), and in plain text tables, no
     meta-data/information is mandatory.  Gnuastro has its own
     convention in the comments of a plain text table to store and
     transfer this information as described in *note Gnuastro text table
     format::.

     This option will take precedence over the ‘--column’ option, so
     when it is called along with requested columns, the latter will be
     ignored.  This can be useful if you forget the identifier of a
     column after you have already typed some on the command-line.  You
     can simply add a ‘-i’ and run Table to see the whole list and
     remember.  Then you can use the shell history (with the up arrow
     key on the keyboard), and retrieve the last command with all the
     previously typed columns present, delete ‘-i’ and add the
     identifier you had forgot.

‘-c STR/INT’
‘--column=STR/INT’
     Set the output columns either by specifying the column number, or
     name.  For more on selecting columns, see *note Selecting table
     columns::.  If a value of this option starts with ‘‘arith ’’, this
     option will do the requested operations/arithmetic on the specified
     columns and output the result in that place (among other requested
     columns).  For more on column arithmetic see *note Column
     arithmetic::.

     To ask for multiple columns this option can be used in two way: 1)
     multiple calls to this option, 2) using a comma between each column
     specifier in one call to this option.  These different solutions
     may be mixed in one call to Table: for example, ‘-cRA,DEC -cMAG’,
     or ‘-cRA -cDEC -cMAG’ are both equivalent to ‘-cRA -cDEC -cMAG’.
     The order of the output columns will be the same order given to the
     option or in the configuration files (see *note Configuration file
     precedence::).

     This option is not mandatory, if no specific columns are requested,
     all the input table columns are output.  When this option is called
     multiple times, it is possible to output one column more than once.

‘-w STR’
‘--wcsfile=STR’
     FITS file that contains the WCS to be used in the ‘wcstoimg’ and
     ‘imgtowcs’ operators of ‘--column’ (see above).  The extension
     name/number within the FITS file can be specified with ‘--wcshdu’.

     If the value to this option is ‘none’, no WCS will be written in
     the output.

‘-W STR’
‘--wcshdu=STR’
     FITS extension/HDU that contains the WCS to be used in the
     ‘wcstoimg’ and ‘imgtowcs’ operators of ‘--column’ (see above).  The
     FITS file name can be specified with ‘--wcsfile’.

‘-F STR’
‘--catcolumn=STR’
     Concatenate/add the columns of this option’s value (a filename)
     with the main input table (keeping number of rows fixed).  The
     concatenation is done after any column selection (for example with
     ‘--column’) or row selection (for example with ‘--range’) is
     applied to the main input argument.

     If the file given to this option is a FITS file, its necessary to
     also define the corresponding HDU/extension with ‘--catcolhdu’.
     Also note that no column or row selection is applied to the table
     given to this option.  This option may be called multiple times (to
     add columns from more than one file into the final output), the
     columns will be added in the same order that this option is called.

‘-u STR/INT’
‘--catcolhdu=STR/INT’
     The HDU/extension of the FITS file(s) that have been added with
     ‘--catcolumn’.  If ‘--catcolumn’ is called more than once with more
     than one FITS file, its necessary to call this option more than
     once.  The HDUs will be loaded in the same order as the FITS files
     given to ‘--catcolumn’.

‘-O’
‘--colinfoinstdout’
     Add column metadata when the output is printed in the standard
     output.  Usually the standard output is used for a fast visual
     check or to pipe into other program for further processing.  So by
     default meta-data aren’t included.

‘-r STR,FLT:FLT’
‘--range=STR,FLT:FLT’
     Only output rows that have a value within the given range in the
     ‘STR’ column (can be a name or counter).  Note that the range is
     only inclusive in the lower-limit.  For example with
     ‘--range=sn,5:20’ the output’s columns will only contain rows that
     have a value in the ‘sn’ column (not case-sensitive) that is
     greater or equal to 5, and less than 20.

     This option can be called multiple times (different ranges for
     different columns) in one run of the Table program.  This is very
     useful for selecting the final rows from multiple criteria/columns.

     The chosen column doesn’t have to be in the output columns.  This
     is good when you just want to select using one column’s values, but
     don’t need that column anymore afterwards.

     For one example of using this option, see the example under
     ‘--sigclip-median’ in *note Invoking aststatistics::.

‘--inpolygon=STR1,STR2’
     Only return rows where the given coordinates are inside the polygon
     specified by the ‘--polygon’ option.  The coordinate columns are
     the given ‘STR1’ and ‘STR2’ columns, they can be a column name or
     counter (see *note Selecting table columns::).

     Note that the chosen columns doesn’t have to be in the output
     columns (which are specified by the ‘--column’ option).  For
     example if we want to select rows in the polygon specified in *note
     Dataset inspection and cropping::, this option can be used like
     this (you can remove the double quotations and write them all in
     one line if you remove the white-spaces around the colon separating
     the column vertices):

          asttable table.fits --inpolygon=RA,DEC      \
                   --polygon="53.187414,-27.779152    \
                              : 53.159507,-27.759633  \
                              : 53.134517,-27.787144  \
                              : 53.161906,-27.807208" \

     *Flat/Euclidean space: * The ‘--inpolygon’ option assumes a
     flat/Euclidean space so it is only correct for RA and Dec when the
     polygon size is very small like the example above.  If your polygon
     is a degree or larger, it may not return correct results.  We are
     working on other options for this.

‘--outpolygon=STR1,STR2’
     Only return rows where the given coordinates are outside the
     polygon specified by the ‘--polygon’ option.  This option is very
     similar to the ‘--inpolygon’ option, so see the description there
     for more.

‘--polygon=FLT:FLT,...’
     The polygon to use for the ‘--inpolygon’ and ‘--outpolygon’
     options.  The values to this option is parsed in the same way that
     the Crop program, see its description there for more: *note Crop
     options::.

‘-e STR,INT/FLT,...’
‘--equal=STR,INT/FLT,...’
     Only output rows that are equal to the given number(s) in the given
     column.  The first argument is the column identifier (name or
     number, see *note Selecting table columns::), after that you can
     specify any number of values.  For example ‘--equal=ID,5,6,8’ will
     only print the rows that have a value of 5, 6, or 8 in the ‘ID’
     column.  This option can also be called multiple times, so
     ‘--equal=ID,4,5 --equal=ID,6,7’ has the same effect as
     ‘--equal=4,5,6,7’.

     The ‘--equal’ and ‘--notequal’ options also work when the given
     column has a string type.  In this case the given value to the
     option will also be parsed as a string, not as a number.  When
     dealing with string columns, be careful with trailing white space
     characters (the actual value maybe adjusted to the right, left, or
     center of the column’s width).  If you need to account for such
     white spaces, you can use shell quoting.  For example
     ‘--equal=NAME," myname "’.

     *Equality and floating point numbers:* Floating point numbers are
     only approximate values (see *note Numeric data types::).  In this
     context, their equality depends on how the the input table was
     originally stored (as a plain text table or as an ASCII/binary FITS
     table).  If you want to select floating point numbers, it is
     strongly recommended to use the ‘--range’ option and set a very
     small interval around your desired number, don’t use ‘--equal’ or
     ‘--notequal’.

‘-n STR,INT/FLT,...’
‘--notequal=STR,INT/FLT,...’
     Only output rows that are _not_ equal to the given number(s) in the
     given column.  The first argument is the column identifier (name or
     number, see *note Selecting table columns::), after that you can
     specify any number of values.  For example ‘--notequal=ID,5,6,8’
     will only print the rows where the ‘ID’ column doesn’t have value
     of 5, 6, or 8.  This option can also be called multiple times, so
     ‘--notequal=ID,4,5 --notequal=ID,6,7’ has the same effect as
     ‘--notequal=4,5,6,7’.

     Be very careful if you want to use the non-equality with floating
     point numbers, see the special note under ‘--equal’ for more.  This
     option also works when the given column has a string type, see the
     description under ‘--equal’ (above) for more.

‘-s STR’
‘--sort=STR’
     Sort the output rows based on the values in the ‘STR’ column (can
     be a column name or number).  By default the sort is done in
     ascending/increasing order, to sort in a descending order, use
     ‘--descending’.

     The chosen column doesn’t have to be in the output columns.  This
     is good when you just want to sort using one column’s values, but
     don’t need that column anymore afterwards.

‘-d’
‘--descending’
     When called with ‘--sort’, rows will be sorted in descending order.

‘-H INT’
‘--head=INT’
     Only print the given number of rows from the _top_ of the final
     table.  Note that this option only affects the _output_ table.  For
     example if you use ‘--sort’, or ‘--range’, the printed rows are the
     first _after_ applying the sort sorting, or selecting a range of
     the full input.

     If the given value to ‘--head’ is 0, the output columns won’t have
     any rows and if its larger than the number of rows in the input
     table, all the rows are printed (this option is effectively
     ignored).  This behavior is taken from the ‘head’ program in GNU
     Coreutils.

‘-t INT’
‘--tail=INT’
     Only print the given number of rows from the _bottom_ of the final
     table.  See ‘--head’ for more.


File: gnuastro.info,  Node: Data manipulation,  Next: Data analysis,  Prev: Data containers,  Up: Top

6 Data manipulation
*******************

Images are one of the major formats of data that is used in astronomy.
The functions in this chapter explain the GNU Astronomy Utilities which
are provided for their manipulation.  For example cropping out a part of
a larger image or convolving the image with a given kernel or applying a
transformation to it.

* Menu:

* Crop::                        Crop region(s) from a dataset.
* Arithmetic::                  Arithmetic on input data.
* Convolve::                    Convolve an image with a kernel.
* Warp::                        Warp/Transform an image to a different grid.


File: gnuastro.info,  Node: Crop,  Next: Arithmetic,  Prev: Data manipulation,  Up: Data manipulation

6.1 Crop
========

Astronomical images are often very large, filled with thousands of
galaxies.  It often happens that you only want a section of the image,
or you have a catalog of sources and you want to visually analyze them
in small postage stamps.  Crop is made to do all these things.  When
more than one crop is required, Crop will divide the crops between
multiple threads to significantly reduce the run time.

   Astronomical surveys are usually extremely large.  So large in fact,
that the whole survey will not fit into a reasonably sized file.
Because of this, surveys usually cut the final image into separate tiles
and store each tile in a file.  For example the COSMOS survey’s Hubble
space telescope, ACS F814W image consists of 81 separate FITS images,
with each one having a volume of 1.7 Giga bytes.

   Even though the tile sizes are chosen to be large enough that too
many galaxies/targets don’t fall on the edges of the tiles, inevitably
some do.  So when you simply crop the image of such targets from one
tile, you will miss a large area of the surrounding sky (which is
essential in estimating the noise).  Therefore in its WCS mode, Crop
will stitch parts of the tiles that are relevant for a target (with the
given width) from all the input images that cover that region into the
output.  Of course, the tiles have to be present in the list of input
files.

   Besides cropping postage stamps around certain coordinates, Crop can
also crop arbitrary polygons from an image (or a set of tiles by
stitching the relevant parts of different tiles within the polygon), see
‘--polygon’ in *note Invoking astcrop::.  Alternatively, it can crop out
rectangular regions through the ‘--section’ option from one image, see
*note Crop section syntax::.

* Menu:

* Crop modes::                  Basic modes to define crop region.
* Crop section syntax::         How to define a section to crop.
* Blank pixels::                Pixels with no value.
* Invoking astcrop::            Calling Crop on the command-line


File: gnuastro.info,  Node: Crop modes,  Next: Crop section syntax,  Prev: Crop,  Up: Crop

6.1.1 Crop modes
----------------

In order to be comprehensive, intuitive, and easy to use, there are two
ways to define the crop:

  1. From its center and side length.  For example if you already know
     the coordinates of an object and want to inspect it in an image or
     to generate postage stamps of a catalog containing many such
     coordinates.

  2. The vertices of the crop region, this can be useful for larger
     crops over many targets, for example to crop out a uniformly deep,
     or contiguous, region of a large survey.

   Irrespective of how the crop region is defined, the coordinates to
define the crop can be in Image (pixel) or World Coordinate System (WCS)
standards.  All coordinates are read as floating point numbers (not
integers, except for the ‘--section’ option, see below).  By setting the
_mode_ in Crop, you define the standard that the given coordinates must
be interpreted.  Here, the different ways to specify the crop region are
discussed within each standard.  For the full list options, please see
*note Invoking astcrop::.

   When the crop is defined by its center, the respective (integer)
central pixel position will be found internally according to the FITS
standard.  To have this pixel positioned in the center of the cropped
region, the final cropped region will have an add number of pixels (even
if you give an even number to ‘--width’ in image mode).

   Furthermore, when the crop is defined as by its center, Crop allows
you to only keep crops what don’t have any blank pixels in the vicinity
of their center (your primary target).  This can be very convenient when
your input catalog/coordinates originated from another survey/filter
which is not fully covered by your input image, to learn more about this
feature, please see the description of the ‘--checkcenter’ option in
*note Invoking astcrop::.

Image coordinates
     In image mode (‘--mode=img’), Crop interprets the pixel coordinates
     and widths in units of the input data-elements (for example pixels
     in an image, not world coordinates).  In image mode, only one image
     may be input.  The output crop(s) can be defined in multiple ways
     as listed below.

     Center of multiple crops (in a catalog)
          The center of (possibly multiple) crops are read from a text
          file.  In this mode, the columns identified with the
          ‘--coordcol’ option are interpreted as the center of a crop
          with a width of ‘--width’ pixels along each dimension.  The
          columns can contain any floating point value.  The value to
          ‘--output’ option is seen as a directory which will host (the
          possibly multiple) separate crop files, see *note Crop
          output:: for more.  For a tutorial using this feature, please
          see *note Finding reddest clumps and visual inspection::.

     Center of a single crop (on the command-line)
          The center of the crop is given on the command-line with the
          ‘--center’ option.  The crop width is specified by the
          ‘--width’ option along each dimension.  The given coordinates
          and width can be any floating point number.

     Vertices of a single crop
          In Image mode there are two options to define the vertices of
          a region to crop: ‘--section’ and ‘--polygon’.  The former is
          lower-level (doesn’t accept floating point vertices, and only
          a rectangular region can be defined), it is also only
          available in Image mode.  Please see *note Crop section
          syntax:: for a full description of this method.

          The latter option (‘--polygon’) is a higher-level method to
          define any polygon (with any number of vertices) with floating
          point values.  Please see the description of this option in
          *note Invoking astcrop:: for its syntax.

WCS coordinates
     In WCS mode (‘--mode=wcs’), the coordinates and widths are
     interpreted using the World Coordinate System (WCS, that must
     accompany the dataset), not pixel coordinates.  In WCS mode, Crop
     accepts multiple datasets as input.  When the cropped region
     (defined by its center or vertices) overlaps with multiple of the
     input images/tiles, the overlapping regions will be taken from the
     respective input (they will be stitched when necessary for each
     output crop).

     In this mode, the input images do not necessarily have to be the
     same size, they just need to have the same orientation and pixel
     resolution.  Currently only orientation along the celestial
     coordinates is accepted, if your input has a different orientation
     you can use Warp’s ‘--align’ option to align the image before
     cropping it (see *note Warp::).

     Each individual input image/tile can even be smaller than the final
     crop.  In any case, any part of any of the input images which
     overlaps with the desired region will be used in the crop.  Note
     that if there is an overlap in the input images/tiles, the pixels
     from the last input image read are going to be used for the
     overlap.  Crop will not change pixel values, so it assumes your
     overlapping tiles were cutout from the same original image.  There
     are multiple ways to define your cropped region as listed below.

     Center of multiple crops (in a catalog)
          Similar to catalog inputs in Image mode (above), except that
          the values along each dimension are assumed to have the same
          units as the dataset’s WCS information.  For example, the
          central RA and Dec value for each crop will be read from the
          first and second calls to the ‘--coordcol’ option.  The width
          of the cropped box (in units of the WCS, or degrees in RA and
          Dec mode) must be specified with the ‘--width’ option.

     Center of a single crop (on the command-line)
          You can specify the center of only one crop box with the
          ‘--center’ option.  If it exists in the input images, it will
          be cropped similar to the catalog mode, see above also for
          ‘--width’.

     Vertices of a single crop
          The ‘--polygon’ option is a high-level method to define any
          convex polygon (with any number of vertices).  Please see the
          description of this option in *note Invoking astcrop:: for its
          syntax.

     *CAUTION:* In WCS mode, the image has to be aligned with the
     celestial coordinates, such that the first FITS axis is parallel
     (opposite direction) to the Right Ascension (RA) and the second
     FITS axis is parallel to the declination.  If these conditions
     aren’t met for an image, Crop will warn you and abort.  You can use
     Warp’s ‘--align’ option to align the input image with these
     coordinates, see *note Warp::.

   As a summary, if you don’t specify a catalog, you have to define the
cropped region manually on the command-line.  In any case the mode is
mandatory for Crop to be able to interpret the values given as
coordinates or widths.


File: gnuastro.info,  Node: Crop section syntax,  Next: Blank pixels,  Prev: Crop modes,  Up: Crop

6.1.2 Crop section syntax
-------------------------

When in image mode, one of the methods to crop only one rectangular
section from the input image is to use the ‘--section’ option.  Crop has
a powerful syntax to read the box parameters from a string of
characters.  If you leave certain parts of the string to be empty, Crop
can fill them for you based on the input image sizes.

   To define a box, you need the coordinates of two points: the first
(‘X1’, ‘Y1’) and the last pixel (‘X2’, ‘Y2’) pixel positions in the
image, or four integer numbers in total.  The four coordinates can be
specified with one string in this format: ‘‘X1:X2,Y1:Y2’’.  This string
is given to the ‘--section’ option.  Therefore, the pixels along the
first axis that are $\geq$‘X1’ and $\leq$‘X2’ will be included in the
cropped image.  The same goes for the second axis.  Note that each
different term will be read as an integer, not a float.

   The reason it only accepts integers is that ‘--section’ is a
low-level option (which is also very fast!).  For a higher-level way to
specify region (any polygon, not just a box), please see the ‘--polygon’
option in *note Crop options::.  Also note that in the FITS standard,
pixel indexes along each axis start from unity(1) not zero(0).

   You can omit any of the values and they will be filled automatically.
The left hand side of the colon (‘:’) will be filled with ‘1’, and the
right side with the image size.  So, ‘2:,:’ will include the full range
of pixels along the second axis and only those with a first axis index
larger than ‘2’ in the first axis.  If the colon is omitted for a
dimension, then the full range is automatically used.  So the same
string is also equal to ‘2:,’ or ‘2:’ or even ‘2’.  If you want such a
case for the second axis, you should set it to: ‘,2’.

   If you specify a negative value, it will be seen as before the
indexes of the image which are outside the image along the bottom or
left sides when viewed in SAO ds9.  In case you want to count from the
top or right sides of the image, you can use an asterisk (‘*’).  When
confronted with a ‘*’, Crop will replace it with the maximum length of
the image in that dimension.  So ‘*-10:*+10,*-20:*+20’ will mean that
the crop box will be 20\times40 pixels in size and only include the top
corner of the input image with 3/4 of the image being covered by blank
pixels, see *note Blank pixels::.

   If you feel more comfortable with space characters between the
values, you can use as many space characters as you wish, just be
careful to put your value in double quotes, for example
‘--section="5:200, 123:854"’.  If you forget the quotes, anything after
the first space will not be seen by ‘--section’ and you will most
probably get an error because the rest of your string will be read as a
filename (which most probably doesn’t exist).  See *note Command-line::
for a description of how the command-line works.

