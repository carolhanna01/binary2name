<html lang="en">
<head>
<title>Surface Hiding - 3DLDF User and Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="3DLDF User and Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Pictures.html#Pictures" title="Pictures">
<link rel="prev" href="Focuses-Getstart.html#Focuses-Getstart" title="Focuses Getstart">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This is the 3DLDF User and Reference Manual, edition 1.1.5.1 for
3DLDF 1.1.5.1.
This manual was last updated on
16 January 2004.

3DLDF is a GNU package for three-dimensional drawing with MetaPost
output.
The author is Laurence D. Finston.

Copyright (C) 2003, 2004 , 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 The Free Software Foundation

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Surface-Hiding"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Focuses-Getstart.html#Focuses-Getstart">Focuses Getstart</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Pictures.html#Pictures">Pictures</a>
<hr>
</div>

<h3 class="section">9.3 Surface Hiding</h3>

<!-- !! TO DO:  Write about z-buffers, and how scan converting is needed -->
<!-- to use them.  Also, show how to do surface hiding of the two -->
<!-- rectangles by hand! -->
<p>In [next figure]
, <code>Circle</code> <var>c</var> lies in front of <code>Rectangle</code>
<var>r</var>. 
Since <var>c</var> is drawn and not filled, <var>r</var> is visible behind
<var>c</var>.

<pre class="example">     default_focus.set(1, 3, -5, 0, 3, 5, 10);
     Point p(0, -2, 5);
     Rectangle r(p, 3, 4, 90);
     r.draw();
     Point q(2, -2, 3);
     Circle c(q, 3, 90);
     c.draw();
     current_picture.output();
</pre>
   <p><p align="center">
<br>
<img src="./graphics/png/3DLDF64.png"
alt="[Figure 64. Not displayed.]" 
/>
<br>
<br>
Fig. 64. 
<br>
</p>

   <p>If instead, <var>c</var> is filled or filldrawn, only the parts of <var>r</var> that are not
covered by <var>c</var> should be visible:

<pre class="example">     r.draw();
     c.filldraw();
</pre>
   <p><p align="center">
<br>
<img src="./graphics/png/3DLDF65.png"
alt="[Figure 65. Not displayed.]" 
/>
<br>
<br>
Fig. 65. 
<br>
</p>

   <p>What parts of <code>r</code> are covered depend on the point of view, i.e.,
the position and direction of the <code>Focus</code> used for outputting the
<code>Picture</code>:

<pre class="example">     default_focus.set(8, 0, -5, 5, 3, 5, 10);
</pre>
   <p><p align="center">
<br>
<img src="./graphics/png/3DLDF66.png"
alt="[Figure 66. Not displayed.]" 
/>
<br>
<br>
Fig. 66. 
<br>
</p>

   <p><a name="index-surface-hiding-78"></a><a name="index-hidden-surface-algorithm-79"></a>Determining what objects cover other objects in a program for 3D
graphics is called
<dfn>surface hiding</dfn>,
and is performed by a
<dfn>hidden surface algorithm</dfn>.  3DLDF currently has a very primitive
hidden surface algorithm that only works for the most simple cases.

   <p><a name="index-painter_0027s-algorithm-80"></a>The hidden surface algorithm used in 3DLDF is a
<dfn>painter's algorithm</dfn>, which means that the objects that are
furthest away from the <code>Focus</code> are drawn first, followed by the
objects that are closer, which may thereby cover them.  In order to make
this possible, the <code>Shapes</code> on a <code>Picture</code> must be sorted
before they are output.  They are sorted according to the z-values in
the <code>projective_coordinates</code> of the <code>Points</code> belonging to the
<code>Shape</code>.  This may seem strange, since the
projection is two-dimensional and only the x and y-values from
<code>projective_coordinates</code> are written to <code>out_stream</code>. 
However, the perspective transformation also produces a z-coordinate,
which indicates the distance of the <code>Points</code> from the <code>Focus</code>
in the z-dimension.

   <p>The problem is, that all <code>Shapes</code>, except <code>Points</code> themselves,
consist of multiple <code>Points</code>, that may have different
z-coordinates.  3DLDF currently does not yet have a satisfactory way of
dealing with this situtation.  In order to try to cope with it, the user
can specify four different ways of sorting the <code>Shapes</code>:  They
can be sorted according to the maximum z-coordinate, the
minimum z-coordinate, the mean of the maximum and minimum z-coordinate
(max + min) / 2,
and not sorted. 
In the last case, the <code>Shapes</code> are output in the order of the
drawing and filling commands in the user code. 
The z-coordinates referred to are those in
<code>projective_coordinates</code>, and will have been calculated for a
particular <code>Focus</code>.

   <p>The function <code>Picture::output()</code> takes a
<code>const unsigned short</code> <var>sort_value</var> argument that specifies
which style of sorting
should be used.  The namespace <code>Sorting</code> contains the following
constants which should be used for <var>sort_value</var>: <code>MAX_Z</code>,
<code>MIN_Z</code>, <code>MEAN_Z</code>, and <code>NO_SORT</code>.  The default is
<code>MAX_Z</code>.

   <p>3DLDF's primitive hidden surface algorithm <em>cannot</em> work for
objects that intersect.  The following examples demonstrate why not:

<pre class="example">     using namespace Sorting;
     using namespace Colors;
     using namespace Projections;
     default_focus.set(5, 3, -10, 3, 1, 1, 10, 180);
     Rectangle r0(origin, 3, 4, 45);
     Rectangle r1(origin, 2, 6, -45);
     r0.draw();
     r1.draw();
     current_picture.output(default_focus, PERSP, 1, MAX_Z);
     r0.show("r0:");
     -| r0:
     fill_draw_value == 0
     (-1.5, -1.41421, -1.41421) -- (1.5, -1.41421, -1.41421) --
     (1.5, 1.41421, 1.41421) -- (-1.5, 1.41421, 1.41421)
     -- cycle;
     
     r0.show("r0:", 'p');
     -| r0:
     fill_draw_value == 0
     Perspective coordinates.
     (-5.05646, -4.59333, -0.040577) -- (-2.10249, -4.86501, -0.102123) --
     (-1.18226, -1.33752, 0.156559) -- (-3.51276, -1.2796, 0.193084)
     -- cycle;
     
     r1.show("r1:");
     -| r1:
     fill_draw_value == 0
     (-1, 2.12132, -2.12132) -- (1, 2.12132, -2.12132) --
     (1, -2.12132, 2.12132) -- (-1, -2.12132, 2.12132)
     -- cycle;
     
     r1.show("r1:", 'p');
     -| r1:
     fill_draw_value == 0
     Perspective coordinates.
     (-5.09222, -0.995681, -0.133156) -- (-2.98342, -1.03775, -0.181037) --
     (-1.39791, -4.05125, 0.208945) -- (-2.87319, -3.93975, 0.230717)
     -- cycle;
</pre>
   <p><p align="center">
<br>
<img src="./graphics/png/3DLDF67.png"
alt="[Figure 67. Not displayed.]" 
/>
<br>
<br>
Fig. 67. 
<br>
</p>

   <p>In [the previous figure]
, the <code>Rectangles</code> r_0 and r_1 intersect along the
x-axis.  The z-values of the <code>world_coordinates</code> of r_0 are
-1.41421 and 1.41421 (two <code>Points</code> each), while those of r_1
are 2.12132 and  -2.12132.  So r_1 has two <code>Points</code> with
z-coordinates greater than the z-coordinate of any <code>Point</code>
on r_0, and two <code>Points</code> with z-coordinates less than the
z-coordinate of any <code>Point</code> on r_0.  The
<code>Points</code> on r_0 and r_1 all have different z-values in
their <code>projective_coordinates</code>, but r_1 still has a <code>Point</code>
with a z-coordinate greater than that of any of the <code>Points</code> on
r_0, and one with a z-coordinate less than that of any of the
<code>Points</code> on r_0.

   <p>In [next figure]
, the <code>Shapes</code> on <code>current_picture</code> are sorted
according to the maximum z-values of the <code>projective_coordinates</code>
of the <code>Points</code> belonging to the <code>Shapes</code>.  r_1 is
filled and drawn first,
because it has the <code>Point</code> with the positive z-coordinate of
greatest magnitude. 
When subsequently r_0 is drawn, it covers part of the top of
r_1, which lies in front of r_0, and should be visible:

<pre class="example">     current_picture.output(default_focus, PERSP, 1, MAX_Z);
</pre>
   <p><p align="center">
<br>
<img src="./graphics/png/3DLDF68.png"
alt="[Figure 68. Not displayed.]" 
/>
<br>
<br>
Fig. 68. 
<br>
</p>

   <p>In [next figure]
, the <code>Shapes</code> on <code>current_picture</code> are sorted
according to the minimum z-values of the <code>projective_coordinates</code>
of the <code>Points</code> belonging to the <code>Shapes</code>.  <code>r1</code> is drawn
and filled last, because
it has the <code>Point</code> with the negative z-coordinate of greatest
magnitude. 
It thereby covers the bottom part of
<code>r0</code>, which lies in front of <code>r1</code>, and should be visible.

<pre class="example">     current_picture.output(default_focus, PERSP, 1, MIN_Z);
</pre>
   <p><p align="center">
<br>
<img src="./graphics/png/3DLDF69.png"
alt="[Figure 69. Not displayed.]" 
/>
<br>
<br>
Fig. 69. 
<br>
</p>

   <p>Neither sorting by the mean z-value in the
<code>projective_coordinates</code>, nor suppressing sorting does any good. 
In each case, one <code>Rectangle</code> is always drawn and filled last,
covering parts of the other that lie in front of the first.

   <p>3DLDF's hidden surface algorithm will fail wherever objects intersect,
not just where one extends past the other in both the positive and
negative z-directions.

<pre class="example">     Rectangle r(origin, 3, 4, 45);
     Circle c(origin, 2, -45);
     r.filldraw();
     c.filldraw(black, gray);
     current_picture.output(default_focus, PERSP, 1, NO_SORT);
</pre>
   <p><p align="center">
<br>
<img src="./graphics/png/3DLDF70.png"
alt="[Figure 70. Not displayed.]" 
/>
<br>
<br>
Fig. 70. 
<br>
</p>

   <p>Even where objects don't intersect, their projections may.  In order to
handle these cases properly, it is necessary to break up the
<code>Shapes</code> on a <code>Picture</code> into smaller <code>Shapes</code>, until
there are none that intersect or whose projections intersect.  Then, any
of the three methods of sorting described above can be used to sort the
<code>Shapes</code>, and they can be output.

   <p>Before this can be done, 3DLDF must be able to find the intersections of
all of the different kinds of <code>Shapes</code>.  If 3DLDF converted solids
to polyhedra and curves to sequences of line segments, this would reduce
to the problem of finding the intersections of lines and planes, however
it does not yet do this.

   <p>Even if it did, a fully functional hidden surface algorithm must compare
each <code>Shape</code> on a <code>Picture</code> with every other <code>Shape</code>. 
Therefore, for n <code>Shapes</code>, there will be
n! / ((n - r)! r!) 
(possibly time-consuming) comparisons.

   <p><p align="center">
<br>
<img src="./graphics/png/3DLDF71.png"
alt="[Figure 71. Not displayed.]" 
/>
<br>
<br>
Fig. 71. 
<br>
</p>

<!-- I've put this here, so that it doesn't interfere with the Emacs-Lisp -->
<!-- routine I'm using to insert the figure numbers for HTML and Info -->
<!-- output.  LDF 2003.12.16. -->
   <p>Clearly, such a hidden surface
algorithm would considerably increase run-time.

   <p>Currently, all of the <code>Shapes</code> on a <code>Picture</code> are output, as
long as they lie completely within the boundaries passed as arguments to
<code>Picture::output()</code>. 
See <a href="Outputting-Pictures.html#Outputting-Pictures">Pictures; Outputting</a>.  It
would be more efficient to suppress output for them, if they are
completely covered by other objects.  This also requires comparisions,
and could be implemented together with a fully-functional hidden surface
algorithm.

   <p>Shadows, reflections, highlights and shading are all effects requiring
comparing each <code>Shape</code> with every other <code>Shape</code>, and could
greatly increase run-time.

<!-- intersct.texi -->
<!-- This file is part of the 3DLDF User and Reference Manual. -->
<!-- Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 The Free Software Foundation -->
<!-- See the section "GNU Free Documentation License" in the file -->
<!-- fdl.texi for copying conditions. -->
   </body></html>

