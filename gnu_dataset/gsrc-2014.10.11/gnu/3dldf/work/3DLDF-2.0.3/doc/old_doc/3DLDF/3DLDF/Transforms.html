<html lang="en">
<head>
<title>Transforms - 3DLDF User and Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="3DLDF User and Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Transforming-Points.html#Transforming-Points" title="Transforming Points">
<link rel="next" href="Drawing-and-Labeling-Points.html#Drawing-and-Labeling-Points" title="Drawing and Labeling Points">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This is the 3DLDF User and Reference Manual, edition 1.1.5.1 for
3DLDF 1.1.5.1.
This manual was last updated on
16 January 2004.

3DLDF is a GNU package for three-dimensional drawing with MetaPost
output.
The author is Laurence D. Finston.

Copyright (C) 2003, 2004 , 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 The Free Software Foundation

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Transforms"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Drawing-and-Labeling-Points.html#Drawing-and-Labeling-Points">Drawing and Labeling Points</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Transforming-Points.html#Transforming-Points">Transforming Points</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">4 Transforms</h2>

<p><a name="index-Transform-35"></a>When <code>Points</code> are transformed using <code>shift()</code>, <code>shear()</code>,
or one of the other transformation functions, the
<code>world_coordinates</code> are not modified directly.  Instead,
another data member of <code>class Point</code> is used to store the
information about the transformation, namely <code>transform</code> of
type <code>class Transform</code>.  A <code>Transform</code> object has a single
data element of type <code>Matrix</code> and a number of member functions.  A
<code>Matrix</code> is
simply a
4 X 4
array<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>
of <code>reals</code>
defined using <code>typedef real Matrix[4][4]</code>. 
Such a matrix suffices for performing all
of the transformations (affine and perspective) possible in
three-dimensional space.<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>
Any combination of transformations can be represented by a single
transformation matrix.  This means that consecutive transformations
of a <code>Point</code> can be &ldquo;saved up&rdquo; and applied to its coordinates
all at once when needed, rather than updating them for each
transformation.

   <p><a name="index-homogeneous-coordinates-36"></a><code>Transforms</code> work by performing matrix multiplication of
<code>Matrix</code> with the homogeneous <code>world_coordinates</code> of
<code>Points</code>. 
If a set of homogeneous coordinates
\alpha = (x, y, z, w)
and
<pre class="display">     <code>Matrix M</code> =
     a e i m
     b f j n
     c g k o
     d h l p
</pre>
   <p>then the set of homogeneous coordinates \beta resulting from
multiplying \alpha and M is calculated as follows:
<pre class="display">     \beta = \alpha\times M = ((xa + yb + zc + wd),  (xe + yf + zg + wh),
     (xi + yj + zk + wl), (xm + yn + zo + wp))
</pre>
   <p>Please note that each coordinate of \beta can be influenced by all of the
coordinates of \alpha.

   <p>Operations on
matrices are very important in computer graphics applications and are
described in many books about computer graphics and geometry.  For
3DLDF, I've mostly used Huw Jones'
<cite>Computer Graphics through Key Mathematics</cite>
and David Salomon's <cite>Computer Graphics and Geometric Modeling</cite>.

   <p><a name="index-Transform-37"></a>It is often useful to declare and use <code>Transform</code> objects in 3DLDF,
just as it is for <code>transforms</code> in Metafont.  Transformations can be
stored in <code>Transforms</code> and then be used to transform <code>Points</code>
by means of <code>Point::operator*=(const Transform&amp;)</code>.

<pre class="example">     <span class="roman">1.</span> Transform t;
     <span class="roman">2.</span> t.shift(0, 1);
     <span class="roman">3.</span> Point p(1, 0, 0);
     <span class="roman">4.</span> p *= t;
     <span class="roman">5.</span> p.show("p:");
     -| p: (1, 1, 0)
</pre>
   <p><a name="index-identity-matrix-38"></a><a name="index-matrix_002c-identity-39"></a><a name="index-matrix-operations-40"></a><a name="index-operations_002c-matrix-41"></a>When a <code>Transform</code> is declared (line 1), it is
initialized to an <dfn>identity matrix</dfn>.  All identity matrices are
square, all of the elements of the main diagonal (upper left to lower
right) are 1, and all of the other elements are 0. 
So a
4 X 4
identity matrix, as used in 3DLDF, looks like this:
<pre class="display">     1 0 0 0
     0 1 0 0
     0 0 1 0
     0 0 0 1
</pre>
   <p>If a matrix A is multiplied with an identity matrix I, the result is
identical to A, i.e.,
A * I = A. 
This is the salient property of an identity matrix.

   <p>The same affine transformations are applied in the same way to
<code>Transforms</code> as they are to <code>Points</code>, i.e., the functions
<code>scale()</code>, <code>shift()</code>,
<code>shear()</code>, and <code>rotate()</code>
correspond to the <code>Point</code>
versions of these functions, and they take the same arguments:

<pre class="example">     Point p;
     Transform t;
     p.shift(3, 4, 5);
     t.shift(3, 4, 5);
     &rArr; p.transform == t
     p.show_transform("p:");
     -| p:
        Transform:
              0   0.707   0.707       0
         -0.866   0.354  -0.354       0
           -0.5  -0.612   0.612       0
              0       0       0       1
     t.show("t:");
     -| t:
              0   0.707   0.707       0
         -0.866   0.354  -0.354       0
           -0.5  -0.612   0.612       0
              0       0       0       1
     
</pre>
   <ul class="menu">
<li><a accesskey="1" href="Applying-Transforms-to-Points-Intro.html#Applying-Transforms-to-Points-Intro">Applying Transforms to Points Intro</a>
<li><a accesskey="2" href="Inverting-Transforms.html#Inverting-Transforms">Inverting Transforms</a>
</ul>

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> It is unfortunate that
the terms &ldquo;array&rdquo;, &ldquo;matrix&rdquo;, and &ldquo;vector&rdquo; have different meanings
in C++
 and in normal mathematical usage. However, in practice, these
discrepancies turn out not to cause many problems.  Stroustrup,
<cite>The C++
 Programming Language</cite>, section
 22.4, p. 662.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> In fact, none of the operations for
transformations require all of the elements of a
4 X 4
matrix.  In many
3D graphics programs, the matrix operations are modified to use smaller
transformation matrices, which reduces the storage requirements of the
program.  This is a bit tricky, because the affine transformations and
the perspective transformation use different elements of the matrix.  I
consider that the risk of something going wrong, possibly producing
hard-to-find bugs, outweighs any benefits from saving memory (which
is usually no longer at a premium, anyway).  In addition, there may be
some interesting non-affine transformations that would be worth
implementing.  Therefore, I've decided to
use full
4 X 4
matrices in 3DLDF.</p>

   <hr></div>

   </body></html>

