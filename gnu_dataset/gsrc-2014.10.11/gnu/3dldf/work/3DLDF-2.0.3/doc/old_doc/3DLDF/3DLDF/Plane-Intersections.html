<html lang="en">
<head>
<title>Plane Intersections - 3DLDF User and Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="3DLDF User and Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Plane-Reference.html#Plane-Reference" title="Plane Reference">
<link rel="prev" href="Planes-Returning-Information.html#Planes-Returning-Information" title="Planes Returning Information">
<link rel="next" href="Planes-Showing.html#Planes-Showing" title="Planes Showing">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This is the 3DLDF User and Reference Manual, edition 1.1.5.1 for
3DLDF 1.1.5.1.
This manual was last updated on
16 January 2004.

3DLDF is a GNU package for three-dimensional drawing with MetaPost
output.
The author is Laurence D. Finston.

Copyright (C) 2003, 2004 , 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 The Free Software Foundation

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled ``GNU Free Documentation License''.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Plane-Intersections"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Planes-Showing.html#Planes-Showing">Planes Showing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Planes-Returning-Information.html#Planes-Returning-Information">Planes Returning Information</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Plane-Reference.html#Plane-Reference">Plane Reference</a>
<hr>
</div>

<h3 class="section">25.6 Intersections</h3>

<div class="defun">
&mdash; <code>const</code> function: bool_point <b>intersection_point</b> (<var>const Point&amp; p0, const Point&amp; p1</var>)<var><a name="index-intersection_005fpoint-521"></a></var><br>
&mdash; <code>const</code> function: bool_point <b>intersection_point</b> (<var>const Path&amp; p</var>)<var><a name="index-intersection_005fpoint-522"></a></var><br>
<blockquote><p>These functions find the intersection point of the <code>Plane</code> and a
line.  In the first version, the
line is defined by the two <code>Point</code> arguments.  In the second
version, the <code>Path</code> <var>p</var> must be linear, i.e.,
<var>p</var>.<code>is_linear()</code> must be <code>true</code>.

        <p>Both versions of <code>intersection_point()</code> return a <code>bool_point</code>
<var>bp</var>, where  <var>bp</var>.<code>pt</code> is the intersection point, or
<code>INVALID_POINT</code>, if there is none.  If an intersection point is
found, <var>bp</var>.<code>b</code> will be <code>true</code>, otherwise <code>false</code>. 
Returning a <code>bool_point</code> makes it possible to test for success
without comparing the <code>Point</code> returned against <code>INVALID_POINT</code>.

     <pre class="example">          Point center(2, 2, 3.5);
          Reg_Polygon h(center, 6, 4, 80, 30, 10);
          Plane q = h.get_plane();
          Point P0 = center.mediate(h.get_point(2));
          P0.shift(5 * (N - center));
          Point P1(P0);
          P1.rotate(h.get_point(1), h.get_point(4));
          P1 = 3 * (P1 - P0);
          P1.shift(P0);
          P1.shift(3, -.5, -2);
          bool_point bp = q.intersection_point(P0, P1);
          Point i_P = bp.pt;
          Point P4 = h.get_point(3).mediate(h.get_point(0), .75);
          P4.shift(N - center);
          Point P5(P4);
          P5.rotate(h.get_point(3), h.get_point(0));
          P4.shift(-1, 2);
          Path theta(P4, P5);
          bp = q.intersection_point(theta);
          Point i_theta = bp.pt;
          draw_axes();
</pre>
        <p><p align="center">
<br>
<img src="./graphics/png/3DLDF107.png"
alt="[Figure 107. Not displayed.]" 
/>
<br>
<br>
Fig. 107. 
<br>
</p>

     </blockquote></div>

<div class="defun">
&mdash; <code>const</code> function: Line <b>intersection_line</b> (<var>const Plane&amp; p</var>)<var><a name="index-intersection_005fline-523"></a></var><br>
<blockquote><p>Returns a <code>Line</code> <var>l</var>.  representing the line of intersection of two
<code>Planes</code>.  See <a href="Line-Reference.html#Line-Reference">Line Reference</a>.

        <p>In [next figure]
, <code>intersection_line()</code> is used to find the line of
intersection of the <code>Planes</code> derived from the <code>Rectangles</code>
r_0 and r_1 using <code>get_plane()</code>
(see <a href="Querying-Paths.html#Querying-Paths">Paths Reference; Querying</a>). 
Please note that there is no guarantee that <var>l</var>.<code>position</code> will
be in a convenient place for your drawing.  A bit of fiddling was
needed to find the <code>Points</code> P_2 and P_3. 
<!-- !! TO DO: -->
I plan to add functions for finding the intersection lines of plane
figures, but haven't done so yet.

     <pre class="example">          Rectangle r0(origin, 5, 5, 10, 15, 6);
          Rectangle r1(origin, 5, 5, 90, 50, 10);
          r1 *= r0.rotate(30, 30, 30);
          r1 *= r0.shift(1, -1, 3);
          Plane q0 = r0.get_plane();
          Plane q1 = r1.get_plane();
          Line l = q0.intersection_line(q1);
          l.show("l:");
          -| l:
             position: (0, 11.2193, 20.0759)
             direction: (0.0466595, -0.570146, -0.796753)
          Point P0(l.direction);
          P0.shift(l.position);
          P0.show("P0:");
          -| P0: (0.0466595, 10.6491, 19.2791)
          Point P1(-l.direction);
          P1.shift(l.position);
          Point P2(P0 - P1);
          P2 *= 12.5;
          P2.shift(P0);
          cout &lt;&lt; P2.is_on_plane(q0);
          -| 1
          cout &lt;&lt; P2.is_on_plane(q1);
          -| 1
          Point P3(P0 - P1);
          P3 *= 7;
          P3.shift(P0);
          cout &lt;&lt; P3.is_on_plane(q0);
          -| 1
          cout &lt;&lt; P3.is_on_plane(q1);
          -| 1
</pre>
        <p><p align="center">
<br>
<img src="./graphics/png/3DLDF108.png"
alt="[Figure 108. Not displayed.]" 
/>
<br>
<br>
Fig. 108. 
<br>
</p>

        </blockquote></div>

   </body></html>

