# Chinese translations for idutils package.
# Copyright (C) 2010 Free Software Foundation, Inc.
# This file is distributed under the same license as the idutils package.
# Ji ZhengYu <zhengyuji@gmail.com>, 2008, 2009, 2010.
#
msgid ""
msgstr ""
"Project-Id-Version: idutils 4.5\n"
"Report-Msgid-Bugs-To: bug-idutils@gnu.org\n"
"POT-Creation-Date: 2012-02-03 11:55+0100\n"
"PO-Revision-Date: 2010-07-02 13:24+0800\n"
"Last-Translator: Ji ZhengYu <zhengyuji@gmail.com>\n"
"Language-Team: Chinese (simplified) <i18n-zh@googlegroups.com>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: lib/closeout.c:112
msgid "write error"
msgstr "写错误"

#: lib/error.c:188
msgid "Unknown system error"
msgstr "未知系统错误"

#: lib/getopt.c:547 lib/getopt.c:576
#, fuzzy, c-format
msgid "%s: option '%s' is ambiguous; possibilities:"
msgstr "%s: 选项‘-W %s’有歧义\n"

#: lib/getopt.c:624 lib/getopt.c:628
#, c-format
msgid "%s: option '--%s' doesn't allow an argument\n"
msgstr "%s: 选项‘--%s’不允许带参数\n"

#: lib/getopt.c:637 lib/getopt.c:642
#, c-format
msgid "%s: option '%c%s' doesn't allow an argument\n"
msgstr "%s: 选项‘%c%s’不允许带参数\n"

#: lib/getopt.c:685 lib/getopt.c:704
#, c-format
msgid "%s: option '--%s' requires an argument\n"
msgstr "%s: 选项‘--%s’需要参数\n"

#: lib/getopt.c:742 lib/getopt.c:745
#, c-format
msgid "%s: unrecognized option '--%s'\n"
msgstr "%s: 选项‘--%s’不可识别\n"

#: lib/getopt.c:753 lib/getopt.c:756
#, c-format
msgid "%s: unrecognized option '%c%s'\n"
msgstr "%s: 选项‘%c%s’不可识别\n"

#: lib/getopt.c:805 lib/getopt.c:808
#, c-format
msgid "%s: invalid option -- '%c'\n"
msgstr "%s: 无效选项 -- '%c'\n"

#: lib/getopt.c:861 lib/getopt.c:878 lib/getopt.c:1088 lib/getopt.c:1106
#, c-format
msgid "%s: option requires an argument -- '%c'\n"
msgstr "%s: 选项 -- '%c' 需要参数\n"

#: lib/getopt.c:934 lib/getopt.c:950
#, c-format
msgid "%s: option '-W %s' is ambiguous\n"
msgstr "%s: 选项‘-W %s’有歧义\n"

#: lib/getopt.c:974 lib/getopt.c:992
#, c-format
msgid "%s: option '-W %s' doesn't allow an argument\n"
msgstr "%s: 选项‘-W %s’不允许带参数\n"

#: lib/getopt.c:1013 lib/getopt.c:1031
#, c-format
msgid "%s: option '-W %s' requires an argument\n"
msgstr "%s: 选项‘-W %s’需要参数\n"

#: lib/obstack.c:413 lib/obstack.c:415 lib/xalloc-die.c:34
msgid "memory exhausted"
msgstr "内存耗尽"

#: lib/openat-die.c:38
#, c-format
msgid "unable to record current working directory"
msgstr "无法记录当前工作目录"

#: lib/openat-die.c:57
#, c-format
msgid "failed to return to initial working directory"
msgstr "无法返回起始工作目录"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  For example, a French Unicode local should translate
#. these to U+00AB (LEFT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), respectively.
#.
#. If the catalog has no translation, we will try to
#. use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and
#. Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the
#. current locale is not Unicode, locale_quoting_style
#. will quote 'like this', and clocale_quoting_style will
#. quote "like this".  You should always include translations
#. for "`" and "'" even if U+2018 and U+2019 are appropriate
#. for your locale.
#.
#. If you don't know what to put here, please see
#. <http://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:311
msgid "`"
msgstr "“"

#: lib/quotearg.c:312
msgid "'"
msgstr "”"

#: lib/regcomp.c:131
msgid "Success"
msgstr "成功"

#: lib/regcomp.c:134
msgid "No match"
msgstr "无匹配"

#: lib/regcomp.c:137
msgid "Invalid regular expression"
msgstr "无效的正则表达式"

#: lib/regcomp.c:140
msgid "Invalid collation character"
msgstr "无效的排序比较方式"

#: lib/regcomp.c:143
msgid "Invalid character class name"
msgstr "无效的字符类名称"

#: lib/regcomp.c:146
msgid "Trailing backslash"
msgstr "反斜杠太多"

#: lib/regcomp.c:149
msgid "Invalid back reference"
msgstr "无效的向后引用"

#: lib/regcomp.c:152
msgid "Unmatched [ or [^"
msgstr "[ 或 [^ 不匹配"

#: lib/regcomp.c:155
msgid "Unmatched ( or \\("
msgstr "( 或 \\( 不匹配"

#: lib/regcomp.c:158
msgid "Unmatched \\{"
msgstr "\\{ 不匹配"

#: lib/regcomp.c:161
msgid "Invalid content of \\{\\}"
msgstr "\\{\\} 中的内容无效"

#: lib/regcomp.c:164
msgid "Invalid range end"
msgstr "无效的范围"

#: lib/regcomp.c:167
msgid "Memory exhausted"
msgstr "内存耗尽"

#: lib/regcomp.c:170
msgid "Invalid preceding regular expression"
msgstr "先前的正则表达式无效"

#: lib/regcomp.c:173
msgid "Premature end of regular expression"
msgstr "正则表达式过早结束"

#: lib/regcomp.c:176
msgid "Regular expression too big"
msgstr "正则表达式太长"

#: lib/regcomp.c:179
msgid "Unmatched ) or \\)"
msgstr ") 或 \\) 不匹配"

#: lib/regcomp.c:700
msgid "No previous regular expression"
msgstr "没有上一次的正则表达式"

#: libidu/fnprint.c:137
#, c-format
msgid "invalid `--separator' style: `%s'"
msgstr "无效的‘--separator’方式: ‘%s’"

#: libidu/idfile.c:106
#, c-format
msgid "can't determine the io_size of a string!"
msgstr "无法确定字符串的 io_size"

#: libidu/idread.c:49 src/lid.c:596 src/mkid.c:588 src/xtokid.c:340
#, c-format
msgid "can't open `%s'"
msgstr "无法打开‘%s’"

#: libidu/idread.c:68
#, c-format
msgid "`%s' is not an ID file! (bad magic #)"
msgstr "‘%s’不是 ID 文件！(错误的 magic #)"

#: libidu/idread.c:70
#, c-format
msgid "`%s' is version %d, but I only grok version %d"
msgstr "‘%s’的版本号为 %d，但我仅想要版本号为 %d 的版本"

#: libidu/idread.c:190
#, c-format
msgid "unsupported size in io_read (): %d"
msgstr "io_read()中有不支持的字节大小: %d"

#: libidu/idread.c:200 libidu/idwrite.c:169
#, c-format
msgid "unknown I/O type: %d"
msgstr "未知的 I/O 类型: %d"

#: libidu/idu-hash.c:51
#, c-format
msgid "can't allocate %ld bytes for hash table: memory exhausted"
msgstr "无法给哈希表分配 %ld 字节: 内存耗尽"

#: libidu/idu-hash.c:264
#, c-format
msgid "Load=%ld/%ld=%.0f%%, "
msgstr "载入=%ld/%ld=%.0f%%, "

#: libidu/idu-hash.c:266
#, c-format
msgid "Rehash=%d, "
msgstr "重新生成哈希表(Rehash)=%d, "

#: libidu/idu-hash.c:267
#, c-format
msgid "Collisions=%ld/%ld=%.0f%%"
msgstr "哈希值冲突=%ld/%ld=%.0f%%"

#: libidu/idwrite.c:158
#, c-format
msgid "unsupported size in io_write (): %d"
msgstr "io_write()中有不支持的字节大小: %d"

#: libidu/scanners.c:108
#, c-format
msgid "unrecognized language: `%s'"
msgstr "不可识别的语言: ‘%s’"

#: libidu/scanners.c:168
#, c-format
msgid "can't allocate language args obstack: memory exhausted"
msgstr "无法分配语言参数的对象堆栈"

#: libidu/scanners.c:222 libidu/scanners.c:291
#, c-format
msgid "can't allocate language args: memory exhausted"
msgstr "无法分配语言参数: 内存耗尽"

#: libidu/scanners.c:230
#, c-format
msgid "language name expected following `%s' in file `%s'"
msgstr "要求语言名称，在文件‘%2$s’中带上‘%1$s’"

#: libidu/scanners.c:285
#, c-format
msgid "can't open language map file `%s'"
msgstr "无法打开语言 map 文件‘%s’"

#: libidu/scanners.c:287
#, c-format
msgid "can't get size of map file `%s'"
msgstr "无法获取 map 文件的大小‘%s’"

#: libidu/scanners.c:297
#, c-format
msgid "can't read language map file `%s'"
msgstr "无法读取语言 map 文件‘%s’"

#: libidu/scanners.c:300
#, c-format
msgid "can't read entire language map file `%s'"
msgstr "无法读取整个语言 map 文件‘%s’"

#: libidu/scanners.c:449
#, c-format
msgid ""
"C language:\n"
"  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the "
"result\n"
"  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the "
"result\n"
"  -u,--strip-underscore  Strip a leading underscore from single-token "
"strings\n"
msgstr ""
"C 语言:\n"
"  -k,--keep=CHARS        允许在单个标记的字符串中使用 CHARS，保留结果\n"
"  -i,--ignore=CHARS      允许在单个标记的字符串中使用 CHARS，不保留结果\n"
"  -u,--strip-underscore  从单个标记的字符串中删除前面的下划线\n"

#: libidu/scanners.c:460
#, c-format
msgid ""
"C++ language:\n"
"  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the "
"result\n"
"  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the "
"result\n"
"  -u,--strip-underscore  Strip a leading underscore from single-token "
"strings\n"
msgstr ""
"C++ 语言:\n"
"  -k,--keep=CHARS        允许在单个标记的字符串中使用 CHARS，保留结果\n"
"  -i,--ignore=CHARS      允许在单个标记的字符串中使用 CHARS，不保留结果\n"
"  -u,--strip-underscore  从单个标记的字符串中删除前面的下划线\n"

#: libidu/scanners.c:471
#, c-format
msgid ""
"Java language:\n"
"  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the "
"result\n"
"  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the "
"result\n"
"  -u,--strip-underscore  Strip a leading underscore from single-token "
"strings\n"
msgstr ""
"Java 语言:\n"
"  -k,--keep=CHARS        允许在单个标记的字符串中使用 CHARS，保留结果\n"
"  -i,--ignore=CHARS      允许在单个标记的字符串中使用 CHARS，不保留结果\n"
"  -u,--strip-underscore  从单个标记的字符串中删除前面的下划线\n"

#: libidu/scanners.c:754 libidu/scanners.c:1023 libidu/scanners.c:1226
#: libidu/scanners.c:1496
#, c-format
msgid "junk: `%c'"
msgstr "内存碎片: ‘%c’"

#: libidu/scanners.c:756 libidu/scanners.c:1025 libidu/scanners.c:1228
#: libidu/scanners.c:1498
#, c-format
msgid "junk: `\\%03o'"
msgstr "内存碎片: ‘\\%03o’"

#: libidu/scanners.c:858
#, c-format
msgid ""
"Assembly language:\n"
"  -c,--comment=CHARS     Any of CHARS starts a comment until end-of-line\n"
"  -k,--keep=CHARS        Allow CHARS in tokens, and keep the result\n"
"  -i,--ignore=CHARS      Allow CHARS in tokens, and toss the result\n"
"  -u,--strip-underscore  Strip a leading underscore from tokens\n"
"  -n,--no-cpp            Don't handle C pre-processor directives\n"
msgstr ""
"汇编语言:\n"
"  -c,--comment=CHARS     从 CHARS 开始为一个注释，直到一行结束\n"
"  -k,--keep=CHARS        允许在标识中使用 CHARS 并保存结果\n"
"  -i,--ignore=CHARS      允许在标识中使用 CHARS 但不保存结果\n"
"  -u,--strip-underscore  从标识中删除前面的下划线\n"
"  -n,--no-cpp            不要处理 C 预处理指定\n"

#: libidu/scanners.c:1129
#, c-format
msgid ""
"Text language:\n"
"  -i,--include=CHAR-CLASS  Treat characters of CHAR-CLASS as token "
"constituents\n"
"  -x,--exclude=CHAR-CLASS  Treat characters of CHAR-CLASS as token "
"delimiters\n"
msgstr ""
"Text 语言:\n"
"  -i,--include=CHAR-CLASS  将 CHAR-CLASS 中的字符作为标识的一部分\n"
"  -x,--exclude=CHAR-CLASS  将 CHAR-CLASS 中的字符作为标识的分隔符\n"

#: libidu/scanners.c:1334
#, c-format
msgid ""
"Perl language:\n"
"  -i,--include=CHAR-CLASS  Treat characters of CHAR-CLASS as token "
"constituents\n"
"  -x,--exclude=CHAR-CLASS  Treat characters of CHAR-CLASS as token "
"delimiters\n"
"  -d,--dtags  Include documentation tags\n"
msgstr ""
"Perl 语言:\n"
"  -i,--include=CHAR-CLASS  将 CHAR-CLASS 中的字符作为标识的一部分\n"
"  -x,--exclude=CHAR-CLASS  将 CHAR-CLASS 中的字符作为标识的分隔符\n"
"  -d,--dtags  包含文档标记\n"

#: libidu/scanners.c:1597
#, c-format
msgid "Lisp language:\n"
msgstr "Lisp 语言:\n"

#: libidu/walker.c:122
#, c-format
msgid "can't read directory `%s' (`.' from `%s')"
msgstr "无法读取目录‘%s’(从‘%s’中读取‘.’)"

#: libidu/walker.c:189
#, c-format
msgid "notice: `%s' was a %s, but is now a %s!"
msgstr "注意: ‘%s’以前是 %s，但现在是 %s！"

#: libidu/walker.c:190 libidu/walker.c:191
msgid "file"
msgstr "文件"

#: libidu/walker.c:190 libidu/walker.c:191
msgid "directory"
msgstr "目录"

#: libidu/walker.c:320
#, c-format
msgid "warning: `%s' and `%s' are the same file, but yield different scans!"
msgstr "警告: ‘%s’和‘%s’是同一个文件，但扫描所得不同！"

#: libidu/walker.c:414
#, c-format
msgid "notice: scan parameters changed for `%s'"
msgstr "注意: 扫描参数改为‘%s’"

#: libidu/walker.c:496 libidu/walker.c:504
#, c-format
msgid "can't mix --include and --exclude options"
msgstr "无法混合使用 --include 和 --exclude 选项"

#: libidu/walker.c:614
#, c-format
msgid "can't get working directory"
msgstr "无法获取工作目录"

#: libidu/walker.c:669
#, c-format
msgid "can't chdir to `%s'"
msgstr "无法更改目录为‘%s’"

#: libidu/walker.c:674
#, c-format
msgid "can't chdir to `%s' from `%s'"
msgstr "无法将目录从‘%2$s’改为‘%1$s’"

#: libidu/walker.c:735
#, c-format
msgid "can't lstat `%s' from `%s'"
msgstr "无法从‘%2$s’中 lstat ‘%1$s’"

#: libidu/walker.c:743
#, c-format
msgid "can't stat `%s' from `%s'"
msgstr "无法从‘%2$s’中 stat ‘%1$s’"

#: src/fid.c:72 src/fnid.c:51 src/lid.c:235 src/mkid.c:129 src/xtokid.c:55
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "尝试使用‘%s --help’来获取更多信息。\n"

#: src/fid.c:80
#, c-format
msgid "Usage: %s [OPTION] FILENAME [FILENAME2]\n"
msgstr "用法: %s [选项] 文件名 [文件名2]\n"

#: src/fid.c:83
#, c-format
msgid ""
"List identifiers that occur in FILENAME, or if FILENAME2 is\n"
"also given list the identifiers that occur in both files.\n"
"\n"
"  -f, --file=FILE  file name of ID database\n"
"      --help       display this help and exit\n"
"      --version    output version information and exit\n"
msgstr ""
"列出出现在 FILENAME 中的识别字符。如果还指定了 FILENAME2 \n"
"那就列出两个文件中都出现的识别字符。\n"
"\n"
"  -f, --file=FILE  ID 数据库的文件名\n"
"      --help       显示此帮助并退出\n"
"      --version    输出版本信息并退出\n"

#: src/fid.c:91 src/fnid.c:80 src/lid.c:284 src/mkid.c:192 src/xtokid.c:106
#, c-format
msgid ""
"\n"
"Report bugs to "
msgstr ""
"\n"
"发送错误报告至 "

#: src/fid.c:149
#, c-format
msgid "no file name arguments"
msgstr "没有文件名参数"

#: src/fid.c:154
#, c-format
msgid "too many file name arguments"
msgstr "文件名参数太多了"

#: src/fid.c:161 src/fnid.c:155 src/lid.c:439
#, c-format
msgid "can't locate `ID'"
msgstr "无法定位‘ID’"

#: src/fid.c:244
#, c-format
msgid "`%s' is ambiguous"
msgstr "‘%s’有歧义"

#: src/fid.c:250
#, c-format
msgid "`%s' not found"
msgstr "‘%s’未找到"

#: src/fnid.c:68
#, c-format
msgid "Usage: %s [OPTION]... [PATTERN]...\n"
msgstr "用法: %s [选项]... [匹配模板]...\n"

#: src/fnid.c:72
#, c-format
msgid ""
"Print constituent file names that match PATTERN,\n"
"using shell-style wildcards.\n"
"  -f, --file=FILE        file name of ID database\n"
"  -S, --separator=STYLE  STYLE is one of `braces', `space' or `newline'\n"
"      --help             display this help and exit\n"
"      --version          output version information and exit\n"
msgstr ""
"打印文件名中匹配 PATTERN 的文件名，\n"
"使用 shell 通配符。\n"
"  -f, --file=FILE        ID 数据库的文件名\n"
"  -S, --separator=STYLE  STYLE 可以是‘braces’，‘space’或是‘newline’中的一个\n"
"      --help             显示此帮助并退出\n"
"      --version          输出版本信息并退出\n"

#: src/lid.c:243
#, c-format
msgid "Usage: %s [OPTION]... PATTERN...\n"
msgstr "用法: %s [选项]... 匹配模板...\n"

#: src/lid.c:247
#, c-format
msgid ""
"Query ID database and report results.\n"
"By default, output consists of multiple lines, each line containing the\n"
"matched identifier followed by the list of file names in which it occurs.\n"
"\n"
"  -f, --file=FILE       file name of ID database\n"
"\n"
"  -i, --ignore-case     match PATTERN case insensitively\n"
"  -l, --literal         match PATTERN as a literal string\n"
"  -r, --regexp          match PATTERN as a regular expression\n"
"  -w, --word            match PATTERN as a delimited word\n"
"  -s, --substring       match PATTERN as a substring\n"
"            Note: If PATTERN contains extended regular expression meta-\n"
"            characters, it is interpreted as a regular expression "
"substring.\n"
"            Otherwise, PATTERN is interpreted as a literal word.\n"
"\n"
"  -k, --key=STYLE       STYLE is one of `token', `pattern' or `none'\n"
"  -R, --result=STYLE    STYLE is one of `filenames', `grep', `edit' or "
"`none'\n"
"  -S, --separator=STYLE  STYLE is one of `braces', `space' or `newline' and\n"
"                        only applies to file names when `--"
"result=filenames'\n"
"            The above STYLE options control how query results are "
"presented.\n"
"            Defaults are --key=token --result=filenames --separator=%s\n"
"\n"
"  -F, --frequency=FREQ  find tokens that occur FREQ times, where FREQ\n"
"                        is a range expressed as `N..M'.  If N is omitted, "
"it\n"
"                        defaults to 1, if M is omitted it defaults to "
"MAX_USHRT\n"
"  -a, --ambiguous=LEN   find tokens whose names are ambiguous for LEN chars\n"
"\n"
"  -x, --hex             only find numbers expressed as hexadecimal\n"
"  -d, --decimal         only find numbers expressed as decimal\n"
"  -o, --octal           only find numbers expressed as octal\n"
"            By default, searches match numbers of any radix.\n"
"\n"
"      --help            display this help and exit\n"
"      --version         output version information and exit\n"
msgstr ""
"查寻 ID 数据库并报告结果。\n"
"默认输出由多行组成，每行包含匹配的标识字符，\n"
"后面跟着标识符出现时的文件名。\n"
"\n"
"  -f, --file=FILE       ID 数据库的文件名\n"
"\n"
"  -i, --ignore-case     匹配 PATTERN，大小写不敏感\n"
"  -l, --literal         以纯文本字符串方式匹配 PATTERN\n"
"  -r, --regexp          以正则表达式方式匹配 PATTERN\n"
"  -w, --word            以分隔符方式匹配 PATTERN\n"
"  -s, --substring       以子串方式匹配 PATTERN\n"
"            注意:如果 PATTERN 包含了扩展的正则表达式元字符\n"
"            (meta-character)，它将被认为是正则表达式的子串。\n"
"            否则，PATTERN 就被解释为一个文本字符串。\n"
"\n"
"  -k, --key=STYLE       STYLE 是 ‘token’，‘pattern’或是‘none’中的一个\n"
"  -R, --result=STYLE    STYLE 是‘filenames’，‘grep’，‘edit’或是‘none’中的一"
"个\n"
"  -S, --separator=STYLE STYLE 是‘braces’，‘space’或是‘newline’中的一个\n"
"                        当使用‘--result=filenames’时则仅对该文件有效\n"
"            以上 STYLE 选项控制查寻结果如果输出。\n"
"            默认是 --key=token --result=filenames --separator=%s\n"
"\n"
"  -F, --frequency=FREQ  找出出现 FREQ 次的标识， FREQ\n"
"                        是个以‘N..M’表达的范围。如果省略 N，\n"
"                        则默认为 1。如果省略 M 则默认为 MAX_USHRT\n"
"  -a, --ambiguous=LEN   找出名称与 LEN 有歧义的标识字符\n"
"\n"
"  -x, --hex             仅查找十六进制表示的数\n"
"  -d, --decimal         仅查找十进制表示的数\n"
"  -o, --octal           仅查找八进制表示的数\n"
"            默认查找将匹配任意底的数。\n"
"\n"
"      --help            显示此帮助并退出\n"
"      --version         输出版本信息并退出\n"

#: src/lid.c:283
msgid "braces"
msgstr "大括号"

#: src/lid.c:283
msgid "space"
msgstr "空格"

#: src/lid.c:377
#, c-format
msgid "notice: use of `-e' is deprecated, use `-r' instead"
msgstr "注意: 不要再用‘-e’了，使用‘-r’代替"

#: src/lid.c:460
#, c-format
msgid "All identifiers are non-ambiguous within the first %d characters\n"
msgstr "在前 %d 个字符中所有的识别字符都没有歧义\n"

#: src/lid.c:495
#, c-format
msgid "invalid `--key' style: `%s'"
msgstr "无效的‘--key’类型: ‘%s’"

#: src/lid.c:507
#, c-format
msgid "invalid `--result' style: `%s'"
msgstr "无效的‘--result’类型: ‘%s’"

#: src/lid.c:608 src/lid.c:929
#, c-format
msgid "can't match regular-expression: memory exhausted"
msgstr "无法匹配正则表达式: 内存耗尽"

#: src/lid.c:697
#, c-format
msgid "edit? [y1-9^S/nq] "
msgstr "编辑？ [y1-9^S/nq] "

#: src/lid.c:766
#, c-format
msgid "can't fork"
msgstr "无法派生"

#: src/lid.c:788
#, c-format
msgid "can't exec `%s'"
msgstr "无法执行‘%s’"

#: src/mkid.c:162 src/xtokid.c:84
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "用法: %s [选项]... [文件]...\n"

#: src/mkid.c:166
#, c-format
msgid ""
"Build an identifier database.\n"
"  -o, --output=OUTFILE    file name of ID database output\n"
"  -f, --file=OUTFILE      synonym for --output\n"
"  -i, --include=LANGS     include languages in LANGS (default: \"C C++ asm"
"\")\n"
"  -x, --exclude=LANGS     exclude languages in LANGS\n"
"  -l, --lang-option=L:OPT pass OPT as a default for language L (see below)\n"
"  -m, --lang-map=MAPFILE  use MAPFILE to map file names onto source "
"language\n"
"  -d, --default-lang=LANG  make LANG the default source language\n"
"  -p, --prune=NAMES       exclude the named files and/or directories\n"
"  -v, --verbose           report per file statistics\n"
"  -s, --statistics        report statistics at end of run\n"
"\n"
"      --files0-from=F     tokenize only the files specified by\n"
"                           NUL-terminated names in file F\n"
"\n"
"       --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
"FILE may be a file name, or a directory name to recursively search.\n"
"If no FILE is given, the current directory is searched by default.\n"
"Note that the `--include' and `--exclude' options are mutually-exclusive.\n"
"\n"
"The following arguments apply to the language-specific scanners:\n"
msgstr ""
"建立一个标识符数据库。\n"
"  -o, --output=OUTFILE    ID 数据库输出时所用的文件名\n"
"  -f, --file=OUTFILE      等同于 --output\n"
"  -i, --include=LANGS     在 LANGS 中包含语言(默认: “C C++ asm”)\n"
"  -x, --exclude=LANGS     在 LANGS 不包含语言\n"
"  -l, --lang-option=L:OPT 传递 OPT 作为语言 L 的默认值(见下)\n"
"  -m, --lang-map=MAPFILE  使用 MAPFILE 将文件名与源语言关联起来\n"
"  -d, --default-lang=LANG 设置 LANG 为默认源语言\n"
"  -p, --prune=NAMES       不包含文件(或目录)\n"
"  -v, --verbose           报告每个文件的统计结果\n"
"  -s, --statistics        运行结束时报告统计结果\n"
"\n"
"  --file0-from=F          仅标识来自 F 的\n"
"                          非终止符所分隔的文件\n"
"\n"
"      --help              显示此帮助并退出\n"
"      --version           输出版本信息并退出\n"
"\n"
"FILE 可以是个文件名，或者是目录名，它将用于递归搜索。\n"
"如果不指定 FILE，默认搜索当前目录。\n"
"注意‘--include’和‘--exclude’选项是互斥的。\n"
"\n"
"以下参数用于指定语言的扫描:\n"

#: src/mkid.c:308 src/xtokid.c:194
#, c-format
msgid "extra operand %s"
msgstr "额外操作 %s"

#: src/mkid.c:310 src/xtokid.c:196
msgid "file operands cannot be combined with --files0-from"
msgstr "文件操作无法与 --files0-from 合并"

#: src/mkid.c:315 src/xtokid.c:201
#, c-format
msgid "cannot open %s for reading"
msgstr "无法读取 %s"

#: src/mkid.c:349 src/xtokid.c:234
#, c-format
msgid "%s: read error"
msgstr "%s: 读错误"

#: src/mkid.c:363 src/xtokid.c:248
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr "当从标准输入(stdin)读取文件名时，不允许 %s 的文件名"

#: src/mkid.c:377 src/mkid.c:385 src/xtokid.c:262 src/xtokid.c:270
msgid "invalid zero-length file name"
msgstr "无效的 0 字节文件名"

#: src/mkid.c:439
#, c-format
msgid "nothing to do"
msgstr "无操作"

#: src/mkid.c:489
#, c-format
msgid "can't create `%s' in `%s'"
msgstr "无法在‘%2$s’中创建‘%1$s’"

#: src/mkid.c:494
#, c-format
msgid "can't modify `%s'"
msgstr "无法修改‘%s’"

#: src/mkid.c:571
#, c-format
msgid "can't stat `%s'"
msgstr "无法 stat ‘%s’"

#: src/mkid.c:640
#, c-format
msgid "  new = %d/%d"
msgstr "  新建 = %d/%d"

#: src/mkid.c:649
#, c-format
msgid "Name=%ld, "
msgstr "名称=%ld, "

#: src/mkid.c:650
#, c-format
msgid "Number=%ld, "
msgstr "个数=%ld, "

#: src/mkid.c:651
#, c-format
msgid "String=%ld, "
msgstr "字符串=%ld, "

#: src/mkid.c:652
#, c-format
msgid "Literal=%ld, "
msgstr "文本=%ld, "

#: src/mkid.c:653
#, c-format
msgid "Comment=%ld\n"
msgstr "注释=%ld\n"

#: src/mkid.c:655
#, c-format
msgid "Files=%ld, "
msgstr "文件=%ld, "

#: src/mkid.c:656
#, c-format
msgid "Tokens=%ld, "
msgstr "标识符=%ld, "

#: src/mkid.c:657
#, c-format
msgid "Bytes=%ld Kb, "
msgstr "字节=%ld Kb, "

#: src/mkid.c:658
#, c-format
msgid "Heap=%llu+%llu Kb, "
msgstr "堆=%llu+%llu Kb, "

#: src/mkid.c:663
#, c-format
msgid "Output=%ld (%ld tok, %ld hit)\n"
msgstr "输出=%ld (%ld 标识, %ld 命中)\n"

#: src/mkid.c:667
#, c-format
msgid ", Freq=%ld/%ld=%.2f\n"
msgstr ", 频率=%ld/%ld=%.2f\n"

#: src/mkid.c:691
#, c-format
msgid "Sorting tokens...\n"
msgstr "正在排序标识...\n"

#: src/mkid.c:699
#, c-format
msgid "Writing `%s'...\n"
msgstr "正在写入‘%s’...\n"

#: src/mkid.c:702
#, c-format
msgid "can't create `%s'"
msgstr "无法创建‘%s’"

#: src/mkid.c:714 src/mkid.c:724 src/mkid.c:771
#, c-format
msgid "internal limitation: offset of 2^32 or larger"
msgstr "内部限制: 2^32 或更大的字节偏移"

#: src/mkid.c:779
#, c-format
msgid "error closing `%s'"
msgstr "关闭‘%s’时发生错误"

#: src/mkid.c:867
#, c-format
msgid "level %d: %ld/%ld = %.0f%%\n"
msgstr "级别 %d: %ld/%ld = %.0f%%\n"

#: src/xtokid.c:88
#, c-format
msgid ""
"Print all tokens found in a source file.\n"
"  -i, --include=LANGS     include languages in LANGS (default: \"C C++ asm"
"\")\n"
"  -x, --exclude=LANGS     exclude languages in LANGS\n"
"  -l, --lang-option=L:OPT pass OPT as a default for language L (see below)\n"
"  -m, --lang-map=MAPFILE  use MAPFILE to map file names onto source "
"language\n"
"  -d, --default-lang=LANG  make LANG the default source language\n"
"  -p, --prune=NAMES       exclude the named files and/or directories\n"
"\n"
"      --files0-from=F     tokenize only the files specified by\n"
"                           NUL-terminated names in file F\n"
"\n"
"      --help              display this help and exit\n"
"\t\t      --version           output version information and exit\n"
"\n"
"The following arguments apply to the language-specific scanners:\n"
msgstr ""
"打印出源文件中找到的所有标识\n"
"  -i, --include=LANGS     在 LANGS 中包含语言(默认: “C C++ asm”)\n"
"  -x, --exclude=LANGS     在 LANGS 中不包含语言\n"
"  -l, --lang-option=L:OPT 传递 OPT 作为语言 L 的默认值(见下)\n"
"  -m, --lang-map=MAPFILE  使用 MAPFILE 将文件名与源语言关联起来\n"
"  -d, --default-lang=LANG 设置 LANG 为默认的源语言\n"
"  -p, --prune=NAMES       不包含指定的文件(或目录)\n"
"\n"
"  --file0-from=F          仅标识来自 F 的\n"
"                          非终止符所分隔的文件\n"
"\n"
"      --help              显示此帮助并退出\n"
"      --version           输出版本信息并退出\n"
"\n"
"以下参数用于指定语言的扫描:\n"

#~ msgid "%s: illegal option -- %c\n"
#~ msgstr "%s: 非法选项 -- %c\n"

#~ msgid ""
#~ "\n"
#~ "\n"
#~ msgstr ""
#~ "\n"
#~ "\n"
