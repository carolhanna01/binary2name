#
# Part of the ht://Dig package   <http://www.htdig.org/>
# Copyright (c) 1999, 2000, 2001 The ht://Dig Group
# For copyright details, see the file COPYING in your distribution
# or the GNU General Public License version 2 or later
# <http://www.gnu.org/copyleft/gpl.html>
#
include $(top_srcdir)/Makefile.config

#
# All test programs use the index description from the
# mifluz.conf file (MIFLUZ_CONFIG set in test_functions.in). 
# Some have hard wired additions but these
# additions are never redundant with mifluz.conf content. Some
# programs have options that allow command line overriding of
# index parameters (page size, compression and such). 
#
# To run individual tests use (for instance):
# make TESTS=t_wordkey check
#
# To turn on verbosity use (for instance):
# VERBOSE=-vv make TESTS=t_wordkey check
#
# Run individual test without using make 
# MAKE=make srcdir=. VERBOSE=-vv t_wordkey
#
# To purify objects use:
# ( cd ../test ; rm -f word ; make CXXLD='purify g++' word )
#
# To generate benchmarks in benchmark/... make sure
# you have rrdtool installed. Reconfigure mifluz with --enable-debug.
# make words ; make MONITOR=' -m' dobench
#

TESTS = t_wordkey t_wordlist t_wordskip t_cmpr \
	t_htdb t_rdonly t_trunc t_dict \
	t_dead t_delete t_cache t_largefile t_env

TESTS_ENVIRONMENT = $(top_srcdir)/test/test_prepare
AM_MAKEFLAGS = MAKE="$(MAKE)"

EXTRA_DIST = test_functions.in test_prepare $(TESTS) \
	skiptest_db.txt cache.txt cache1.txt cache-dict.txt \
	mifluz.conf mifluz-cache.conf \
	dict.txt mifluz-dict.conf \
	mifluz-delete.conf \
	benchmark-report t_htdb.dump

LOCAL_DEFINES = -I$(top_builddir)/db -I$(top_srcdir)/db $(PROFILING)

check_PROGRAMS = word dbbench cmpr delete

dbbench_SOURCES = dbbench.cc
dbbench_DEPENDENCIES = $(MIFLUZLIBS)
dbbench_LDFLAGS = $(PROFILING)
dbbench_LDADD = $(MIFLUZLIBS)

word_SOURCES = word.cc
word_DEPENDENCIES = $(MIFLUZLIBS)
word_LDFLAGS = $(PROFILING)
word_LDADD = $(MIFLUZLIBS)

delete_SOURCES = delete.cc
delete_DEPENDENCIES = $(MIFLUZLIBS)
delete_LDFLAGS = $(PROFILING)
delete_LDADD = $(MIFLUZLIBS)

cmpr_SOURCES = cmpr.cc
cmpr_DEPENDENCIES = $(MIFLUZLIBS)
cmpr_LDFLAGS = $(PROFILING)
cmpr_LDADD = $(MIFLUZLIBS)

clean-local:
	rm -fr gmon.out test __db*
	rm -f  tmpfile t_htdb.d? monitor.out 

distclean-local:
	rm -fr words.all words.uniq

#
# The benchmark directory contains the result of some benchmarks in HTML
# form generated by benchmark-report, if MONITOR='-m' is specified.
#
dobench: dbbench
	$(MAKE) BASE="$(BASE)" CACHESIZE="$(CACHESIZE)" PAGESIZE="$(PAGESIZE)" LOOP="$(LOOP)" NWORDS="$(NWORDS)" CMPR='-W -z' REPORT='Wz' MONITOR="$(MONITOR)" bench
	$(MAKE) BASE="$(BASE)" CACHESIZE="$(CACHESIZE)" PAGESIZE="$(PAGESIZE)" LOOP="$(LOOP)" NWORDS="$(NWORDS)" CMPR='-W' REPORT='W' MONITOR="$(MONITOR)" bench

BASE = test
CACHESIZE = -C `expr 20 \* 1024 \* 1024`
PAGESIZE = -S 8192
CMPR = -z
WORDS = -w words.all
LOOP = -l 3
NWORDS = 
#MONITOR = -m
MONITOR = 
#NWORDS = -n 50000

bench:
	rm -f $(BASE) $(BASE)C* __db* monitor.out bench.out
	( \
	  MIFLUZ_CONFIG=$(top_srcdir)/test/mifluz.conf $(TIMEV) $(top_builddir)/test/dbbench $(CACHESIZE) $(PAGESIZE) $(CMPR) $(WORDS) $(LOOP) -B $(BASE) $(NWORDS) $(MONITOR) ; \
	  ls -l $(BASE) ; \
	  echo 'stat dict:' ; MIFLUZ_CONFIG=$(top_srcdir)/test/mifluz.conf $(top_builddir)/htdb/htdb_stat $(CMPR) -d $(BASE) -s dict ; \
	  echo 'stat index:' ; MIFLUZ_CONFIG=$(top_srcdir)/test/mifluz.conf $(top_builddir)/htdb/htdb_stat $(CMPR) -d $(BASE) -s index ; \
	) 2>&1 | tee bench.out
	if [ "$(RRDTOOL)" -a "X$(MONITOR)" != "X" ] ; then \
		if [ "$(REPORT)" ] ; \
		then \
			output="--output $(REPORT)" ; \
		fi ; \
		$(PERL) benchmark-report $$output --comment="`cat bench.out`" ; \
		rm monitor.out ; \
	fi

#
# Generate list of words from info and man files.
#
words:
	if [ -d /usr/info ] ; then root=/usr ; else root=/usr/share ; fi ; \
	find $$root/info -name '*.gz' -print | xargs zcat | perl -n -e 'print join("\n", map { lc } grep(length() > 2 && length() < 32, m/[a-z]+/ig)) . "\n"' | grep -v '^$$' > words.all ; \
	find $$root/man -type f -name '*.gz' -print | xargs zcat | perl -n -e 'print join("\n", map { lc } grep(length() > 2 && length() < 32, m/[a-z]+/ig)) . "\n"' | grep -v '^$$' >> words.all 
	sort -u < words.all > words.uniq
