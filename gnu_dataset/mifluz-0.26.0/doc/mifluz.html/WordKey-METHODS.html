<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Mifluz: WordKey METHODS</title>

<meta name="description" content="Mifluz: WordKey METHODS">
<meta name="keywords" content="Mifluz: WordKey METHODS">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="Concept-Index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="WordKey.html#WordKey" rel="up" title="WordKey">
<link href="WordKeyInfo.html#WordKeyInfo" rel="next" title="WordKeyInfo">
<link href="WordKey-ASCII-FORMAT.html#WordKey-ASCII-FORMAT" rel="previous" title="WordKey ASCII FORMAT">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="WordKey-METHODS"></a>
<div class="header">
<p>
Previous: <a href="WordKey-ASCII-FORMAT.html#WordKey-ASCII-FORMAT" accesskey="p" rel="previous">WordKey ASCII FORMAT</a>, Up: <a href="WordKey.html#WordKey" accesskey="u" rel="up">WordKey</a> &nbsp; [<a href="Concept-Index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="WordKey-METHODS-1"></a>
<h4 class="subsection">10.12.5 WordKey METHODS</h4>

<dl compact="compact">
<dt>&lsquo;<samp>WordKey(WordContext* ncontext)</samp>&rsquo;</dt>
<dd><p>Constructor. Build an empty key.
The
<strong>ncontext
</strong> argument must be a pointer to a valid
WordContext object.
</p></dd>
<dt>&lsquo;<samp>WordKey(WordContext* ncontext, const String&amp; desc)</samp>&rsquo;</dt>
<dd><p>Constructor. Initialize from an ASCII description of a key.
See
<code>ASCII FORMAT
</code> section.
The
<strong>ncontext
</strong> argument must be a pointer to a valid
WordContext object.
</p></dd>
<dt>&lsquo;<samp>void Clear()</samp>&rsquo;</dt>
<dd><p>Reset to empty key.
</p></dd>
<dt>&lsquo;<samp>inline int NFields() const</samp>&rsquo;</dt>
<dd><p>Convenience functions to access the total number of fields
in a key (see
<code>WordKeyInfo(3)
</code>).
</p></dd>
<dt>&lsquo;<samp>inline WordKeyNum MaxValue(int position)</samp>&rsquo;</dt>
<dd><p>Convenience functions to access the 
maximum possible value for field at
<strong>position.
</strong>
in a key (see
<code>WordKeyInfo(3)
</code>).
</p></dd>
<dt>&lsquo;<samp>inline WordContext* GetContext()</samp>&rsquo;</dt>
<dd><p>Return a pointer to the WordContext object used to create
this instance.
</p></dd>
<dt>&lsquo;<samp>inline const WordContext* GetContext() const</samp>&rsquo;</dt>
<dd><p>Return a pointer to the WordContext object used to create
this instance as a const.
</p></dd>
<dt>&lsquo;<samp>inline WordKeyNum Get(int position) const</samp>&rsquo;</dt>
<dd><p>Return value of numerical field at
<strong>position
</strong> as const.
</p></dd>
<dt>&lsquo;<samp>inline WordKeyNum&amp; Get(int position)</samp>&rsquo;</dt>
<dd><p>Return value of numerical field at
<strong>position.
</strong>
</p></dd>
<dt>&lsquo;<samp>inline const WordKeyNum &amp; operator[] (int position) const</samp>&rsquo;</dt>
<dd><p>Return value of numerical field at
<strong>position
</strong> as const.
</p></dd>
<dt>&lsquo;<samp>inline WordKeyNum &amp; operator[] (int position)</samp>&rsquo;</dt>
<dd><p>Return value of numerical field at
<strong>position.
</strong>
</p></dd>
<dt>&lsquo;<samp>inline void Set(int position, WordKeyNum val)</samp>&rsquo;</dt>
<dd><p>Set value of numerical field at
<strong>position
</strong> to
<strong>val.
</strong>
</p></dd>
<dt>&lsquo;<samp>int IsDefined(int position) const</samp>&rsquo;</dt>
<dd><p>Returns true if field at
<strong>position
</strong> is
<code>defined
</code>, false
otherwise.
</p></dd>
<dt>&lsquo;<samp>void SetDefined(int position)</samp>&rsquo;</dt>
<dd><p>Value in field
<strong>position
</strong> becomes
<code>defined.
</code> A bit
is set in the bit field describing the defined/undefined state
of the value and the actual value of the field is not modified.
</p></dd>
<dt>&lsquo;<samp>void Undefined(int position)</samp>&rsquo;</dt>
<dd><p>Value in field
<strong>position
</strong> becomes
<code>undefined.
</code> A bit
is set in the bit field describing the defined/undefined state
of the value and the actual value of the field is not modified.
</p></dd>
<dt>&lsquo;<samp>int Set(const String&amp; bufferin)</samp>&rsquo;</dt>
<dd><p>Set the whole structure from ASCII string in
<strong>bufferin.
</strong>
See
<code>ASCII FORMAT
</code> section.
Return OK if successfull, NOTOK otherwise.
</p></dd>
<dt>&lsquo;<samp>int Get(String&amp; bufferout) const</samp>&rsquo;</dt>
<dd><p>Convert the whole structure to an ASCII string description 
in
<strong>bufferout.
</strong>
See
<code>ASCII FORMAT
</code> section.
Return OK if successfull, NOTOK otherwise.
</p></dd>
<dt>&lsquo;<samp>String Get() const</samp>&rsquo;</dt>
<dd><p>Convert the whole structure to an ASCII string description 
and return it.
See
<code>ASCII FORMAT
</code> section.
</p></dd>
<dt>&lsquo;<samp>int Unpack(const char* string, int length)</samp>&rsquo;</dt>
<dd><p>Set structure from disk storage format as found in
<strong>string
</strong> buffer or length
<strong>length.
</strong>
Return OK if successfull, NOTOK otherwise.
</p></dd>
<dt>&lsquo;<samp>inline int Unpack(const String&amp; data)</samp>&rsquo;</dt>
<dd><p>Set structure from disk storage format as found in
<strong>data
</strong> string.
Return OK if successfull, NOTOK otherwise.
</p></dd>
<dt>&lsquo;<samp>int Pack(String&amp; data) const</samp>&rsquo;</dt>
<dd><p>Convert object into disk storage format as found in 
and place the result in
<strong>data
</strong> string.
Return OK if successfull, NOTOK otherwise.
</p></dd>
<dt>&lsquo;<samp>int Merge(const WordKey&amp; other)</samp>&rsquo;</dt>
<dd><p>Copy each
<code>defined
</code> field from other into the object, if 
the corresponding field of the object is not defined. 
Return OK if successfull, NOTOK otherwise.
</p></dd>
<dt>&lsquo;<samp>int PrefixOnly()</samp>&rsquo;</dt>
<dd><p>Undefine all fields found after the first undefined field. The
resulting key has a set of defined fields followed by undefined fields.
Returns NOTOK if the word is not defined because the resulting key would 
be empty and this is considered an error. Returns OK on success.
</p></dd>
<dt>&lsquo;<samp>int SetToFollowing(int position = WORD_FOLLOWING_MAX)</samp>&rsquo;</dt>
<dd><p>Implement ++ on a key.
</p>
<p>It behaves like arithmetic but follows these rules:
</p><div class="example">
<pre class="example">. Increment starts at field &lt;position&gt;
. If a field value overflows, increment field
<strong>position
</strong> - 1
. Undefined fields are ignored and their value untouched
. When a field is incremented all fields to the left are set to 0
</pre></div>
<p>If position is not specified it is equivalent to NFields() - 1.
It returns OK if successfull, NOTOK if
<strong>position
</strong> out of range or
WORD_FOLLOWING_ATEND if the maximum possible value was reached.
</p></dd>
<dt>&lsquo;<samp>int Filled() const</samp>&rsquo;</dt>
<dd><p>Return true if all the fields are
<code>defined
</code>, false otherwise.
</p></dd>
<dt>&lsquo;<samp>int Empty() const</samp>&rsquo;</dt>
<dd><p>Return true if no fields are
<code>defined
</code>, false otherwise.
</p></dd>
<dt>&lsquo;<samp>int Equal(const WordKey&amp; other) const</samp>&rsquo;</dt>
<dd><p>Return true if the object and
<strong>other
</strong> are equal. 
Only fields defined in both keys are compared.
</p></dd>
<dt>&lsquo;<samp>int ExactEqual(const WordKey&amp; other) const</samp>&rsquo;</dt>
<dd><p>Return true if the object and
<strong>other
</strong> are equal. 
All fields are compared. If a field is defined in
<strong>object
</strong>
and not defined in the object, the key are not considered
equal.
</p></dd>
<dt>&lsquo;<samp>int Cmp(const WordKey&amp; other) const</samp>&rsquo;</dt>
<dd><p>Compare
<strong>object
</strong> and
<strong>other
</strong> as in strcmp. Undefined
fields are ignored. Returns a positive number if
<strong>object
</strong> is
greater than
<strong>other
</strong>, zero if they are equal, a negative
number if
<strong>object
</strong> is lower than
<strong>other.
</strong>
</p></dd>
<dt>&lsquo;<samp>int PackEqual(const WordKey&amp; other) const</samp>&rsquo;</dt>
<dd><p>Return true if the object and
<strong>other
</strong> are equal. 
The packed string are compared. An
<code>undefined
</code> numerical field 
will be 0 and therefore undistinguishable from a
<code>defined
</code> field
whose value is 0.
</p></dd>
<dt>&lsquo;<samp>int Outbound(int position, int increment)</samp>&rsquo;</dt>
<dd><p>Return true if adding
<strong>increment
</strong> in field at
<strong>position
</strong> makes
it overflow or underflow, false if it fits.
</p></dd>
<dt>&lsquo;<samp>int Overflow(int position, int increment)</samp>&rsquo;</dt>
<dd><p>Return true if adding positive
<strong>increment
</strong> to field at
<strong>position
</strong> makes it overflow, false if it fits.
</p></dd>
<dt>&lsquo;<samp>int Underflow(int position, int increment)</samp>&rsquo;</dt>
<dd><p>Return true if subtracting positive
<strong>increment
</strong> to field 
at
<strong>position
</strong> makes it underflow, false if it fits.
</p></dd>
<dt>&lsquo;<samp>int Prefix() const</samp>&rsquo;</dt>
<dd><p>Return OK if the key may be used as a prefix for search.
In other words return OK if the fields set in the key
are all contiguous, starting from the first field.
Otherwise returns NOTOK
</p></dd>
<dt>&lsquo;<samp>static int Compare(WordContext* context, const String&amp; a, const String&amp; b)</samp>&rsquo;</dt>
<dd><p>Compare
<strong>a
</strong> and
<strong>b
</strong> in the Berkeley DB fashion.
<strong>a
</strong> and
<strong>b
</strong> are packed keys. The semantics of the
returned int is as of strcmp and is driven by the key description
found in
<code>WordKeyInfo.
</code> Returns a positive number if
<strong>a
</strong> is
greater than
<strong>b
</strong>, zero if they are equal, a negative number 
if
<strong>a
</strong> is lower than
<strong>b.
</strong>
</p></dd>
<dt>&lsquo;<samp>static int Compare(WordContext* context, const unsigned char *a, int a_length, const unsigned char *b, int b_length)</samp>&rsquo;</dt>
<dd><p>Compare
<strong>a
</strong> and
<strong>b
</strong> in the Berkeley DB fashion.
<strong>a
</strong> and
<strong>b
</strong> are packed keys. The semantics of the
returned int is as of strcmp and is driven by the key description
found in
<code>WordKeyInfo.
</code> Returns a positive number if
<strong>a
</strong> is
greater than
<strong>b
</strong>, zero if they are equal, a negative number 
if
<strong>a
</strong> is lower than
<strong>b.
</strong>
</p></dd>
<dt>&lsquo;<samp>int Diff(const WordKey&amp; other, int&amp; position, int&amp; lower)</samp>&rsquo;</dt>
<dd><p>Compare object defined fields with
<strong>other
</strong> key defined fields only,
ignore fields that are not defined in object or
<strong>other.
</strong> 
Return 1 if different 0 if equal. 
If different,
<strong>position
</strong> is set to the field number that differ,
<strong>lower
</strong> is set to 1 if Get(
<strong>position
</strong>) is lower than
other.Get(
<strong>position
</strong>) otherwise lower is set to 0.
</p></dd>
<dt>&lsquo;<samp>int Write(FILE* f) const</samp>&rsquo;</dt>
<dd><p>Print object in ASCII form on
<strong>f
</strong> (uses
<code>Get
</code> method).
See
<code>ASCII FORMAT
</code> section.
</p></dd>
<dt>&lsquo;<samp>void Print() const</samp>&rsquo;</dt>
<dd><p>Print object in ASCII form on
<strong>stdout
</strong> (uses
<code>Get
</code> method).
See
<code>ASCII FORMAT
</code> section.
</p></dd>
</dl>


<hr>
<div class="header">
<p>
Previous: <a href="WordKey-ASCII-FORMAT.html#WordKey-ASCII-FORMAT" accesskey="p" rel="previous">WordKey ASCII FORMAT</a>, Up: <a href="WordKey.html#WordKey" accesskey="u" rel="up">WordKey</a> &nbsp; [<a href="Concept-Index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
