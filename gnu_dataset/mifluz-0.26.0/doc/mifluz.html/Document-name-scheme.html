<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Mifluz: Document name scheme</title>

<meta name="description" content="Mifluz: Document name scheme">
<meta name="keywords" content="Mifluz: Document name scheme">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="Concept-Index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html#Top" rel="up" title="Top">
<link href="Data-Storage-Spec.html#Data-Storage-Spec" rel="next" title="Data Storage Spec">
<link href="Constraints.html#Constraints" rel="previous" title="Constraints">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Document-name-scheme"></a>
<div class="header">
<p>
Next: <a href="Data-Storage-Spec.html#Data-Storage-Spec" accesskey="n" rel="next">Data Storage Spec</a>, Previous: <a href="Constraints.html#Constraints" accesskey="p" rel="previous">Constraints</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="Concept-Index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Document-name-scheme-1"></a>
<h2 class="chapter">4 Document name scheme</h2>

<p>In all of the literature dealing with full text indexing a collection of
documents is considered to be a flat set of documents containing
words. Each document has a unique name. The inverted index associates
terms found in the documents with a list of unique document names.
</p>
<img src="drawdoc1.png" alt="drawdoc1">

<p>We found it more interesting to consider that the document names have a
hierarchical structure, just like path names in file systems. The main
difference is that each component of the document name (think path name
in file system) may contain terms.
</p>
<p>As shown in the figure above we can consider that the first component of
the document name is the name of a collection, the second the logical
name of a set of documents within the collection, the third the name of
the document, the fourth the name of a part of the document.
</p>
<img src="drawdoc2.png" alt="drawdoc2">

<p>This logical structure may be applied to URLs in the following way :
there is only one collection, it contains servers (document sets)
containing URLs (documents) containing tags such as TITLE (document
parts).
</p>
<img src="drawdoc3.png" alt="drawdoc3">

<p>This logical structure may be also be applied to databases in the following
way : there is one collection for each database, it contains tables
(document set) containing fields (document) containing records (document
part).
</p>
<p>What does this imply for full text indexing ? Instead of having only
one dictionary to map the document name to a numerical identifier (this
is needed to compress the postings for a term), we must have a
dictionary for each level of the hierarchy. 
</p>
<p>Using the database example again:
</p>
<ul>
<li> A dictionary for database names

</li><li> A dictionary for table names

</li><li> A dictionary for field names

</li><li> Since records are already identified by a number, no dictionary is needed.

</li></ul>

<p>When coding the document identifier in the postings for a term, we have
to code a list of numerical identifiers instead of a single numerical
identifier. Alternatively one could see the document identifier as an
aribtrary precision number sliced in parts.
</p>
<p>The advantage of this document naming scheme are:
</p>
<ul>
<li> A <code>uniq</code> query operator can be trivially implemented. This is mostly
useful to answer a query such as : I want URLs matching the word foo
but I only want to see one URL for a given server (avoid the problem of
having the first 40 URLs for a request on the same server).

</li><li> The posting lists are traditionally ordered according to the document
number.  This is a must to have an efficient query mechanism. With a
hierachical document name, each level of the hierarchy is
sorted. Therefore the postings are sorted in multiple ways: sorted by
collection first, then document set, then document part.

</li><li> Searching document paths is facilitated by the structure of the key.
For instance: I only want to
search TITLEs.

</li></ul>

<p>Of course, the suggested hierarchy semantic is not mandatory and may be
redefined according to sorting needs. For instance a relevance ranking
algorithm can lead to a relevance ranking number being inserted into the
hierarchy.
</p>
<p>The space overhead implied by this name scheme is quite small for
databases and URL pools.  The big dictionary for URL pools maps URL to
identifiers. The dictionary for tags (TITLE etc..) is only 10-50 at
most. The dictionary for site names (www.domain.com) will be ~1/100 of
the dictionary for URLs, assuming you have 100 URLs for a given site. For
databases the situation is even better: the big dictionary would be the
dictionary mapping rowids to numerical identifiers. But since rowids are
already numerical we don&rsquo;t need this.  We only need the database name,
field name and table name dictionaries and they are small. Since we are
able to encode small numbers using only a few bits in postings, the
overhead of hierarchical names is acceptable.
</p>
<hr>
<div class="header">
<p>
Next: <a href="Data-Storage-Spec.html#Data-Storage-Spec" accesskey="n" rel="next">Data Storage Spec</a>, Previous: <a href="Constraints.html#Constraints" accesskey="p" rel="previous">Constraints</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="Concept-Index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
