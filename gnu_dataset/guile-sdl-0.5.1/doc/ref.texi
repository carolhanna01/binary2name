@c ref.texh --- reference chapters
@c Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009,
@c               2011, 2013 Thien-Thi Nguyen
@c
@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.3 or
@c any later version published by the Free Software Foundation; with no
@c Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
@c Texts.  A copy of the license is included in the appendix entitled
@c ``GNU Free Documentation License''.

@node General SDL
@chapter General SDL

@set TSINCURMOD (sdl sdl)

@deffn {Procedure} init sel
Initialize SDL and the subsystems/configuration
represented by @var{sel} (@pxref{init flags}).
@end deffn

@deffn {Procedure} init-subsystem sel
Initialize the SDL subsystems represented by @var{sel}.
@var{sel} is a list of flags (symbols)
from the same set useful for @code{init}.
@end deffn

@deffn {Procedure} quit
Shut down all SDL subsystems.
Return @code{#t}.
@end deffn

@deffn {Procedure} quit-subsystem sel
Shut down the SDL subsystems represented by @var{sel}.
@var{sel} is a list of flags (symbols)
from the same set useful for @code{init}.
Return @code{#t}.
@end deffn

@deffn {Procedure} was-init sel
Check if the SDL subsystems represented by @var{sel} have
been initialized.  @var{sel} is a list of flags (symbols)
from the same set useful for @code{init}.  Return a list
likewise composed.
@end deffn

@deffn {Procedure} get-ticks
Return the number of milliseconds since
the SDL library initialization.
@end deffn

@deffn {Procedure} delay ms
Wait @var{ms} milliseconds.
@end deffn

@deffn {Procedure} get-error
Return the current SDL error string.
@end deffn

@node Video
@chapter Video

@deffn {Procedure} create-cursor data mask w h x y
Return a new cursor from @var{data} and @var{mask}
(both u8 uniform vectors), sized @var{w} by @var{h}
and with hot pixel located at @var{x},@var{y}.
@end deffn

@deffn {Procedure} create-yuv-overlay width height format [display]
Create a new YUV overlay, sized @var{width} by @var{height}
with overlay @var{format} (a symbol or an exact number).
Optional arg @var{display} specifies a surface to use
instead of creating a new one.
@end deffn

@deffn {Procedure} get-video-surface
Return the current display surface.
@end deffn

@deffn {Procedure} video-cmf
Return information about the video hardware as three values:
@code{capabilities} (list of symbols), @code{memory} (integer),
and @code{format} (pixel format object).  The @code{capabilities} are:

@example
hw-available
wm-available
blit-hw   blit-hw-CC   blit-hw-A
blit-sw   blit-sw-CC   blit-sw-A
blit-fill
@end example
@end deffn

@deffn {Procedure} get-video-info
NB: This procedure is obsoleted by @code{video-cmf}
and @strong{will be removed} after 2013-12-31.

Return information about the video hardware as an alist.
Keys are: @code{hw-available}, @code{wm-available},
@code{bit-hw}, @code{blit-hw-CC}, @code{blit-hw-A},
@code{blit-sw}, @code{blit-sw-CC}, @code{blit-sw-A},
@code{blit-fill}, @code{video-mem} and @code{vfmt}.
@end deffn

@deffn {Procedure} video-driver-name
Return the name of the video driver.
@end deffn

@deffn {Procedure} list-modes [format [flags]]
Return a list of available screen dimensions for pixel
@var{format} and @var{flags} (@pxref{video flags}).
Format defaults to that for
the current screen.  Flags default to none.
Return @code{#f} if no modes are available, @code{#t} if all are available.
@end deffn

@deffn {Procedure} video-mode-ok width height bpp [flags]
Check to see if a particular video mode is supported.
Args are @var{width}, @var{height}, @var{bpp} (numbers),
and @var{flags} (@pxref{video flags}).
Return @code{#f} if the mode is not supported, or a number
indicating the bits-per-pixel of the closest available
mode supporting @var{width} and @var{height}.
@end deffn

@deffn {Procedure} set-video-mode width height bpp [flags]
Set the SDL video mode with @var{width},
@var{height} and bits-per-pixel @var{bpp}.  Optional arg
@var{flags} (@pxref{video flags}) is supported.
Return a new surface.
@end deffn

@section Rectangles

@deffn {Procedure} rect? obj
Return @code{#t} iff @var{obj} is an SDL-rectangle object.
@end deffn

@deffn {Procedure} make-rect x y width height
Return a rectangle object with location @var{x},@var{y}
and dimensions @var{width} by @var{height}.
@end deffn

@deffn {Procedure} rect:x rect
Get @code{x} from @var{rect}.
@end deffn

@deffn {Procedure} rect:y rect
Get @code{y} from @var{rect}.
@end deffn

@deffn {Procedure} rect:w rect
Get @code{w} from @var{rect}.
@end deffn

@deffn {Procedure} rect:h rect
Get @code{h} from @var{rect}.
@end deffn

@deffn {Procedure} rect:set-x! rect value
Set @code{x} in @var{rect}
to @var{value}.
@end deffn

@deffn {Procedure} rect:set-y! rect value
Set @code{y} in @var{rect}
to @var{value}.
@end deffn

@deffn {Procedure} rect:set-w! rect value
Set @code{w} in @var{rect}
to @var{value}.
@end deffn

@deffn {Procedure} rect:set-h! rect value
Set @code{h} in @var{rect}
to @var{value}.
@end deffn

@deffn {Procedure} update-rect surface x [y [w [h]]]
Update @var{surface} within a specified rectangle.
The second arg can either be an SDL-Rect object, or
the second through fifth args are numbers specifying
the x, y, width and height of a rectangular area.
@end deffn

@deffn {Procedure} update-rects surface ls
On @var{surface}, update the rectangles in @var{ls},
a list of rectangles.
@end deffn

@deffn {Procedure} flip [surface]
Swap double buffers of the default surface,
or of @var{surface} if specified.
@end deffn

@section Colors

@deffn {Procedure} color? obj
Return @code{#t} iff @var{obj} is an SDL-Color object.
@end deffn

@deffn {Procedure} make-color r g b
Return a color object with @var{r}, @var{g},
and @var{b} components.
@end deffn

@deffn {Procedure} color:r color
Get @code{r} from @var{color}.
@end deffn

@deffn {Procedure} color:g color
Get @code{g} from @var{color}.
@end deffn

@deffn {Procedure} color:b color
Get @code{b} from @var{color}.
@end deffn

@deffn {Procedure} color:set-r! color value
Set @code{r} in @var{color}
to @var{value}.
@end deffn

@deffn {Procedure} color:set-g! color value
Set @code{g} in @var{color}
to @var{value}.
@end deffn

@deffn {Procedure} color:set-b! color value
Set @code{b} in @var{color}
to @var{value}.
@end deffn

@deffn {Procedure} set-colors! surface colors [start]
Set a portion of the colormap for the 8-bit @var{surface}
using @var{colors}, a vector of SDL-Colors.
Optional arg @var{start} (an integer in the range [0,255])
specifies the portion to be modified.  It defaults to 0.
@end deffn

@deffn {Procedure} set-palette surface flags colors [start]
Set the palette of an 8-bit @var{surface}
using @var{flags} (@pxref{palette flags}) and
@var{colors}, a vector of SDL-Colors.
Optional arg @var{start} (an integer in the range [0,255])
specifies the portion to be modified.  It defaults to 0.
@end deffn

@deffn {Procedure} set-gamma redgamma greengamma bluegamma
Set the color gamma function for the display
using real numbers @var{redgamma}, @var{greengamma}
and @var{bluegamma}.
@end deffn

@deffn {Procedure} get-gamma-ramp
Return the gamma translation lookup tables currently used by
the display as a list of three tables, for red, green and blue.
Each table is a u16 uniform vector of length 256.
Return @code{#f} if unsuccessful.
@end deffn

@deffn {Procedure} set-gamma-ramp r g b
Set the gamma translation lookup tables currently
used by the display to tables @var{r}, @var{g} and @var{b},
each a u16 uniform vector of length 256, or @code{#f},
in which case that particular component is unchanged.
Return @code{#t} if successful.
@end deffn

@deffn {Procedure} map-rgb format r [g [b]]
Map a RGB color value to the pixel @var{format}.
The second arg can be an SDL-Color, otherwise the second
through fourth args are red, green and blue values (numbers).
Return the mapped components as an unsigned integer.
@end deffn

@deffn {Procedure} map-rgba format r g [b [a]]
Map a RGB color value to the pixel @var{format}.
If the second arg is an SDL-Color, the third is an alpha
value (number).  Otherwise, the second through fifth args
are red, green, blue and alpha values (numbers).
Return the mapped components as an unsigned integer.
@end deffn

@deffn {Procedure} pixel-rgb pixel format
Return RGB info from @var{pixel} in the specified pixel @var{format}
as three values: @code{r}, @code{g} and @code{b} (all integers).
@end deffn

@deffn {Procedure} get-rgb pixel format
NB: This procedure is obsoleted by @code{pixel-rgb}
and @strong{will be removed} after 2013-12-31.

Get RGB values from @var{pixel} in the specified pixel
@var{format}.  Return an alist with keys @code{r}, @code{g}
and @code{b}, with red, green and blue values (numbers),
respectively.
@end deffn

@deffn {Procedure} pixel-rgba pixel format
Return RGBA info from @var{pixel} in the specified pixel @var{format} as
four values: @code{r}, @code{g}, @code{b} and @code{a} (all integers).
@end deffn

@deffn {Procedure} get-rgba pixel format
NB: This procedure is obsoleted by @code{pixel-rgba}
and @strong{will be removed} after 2013-12-31.

Get RGBA values from @var{pixel} in the specified pixel
@var{format}.  Return an alist with keys @code{r}, @code{g},
@code{b} and @code{a}, with red, green, blue and alpha values
(numbers), respectively.
@end deffn

@deffn {Procedure} fill-rect surface rect color
Fill @var{surface} @var{rect} with @var{color} (a number).
If @var{rect} is @code{#f}, fill the entire surface.
Return @code{#t} if successful.
@end deffn

@deffn {Procedure} display-format surface
Return a new surface made by converting @var{surface}
to the display format.  Return @code{#f} if not successful.
@end deffn

@deffn {Procedure} display-format-alpha surface
Return a new surface made by converting @var{surface}
to the display format, with an alpha channel.  Return @code{#f}
if not successful.
@end deffn

@deffn {Procedure} warp-mouse x y
Set the position of the mouse cursor to @var{x},@var{y}.
@end deffn

@deffn {Procedure} set-cursor cursor
Set the current mouse cursor to @var{cursor}.
@end deffn

@deffn {Procedure} get-cursor
Get the current mouse cursor.
@end deffn

@deffn {Procedure} show-cursor [setting]
Return the current visibility of the pointer (aka ``mouse cursor'')
as a boolean.  If arg @var{setting} (a boolean) is specified, set
the visibility to @var{setting} (the returned visibility corresponds
to that before the call, regardless).
@end deffn

@deffn {Procedure} gl-get-attribute attribute
Return the value of a special SDL/OpenGL @var{attribute}.
@end deffn

@deffn {Procedure} gl-set-attribute attribute value
Set the special SDL/OpenGL @var{attribute} to @var{value}.
Both args are numbers.
@end deffn

@deffn {Procedure} gl-swap-buffers
Swap OpenGL framebuffers/Update Display.
@end deffn

@deffn {Procedure} lock-yuv-overlay overlay
Lock the given YUV @var{overlay}.
Return @code{#f} if successful.
@end deffn

@deffn {Procedure} unlock-yuv-overlay overlay
Unlock the previously locked YUV @var{overlay}.
@end deffn

@deffn {Procedure} display-yuv-overlay overlay dstrect
Blit the YUV @var{overlay} to the display @var{dstrect}
over which it was created.  Return @code{#t} if successful.
@end deffn

@section Windowing System Interaction

@deffn {Procedure} get-wm-info
Return information on the window manager, as a list of the
form: (VERSION SUBSYSTEM DISPLAY WINDOW FSWINDOW WMWINDOW).
VERSION is a sub-list of form: (MAJOR MINOR PATCH), where
element is an integer.  SUBSYSTEM is either the symbol
@code{x11}, or @code{#f}.  DISPLAY is a pointer (machine address)
of the X11 Display structure, converted to an integer.
WINDOW, FSWINDOW and WMWINDOW are Window identifiers (also
integers).
@end deffn

@deffn {Procedure} set-caption title [icon]
Set the title-bar and icon name of the display window
to @var{title} and @var{icon} (both strings), respectively.
If @var{icon} is not specified, use @var{title} by default.
@end deffn

@deffn {Procedure} caption-ti
Return display-window caption as two values: @code{title}
and @code{icon} (both strings, or @code{#f} if not set).
@end deffn

@deffn {Procedure} get-caption
NB: This procedure is obsoleted by @code{caption-ti}
and @strong{will be removed} after 2013-12-31.

Return an alist with keys @code{title} and @code{icon}
and values the title-bar and icon name (or @code{#f}) of the display
window, respectively.
@end deffn

@deffn {Procedure} set-icon icon
Set @var{icon} for the display window.
@end deffn

@deffn {Procedure} iconify-window
Iconify/Minimize the window.
Return @code{#t} if successful.
@end deffn

@deffn {Procedure} toggle-full-screen [surface]
Toggle the default video surface between windowed
and fullscreen mode, if supported.  Optional arg
@var{surface} specifies another surface to toggle.
Return @code{#t} if successful.
@end deffn

@deffn {Procedure} grab-input [mode]
Grab mouse and keyboard input.  Return new grab state.
Optional arg @var{mode} (a symbol) specifies the kind
of grab, one of @code{query} (the default),
@code{off} or @code{on}.
@end deffn

@deffn {Procedure} get-app-state
Return the current state of the application, a list of symbols.
The list may include: `mousefocus', `inputfocus', `active'.
@end deffn

@section Surface

@deffn {Procedure} make-surface width height [flags]
Return a new surface of dimensions @var{width} by @var{height}.
Optional third arg @var{flags} (@pxref{video flags})
further specifies the surface.  Color depth and masks
are those for the current video surface.
@end deffn

@deffn {Procedure} create-rgb-surface flags width height depth rmask gmask bmask amask
Return an empty surface.
The eight arguments, directly analagous to those
for SDL_CreateRGBSurface, are: @var{flags}
(list of symbols, @pxref{video flags}),
@var{width}, @var{height}, @var{depth}, @var{rmask},
@var{gmask}, @var{bmask}, @var{amask}
(all numbers).
@end deffn

@deffn {Procedure} surface:w surface
Get @code{w} from @var{surface}.
@end deffn

@deffn {Procedure} surface:h surface
Get @code{h} from @var{surface}.
@end deffn

@deffn {Procedure} surface:depth surface
Get @code{format->BitsPerPixel} from @var{surface}.
@end deffn

@deffn {Procedure} surface:flags surface
Return @code{flags} from @var{surface} as a (possibly empty) list of symbols.
@end deffn

@deffn {Procedure} surface-get-format surface
Return a new pixel format, the same used by @var{surface}.
@end deffn

@deffn {Procedure} surface? obj
Return true iff @var{obj} is a surface.
@end deffn

@deffn {Procedure} lock-surface surface
Lock @var{surface} for direct access.
Return @code{#t} if successful.
@end deffn

@deffn {Procedure} unlock-surface surface
Unlock previously locked @var{surface}.
@end deffn

@deffn {Procedure} load-bmp filename
Load bitmap data from @var{filename}.
Return a new surface if successful, otherwise @code{#f}.
@end deffn

@deffn {Procedure} load-image filename
Load image data from @var{filename}.
Return a new surface if successful, otherwise @code{#f}.
@end deffn

@deffn {Procedure} save-bmp surface filename
Save @var{surface} to @var{filename} in Windows BMP format.
Return @code{#t} if successful.
@end deffn

@deffn {Procedure} surface-color-key! surface pixel [rle]
Set the color key for @var{surface} to @var{pixel}.
If @var{pixel} is @code{#f}, clear the current color key.
Otherwise, it should be an integer of the appropriate depth
for @var{surface} (e.g., in the range [0,65535] for 16 bpp).
If color key processing is enabled, optional arg @var{rle} is a
boolean that enables (true) or disables (false, the default)
RLE acceleration.
Return @code{#t} if successful.
@end deffn

@deffn {Procedure} set-color-key! surface flag key
NB: This procedure is obsoleted by @code{surface-color-key!}
and @strong{will be removed} after 2013-12-31.

Set @var{surface} color key as specified by @var{flag}
(@pxref{video flags}) and @var{key}.
@end deffn

@deffn {Procedure} surface-alpha! surface alpha [rle]
Set alpha blending for the entire @var{surface} to @var{alpha}.
If @var{alpha} is @code{#f}, disable alpha blending.
Otherwise it should be an integer in the range [0,255]
or one of the symbols @code{transparent} or @code{opaque}.
If alpha blending is enabled, optional arg @var{rle} is a
boolean that enables (true) or disables (false, the default)
RLE acceleration.
Return @code{#t} if successful.
@end deffn

@deffn {Procedure} set-alpha! surface flag [alpha]
NB: This procedure is obsoleted by @code{surface-alpha!}
and @strong{will be removed} after 2013-12-31.

Adjust whole-@var{surface} alpha as specified by
@var{flag} (@pxref{video flags}) and @var{alpha}
(@pxref{alpha-enum enums}, or a number 0-255).
If @var{flag} is @code{#f}, ignore @var{alpha} completely.
@end deffn

@deffn {Procedure} set-clip-rect! surface [rect]
Set @var{surface} clipping rectangle to the whole surface.
Optional arg @var{rect}, if non-@code{#f}, specifies a particular
rectangle instead of using the whole surface.
@end deffn

@deffn {Procedure} get-clip-rect surface
Return the clipping rectangle for @var{surface}.
@end deffn

@deffn {Procedure} convert-surface surface format [flags]
Convert @var{surface} to the same @var{format} as another
surface.  Optional third arg @var{flags} is a list of flags
(@pxref{video flags}).
@end deffn

@deffn {Procedure} blit-surface src [srcrect [dst [dstrect]]]
Perform a fast blit from the
@var{src} surface @var{srcrect} to the
@var{dst} surface @var{dstrect}.
@var{srcrect} defaults to x=0, y=0, @var{src} surface
dimensions.  If unspecified @var{dst} is taken as
the default video surface.  @var{dstrect} likewise defaults
to x=0, y=0, @var{dst} surface dimensions.
@end deffn

@section Misc Surface Operations

@deffn {Procedure} vertical-flip-surface surface
Return a new surface created by flipping @var{surface} vertically.
@end deffn

@deffn {Procedure} horizontal-flip-surface surface
Return a new surface created by flipping @var{surface} horizontally.
@end deffn

@deffn {Procedure} vh-flip-surface surface
Return a new surface created by flipping @var{surface}
both vertically and horizontally.
@end deffn

@deffn {Procedure} surface-pixels surface [squash]
Return pixel data of @var{surface} as a new uniform vector.
The uvec has type @code{u8}, @code{u16} or @code{u32}, corresponding
to the @var{surface} depth, with @var{height} x @var{width} elements.
A 24bpp surface --- @var{depth-in-bytes} of 3 --- is expanded (per pixel)
to @code{u32}, leaving the high nybble clear.

Optional arg @var{squash} non-@code{#f} means to
return a u8vector regardless of @var{surface} depth,
with @var{height} x @var{width} x @var{depth-in-bytes} elements.
@end deffn

@node Events
@chapter Events

@deffn {Procedure} make-event [type]
Return a new SDL event.
Optional arg @var{type} is a symbol (@pxref{event-type enums}).
If omitted, the default is @code{SDL_NOEVENT}.
@end deffn

@deffn {Procedure} event:type event
Return the symbolic @code{type} from @var{event}.
@end deffn

@deffn {Procedure} event:set-type! event value
Set @code{type} in @var{event} to @var{value}, a symbol or integer.
@end deffn

@section Activity

The value for @code{event:active:gain} and @code{event:active:set-gain!}
is a symbol, one of: @code{gained} or @code{lost}.

The value for @code{event:active:state} and @code{event:active:set-state!}
is a (possibly empty) list of symbols from the same set used by
@code{get-app-state}.

@deffn {Procedure} event:active:gain event
Return the symbolic @code{active.gain} from @var{event}.
@end deffn

@deffn {Procedure} event:active:state event
Return @code{active.state} from @var{event} as a (possibly empty) list of symbols.
@end deffn

@deffn {Procedure} event:active:set-gain! event value
Set @code{active.gain} in @var{event} to @var{value}, a symbol or integer.
@end deffn

@deffn {Procedure} event:active:set-state! event value
Set @code{active.state} in @var{event} to @var{value}, a (possibly empty) list of symbols.
@end deffn

@section Keys

The value for @code{event:key:state} and @code{event:key:set-state!}
is a symbol, one of: @code{released} or @code{pressed}.

@deffn {Procedure} event:key:keysym:sym event
Return the symbolic @code{key.keysym.sym} from @var{event}.
@end deffn

@deffn {Procedure} event:key:keysym:set-sym! event value
Set @code{key.keysym.sym} in @var{event} to @var{value}, a symbol or integer.
@end deffn

@deffn {Procedure} event:key:keysym:mod event
Return @code{key.keysym.mod} from @var{event} as a (possibly empty) list of symbols.
@end deffn

@deffn {Procedure} event:key:keysym:set-mod! event value
Set @code{key.keysym.mod} in @var{event} to @var{value}, a (possibly empty) list of symbols.
@end deffn

@deffn {Procedure} event:key:state event
Return the symbolic @code{key.state} from @var{event}.
@end deffn

@deffn {Procedure} event:key:keysym:scancode event
Get @code{key.keysym.scancode} from @var{event}.
@end deffn

@deffn {Procedure} event:key:keysym:unicode event
Get @code{key.keysym.unicode} from @var{event}.
@end deffn

@deffn {Procedure} event:key:set-state! event value
Set @code{key.state} in @var{event} to @var{value}, a symbol or integer.
@end deffn

@deffn {Procedure} event:key:keysym:set-scancode! event value
Set @code{key.keysym.scancode} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:key:keysym:set-unicode! event value
Set @code{key.keysym.unicode} in @var{event}
to @var{value}.
@end deffn

@section Motions

@deffn {Procedure} event:motion:state event
Return @code{motion.state} from @var{event} as a (possibly empty) list of symbols.
@end deffn

@deffn {Procedure} event:motion:x event
Get @code{motion.x} from @var{event}.
@end deffn

@deffn {Procedure} event:motion:y event
Get @code{motion.y} from @var{event}.
@end deffn

@deffn {Procedure} event:motion:xrel event
Get @code{motion.xrel} from @var{event}.
@end deffn

@deffn {Procedure} event:motion:yrel event
Get @code{motion.yrel} from @var{event}.
@end deffn

@deffn {Procedure} event:motion:set-state! event value
Set @code{motion.state} in @var{event} to @var{value}, a (possibly empty) list of symbols.
@end deffn

@deffn {Procedure} event:motion:set-x! event value
Set @code{motion.x} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:motion:set-y! event value
Set @code{motion.y} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:motion:set-xrel! event value
Set @code{motion.xrel} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:motion:set-yrel! event value
Set @code{motion.yrel} in @var{event}
to @var{value}.
@end deffn

@section Buttons

The value for @code{event:button:button} and @code{event:button:set-button!}
is a (possibly empty) list of symbols from the set:

@example
left middle right
wheel-up wheel-down
x1 x2
@end example

The value for @code{event:button:state} and @code{event:button:set-state!}
is a symbol, one of: @code{released} or @code{pressed}.

@deffn {Procedure} event:button:button event
Return the symbolic @code{button.button} from @var{event}.
@end deffn

@deffn {Procedure} event:button:state event
Return the symbolic @code{button.state} from @var{event}.
@end deffn

@deffn {Procedure} event:button:x event
Get @code{button.x} from @var{event}.
@end deffn

@deffn {Procedure} event:button:y event
Get @code{button.y} from @var{event}.
@end deffn

@deffn {Procedure} event:button:set-button! event value
Set @code{button.button} in @var{event} to @var{value}, a symbol or integer.
@end deffn

@deffn {Procedure} event:button:set-state! event value
Set @code{button.state} in @var{event} to @var{value}, a symbol or integer.
@end deffn

@deffn {Procedure} event:button:set-x! event value
Set @code{button.x} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:button:set-y! event value
Set @code{button.y} in @var{event}
to @var{value}.
@end deffn

@section Joysticks

The value for @code{event:jbutton:state} and @code{event:jbutton:set-state!}
is a symbol, one of: @code{released} or @code{pressed}.

The value for @code{event:jhat:value} and @code{event:jhat:set-value!}
is a list of or more symbols from the set:

@example
centered
up    down
left  right
@end example

@noindent
Specifying the empty list for @code{event:jhat:set-value!} is
effectively the same as specifying @code{centered}.

@deffn {Procedure} event:jaxis:which event
Get @code{jaxis.which} from @var{event}.
@end deffn

@deffn {Procedure} event:jaxis:axis event
Get @code{jaxis.axis} from @var{event}.
@end deffn

@deffn {Procedure} event:jaxis:value event
Get @code{jaxis.value} from @var{event}.
@end deffn

@deffn {Procedure} event:jaxis:set-which! event value
Set @code{jaxis.which} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jaxis:set-axis! event value
Set @code{jaxis.axis} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jaxis:set-value! event value
Set @code{jaxis.value} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jbutton:which event
Get @code{jbutton.which} from @var{event}.
@end deffn

@deffn {Procedure} event:jbutton:button event
Get @code{jbutton.button} from @var{event}.
@end deffn

@deffn {Procedure} event:jbutton:state event
Return the symbolic @code{jbutton.state} from @var{event}.
@end deffn

@deffn {Procedure} event:jbutton:set-which! event value
Set @code{jbutton.which} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jbutton:set-button! event value
Set @code{jbutton.button} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jbutton:set-state! event value
Set @code{jbutton.state} in @var{event} to @var{value}, a symbol or integer.
@end deffn

@deffn {Procedure} event:jball:which event
Get @code{jball.which} from @var{event}.
@end deffn

@deffn {Procedure} event:jball:ball event
Get @code{jball.ball} from @var{event}.
@end deffn

@deffn {Procedure} event:jball:xrel event
Get @code{jball.xrel} from @var{event}.
@end deffn

@deffn {Procedure} event:jball:yrel event
Get @code{jball.yrel} from @var{event}.
@end deffn

@deffn {Procedure} event:jball:set-which! event value
Set @code{jball.which} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jball:set-ball! event value
Set @code{jball.ball} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jball:set-xrel! event value
Set @code{jball.xrel} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jball:set-yrel! event value
Set @code{jball.yrel} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jhat:which event
Get @code{jhat.which} from @var{event}.
@end deffn

@deffn {Procedure} event:jhat:hat event
Get @code{jhat.hat} from @var{event}.
@end deffn

@deffn {Procedure} event:jhat:value event
Return @code{jhat.value} from @var{event} as a (possibly empty) list of symbols.
@end deffn

@deffn {Procedure} event:jhat:set-which! event value
Set @code{jhat.which} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jhat:set-hat! event value
Set @code{jhat.hat} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:jhat:set-value! event value
Set @code{jhat.value} in @var{event} to @var{value}, a (possibly empty) list of symbols.
@end deffn

@section Resizes

@deffn {Procedure} event:resize:w event
Get @code{resize.w} from @var{event}.
@end deffn

@deffn {Procedure} event:resize:h event
Get @code{resize.h} from @var{event}.
@end deffn

@deffn {Procedure} event:resize:set-w! event value
Set @code{resize.w} in @var{event}
to @var{value}.
@end deffn

@deffn {Procedure} event:resize:set-h! event value
Set @code{resize.h} in @var{event}
to @var{value}.
@end deffn

@section Misc

@deffn {Procedure} pump-events
Gather events from input devices and update the event queue.
@end deffn

@deffn {Procedure} evqueue-add [events@dots{}]
Add @code{events} to the back of the event queue.
Return the count of succesfully added events.
@end deffn

@deffn {Procedure} evqueue-peek n mask [accumulate]
Return a count (less than or equal to @var{n}) of events at
the front of the event queue that match @var{mask},
without changing the queue.  Optional arg @var{accumulate} if
non-@code{#f} means to return the list of matched events, instead.
If there are errors, return @code{#f}.

@xref{event-mask flags}.
@end deffn

@deffn {Procedure} evqueue-get n mask
Return a list (of length at most @var{n}) of
events at the front of the event queue that match
@var{mask}, removing them from the queue.
If there are errors, return @code{#f}.

@xref{event-mask flags}.
@end deffn

@deffn {Procedure} peep-events events numevents action mask
NB: This procedure is obsoleted by @code{evqueue-add},
@code{evqueue-peek} and @code{evqueue-get};
it @strong{will be removed} after 2013-12-31.

Manage the event queue, depending
on @var{action} (@pxref{event-action enums}):

@table @code
@item SDL_ADDEVENT
Add up to @var{numevents} (an integer) events from
@var{events} (a list) to the back of the event queue.

@item SDL_PEEKEVENT
Return a count (number less than or equal to @var{numevents})
of events at the front of the event queue that match @var{mask}
(@pxref{event-mask flags}), without changing the queue.

@item SDL_GETEVENT
Act like for @code{SDL_PEEKEVENT} except return a list of
matching events instead of a count, removing them from the queue.
@end table
@end deffn

@deffn {Procedure} poll-event [event]
Poll for events and return @code{#t} if there are any pending.
Optional arg @var{event} specifies an event object (from
@code{make-event}) to be filled in with the next event from
the queue (if available).
@end deffn

@deffn {Procedure} wait-event [event]
Wait indefinitely for and return @code{#f} only if there were errors.
Optional arg @var{event} specifies an event object (from
@code{make-event}) to be filled in with the next event from
the queue.
@end deffn

@deffn {Procedure} push-event event
Push @var{event} onto the queue.
Return @code{#t} on success.
@end deffn

@deffn {Procedure} set-event-filter filter full?
Set the event filter to @var{filter}, or clear it if @var{filter}
is @code{#f}.  This is a procedure called with one arg, and whose
return value, if non-@code{#f}, means to keep the event, otherwise
discard it.  If @var{full?} is @code{#f}, the arg the event type (a
symbol), otherwise it is an event object.
@end deffn

@deffn {Procedure} get-event-filter
Return information on the current event filter, or @code{#f}
if none is set.  If there is a filter, the value is a pair
with car the filter proc, and cdr @code{#f} if the proc takes
an event type, or @code{#t} if the proc takes an event object.
@end deffn

@deffn {Procedure} event-type-handling type [setting]
Return @code{#t} if event @var{type} (@pxref{event-type enums})
is recognized and queued, or @code{#f} if it is ignored.
If @var{setting} is specified, set the handling of
@var{type} to the truth value of @var{setting} first.
@end deffn

@deffn {Procedure} event-state type state
NB: This procedure is obsoleted by @code{event-type-handling}
and @strong{will be removed} after 2013-12-31.

Set or query the state of event @var{type} (@pxref{event-type enums})
processing, based on @var{state} (@pxref{event-state enums}).
If @var{state} is @code{SDL_QUERY}, return the current state.
If it is @code{SDL_IGNORE} or @code{SDL_ENABLE},
disable or enable, respectively, internal event @var{type}
processing and return @var{state}.
@end deffn

@deffn {Procedure} enable-unicode [enable-p]
Return @code{#t} iff UNICODE keyboard translation is enabled.
Optional arg @var{enable?} if non-@code{#f}, enables UNICODE
keyboard translation, or disables it if @code{#f}.
@end deffn

@deffn {Procedure} enable-key-repeat delay interval
Enable or disable keyboard repeat.
@var{delay} is the initial delay in ms between the time
when a key is pressed, and keyboard repeat begins.
@var{interval} is the time in ms between keyboard repeat
events.  If @var{delay} is 0, keyboard repeat is disabled.
Return @code{#t} on success.
@end deffn

@deffn {Procedure} get-key-state
Return a list of pressed keys (@pxref{keysym enums}).
@end deffn

@deffn {Procedure} get-mod-state
Return the current key modifier state as a list of symbols.
@end deffn

@deffn {Procedure} set-mod-state modstate
Set the current key modifier state to @var{modstate},
a list of symbols.  This does not change the keyboard state,
only the key modifier flags.
@end deffn

@deffn {Procedure} get-mouse-state [symbolic]
NB: This procedure is obsoleted by @code{mouse-bxy}
and @strong{will be removed} after 2013-12-31.

Return the current state of the mouse as an alist with
symbolic keys: @code{state}, @code{x} and @code{y}.
Normally, all values are integers.
However, if optional arg @var{symbolic} is non-@code{#f},
the @code{state} value is instead a (possibly empty)
list of symbols of the set:

@example
left middle right
wheel-up wheel-down
x1 x2
@end example
@end deffn

@deffn {Procedure} get-mouse-relative-state [symbolic]
NB: This procedure is obsoleted by @code{mouse-bxy}
and @strong{will be removed} after 2013-12-31.

Return the current relative state of the mouse as an alist
with symbolic keys: @code{state}, @code{x} and @code{y}.
Optional arg @var{symbolic} has the same effect as
for @code{get-mouse-state}.
@end deffn

@deffn {Procedure} button? mask
Return @code{#t} if buttons specified in @var{mask} are pressed,
otherwise @code{#f}.
@var{mask} is a symbol or a list of symbols from the set returned
by @code{get-mouse-state}.

For backward compatability, @var{mask} can also be the (integer)
logior of the buttons, using mapping:

@example
 1  left
 2  middle
 4  right
 8  wheel-up
16  wheel-down
32  x1
64  x2
@end example

For example, a value of 5 specifies both left and right buttons,
equivalent to @code{(left right)}.
@end deffn

@deffn {Procedure} mouse-bxy [relative]
Return three values: a (possibly empty) list of symbols
representing pressed mouse buttons (like @code{event:button:button}),
and two integer coordinates @var{x} and @var{y}.

Optional arg @code{relative} non-@code{#f} means the
coordinates are relative to the last time the underlying
@code{SDL_GetRelativeMouseState} was called.
@end deffn

@node Joystick
@chapter Joystick

@deffn {Procedure} num-joysticks
Return the number of joysticks.
@end deffn

@deffn {Procedure} joystick? obj
Return @code{#t} iff @var{obj} is a joystick object.
@end deffn

@deffn {Procedure} joystick-name [n]
Return the (string) name of the default joystick, or @code{#f}.
Optional arg @var{n} specifies which joystick to check.
@end deffn

@deffn {Procedure} joystick-open [n]
Return a handle to the default joystick opened for use.
Optional arg @var{n} specifies which joystick to open.
@end deffn

@deffn {Procedure} joystick-opened? [n]
Return @code{#t} iff the default joystick is opened.
Optional arg @var{n} specifies which joystick to check.
@end deffn

@deffn {Procedure} joystick-index joystick
Return the index of @var{joystick}.
@end deffn

@deffn {Procedure} joystick-num-axes joystick
Return the number of axes for @var{joystick}.
@end deffn

@deffn {Procedure} joystick-num-balls joystick
Return the number trackballs for @var{joystick}.
@end deffn

@deffn {Procedure} joystick-num-hats joystick
Return the number of hats for @var{joystick}.
@end deffn

@deffn {Procedure} joystick-num-buttons joystick
Return number of buttons for @var{joystick}.
@end deffn

@deffn {Procedure} joystick-update
Update the state of all Joysticks.
@end deffn

@deffn {Procedure} joystick-polling [setting]
Return @code{#t} if joystick events are polled and queued (such
that it is unnecessary to ``manually'' call @code{joystick-update}),
otherwise @code{#f}.
If @var{setting} is specified, set joystick events polling
to the truth value of @var{setting} first.
@end deffn

@deffn {Procedure} joystick-event-state state
NB: This procedure is obsoleted by @code{joystick-polling}
and @strong{will be removed} after 2013-12-31.

Set or query the state of internal joystick event processing,
based on @var{state} (a symbol).
If @var{state} is @code{SDL_QUERY}, return the current state.
If it is @code{SDL_IGNORE} or @code{SDL_ENABLE},
disable or enable, respectively, internal joystick
event processing and return @var{state}.
When enabled, it is not necessary to call @code{joystick-update}.
@end deffn

@deffn {Procedure} joystick-get-axis joystick axis
For @var{joystick}, return state of @var{axis}.
@end deffn

@deffn {Procedure} joystick-ball-xy joystick n
Return relative motion of @var{joystick} trackball @var{n}
as two values: @code{dx} and @code{dy} (both integers).
@end deffn

@deffn {Procedure} joystick-get-ball joystick n
NB: This procedure is obsoleted by @code{joystick-ball-xy}
and @strong{will be removed} after 2013-12-31.

For @var{joystick}, return relative motion of trackball
@var{n}, as an alist with keys @code{dx} and @code{dy}.
If @var{n} is invalid, return @code{#f}.
@end deffn

@deffn {Procedure} joystick-get-hat joystick n
For @var{joystick}, return state of hat @var{n}.
@end deffn

@deffn {Procedure} joystick-get-button joystick n
For @var{joystick}, return state of button @var{n},
a symbol, one of: @code{released} or @code{pressed}.
@end deffn

@deffn {Procedure} joystick-close joystick
Close a previously opened @var{joystick}.
@end deffn

@node CDROM
@chapter CDROM

@deffn {Procedure} cd? obj
Return @code{#t} iff @var{obj} is a CDROM drive object.
@end deffn

@deffn {Procedure} cd-num-drives
Return the number of CDROM drives.
@end deffn

@deffn {Procedure} cd-name [drive]
Return a human-readable, system-dependent
identifier (a string) for the CDROM, or @code{#f}.
Optional arg @var{drive} is a number specifying which drive.
@end deffn

@deffn {Procedure} cd-open [drive]
Open the CDROM drive for access and return its handle.
If the drive is unavailable, return @code{#f}.
Optional arg @var{drive} is a number specifying which drive.
@end deffn

@deffn {Procedure} cd-status cdrom
Return the current status of the drive @var{cdrom}
as a symbol (@pxref{cdrom-state enums}).
@end deffn

@deffn {Procedure} cd-in-drive? cdrom
Return @code{#t} iff there is a CD in drive @var{cdrom}.
@end deffn

@deffn {Procedure} cd-get-num-tracks cdrom
Return the number of tracks on the CD in drive @var{cdrom}.
@end deffn

@deffn {Procedure} cd-get-cur-track cdrom
Return the current track on the CD in drive @var{cdrom}.
@end deffn

@deffn {Procedure} cd-get-cur-frame cdrom
Return the current frame of the CD in drive @var{cdrom}.
@end deffn

@deffn {Procedure} cd-nth-track-itlo cdrom [n]
For CD in drive @var{cdrom}, return four values describing track
@var{n} (zero if unspecified): @code{id}, @code{type}, @code{length}
and @code{offset}, all integers except for @code{type}, which is
a symbol, either @code{audio} or @code{data}.
@end deffn

@deffn {Procedure} cd-get-nth-track cdrom [n]
NB: This procedure is obsoleted by @code{cd-nth-track-itlo}
and @strong{will be removed} after 2013-12-31.

For CD in drive @var{cdrom}, return info on track @var{n}
as an alist or @code{#f} if there were problems.
@end deffn

@deffn {Procedure} cd-play-tracks cdrom [start-track [start-frame [n-tracks [n-frames]]]]
Play the given CD tracks in drive @var{cdrom}.
Play the CD starting at @var{start-track} and
@var{start-frame} for @var{ntracks} tracks and @var{nframes}
frames.  If both @var{ntrack} and @var{nframe} are 0, play
until the end of the CD.  This procedure will skip data
tracks, and should only be called after calling
@code{cd-status} to get track information about the CD.
Return @code{#t} if successful.
@end deffn

@deffn {Procedure} cd-play cdrom start length
Play CD in drive @var{cdrom} from @var{start} frame for
@var{length} frames.  Return @code{#t} if successful.
@end deffn

@deffn {Procedure} cd-pause cdrom
Pause the CD in drive @var{cdrom}.  Return @code{#t} if successful.
@end deffn

@deffn {Procedure} cd-resume cdrom
Resume (unpause) the CD in drive @var{cdrom}.
Return @code{#t} if successful.
@end deffn

@deffn {Procedure} cd-stop cdrom
Stop the CD in drive @var{cdrom}.  Return @code{#t} if successful.
@end deffn

@deffn {Procedure} cd-eject cdrom
Eject the CD from drive @var{cdrom}.  Return @code{#t} if successful.
@end deffn

@deffn {Procedure} cd-close cdrom
Close the drive @var{cdrom}.
@end deffn

@deffn {Procedure} cd-msf->frames m [s [f]]
Return frames (an integer) computed fr
@var{m}, second @var{s} and frame @var{f}.
@var{s} and @var{f} are optional.
@end deffn

@deffn {Procedure} frames-msf frames
Break down @var{frames} (an integer) and return three values:
@code{minute}, @code{second} and @code{frames} (all integers).
@end deffn

@deffn {Procedure} cd-frames->msf frames
NB: This procedure is obsoleted by @code{frames-msf}
and @strong{will be removed} after 2013-12-31.

Return a minute/second/frames alist made from
converting @var{frames} (a number).
@end deffn

@node OpenGL
@chapter OpenGL

[todo]

@node TrueType
@chapter TrueType

@set TSINCURMOD (sdl ttf)

@deffn {Procedure} ttf-init
Initialize the SDL_ttf subsystem.
@end deffn

@deffn {Procedure} load-font file ptsize
Load a font from @var{file} with point size @var{ptsize}.
Return a handle.
@end deffn

@deffn {Procedure} font:style font
Return the style of @var{font} (@pxref{font-style flags}).
This font style is implemented by modifying the font glyphs, and
doesn't reflect any inherent properties of the truetype font file.
@end deffn

@deffn {Procedure} font:set-style! font style
Set @var{font} style to @var{style} (@pxref{font-style flags}).
This font style is implemented by modifying the font glyphs, and
doesn't reflect any inherent properties of the truetype font file.
@end deffn

@deffn {Procedure} font:height font
Return the total height of @var{font},
usually equal to point size.
@end deffn

@deffn {Procedure} font:ascent font
Return the offset from the baseline to the top of
@var{font}.  This is a positive number.
@end deffn

@deffn {Procedure} font:descent font
Return the offset from the baseline to the bottom of
@var{font}.  This is a negative number.
@end deffn

@deffn {Procedure} font:line-skip font
Return the recommended spacing between lines of
text for @var{font}.
@end deffn

@deffn {Procedure} font:glyph-xXyYa font ch
Return the metrics (dimensions) of a glyph as five values.
The glyph is a @var{font}-specific rendering of char @var{ch}.
Values are: @code{minx}, @code{maxx}, @code{miny},
@code{maxy} and @code{advance} (all integers).
@end deffn

@deffn {Procedure} font:glyph-metrics font ch
NB: This procedure is obsoleted by @code{font:glyph-xXyYa}
and @strong{will be removed} after 2013-12-31.

Return the metrics (dimensions) of a glyph as an alist.
The glyph is a @var{font}-specific rendering of char @var{ch}.
Alist keys are: @code{minx}, @code{maxx}, @code{miny},
@code{maxy} and @code{advance}.  Values are numbers.
@end deffn

@deffn {Procedure} text-wh font text
Return two values: @code{width} and @code{height} (both integers)
representing the dimensions of the @var{font}-specific rendering
of the string @var{text}.
@end deffn

@deffn {Procedure} font:size-text font text
NB: This procedure is obsoleted by @code{text-wh}
and @strong{will be removed} after 2013-12-31.

Return an alist with keys @code{w} and @code{h} and
corresponding values (numbers) representing the width
and height of the @var{font}-specific rendering of
the string @var{text}.
@end deffn

@deffn {Procedure} utf8-wh font text
Return two values: @code{width} and @code{height} (both integers)
representing the dimensions of the @var{font}-specific rendering
of the UTF-8 string @var{text}.
@end deffn

@deffn {Procedure} font:size-utf8 font text
NB: This procedure is obsoleted by @code{utf8-wh}
and @strong{will be removed} after 2013-12-31.

Return an alist with keys @code{w} and @code{h} and
corresponding values (numbers) representing the width
and height of the @var{font}-specific rendering of
the utf8 string @var{text}.
@end deffn

@deffn {Procedure} render-text font text fg [bg]
Return a new surface containing the @var{font}-specific
rendering of the @var{text} string.
Third argument is the foreground color;
optional fourth argument is the background color,
or @code{#t} if the text is to be blended.
@end deffn

@deffn {Procedure} render-utf8 font text fg [bg]
Return a new surface containing a @var{font}-specific
rendering of the utf8 string @var{text}.
Third argument is the foreground color;
optional fourth argument is the background color,
or @code{#t} if the text is to be blended.
@end deffn

@deffn {Procedure} render-glyph font ch fg [bg]
Return a new surface containing a @var{font}-specific
rendering of the character @var{ch}.
Third argument is the foreground color;
optional fourth argument is the background color,
or @code{#t} if the text is to be blended.
@end deffn

@deffn {Procedure} ttf-quit
Quit the SDL_ttf subsystem.
@end deffn

@node Audio
@chapter Audio

@set TSINCURMOD (sdl mixer)

@deffn {Procedure} open-audio [freq [format [stereo [chunksize]]]]
Open the mixer with a certain audio format.
Optional args @var{freq} (number), @var{format} (number),
@var{stereo} (boolean) and @var{chunksize} (number) specify
those aspects of the device.  Return @code{#t} if successful.
@end deffn

@deffn {Procedure} allocated-channels numchans
Dynamically change the number of channels managed by
the mixer to @var{numchans}.  If decreasing the number
of channels, the upper channels are stopped.  Return the
new number of allocated channels.
@end deffn

@deffn {Procedure} device-ffc
Return audio device parameters as three values: @code{frequency} (Hz),
@code{format} (number of bits) and @code{channels} (number of
allocated channels).
@end deffn

@deffn {Procedure} query-spec
NB: This procedure is obsoleted by @code{device-ffc}
and @strong{will be removed} after 2013-12-31.

Return audio device parameters as an alist, or @code{#f}
if the audio has not yet been opened.
Keys are @code{freq} (frequency), @code{format},
and @code{channels} (the number of allocated channels).
@end deffn

@deffn {Procedure} load-music filename
Load music data (.mod .s3m .it .xm) from @var{filename}.
Return a new music object if successful, otherwise @code{#f}.
@end deffn

@deffn {Procedure} load-wave filename
Load wave data from @var{filename}.
Return a new audio object if succesful, otherwise @code{#f}.
@end deffn

@deffn {Procedure} reserve-channels num
Reserve the first @var{num} channels (0 through @var{num}-1)
for the application.  In other words don't allocate them
dynamically to
the next sample if requested with a -1 value below.
Return the number of reserved channels.
@end deffn

@deffn {Procedure} group-channel channel [tag]
Attach to @var{channel} a @var{tag}.
A tag can be assigned to several mixer channels, to
form groups of channels.  If @var{tag} is not specified, or
is -1, the tag is removed (actually -1 is the tag used
to represent the group of all the channels).  Return
@code{#t} if successful.
@end deffn

@deffn {Procedure} group-channels from to [tag]
Assign channels in the range @var{from} through @var{to}
to the default group.  Optional arg @var{tag} specifies
the group to use.  Return @code{#t} if successful.
@end deffn

@deffn {Procedure} group-available [tag]
Return the first available channel in the default
group of channels.
Optional arg @var{tag} specifies the group to check.
@end deffn

@deffn {Procedure} group-count [tag]
Return the number of channels in the default group.
Optional arg @var{tag} specifies the group to check.
@end deffn

@deffn {Procedure} group-oldest [tag]
Return the "oldest" sample playing in the default
group of channels.
Optional arg @var{tag} specifies the group to check.
@end deffn

@deffn {Procedure} group-newer [tag]
Return the "most recent" (i.e. last) sample playing
in the default group of channels.
Optional arg @var{tag} specifies the group to check.
@end deffn

@deffn {Procedure} play-channel chunk [channel [loops [ticks [fade]]]]
Play an audio @var{chunk} on a specific @var{channel}.
If the channel is unspecified or is -1, play on the
first free channel.  If @var{loops} is specified and
greater than zero, loop the sound that many times.  If
@var{loops} is -1, loop infinitely (~65000 times).  If
@var{ticks} is specified, stop after that number of ticks.
If @var{fade} is specified, fade in over that number of
milliseconds.  Return which channel was used to play
the sound.
@end deffn

@deffn {Procedure} play-music music [loops [fade]]
Play a @var{music} track.
Optional args @var{loops} and @var{fade}
are as in @code{play-channel}.
@end deffn

@deffn {Procedure} volume [volume [which]]
Return the current volume on the default channel.
Optional arg @var{volume} (a number in the range 0-128) means
set the volume to @var{volume} and return the original volume.
Optional second arg @var{which} specifies a chunk or
channel to check (or modify) instead of the default.
If @var{volume} is non-@code{#f} and @var{which} is @code{#f}, modify all
channels.

[Here is the original (perhaps clearer) docstring. ---ttn]

Set the volume in the range of 0-128 of a specific channel
or chunk.  If the channel is unspecified or is -1, set volume
for all channels.  Return the original volume.  If the volume
is unspecified or is -1, just return the current volume.
@end deffn

@deffn {Procedure} music-volume [volume]
Return the current volume.
Optional arg @var{volume} (a number in the range 0-128)
means set the volume to @var{volume}.
@end deffn

@deffn {Procedure} halt-channel [channel]
Halt playing of the default channel.
Optional arg @var{channel} specifies a channel to halt.
@end deffn

@deffn {Procedure} halt-group [tag]
Halt playing of the default group.
Optional arg @var{tag} specifies the group to halt.
@end deffn

@deffn {Procedure} halt-music
Halt playing of the music.
@end deffn

@deffn {Procedure} expire-channel [channel [ticks]]
Turn off expiration for the default channel.
Optional arg @var{channel} specifies a channel to change.
Optional arg @var{ticks} (a number) means set the expiration
delay to that many milliseconds, rather than turning it off.
@end deffn

@deffn {Procedure} fade-out-channel [which [ms]]
Halt a channel, fading it out progressively until silent.
Optional arg @var{which} specifies a channel to halt.
Second optional arg @var{ms} specifies the number of
milliseconds the fading will take (default 0).
@end deffn

@deffn {Procedure} fade-out-group [tag [ms]]
Halt a group, fading it out progressively until silent.
Optional arg @var{tag} specifies a group to halt.
Second optional arg @var{ms} specifies the number of
milliseconds the fading will take (default 0).
@end deffn

@deffn {Procedure} fade-out-music [ms]
Halt the music, fading it out progressively until silent.
Optional arg @var{ms} specifies the number of milliseconds
the fading will take (default 0).
@end deffn

@deffn {Procedure} fading-music
Return the fading status of the music, one of the symbols:
@code{no}, @code{out}, @code{in}.
@end deffn

@deffn {Procedure} fading-channel [which]
Return the fading status (a symbol, see @code{fading-music})
of the default channel.
Optional arg @var{which} selects which channel to check.
@end deffn

@deffn {Procedure} pause [channel]
Pause the default channel.
Optional arg @var{channel} selects which channel to pause.
@end deffn

@deffn {Procedure} resume [channel]
Resume (unpause) the default channel.
Optional arg @var{channel} selects which channel to resume.
@end deffn

@deffn {Procedure} paused? [channel]
Return @code{#t} if the default channel is paused.
Optional arg @var{channel} selects a which channel to check.
@end deffn

@deffn {Procedure} pause-music
Pause the music.
@end deffn

@deffn {Procedure} resume-music
Resume (unpause) the music.
@end deffn

@deffn {Procedure} rewind-music
Rewind the music.
@end deffn

@deffn {Procedure} paused-music?
Return @code{#t} if the music is currently paused.
@end deffn

@deffn {Procedure} playing? [channel]
Return @code{#t} iff the default channel is playing.
Optional arg @var{channel} selects which channel to check.
@end deffn

@deffn {Procedure} playing-music?
Return @code{#t} iff the music is currently playing.
@end deffn

@deffn {Procedure} set-music-command command
Stop music and set external music playback command
to @var{command}, a string.  As a special case, if @var{command}
is @code{#f}, arrange to use internal playback, instead.
@end deffn

FWIW, the C header file for the following panning, distance and
position procs says:

@quotation
Setting (channel) to MIX_CHANNEL_POST registers this as a posteffect, and
the panning will be done to the final mixed stream before passing it on
to the audio device.
@end quotation

@deffn {Procedure} set-panning channel l r
Set panning for (stereo) @var{channel} with @var{l} and @var{r}.
Both @var{l} and @var{r} are integers 0--255, inclusive, where
0 is quietest and 255 is loudest.

To get ``true'' panning, use @code{(set-panning CH N (- 255 N))}.
@end deffn

@deffn {Procedure} set-distance channel distance
Set the ``distance'' of @var{channel} to @var{distance} (integer, 0--255).
This controls the location of the sound with respect to the listener.

Distance 0 is overlapping the listener, and 255 is as far away as possible.
A distance of 255 does not guarantee silence; in such a case, you might
want to try changing the chunk's volume, or just cull the sample from the
mixing process with @code{halt-channel}.

For efficiency, the precision of this effect may be limited (distances 1
through 7 might all produce the same effect, 8 through 15 are equal, etc).

Setting (distance) to 0 unregisters this effect, since the data would be
unchanged.
@end deffn

@deffn {Procedure} set-position channel angle distance
Set the ``position'' of @var{channel} to @var{angle}, @var{distance}.
In this polar coordinate, @var{angle} is in degrees (integer modulo 360),
and @var{distance} is an integer 0--255 (and is treated as in proc
@code{set-distance} -- see notes there).

Angle 0 is due north, and rotates clockwise as the value increases.
For efficiency, the precision of this effect may be limited (angles 1
through 7 might all produce the same effect, 8 through 15 are equal, etc).

Setting @var{angle} and @var{distance} to 0 unregisters this effect,
since the data would be unchanged.

Additionally, the C header says:
@quotation
If the audio device is configured for mono output, then you won't get
any effectiveness from the angle; however, distance attenuation on the
channel will still occur. While this effect will function with stereo
voices, it makes more sense to use voices with only one channel of sound,
so when they are mixed through this effect, the positioning will sound
correct. You can convert them to mono through SDL before giving them to
the mixer in the first place if you like.
@end quotation
@end deffn

@deffn {Procedure} close-audio
Close the mixer, halting all playing audio.
@end deffn

@node SDL_gfx
@chapter SDL_gfx by Andreas Schiffler

@section Graphics Primitives

@set TSINCURMOD (sdl gfx)

@deffn {Procedure} draw-point surface x y color
On @var{surface}, draw a point at location
@var{x},@var{y} with color @var{color}.
@end deffn

@deffn {Procedure} draw-hline surface x1 x2 y color
On @var{surface}, draw a horizontal line segment
from @var{x1},@var{y} to @var{x2},@var{y},
with color @var{color}.
@end deffn

@deffn {Procedure} draw-vline surface x y1 y2 color
On @var{surface}, draw a vertical line segment
from @var{x},@var{y1} to @var{x},@var{y2},
with color @var{color}.
@end deffn

@deffn {Procedure} draw-rectangle surface x1 y1 x2 y2 color [fill]
On @var{surface}, draw a rectangle with opposite points
@var{x1},@var{y1} and @var{x2},@var{y2},
with color @var{color}.
Optional arg @var{fill} means to fill the rectangle as well.
@end deffn

@deffn {Procedure} draw-rounded-rectangle surface x1 y1 x2 y2 rad color [fill]
On @var{surface}, draw a rectangle with opposite points
@var{x1},@var{y1} and @var{x2},@var{y2},
with rounded corners radius @var{rad} in color @var{color}.
Optional arg @var{fill} means to fill the rectangle as well.
@end deffn

@deffn {Procedure} draw-line surface x1 y1 x2 y2 color
On @var{surface}, draw a line segment from
@var{x1},@var{y1} to @var{x2},@var{y2},
with color @var{color}.
@end deffn

@deffn {Procedure} draw-aa-line surface x1 y1 x2 y2 color
On @var{surface}, draw an anti-aliased line segment from
@var{x1},@var{y1} to @var{x2},@var{y2},
with color @var{color}.
@end deffn

@deffn {Procedure} draw-thick-line surface x1 y1 x2 y2 width color
On @var{surface}, draw a line segment from
@var{x1},@var{y1} to @var{x2},@var{y2},
with thickness @var{width} in color @var{color}.
@end deffn

@deffn {Procedure} draw-arc surface x y r start end color
On @var{surface}, draw arc with center @var{x},@var{y}
and radius @var{r}, going from @var{start} to @var{end} (degrees),
with color @var{color}.

If @var{start} is greater than @var{end}, the effective range of
the arc is taken to be @var{end} to @var{start} (that is, these
arguments are internally reversed).
@end deffn

@deffn {Procedure} draw-circle surface x y r color [fill]
On @var{surface}, draw a circle with center @var{x},@var{y}
and radius @var{r}, with color @var{color}.
Optional arg @var{fill} means to fill the circle as well.
@end deffn

@deffn {Procedure} draw-aa-circle surface x y r color
On @var{surface}, draw an anti-aliased circle with center
@var{x},@var{y} and radius @var{r}, with color @var{color}.
@end deffn

@deffn {Procedure} draw-ellipse surface x y rx ry color [fill]
On @var{surface}, draw an ellipse with center @var{x},@var{y}
x-radius @var{rx}, y-radius @var{ry}, with color @var{color}.
Optional arg @var{fill} means to fill the ellipse as well.
@end deffn

@deffn {Procedure} draw-aa-ellipse surface x y rx ry color
On @var{surface}, draw an anti-aliased ellipse with center
@var{x},@var{y}, x-radius @var{rx}, y-radius @var{ry}, with
color @var{color}.
@end deffn

@deffn {Procedure} draw-pie-slice surface x y rad start end color [fill]
On @var{surface}, draw a pie slice with center
@var{x},@var{y} and radius @var{rad}, going from
@var{start} to @var{end} (degrees), with color @var{color}.
Optional arg @var{fill} means to fill the slice as well.
@end deffn

@deffn {Procedure} draw-trigon surface x1 y1 x2 y2 x3 y3 color [fill]
On @var{surface}, draw a triangle with vertices at
@var{x1},@var{y1}, @var{x2},@var{y2} and @var{x3},@var{y3},
with color @var{color}.  Optional arg @var{fill} means to
fill the triangle as well.
@end deffn

@deffn {Procedure} draw-aa-trigon surface x1 y1 x2 y2 x3 y3 color
On @var{surface}, draw an anti-aliased triangle with vertices at
@var{x1},@var{y1}, @var{x2},@var{y2} and @var{x3},@var{y3},
with color @var{color}.
@end deffn

@deffn {Procedure} draw-polygon surface vx vy color [fill]
On @var{surface}, draw a polygon whose points are specified
by corresponding pairs from the s16 uniform vectors
@var{vx} and @var{vy}, in color @var{color}.  Optional
arg @var{fill} means to fill the polygon as well.
@end deffn

@deffn {Procedure} draw-aa-polygon surface vx vy color
On @var{surface}, draw an anti-aliased polygon whose points
are specified by corresponding pairs from the s16 uniform vectors
@var{vx} and @var{vy}, in color @var{color}.
@end deffn

@deffn {Procedure} draw-textured-polygon surface vx vy texture tdx tdy
On @var{surface}, draw a polygon whose points are specified
by corresponding pairs from the s16 uniform vectors @var{vx}
and @var{vy}, filling from @var{texture} (a surface) with
offset @var{tdx}, @var{tdy}.
@end deffn

@deffn {Procedure} draw-bezier surface vx vy s color
On @var{surface}, draw a bezier curve whose points are
specified by corresponding pairs from the s16 uniform vectors
@var{vx} and @var{vy}, with @var{s} steps in color @var{color}.
@end deffn

@deffn {Procedure} draw-character surface x y c color
On @var{surface} at position @var{x},@var{y},
draw char @var{c} with @var{color} (a number).
@end deffn

@deffn {Procedure} draw-string surface x y text color
On @var{surface} at position @var{x},@var{y},
draw string @var{text} with @var{color} (a number).
@end deffn

@deffn {Procedure} font-rotation! rotation
Set the rotation for glyphs drawn by @code{draw-character} and
@code{draw-string} to @var{rotation} (an integer or symbol), one of:

@example
0  none
1  clockwise
2  upside-down
3  counter-clockwise
@end example
@end deffn

@section Rotation / Zooming

@deffn {Procedure} roto-zoom-surface surface angle [zoom [smooth]]
Return a new surface made from rotating @var{surface}
by @var{angle} degrees.  Optional third arg @var{zoom}
(default value 1.0) changes the size as well.  Optional
fourth arg @var{smooth} turns on anti-aliasing.
@end deffn

@deffn {Procedure} roto-zoom-surface-xy surface angle [zoomx [zoomy [smooth]]]
Return a new surface made from rotating @var{surface}
by @var{angle} degrees.  Optional third and fourth args
@var{zoomx} and @var{zoomy} (default value 1.0 for both)
changes the size as well.  Optional fifth arg @var{smooth}
turns on anti-aliasing.
@end deffn

@deffn {Procedure} zoom-surface surface zoomx [zoomy [smooth]]
Return a new scaled copy of @var{surface}.
@var{zoomx} and @var{zoomy} specify the scaling factor.
If omitted, @var{zoomy} defaults to @var{zoomx}.
Optional fourth arg @var{smooth} turns on anti-aliasing.
@end deffn

@deffn {Procedure} shrink-surface surface factorx factory
Return a new shrunken copy of @var{surface}.
@var{factorx} and @var{factory} are positive integers specifying
the inverse scaling factor.  For example, 2 means half size,
3 means one-third size, etc.

The returned surface is antialiased by ``averaging the source
box RGBA or Y information'' and is in 32-bit RGBA format.
@end deffn

@section Managing Frame Rate

@deffn {Procedure} make-fps-manager [n]
Return a FPS manager object to be passed as the first
arg to @code{fps-manager-set!}, @code{fps-manager-get} and
@code{fps-manager-delay!}.
Optional arg @var{n} specifies the value in Hz to
initialize the object (default 30 if not specified).
@end deffn

@deffn {Procedure} fps-manager-set! mgr n
Arrange for FPS manager @var{mgr} to try to maintain a
frame rate of @var{n} Hz.  Return @code{#f} if not successful.
@end deffn

@deffn {Procedure} fps-manager-get mgr
Return the frame rate of FPS manager @var{mgr} in Hz,
or @code{#f} if unsuccessful.
@end deffn

@deffn {Procedure} fps-manager-delay! mgr
Request an appropriate delay from FPS manager @var{mgr}.
@end deffn

@section RGBA Extras

@deffn {Procedure} set-pixel-alpha! surface alpha
If @var{surface} is 32-bit, set each pixel's alpha value to
@var{alpha}, an integer 0-255, inclusive, and return @code{#t}.
Otherwise, do nothing and return @code{#f}.
@end deffn

@deffn {Procedure} blit-rgba src srect dst drect
Blit from 32-bit surface @var{src} rectangle @var{srect}
to 32-bit surface @var{dst} rectangle @var{drect}.
Return @code{#t} if there are no problems.

Note that unlike @code{blit-surface} (@pxref{Video}),
all arguments must be fully specified.  This restriction
may be relaxed in the future.
@end deffn

@section Image Filtering

@deffn {Procedure} imfi-mmx? [setting]
If @var{setting} is @code{#t}, enable @sc{mmx} instructions
for the image filter procs (if possible); if @code{#f}, disable;
otherwise do nothing.  Return the (boolean) value of the setting
afterwards.
@end deffn

@deffn {Procedure} imfi-add src1 src2 dst
D = saturation255 (S1 + S2).
@end deffn

@deffn {Procedure} imfi-mean src1 src2 dst
D = S1/2 + S2/2.
@end deffn

@deffn {Procedure} imfi-sub src1 src2 dst
D = saturation0 (S1 - S2).
@end deffn

@deffn {Procedure} imfi-abs-diff src1 src2 dst
D = | S1 - S2 |.
@end deffn

@deffn {Procedure} imfi-mult src1 src2 dst
D = saturation (S1 * S2).
@end deffn

@deffn {Procedure} imfi-mulnor src1 src2 dst
D = S1 * S2 (non-MMX).
@end deffn

@deffn {Procedure} imfi-muldiv2 src1 src2 dst
D = saturation255 (S1/2 * S2).
@end deffn

@deffn {Procedure} imfi-muldiv4 src1 src2 dst
D = saturation255 (S1/2 * S2/2).
@end deffn

@deffn {Procedure} imfi-logand src1 src2 dst
D = S1 & S2.
@end deffn

@deffn {Procedure} imfi-logior src1 src2 dst
D = S1 | S2.
@end deffn

@deffn {Procedure} imfi-div src1 src2 dst
D = S1 / S2 (non-MMX).
@end deffn

@deffn {Procedure} imfi-not src dst
D = !S.
@end deffn

@deffn {Procedure} imfi-add-c src dst c
D = saturation255 (S + C).
@end deffn

@deffn {Procedure} imfi-add-c-to-half src dst c
D = saturation255 (S/2 + C).
@end deffn

@deffn {Procedure} imfi-sub-c src dst c
D = saturation0 (S - C).
@end deffn

@deffn {Procedure} imfi-ashr src dst n
D = saturation0 (S >> N).
@end deffn

@deffn {Procedure} imfi-lshr src dst n
D = saturation0 ((uint) S >> N).
@end deffn

@deffn {Procedure} imfi-mul-c src dst c
D = saturation255 (S * C).
@end deffn

@deffn {Procedure} imfi-ashr-mul-c src dst n c
D = saturation255 ((S >> N) * C).
@end deffn

@deffn {Procedure} imfi-bshl src dst n
D = (S << N).
@end deffn

@deffn {Procedure} imfi-lshl src dst n
D = ((uint) S << N).
@end deffn

@deffn {Procedure} imfi-ashl src dst n
D = saturation255 (S << N).
@end deffn

@deffn {Procedure} imfi-binarize src dst t
D = (S < T ? 0 : 255).
@end deffn

@deffn {Procedure} imfi-clip src dst tmin tmax
D = (Tmin <= S <= Tmax) ? 255 : 0.
@end deffn

@deffn {Procedure} imfi-normalize-linear src dst cmin cmax nmin nmax
D = saturation255 ((Nmax - Nmin) / (Cmax - Cmin) * (S - Cmin) + Nmin).
@end deffn

@node Miscellaneous Utilities
@chapter Miscellaneous Utilities

These are available in module @code{(sdl misc-utils)}.

@set TSINCURMOD (sdl misc-utils)

@deffn {Procedure} exact-truncate number
Return the exact truncation (rounding to zero) of @var{number}.
This is ``safer'' than simply @code{inexact->exact}
for some Guile versions.

@example
(define scale 0.180281690140845)
(inexact->exact scale)
  @result{} 3247666210160131/18014398509481984 ; Guile 1.8.7
  @result{} 0                                  ; Guile 1.4.x
(exact-truncate scale)
  @result{} 0
@end example
@end deffn

@deffn {Procedure} call-with-clip-rect rect thunk
Set default clip rect to @var{rect}, call @var{thunk}, and restore it.
@var{thunk} is a procedure that takes no arguments.
@end deffn

@deffn {Procedure} rotate-square square angle
Return a new surface made by rotating @var{square} by @var{angle} degrees.
The square retains its original size.
@end deffn

@deffn {Procedure} rectangle-closure [rect]
Return a closure that manages a single rectangle object.
Calling the closure with no args returns the rectangle object.
Otherwise, the messages @code{#:w}, @code{#:h}, @code{#:x}
and @code{#:y} return the rectangle's width, height, horizontal
offset and vertical offset, respectively;
and the messages @code{#:w!}, @code{#:h!}, @code{#:x!}
and @code{#:y!}, followed by an integer, update the rectangle's
width, height, horizontal offset and vertical offset, respectively.

Optional arg @var{rect} specifies a rectangle object to manage
instead of allocating a new one.
@end deffn

@deffn {Procedure} rectangle<-geometry-string spec
Return a rectangle made from parsing the @dfn{geometry string} @var{spec},
which typically has the form @code{WxH+X+Y}, where @code{+X+Y} is optional
(defaults to ``+0+0''), and @code{W}, @code{H}, @code{X} and @code{Y} are
integers.  Actually, the @code{+} can also be a @code{-}.  If @var{spec}
cannot be parsed, return @code{#f}.  Examples:

@example
(rectangle<-geometry-string "42x43+44+45")
@result{} #<SDL-Rect 42x43+44+45>

(rectangle<-geometry-string "42x43-10-20")
@result{} #<SDL-Rect 42x43+-10+-20>

(rectangle<-geometry-string "42x43")
@result{} #<SDL-Rect 42x43+0+0>

(rectangle<-geometry-string "42")
@result{} #f
@end example

Note that the print representation of a rectangle always has ``+''.  The
term ``geometry string'' derives from the X Window System, where many
programs take a @code{--geometry} (or @code{-g} for short) command-line
option.
@end deffn

@deffn {Procedure} poll-with-push-on-timeout-proc timeout slice [get-timeout-events]
Return a procedure @code{P} that checks the event queue for @var{timeout}
ms, polling every @var{slice} ms.  If an event arrives during that time,
return @code{#t}.  Otherwise return @code{#f}.  Optional arg
@var{get-timeout-events} is either a list of events to be pushed on the
queue in the case of timeout, or a thunk to be called that produces such a
list.  If @var{get-timeout-events} is specified, return the result of
another event queue polling.  (This may still be @code{#f} if the pushed
events are masked in some way.)

@code{P} is called with a single arg, a pre-constructed event object.  This
interface is congruent with that of @code{wait-event} and @code{poll-event}.
@xref{Events}.
@end deffn

@deffn {Procedure} rect<-surface surface [x y]
Return a new rectangle with the same width and height as @var{surface}.
Optional second and third arg (which must appear together or not at all)
specifies the @var{x} and @var{y} components, respectively, to use instead
of the default of 0 (zero).
@end deffn

@deffn {Procedure} copy-rectangle rect [modify args...]
Return a new rectangle copied from @var{rect}.

Optional second arg @var{modify} specifies which portions,
if any, to modify using the values in the rest @var{args}.
If @var{modify} is @code{#:xy}, the two @var{args} specify
new @code{x} and @code{y} values.  If @var{modify} is
@code{#:wh}, the two @var{args} specify new @code{w} and
@code{h} values.

@example
rect
@result{} #<SDL-Rect 3x4+1+2>

(copy-rectangle rect)
@result{} #<SDL-Rect 3x4+1+2>

(copy-rectangle rect #:xy 11 22)
@result{} #<SDL-Rect 3x4+11+22>

(copy-rectangle rect #:wh 33 44)
@result{} #<SDL-Rect 33x44+1+2>
@end example
@end deffn

@deffn {Procedure} copy-surface surface [clip]
Create a new surface and blit @var{surface} onto it.
The new surface has the same pixel format as @var{surface}.
Return the new surface.

Optional second arg @var{clip} is a rectangle describing the
portion of @var{surface} to copy (default is the entire surface).
@end deffn

@deffn {Procedure} ignore-all-event-types-except [types@dots{}]
Arrange to ignore all event types except those in @var{types}
(@pxref{event-type enums}).  As a special case, if @var{types}
is @code{#f}, arrange to not ignore any event types (all are enabled).
@end deffn

In the following procs, those named ending with @code{/3p} return
three values, each a thunk (unless specified otherwise) handling the
three-phase calling convention, namely @dfn{init}, @dfn{next}, and
@dfn{done}.

@lisp
(call-with-values (lambda () (foo/3p ...))
  (lambda (init! foo! done!)
    (init!)
    (let loop ((continue? (foo!)))
      (and continue? (loop (foo!))))
    (done!)))
@end lisp

Note that @code{foo!} returns non-@code{#f} to indicate that the
looping is not yet complete.

@deffn {Procedure} fader/3p sec realized location image replacement
Return three values, each a thunk, that can be used to loop for
@var{sec} seconds, blitting onto @var{realized} at @var{location} (a
rectangle or @code{#f} to indicate the origin) the alpha-composition
of @var{image} and its @var{replacement} (both surfaces), to effect a
@dfn{fade-in} of @var{replacement} over @var{image}.  The alpha value
is directly proportional to the time between the ``next!'' phase call
and the ``init!''  phase call.

@var{realized} may be either a surface, in which case at the end of each
loop it is shown via @code{update-rect}; or a pair whose @sc{car} is
a surface and whose @sc{cdr} is a thunk that should do the showing.

Note that @var{location} is used for blitting, so its width and height
should match those of @var{image} and @var{replacement}.
@end deffn

@deffn {Procedure} toroidal-panner/3p surface dx dy [sub [batch?]]
Return three values, the first a procedure of one arg, the other two
thunks, that can be used to toroidally pan @var{surface} by @var{dx}
and @var{dy} pixels.  This means that data disappearing from one side
of the surface (left, right, top, bottom) is rotated to appear at the
other side (right, left, bottom, top).  The @code{init!} procedure takes
one arg @var{count}, the number of pans to do.

Positive @var{dx} moves surface data to the left (panning right),
and likewise, positive @var{dy}, up (panning down).

Optional third arg @var{sub} is a rectangle object specifying a subset
of the surface.  The default is to pan the entire surface.

Optional fourth arg @var{batch?} non-@code{#f} means to call
@code{update-rect} on the (sub)surface after all the panning is done.
The default is to update the surface after each pan.  Batch mode is
useful for implementing variable-speed panning, for example:

@example
(define (pan dir)
  (call-with-values (lambda ()
                      (toroidal-panner/3p screen
                                          (* dir 21)
                                          (* dir 12)
                                          #f #t))
    (lambda (init! next! done!)
      (lambda (count)
        (init! count)
        (let loop ((continue? (next!)))
          (and continue? (loop (next!))))
        (done!)))))

(define pan-away (pan  1))
(define pan-back (pan -1))
(define ramp (map 1+ (append (make-list 21 0)
                             (identity (iota 12))
                             (reverse! (iota 12))
                             (make-list 21 0))))
(for-each pan-away ramp)
(for-each pan-back ramp)
@end example
@end deffn

@node Simple Closures
@chapter Simple Closures

This chapter documents module @code{(sdl simple)}.
@set TSINCURMOD (sdl simple)

This module provides some simple abstractions to introduce common
Guile-SDL programming idioms.  Although the interfaces are documented,
they are @dfn{permanently alpha}, that is, subject to change w/o
notice.  Instead of relying on the stability of the interface, you are
encouraged to look at the implementation as a model for creating
customized abstractions.

@deffn {Procedure} simple-canvas init? w h bpp [flags@dots{}]
Return a @dfn{canvas closure} that accepts a few simple messages.
If @var{init?} is non-@code{#f}, initalize the SDL video subsystem first.
@var{w}, @var{h}, and @var{bpp} specify the width, height, and
bits-per-pixel, respectively.
@var{flags} are symbols to set the video mode.  If omitted, the
default is @code{hw-surface} and @code{doublebuf}.

The closure, if called without arguments, returns the video surface.
Otherwise, the following messages are recognized:

@table @code
@item #:rect
Return a rectangle the width and height of the canvas.

@item #:set-bg! r g b
Set the background color (used for clearing) to the color specified
by @var{r}, @var{g} and @var{b} (integers 0-255), respectively.
By default it is black (all values zero).

@item #:clear!
Fill the canvas with the background color.

@item #:w
@itemx #:h
@itemx #:w/h
Return width, height, or a cons of width and height, respectively.

@item #:resize! new-width new-height
Request that the canvas dimension be changed to @var{new-width} by
@var{new-height}.  Return a rect that reflects the actual dimension.
@end table
@end deffn

@deffn {Procedure} simple-stylus init? filename size r g b
Return a @dfn{stylus closure} that accepts a few simple messages.
If @var{init?} is non-@code{#f}, initialize the SDL TTF support first.
@var{filename} specifes the .ttf file to load and @code{size} the size.
@var{r}, @var{g} and @var{b} are integers (0-255) specifying the color.
The closure recognizes the following messages:

@table @code
@item #:set-font! filename size
@itemx #:set-color! r g b
Change the font or color, respectively.

@item #:set-canvas! surface
Set the surface on which the @code{#:write!} command renders.

@item #:render text [color [bg]]
Return a surface of @var{text} rendered using the default
font, size, color and size.  Optional second arg @var{color}
specifies another color to use.  Optional third arg @var{bg}
specifies a background mode: @code{#f} (default) for ``solid'';
@code{#t} for ``blended''; a color to use that color.

@item #:write! where text [color [bg]]
Similar to #:render, but also blit the surface onto the canvas
at the rectangle position specified by @var{where}.  The width
and height components of @var{where} are updated by side effect.
@end table
@end deffn

@deffn {Procedure} simple-vpacked-image filename [canvas]
Return a @dfn{vpacked image closure} that accepts a few simple messages.
"Vpacked" means multiple vertically-abutted images of dimensions NxN (at
the top) through Nx1 (at the bottom), stored in a single image file.
@var{filename} specifies the file and optional arg @var{canvas} specifies
a surface for blitting.  The closure recognizes the following messages:

@table @code
@item #:set-canvas! surface
Change the canvas.

@item #:rects
Return the vector of rectangles of length N+1 (the element at index
zero is @code{#f}) corresponding to areas on the image representing
the smaller sub-images.  The element at index I is a rectangle of
dimension IxI.

@item #:blit! i rect
Blit the sub-image @var{i} (an integer 1 <= I <= N), onto the canvas.
@var{rect} specifies a rectangle to blit to.
@end table
@end deffn

@c ref.texh ends here
