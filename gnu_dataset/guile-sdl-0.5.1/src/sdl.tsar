 ; -*- mode: text; coding: utf-8; -*-
"./"
1
""
10
(0 . "sdl.c")
(0 . "sdlvideo.c")
(0 . "sdlsurface.c")
(0 . "sdlcdrom.c")
(0 . "sdlrect.c")
(0 . "sdlcolor.c")
(0 . "sdljoystick.c")
(0 . "sdlevent.c")
(0 . "sdlenums.c")
(0 . "misc.c")
1
(sdl sdl)
228
(0 0 . init)
(142 0 . init-subsystem)
(327 0 . quit)
(418 0 . quit-subsystem)
(620 0 . was-init)
(861 0 . get-ticks)
(977 0 . delay)
(1052 0 . get-error)
(1133 0 . %%Guile-SDL-obtw)
(1209 0 . create-cursor)
(1422 0 . create-yuv-overlay)
(1697 0 . get-video-surface)
(1777 0 . video-cmf)
(2143 0 . get-video-info)
(2554 0 . video-driver-name)
(2635 0 . list-modes)
(2948 0 . video-mode-ok)
(3326 0 . set-video-mode)
(3562 0 . update-rect)
(3829 0 . update-rects)
(3959 0 . flip)
(4089 0 . set-colors!)
(4373 0 . set-palette)
(4687 0 . set-gamma)
(4880 0 . get-gamma-ramp)
(5134 0 . set-gamma-ramp)
(5436 0 . map-rgb)
(5715 0 . map-rgba)
(6041 0 . pixel-rgb)
(6233 0 . get-rgb)
(6577 0 . pixel-rgba)
(6779 0 . get-rgba)
(7142 0 . fill-rect)
(7350 0 . display-format)
(7517 0 . display-format-alpha)
(7707 0 . warp-mouse)
(7813 0 . set-cursor)
(7911 0 . get-cursor)
(7986 0 . show-cursor)
(8281 0 . gl-get-attribute)
(8394 0 . gl-set-attribute)
(8537 0 . gl-swap-buffers)
(8623 0 . lock-yuv-overlay)
(8742 0 . unlock-yuv-overlay)
(8843 0 . display-yuv-overlay)
(9021 0 . set-caption)
(9252 0 . caption-ti)
(9413 0 . get-caption)
(9706 0 . set-icon)
(9795 0 . iconify-window)
(9901 0 . toggle-full-screen)
(10137 0 . grab-input)
(10366 0 . make-surface)
(10641 0 . create-rgb-surface)
(10998 0 . surface:w)
(11083 0 . surface:h)
(11168 0 . surface:depth)
(11272 0 . surface:flags)
(11402 0 . surface-get-format)
(11513 0 . surface?)
(11601 0 . lock-surface)
(11723 0 . unlock-surface)
(11815 0 . load-bmp)
(11963 0 . load-image)
(12110 0 . save-bmp)
(12263 0 . surface-color-key!)
(12732 0 . set-color-key!)
(12995 0 . surface-alpha!)
(13458 0 . set-alpha!)
(13831 0 . set-clip-rect!)
(14060 0 . get-clip-rect)
(14161 0 . convert-surface)
(14368 0 . blit-surface)
(14745 0 . vertical-flip-surface)
(14864 0 . horizontal-flip-surface)
(14985 0 . vh-flip-surface)
(15126 0 . surface-pixels)
(15673 0 . cd?)
(15776 0 . cd-num-drives)
(15854 0 . cd-name)
(16058 0 . cd-open)
(16272 0 . cd-status)
(16414 0 . cd-in-drive?)
(16521 0 . cd-get-num-tracks)
(16631 0 . cd-get-cur-track)
(16738 0 . cd-get-cur-frame)
(16845 0 . cd-nth-track-itlo)
(17143 0 . cd-get-nth-track)
(17411 0 . cd-play-tracks)
(17909 0 . cd-play)
(18083 0 . cd-pause)
(18201 0 . cd-resume)
(18329 0 . cd-stop)
(18446 0 . cd-eject)
(18566 0 . cd-close)
(18645 0 . cd-msf->frames)
(18812 0 . frames-msf)
(18989 0 . cd-frames->msf)
(19224 0 . rect?)
(19330 0 . make-rect)
(19490 0 . rect:x)
(19569 0 . rect:set-x!)
(19667 0 . rect:y)
(19746 0 . rect:set-y!)
(19844 0 . rect:w)
(19923 0 . rect:set-w!)
(20021 0 . rect:h)
(20100 0 . rect:set-h!)
(20198 0 . color?)
(20300 0 . make-color)
(20418 0 . color:r)
(20499 0 . color:set-r!)
(20599 0 . color:g)
(20680 0 . color:set-g!)
(20780 0 . color:b)
(20861 0 . color:set-b!)
(20961 0 . joystick?)
(21061 0 . num-joysticks)
(21136 0 . joystick-name)
(21302 0 . joystick-open)
(21460 0 . joystick-opened?)
(21616 0 . joystick-index)
(21705 0 . joystick-num-axes)
(21804 0 . joystick-num-balls)
(21906 0 . joystick-num-hats)
(22005 0 . joystick-num-buttons)
(22103 0 . joystick-update)
(22182 0 . joystick-polling)
(22491 0 . joystick-event-state)
(23013 0 . joystick-get-axis)
(23119 0 . joystick-ball-xy)
(23290 0 . joystick-get-ball)
(23606 0 . joystick-get-hat)
(23710 0 . joystick-get-button)
(23871 0 . joystick-close)
(23966 0 . make-event)
(24150 0 . event:type)
(24250 0 . event:set-type!)
(24374 0 . event:active:gain)
(24481 0 . event:active:set-gain!)
(24612 0 . event:active:state)
(24745 0 . event:active:set-state!)
(24892 0 . event:key:state)
(24997 0 . event:key:set-state!)
(25126 0 . event:key:keysym:sym)
(25236 0 . event:key:keysym:set-sym!)
(25370 0 . event:key:keysym:mod)
(25505 0 . event:key:keysym:set-mod!)
(25654 0 . event:key:keysym:scancode)
(25753 0 . event:key:keysym:set-scancode!)
(25871 0 . event:key:keysym:unicode)
(25969 0 . event:key:keysym:set-unicode!)
(26086 0 . event:motion:state)
(26219 0 . event:motion:set-state!)
(26366 0 . event:motion:x)
(26454 0 . event:motion:set-x!)
(26561 0 . event:motion:y)
(26649 0 . event:motion:set-y!)
(26756 0 . event:motion:xrel)
(26847 0 . event:motion:set-xrel!)
(26957 0 . event:motion:yrel)
(27048 0 . event:motion:set-yrel!)
(27158 0 . event:button:button)
(27267 0 . event:button:set-button!)
(27400 0 . event:button:state)
(27508 0 . event:button:set-state!)
(27640 0 . event:button:x)
(27728 0 . event:button:set-x!)
(27835 0 . event:button:y)
(27923 0 . event:button:set-y!)
(28030 0 . event:jaxis:which)
(28121 0 . event:jaxis:set-which!)
(28231 0 . event:jaxis:axis)
(28321 0 . event:jaxis:set-axis!)
(28430 0 . event:jaxis:value)
(28521 0 . event:jaxis:set-value!)
(28631 0 . event:jbutton:which)
(28724 0 . event:jbutton:set-which!)
(28836 0 . event:jbutton:button)
(28930 0 . event:jbutton:set-button!)
(29043 0 . event:jbutton:state)
(29152 0 . event:jbutton:set-state!)
(29285 0 . event:jball:which)
(29376 0 . event:jball:set-which!)
(29486 0 . event:jball:ball)
(29576 0 . event:jball:set-ball!)
(29685 0 . event:jball:xrel)
(29775 0 . event:jball:set-xrel!)
(29884 0 . event:jball:yrel)
(29974 0 . event:jball:set-yrel!)
(30083 0 . event:jhat:which)
(30173 0 . event:jhat:set-which!)
(30282 0 . event:jhat:hat)
(30370 0 . event:jhat:set-hat!)
(30477 0 . event:jhat:value)
(30608 0 . event:jhat:set-value!)
(30753 0 . event:resize:w)
(30841 0 . event:resize:set-w!)
(30948 0 . event:resize:h)
(31036 0 . event:resize:set-h!)
(31143 0 . pump-events)
(31248 0 . evqueue-add)
(31395 0 . evqueue-peek)
(31764 0 . evqueue-get)
(32018 0 . peep-events)
(32814 0 . poll-event)
(33071 0 . wait-event)
(33320 0 . push-event)
(33432 0 . set-event-filter)
(33799 0 . get-event-filter)
(34089 0 . event-type-handling)
(34373 0 . event-state)
(34876 0 . enable-unicode)
(35104 0 . enable-key-repeat)
(35451 0 . get-key-state)
(35549 0 . get-mod-state)
(35653 0 . set-mod-state)
(35851 0 . get-mouse-state)
(36353 0 . get-mouse-relative-state)
(36702 0 . button?)
(37231 0 . mouse-bxy)
(37616 0 . get-app-state)
(37785 0 . enum->number)
(37905 0 . number->enum)
(38061 0 . flags->number)
(38333 0 . number->flags)
(38580 0 . kotk)
(39001 0 . get-wm-info)
(94 0 procedure #(1 0 0 sel) #(50 0 0 0) ())
Initialize SDL and the subsystems/configuration
represented by @var{sel} (@pxref{init flags}).
(136 0 procedure #(1 0 0 sel) #(65 0 0 0) ())
Initialize the SDL subsystems represented by @var{sel}.
@var{sel} is a list of flags (symbols)
from the same set useful for @code{init}.
(47 0 procedure #(0 0 0) #(80 0 0 0) ())
Shut down all SDL subsystems.
Return @code{#t}.
(153 0 procedure #(1 0 0 sel) #(97 0 0 0) ())
Shut down the SDL subsystems represented by @var{sel}.
@var{sel} is a list of flags (symbols)
from the same set useful for @code{init}.
Return @code{#t}.
(191 0 procedure #(1 0 0 sel) #(117 0 0 0) ())
Check if the SDL subsystems represented by @var{sel} have
been initialized.  @var{sel} is a list of flags (symbols)
from the same set useful for @code{init}.  Return a list
likewise composed.
(71 0 procedure #(0 0 0) #(135 0 0 0) ())
Return the number of milliseconds since
the SDL library initialization.
(27 0 procedure #(1 0 0 ms) #(147 0 0 0) ())
Wait @var{ms} milliseconds.
(36 0 procedure #(0 0 0) #(163 0 0 0) ())
Return the current SDL error string.
(31 0 procedure #(0 0 0) #(176 0 0 0) ())
Internal procedure; do not use.
(149 1 procedure #(6 0 0 data mask w h x y) #(157 0 0 0) ())
Return a new cursor from @var{data} and @var{mask}
(both u8 uniform vectors), sized @var{w} by @var{h}
and with hot pixel located at @var{x},@var{y}.
(201 1 procedure #(3 1 0 width height format display) #(191 0 0 0) ())
Create a new YUV overlay, sized @var{width} by @var{height}
with overlay @var{format} (a symbol or an exact number).
Optional arg @var{display} specifies a surface to use
instead of creating a new one.
(35 1 procedure #(0 0 0) #(225 0 0 0) ())
Return the current display surface.
(320 1 procedure #(0 0 0) #(257 0 0 0) ())
Return information about the video hardware as three values:
@code{capabilities} (list of symbols), @code{memory} (integer),
and @code{format} (pixel format object).  The @code{capabilities} are:

@example
hw-available
wm-available
blit-hw   blit-hw-CC   blit-hw-A
blit-sw   blit-sw-CC   blit-sw-A
blit-fill
@end example
(365 1 procedure #(0 0 0) #(302 0 0 0) ())
NB: This procedure is obsoleted by @code{video-cmf}
and @strong{will be removed} after 2013-12-31.

Return information about the video hardware as an alist.
Keys are: @code{hw-available}, @code{wm-available},
@code{bit-hw}, @code{blit-hw-CC}, @code{blit-hw-A},
@code{blit-sw}, @code{blit-sw-CC}, @code{blit-sw-A},
@code{blit-fill}, @code{video-mem} and @code{vfmt}.
(36 1 procedure #(0 0 0) #(336 0 0 0) ())
Return the name of the video driver.
(254 1 procedure #(0 2 0 format flags) #(354 0 0 0) ())
Return a list of available screen dimensions for pixel
@var{format} and @var{flags} (@pxref{video flags}).
Format defaults to that for
the current screen.  Flags default to none.
Return @code{#f} if no modes are available, @code{#t} if all are available.
(309 1 procedure #(3 1 0 width height bpp flags) #(414 0 0 0) ())
Check to see if a particular video mode is supported.
Args are @var{width}, @var{height}, @var{bpp} (numbers),
and @var{flags} (@pxref{video flags}).
Return @code{#f} if the mode is not supported, or a number
indicating the bits-per-pixel of the closest available
mode supporting @var{width} and @var{height}.
(167 1 procedure #(3 1 0 width height bpp flags) #(442 0 0 0) ())
Set the SDL video mode with @var{width},
@var{height} and bits-per-pixel @var{bpp}.  Optional arg
@var{flags} (@pxref{video flags}) is supported.
Return a new surface.
(205 1 procedure #(2 3 0 surface x y w h) #(469 0 0 0) ())
Update @var{surface} within a specified rectangle.
The second arg can either be an SDL-Rect object, or
the second through fifth args are numbers specifying
the x, y, width and height of a rectangular area.
(74 1 procedure #(2 0 0 surface ls) #(506 0 0 0) ())
On @var{surface}, update the rectangles in @var{ls},
a list of rectangles.
(77 1 procedure #(0 1 0 surface) #(534 0 0 0) ())
Swap double buffers of the default surface,
or of @var{surface} if specified.
(217 1 procedure #(2 1 0 surface colors start) #(591 0 0 0) ())
Set a portion of the colormap for the 8-bit @var{surface}
using @var{colors}, a vector of SDL-Colors.
Optional arg @var{start} (an integer in the range [0,255])
specifies the portion to be modified.  It defaults to 0.
(241 1 procedure #(3 1 0 surface flags colors start) #(620 0 0 0) ())
Set the palette of an 8-bit @var{surface}
using @var{flags} (@pxref{palette flags}) and
@var{colors}, a vector of SDL-Colors.
Optional arg @var{start} (an integer in the range [0,255])
specifies the portion to be modified.  It defaults to 0.
(117 1 procedure #(3 0 0 redgamma greengamma bluegamma) #(649 0 0 0) ())
Set the color gamma function for the display
using real numbers @var{redgamma}, @var{greengamma}
and @var{bluegamma}.
(208 1 procedure #(0 0 0) #(671 0 0 0) ())
Return the gamma translation lookup tables currently used by
the display as a list of three tables, for red, green and blue.
Each table is a u16 uniform vector of length 256.
Return @code{#f} if unsuccessful.
(250 1 procedure #(3 0 0 r g b) #(715 0 0 0) ())
Set the gamma translation lookup tables currently
used by the display to tables @var{r}, @var{g} and @var{b},
each a u16 uniform vector of length 256, or @code{#f},
in which case that particular component is unchanged.
Return @code{#t} if successful.
(220 1 procedure #(2 2 0 format r g b) #(758 0 0 0) ())
Map a RGB color value to the pixel @var{format}.
The second arg can be an SDL-Color, otherwise the second
through fourth args are red, green and blue values (numbers).
Return the mapped components as an unsigned integer.
(265 1 procedure #(3 2 0 format r g b a) #(793 0 0 0) ())
Map a RGB color value to the pixel @var{format}.
If the second arg is an SDL-Color, the third is an alpha
value (number).  Otherwise, the second through fifth args
are red, green, blue and alpha values (numbers).
Return the mapped components as an unsigned integer.
(133 1 procedure #(2 0 0 pixel format) #(829 0 0 0) ())
Return RGB info from @var{pixel} in the specified pixel @var{format}
as three values: @code{r}, @code{g} and @code{b} (all integers).
(285 1 procedure #(2 0 0 pixel format) #(864 0 0 0) ())
NB: This procedure is obsoleted by @code{pixel-rgb}
and @strong{will be removed} after 2013-12-31.

Get RGB values from @var{pixel} in the specified pixel
@var{format}.  Return an alist with keys @code{r}, @code{g}
and @code{b}, with red, green and blue values (numbers),
respectively.
(143 1 procedure #(2 0 0 pixel format) #(887 0 0 0) ())
Return RGBA info from @var{pixel} in the specified pixel @var{format} as
four values: @code{r}, @code{g}, @code{b} and @code{a} (all integers).
(304 1 procedure #(2 0 0 pixel format) #(917 0 0 0) ())
NB: This procedure is obsoleted by @code{pixel-rgba}
and @strong{will be removed} after 2013-12-31.

Get RGBA values from @var{pixel} in the specified pixel
@var{format}.  Return an alist with keys @code{r}, @code{g},
@code{b} and @code{a}, with red, green, blue and alpha values
(numbers), respectively.
(143 1 procedure #(3 0 0 surface rect color) #(942 0 0 0) ())
Fill @var{surface} @var{rect} with @var{color} (a number).
If @var{rect} is @code{#f}, fill the entire surface.
Return @code{#t} if successful.
(113 1 procedure #(1 0 0 surface) #(966 0 0 0) ())
Return a new surface made by converting @var{surface}
to the display format.  Return @code{#f} if not successful.
(136 1 procedure #(1 0 0 surface) #(989 0 0 0) ())
Return a new surface made by converting @var{surface}
to the display format, with an alpha channel.  Return @code{#f}
if not successful.
(56 1 procedure #(2 0 0 x y) #(1010 0 0 0) ())
Set the position of the mouse cursor to @var{x},@var{y}.
(45 1 procedure #(1 0 0 cursor) #(1026 0 0 0) ())
Set the current mouse cursor to @var{cursor}.
(29 1 procedure #(0 0 0) #(1040 0 0 0) ())
Get the current mouse cursor.
(240 1 procedure #(0 1 0 setting) #(1055 0 0 0) ())
Return the current visibility of the pointer (aka ``mouse cursor'')
as a boolean.  If arg @var{setting} (a boolean) is specified, set
the visibility to @var{setting} (the returned visibility corresponds
to that before the call, regardless).
(57 1 procedure #(1 0 0 attribute) #(1069 0 0 0) ())
Return the value of a special SDL/OpenGL @var{attribute}.
(81 1 procedure #(2 0 0 attribute value) #(1088 0 0 0) ())
Set the special SDL/OpenGL @var{attribute} to @var{value}.
Both args are numbers.
(40 1 procedure #(0 0 0) #(1105 0 0 0) ())
Swap OpenGL framebuffers/Update Display.
(65 1 procedure #(1 0 0 overlay) #(1119 0 0 0) ())
Lock the given YUV @var{overlay}.
Return @code{#f} if successful.
(47 1 procedure #(1 0 0 overlay) #(1134 0 0 0) ())
Unlock the previously locked YUV @var{overlay}.
(115 1 procedure #(2 0 0 overlay dstrect) #(1150 0 0 0) ())
Blit the YUV @var{overlay} to the display @var{dstrect}
over which it was created.  Return @code{#t} if successful.
(173 1 procedure #(1 1 0 title icon) #(1171 0 0 0) ())
Set the title-bar and icon name of the display window
to @var{title} and @var{icon} (both strings), respectively.
If @var{icon} is not specified, use @var{title} by default.
(114 1 procedure #(0 0 0) #(1196 0 0 0) ())
Return display-window caption as two values: @code{title}
and @code{icon} (both strings, or @code{#f} if not set).
(246 1 procedure #(0 0 0) #(1221 0 0 0) ())
NB: This procedure is obsoleted by @code{caption-ti}
and @strong{will be removed} after 2013-12-31.

Return an alist with keys @code{title} and @code{icon}
and values the title-bar and icon name (or @code{#f}) of the display
window, respectively.
(38 1 procedure #(1 0 0 icon) #(1237 0 0 0) ())
Set @var{icon} for the display window.
(60 1 procedure #(0 0 0) #(1254 0 0 0) ())
Iconify/Minimize the window.
Return @code{#t} if successful.
(181 1 procedure #(0 1 0 surface) #(1270 0 0 0) ())
Toggle the default video surface between windowed
and fullscreen mode, if supported.  Optional arg
@var{surface} specifies another surface to toggle.
Return @code{#t} if successful.
(177 1 procedure #(0 1 0 mode) #(1296 0 0 0) ())
Grab mouse and keyboard input.  Return new grab state.
Optional arg @var{mode} (a symbol) specifies the kind
of grab, one of @code{query} (the default),
@code{off} or @code{on}.
(211 2 procedure #(2 1 0 width height flags) #(88 0 0 0) ())
Return a new surface of dimensions @var{width} by @var{height}.
Optional third arg @var{flags} (@pxref{video flags})
further specifies the surface.  Color depth and masks
are those for the current video surface.
(262 2 procedure #(8 0 0 flags width height depth rmask gmask bmask amask) #(130 0 0 0) ())
Return an empty surface.
The eight arguments, directly analagous to those
for SDL_CreateRGBSurface, are: @var{flags}
(list of symbols, @pxref{video flags}),
@var{width}, @var{height}, @var{depth}, @var{rmask},
@var{gmask}, @var{bmask}, @var{amask}
(all numbers).
(32 2 procedure #(1 0 0 surface) #(164 0 0 0) ())
Get @code{w} from @var{surface}.
(32 2 procedure #(1 0 0 surface) #(165 0 0 0) ())
Get @code{h} from @var{surface}.
(51 2 procedure #(1 0 0 surface) #(166 0 0 0) ())
Get @code{format->BitsPerPixel} from @var{surface}.
(77 2 procedure #(1 0 0 surface) #(170 0 0 0) ())
Return @code{flags} from @var{surface} as a (possibly empty) list of symbols.
(58 2 procedure #(1 0 0 surface) #(177 0 0 0) ())
Return a new pixel format, the same used by @var{surface}.
(39 2 procedure #(1 0 0 obj) #(193 0 0 0) ())
Return true iff @var{obj} is a surface.
(69 2 procedure #(1 0 0 surface) #(207 0 0 0) ())
Lock @var{surface} for direct access.
Return @code{#t} if successful.
(39 2 procedure #(1 0 0 surface) #(222 0 0 0) ())
Unlock previously locked @var{surface}.
(94 2 procedure #(1 0 0 filename) #(238 0 0 0) ())
Load bitmap data from @var{filename}.
Return a new surface if successful, otherwise @code{#f}.
(93 2 procedure #(1 0 0 filename) #(260 0 0 0) ())
Load image data from @var{filename}.
Return a new surface if successful, otherwise @code{#f}.
(91 2 procedure #(2 0 0 surface filename) #(282 0 0 0) ())
Save @var{surface} to @var{filename} in Windows BMP format.
Return @code{#t} if successful.
(405 2 procedure #(2 1 0 surface pixel rle) #(310 0 0 0) ())
Set the color key for @var{surface} to @var{pixel}.
If @var{pixel} is @code{#f}, clear the current color key.
Otherwise, it should be an integer of the appropriate depth
for @var{surface} (e.g., in the range [0,65535] for 16 bpp).
If color key processing is enabled, optional arg @var{rle} is a
boolean that enables (true) or disables (false, the default)
RLE acceleration.
Return @code{#t} if successful.
(200 2 procedure #(3 0 0 surface flag key) #(345 0 0 0) ())
NB: This procedure is obsoleted by @code{surface-color-key!}
and @strong{will be removed} after 2013-12-31.

Set @var{surface} color key as specified by @var{flag}
(@pxref{video flags}) and @var{key}.
(399 2 procedure #(2 1 0 surface alpha rle) #(373 0 0 0) ())
Set alpha blending for the entire @var{surface} to @var{alpha}.
If @var{alpha} is @code{#f}, disable alpha blending.
Otherwise it should be an integer in the range [0,255]
or one of the symbols @code{transparent} or @code{opaque}.
If alpha blending is enabled, optional arg @var{rle} is a
boolean that enables (true) or disables (false, the default)
RLE acceleration.
Return @code{#t} if successful.
(308 2 procedure #(2 1 0 surface flag alpha) #(411 0 0 0) ())
NB: This procedure is obsoleted by @code{surface-alpha!}
and @strong{will be removed} after 2013-12-31.

Adjust whole-@var{surface} alpha as specified by
@var{flag} (@pxref{video flags}) and @var{alpha}
(@pxref{alpha-enum enums}, or a number 0-255).
If @var{flag} is @code{#f}, ignore @var{alpha} completely.
(170 2 procedure #(1 1 0 surface rect) #(450 0 0 0) ())
Set @var{surface} clipping rectangle to the whole surface.
Optional arg @var{rect}, if non-@code{#f}, specifies a particular
rectangle instead of using the whole surface.
(48 2 procedure #(1 0 0 surface) #(474 0 0 0) ())
Return the clipping rectangle for @var{surface}.
(140 2 procedure #(2 1 0 surface format flags) #(496 0 0 0) ())
Convert @var{surface} to the same @var{format} as another
surface.  Optional third arg @var{flags} is a list of flags
(@pxref{video flags}).
(307 2 procedure #(1 3 0 src srcrect dst dstrect) #(529 0 0 0) ())
Perform a fast blit from the
@var{src} surface @var{srcrect} to the
@var{dst} surface @var{dstrect}.
@var{srcrect} defaults to x=0, y=0, @var{src} surface
dimensions.  If unspecified @var{dst} is taken as
the default video surface.  @var{dstrect} likewise defaults
to x=0, y=0, @var{dst} surface dimensions.
(66 2 procedure #(1 0 0 surface) #(594 0 0 0) ())
Return a new surface created by flipping @var{surface} vertically.
(68 2 procedure #(1 0 0 surface) #(634 0 0 0) ())
Return a new surface created by flipping @var{surface} horizontally.
(88 2 procedure #(1 0 0 surface) #(675 0 0 0) ())
Return a new surface created by flipping @var{surface}
both vertically and horizontally.
(486 2 procedure #(1 1 0 surface squash) #(696 0 0 0) ())
Return pixel data of @var{surface} as a new uniform vector.
The uvec has type @code{u8}, @code{u16} or @code{u32}, corresponding
to the @var{surface} depth, with @var{height} x @var{width} elements.
A 24bpp surface --- @var{depth-in-bytes} of 3 --- is expanded (per pixel)
to @code{u32}, leaving the high nybble clear.

Optional arg @var{squash} non-@code{#f} means to
return a u8vector regardless of @var{surface} depth,
with @var{height} x @var{width} x @var{depth-in-bytes} elements.
(55 3 procedure #(1 0 0 obj) #(68 0 0 0) ())
Return @code{#t} iff @var{obj} is a CDROM drive object.
(34 3 procedure #(0 0 0) #(81 0 0 0) ())
Return the number of CDROM drives.
(153 3 procedure #(0 1 0 drive) #(95 0 0 0) ())
Return a human-readable, system-dependent
identifier (a string) for the CDROM, or @code{#f}.
Optional arg @var{drive} is a number specifying which drive.
(162 3 procedure #(0 1 0 drive) #(113 0 0 0) ())
Open the CDROM drive for access and return its handle.
If the drive is unavailable, return @code{#f}.
Optional arg @var{drive} is a number specifying which drive.
(91 3 procedure #(1 0 0 cdrom) #(131 0 0 0) ())
Return the current status of the drive @var{cdrom}
as a symbol (@pxref{cdrom-state enums}).
(56 3 procedure #(1 0 0 cdrom) #(145 0 0 0) ())
Return @code{#t} iff there is a CD in drive @var{cdrom}.
(59 3 procedure #(1 0 0 cdrom) #(169 0 0 0) ())
Return the number of tracks on the CD in drive @var{cdrom}.
(56 3 procedure #(1 0 0 cdrom) #(180 0 0 0) ())
Return the current track on the CD in drive @var{cdrom}.
(56 3 procedure #(1 0 0 cdrom) #(191 0 0 0) ())
Return the current frame of the CD in drive @var{cdrom}.
(244 3 procedure #(1 1 0 cdrom n) #(208 0 0 0) ())
For CD in drive @var{cdrom}, return four values describing track
@var{n} (zero if unspecified): @code{id}, @code{type}, @code{length}
and @code{offset}, all integers except for @code{type}, which is
a symbol, either @code{audio} or @code{data}.
(214 3 procedure #(1 1 0 cdrom n) #(240 0 0 0) ())
NB: This procedure is obsoleted by @code{cd-nth-track-itlo}
and @strong{will be removed} after 2013-12-31.

For CD in drive @var{cdrom}, return info on track @var{n}
as an alist or @code{#f} if there were problems.
(404 3 procedure #(1 4 0 cdrom start-track start-frame n-tracks n-frames) #(277 0 0 0) ())
Play the given CD tracks in drive @var{cdrom}.
Play the CD starting at @var{start-track} and
@var{start-frame} for @var{ntracks} tracks and @var{nframes}
frames.  If both @var{ntrack} and @var{nframe} are 0, play
until the end of the CD.  This procedure will skip data
tracks, and should only be called after calling
@code{cd-status} to get track information about the CD.
Return @code{#t} if successful.
(109 3 procedure #(3 0 0 cdrom start length) #(304 0 0 0) ())
Play CD in drive @var{cdrom} from @var{start} frame for
@var{length} frames.  Return @code{#t} if successful.
(67 3 procedure #(1 0 0 cdrom) #(323 0 0 0) ())
Pause the CD in drive @var{cdrom}.  Return @code{#t} if successful.
(77 3 procedure #(1 0 0 cdrom) #(339 0 0 0) ())
Resume (unpause) the CD in drive @var{cdrom}.
Return @code{#t} if successful.
(66 3 procedure #(1 0 0 cdrom) #(354 0 0 0) ())
Stop the CD in drive @var{cdrom}.  Return @code{#t} if successful.
(69 3 procedure #(1 0 0 cdrom) #(369 0 0 0) ())
Eject the CD from drive @var{cdrom}.  Return @code{#t} if successful.
(28 3 procedure #(1 0 0 cdrom) #(384 0 0 0) ())
Close the drive @var{cdrom}.
(115 3 procedure #(1 2 0 m s f) #(404 0 0 0) ())
Return frames (an integer) computed fr
@var{m}, second @var{s} and frame @var{f}.
@var{s} and @var{f} are optional.
(124 3 procedure #(1 0 0 frames) #(425 0 0 0) ())
Break down @var{frames} (an integer) and return three values:
@code{minute}, @code{second} and @code{frames} (all integers).
(182 3 procedure #(1 0 0 frames) #(453 0 0 0) ())
NB: This procedure is obsoleted by @code{frames-msf}
and @strong{will be removed} after 2013-12-31.

Return a minute/second/frames alist made from
converting @var{frames} (a number).
(58 4 procedure #(1 0 0 obj) #(55 0 0 0) ())
Return @code{#t} iff @var{obj} is an SDL-rectangle object.
(99 4 procedure #(4 0 0 x y width height) #(68 0 0 0) ())
Return a rectangle object with location @var{x},@var{y}
and dimensions @var{width} by @var{height}.
(29 4 procedure #(1 0 0 rect) #(109 0 0 0) ())
Get @code{x} from @var{rect}.
(42 4 procedure #(2 0 0 rect value) #(109 0 0 0) ())
Set @code{x} in @var{rect}
to @var{value}.
(29 4 procedure #(1 0 0 rect) #(110 0 0 0) ())
Get @code{y} from @var{rect}.
(42 4 procedure #(2 0 0 rect value) #(110 0 0 0) ())
Set @code{y} in @var{rect}
to @var{value}.
(29 4 procedure #(1 0 0 rect) #(111 0 0 0) ())
Get @code{w} from @var{rect}.
(42 4 procedure #(2 0 0 rect value) #(111 0 0 0) ())
Set @code{w} in @var{rect}
to @var{value}.
(29 4 procedure #(1 0 0 rect) #(112 0 0 0) ())
Get @code{h} from @var{rect}.
(42 4 procedure #(2 0 0 rect value) #(112 0 0 0) ())
Set @code{h} in @var{rect}
to @var{value}.
(54 5 procedure #(1 0 0 obj) #(54 0 0 0) ())
Return @code{#t} iff @var{obj} is an SDL-Color object.
(68 5 procedure #(3 0 0 r g b) #(67 0 0 0) ())
Return a color object with @var{r}, @var{g},
and @var{b} components.
(30 5 procedure #(1 0 0 color) #(106 0 0 0) ())
Get @code{r} from @var{color}.
(43 5 procedure #(2 0 0 color value) #(106 0 0 0) ())
Set @code{r} in @var{color}
to @var{value}.
(30 5 procedure #(1 0 0 color) #(107 0 0 0) ())
Get @code{g} from @var{color}.
(43 5 procedure #(2 0 0 color value) #(107 0 0 0) ())
Set @code{g} in @var{color}
to @var{value}.
(30 5 procedure #(1 0 0 color) #(108 0 0 0) ())
Get @code{b} from @var{color}.
(43 5 procedure #(2 0 0 color value) #(108 0 0 0) ())
Set @code{b} in @var{color}
to @var{value}.
(52 6 procedure #(1 0 0 obj) #(62 0 0 0) ())
Return @code{#t} iff @var{obj} is a joystick object.
(31 6 procedure #(0 0 0) #(75 0 0 0) ())
Return the number of joysticks.
(119 6 procedure #(0 1 0 n) #(88 0 0 0) ())
Return the (string) name of the default joystick, or @code{#f}.
Optional arg @var{n} specifies which joystick to check.
(110 6 procedure #(0 1 0 n) #(106 0 0 0) ())
Return a handle to the default joystick opened for use.
Optional arg @var{n} specifies which joystick to open.
(108 6 procedure #(0 1 0 n) #(124 0 0 0) ())
Return @code{#t} iff the default joystick is opened.
Optional arg @var{n} specifies which joystick to check.
(35 6 procedure #(1 0 0 joystick) #(142 0 0 0) ())
Return the index of @var{joystick}.
(45 6 procedure #(1 0 0 joystick) #(156 0 0 0) ())
Return the number of axes for @var{joystick}.
(48 6 procedure #(1 0 0 joystick) #(170 0 0 0) ())
Return the number trackballs for @var{joystick}.
(45 6 procedure #(1 0 0 joystick) #(184 0 0 0) ())
Return the number of hats for @var{joystick}.
(44 6 procedure #(1 0 0 joystick) #(198 0 0 0) ())
Return number of buttons for @var{joystick}.
(34 6 procedure #(0 0 0) #(212 0 0 0) ())
Update the state of all Joysticks.
(255 6 procedure #(0 1 0 setting) #(229 0 0 0) ())
Return @code{#t} if joystick events are polled and queued (such
that it is unnecessary to ``manually'' call @code{joystick-update}),
otherwise @code{#f}.
If @var{setting} is specified, set joystick events polling
to the truth value of @var{setting} first.
(470 6 procedure #(1 0 0 state) #(251 0 0 0) ())
NB: This procedure is obsoleted by @code{joystick-polling}
and @strong{will be removed} after 2013-12-31.

Set or query the state of internal joystick event processing,
based on @var{state} (a symbol).
If @var{state} is @code{SDL_QUERY}, return the current state.
If it is @code{SDL_IGNORE} or @code{SDL_ENABLE},
disable or enable, respectively, internal joystick
event processing and return @var{state}.
When enabled, it is not necessary to call @code{joystick-update}.
(47 6 procedure #(2 0 0 joystick axis) #(270 0 0 0) ())
For @var{joystick}, return state of @var{axis}.
(114 6 procedure #(2 0 0 joystick n) #(288 0 0 0) ())
Return relative motion of @var{joystick} trackball @var{n}
as two values: @code{dx} and @code{dy} (both integers).
(259 6 procedure #(2 0 0 joystick n) #(319 0 0 0) ())
NB: This procedure is obsoleted by @code{joystick-ball-xy}
and @strong{will be removed} after 2013-12-31.

For @var{joystick}, return relative motion of trackball
@var{n}, as an alist with keys @code{dx} and @code{dy}.
If @var{n} is invalid, return @code{#f}.
(48 6 procedure #(2 0 0 joystick n) #(340 0 0 0) ())
For @var{joystick}, return state of hat @var{n}.
(104 6 procedure #(2 0 0 joystick n) #(358 0 0 0) ())
For @var{joystick}, return state of button @var{n},
a symbol, one of: @code{released} or @code{pressed}.
(41 6 procedure #(1 0 0 joystick) #(375 0 0 0) ())
Close a previously opened @var{joystick}.
(134 7 procedure #(0 1 0 type) #(98 0 0 0) ())
Return a new SDL event.
Optional arg @var{type} is a symbol (@pxref{event-type enums}).
If omitted, the default is @code{SDL_NOEVENT}.
(49 7 procedure #(1 0 0 event) #(222 0 0 0) ())
Return the symbolic @code{type} from @var{event}.
(67 7 procedure #(2 0 0 event value) #(222 0 0 0) ())
Set @code{type} in @var{event} to @var{value}, a symbol or integer.
(56 7 procedure #(1 0 0 event) #(227 0 0 0) ())
Return the symbolic @code{active.gain} from @var{event}.
(74 7 procedure #(2 0 0 event value) #(227 0 0 0) ())
Set @code{active.gain} in @var{event} to @var{value}, a symbol or integer.
(82 7 procedure #(1 0 0 event) #(231 0 0 0) ())
Return @code{active.state} from @var{event} as a (possibly empty) list of symbols.
(90 7 procedure #(2 0 0 event value) #(231 0 0 0) ())
Set @code{active.state} in @var{event} to @var{value}, a (possibly empty) list of symbols.
(54 7 procedure #(1 0 0 event) #(236 0 0 0) ())
Return the symbolic @code{key.state} from @var{event}.
(72 7 procedure #(2 0 0 event value) #(236 0 0 0) ())
Set @code{key.state} in @var{event} to @var{value}, a symbol or integer.
(59 7 procedure #(1 0 0 event) #(241 0 0 0) ())
Return the symbolic @code{key.keysym.sym} from @var{event}.
(77 7 procedure #(2 0 0 event value) #(241 0 0 0) ())
Set @code{key.keysym.sym} in @var{event} to @var{value}, a symbol or integer.
(84 7 procedure #(1 0 0 event) #(246 0 0 0) ())
Return @code{key.keysym.mod} from @var{event} as a (possibly empty) list of symbols.
(92 7 procedure #(2 0 0 event value) #(246 0 0 0) ())
Set @code{key.keysym.mod} in @var{event} to @var{value}, a (possibly empty) list of symbols.
(48 7 procedure #(1 0 0 event) #(248 0 0 0) ())
Get @code{key.keysym.scancode} from @var{event}.
(61 7 procedure #(2 0 0 event value) #(248 0 0 0) ())
Set @code{key.keysym.scancode} in @var{event}
to @var{value}.
(47 7 procedure #(1 0 0 event) #(249 0 0 0) ())
Get @code{key.keysym.unicode} from @var{event}.
(60 7 procedure #(2 0 0 event value) #(249 0 0 0) ())
Set @code{key.keysym.unicode} in @var{event}
to @var{value}.
(82 7 procedure #(1 0 0 event) #(254 0 0 0) ())
Return @code{motion.state} from @var{event} as a (possibly empty) list of symbols.
(90 7 procedure #(2 0 0 event value) #(254 0 0 0) ())
Set @code{motion.state} in @var{event} to @var{value}, a (possibly empty) list of symbols.
(37 7 procedure #(1 0 0 event) #(255 0 0 0) ())
Get @code{motion.x} from @var{event}.
(50 7 procedure #(2 0 0 event value) #(255 0 0 0) ())
Set @code{motion.x} in @var{event}
to @var{value}.
(37 7 procedure #(1 0 0 event) #(256 0 0 0) ())
Get @code{motion.y} from @var{event}.
(50 7 procedure #(2 0 0 event value) #(256 0 0 0) ())
Set @code{motion.y} in @var{event}
to @var{value}.
(40 7 procedure #(1 0 0 event) #(257 0 0 0) ())
Get @code{motion.xrel} from @var{event}.
(53 7 procedure #(2 0 0 event value) #(257 0 0 0) ())
Set @code{motion.xrel} in @var{event}
to @var{value}.
(40 7 procedure #(1 0 0 event) #(258 0 0 0) ())
Get @code{motion.yrel} from @var{event}.
(53 7 procedure #(2 0 0 event value) #(258 0 0 0) ())
Set @code{motion.yrel} in @var{event}
to @var{value}.
(58 7 procedure #(1 0 0 event) #(263 0 0 0) ())
Return the symbolic @code{button.button} from @var{event}.
(76 7 procedure #(2 0 0 event value) #(263 0 0 0) ())
Set @code{button.button} in @var{event} to @var{value}, a symbol or integer.
(57 7 procedure #(1 0 0 event) #(267 0 0 0) ())
Return the symbolic @code{button.state} from @var{event}.
(75 7 procedure #(2 0 0 event value) #(267 0 0 0) ())
Set @code{button.state} in @var{event} to @var{value}, a symbol or integer.
(37 7 procedure #(1 0 0 event) #(268 0 0 0) ())
Get @code{button.x} from @var{event}.
(50 7 procedure #(2 0 0 event value) #(268 0 0 0) ())
Set @code{button.x} in @var{event}
to @var{value}.
(37 7 procedure #(1 0 0 event) #(269 0 0 0) ())
Get @code{button.y} from @var{event}.
(50 7 procedure #(2 0 0 event value) #(269 0 0 0) ())
Set @code{button.y} in @var{event}
to @var{value}.
(40 7 procedure #(1 0 0 event) #(271 0 0 0) ())
Get @code{jaxis.which} from @var{event}.
(53 7 procedure #(2 0 0 event value) #(271 0 0 0) ())
Set @code{jaxis.which} in @var{event}
to @var{value}.
(39 7 procedure #(1 0 0 event) #(272 0 0 0) ())
Get @code{jaxis.axis} from @var{event}.
(52 7 procedure #(2 0 0 event value) #(272 0 0 0) ())
Set @code{jaxis.axis} in @var{event}
to @var{value}.
(40 7 procedure #(1 0 0 event) #(273 0 0 0) ())
Get @code{jaxis.value} from @var{event}.
(53 7 procedure #(2 0 0 event value) #(273 0 0 0) ())
Set @code{jaxis.value} in @var{event}
to @var{value}.
(42 7 procedure #(1 0 0 event) #(275 0 0 0) ())
Get @code{jbutton.which} from @var{event}.
(55 7 procedure #(2 0 0 event value) #(275 0 0 0) ())
Set @code{jbutton.which} in @var{event}
to @var{value}.
(43 7 procedure #(1 0 0 event) #(276 0 0 0) ())
Get @code{jbutton.button} from @var{event}.
(56 7 procedure #(2 0 0 event value) #(276 0 0 0) ())
Set @code{jbutton.button} in @var{event}
to @var{value}.
(58 7 procedure #(1 0 0 event) #(280 0 0 0) ())
Return the symbolic @code{jbutton.state} from @var{event}.
(76 7 procedure #(2 0 0 event value) #(280 0 0 0) ())
Set @code{jbutton.state} in @var{event} to @var{value}, a symbol or integer.
(40 7 procedure #(1 0 0 event) #(282 0 0 0) ())
Get @code{jball.which} from @var{event}.
(53 7 procedure #(2 0 0 event value) #(282 0 0 0) ())
Set @code{jball.which} in @var{event}
to @var{value}.
(39 7 procedure #(1 0 0 event) #(283 0 0 0) ())
Get @code{jball.ball} from @var{event}.
(52 7 procedure #(2 0 0 event value) #(283 0 0 0) ())
Set @code{jball.ball} in @var{event}
to @var{value}.
(39 7 procedure #(1 0 0 event) #(284 0 0 0) ())
Get @code{jball.xrel} from @var{event}.
(52 7 procedure #(2 0 0 event value) #(284 0 0 0) ())
Set @code{jball.xrel} in @var{event}
to @var{value}.
(39 7 procedure #(1 0 0 event) #(285 0 0 0) ())
Get @code{jball.yrel} from @var{event}.
(52 7 procedure #(2 0 0 event value) #(285 0 0 0) ())
Set @code{jball.yrel} in @var{event}
to @var{value}.
(39 7 procedure #(1 0 0 event) #(287 0 0 0) ())
Get @code{jhat.which} from @var{event}.
(52 7 procedure #(2 0 0 event value) #(287 0 0 0) ())
Set @code{jhat.which} in @var{event}
to @var{value}.
(37 7 procedure #(1 0 0 event) #(288 0 0 0) ())
Get @code{jhat.hat} from @var{event}.
(50 7 procedure #(2 0 0 event value) #(288 0 0 0) ())
Set @code{jhat.hat} in @var{event}
to @var{value}.
(80 7 procedure #(1 0 0 event) #(292 0 0 0) ())
Return @code{jhat.value} from @var{event} as a (possibly empty) list of symbols.
(88 7 procedure #(2 0 0 event value) #(292 0 0 0) ())
Set @code{jhat.value} in @var{event} to @var{value}, a (possibly empty) list of symbols.
(37 7 procedure #(1 0 0 event) #(294 0 0 0) ())
Get @code{resize.w} from @var{event}.
(50 7 procedure #(2 0 0 event value) #(294 0 0 0) ())
Set @code{resize.w} in @var{event}
to @var{value}.
(37 7 procedure #(1 0 0 event) #(295 0 0 0) ())
Get @code{resize.h} from @var{event}.
(50 7 procedure #(2 0 0 event value) #(295 0 0 0) ())
Set @code{resize.h} in @var{event}
to @var{value}.
(60 7 procedure #(0 0 0) #(310 0 0 0) ())
Gather events from input devices and update the event queue.
(95 7 procedure #(0 0 1 events) #(323 0 0 0) ())
Add @code{events} to the back of the event queue.
Return the count of succesfully added events.
(305 7 procedure #(2 1 0 n mask accumulate) #(404 0 0 0) ())
Return a count (less than or equal to @var{n}) of events at
the front of the event queue that match @var{mask},
without changing the queue.  Optional arg @var{accumulate} if
non-@code{#f} means to return the list of matched events, instead.
If there are errors, return @code{#f}.

@xref{event-mask flags}.
(201 7 procedure #(2 0 0 n mask) #(425 0 0 0) ())
Return a list (of length at most @var{n}) of
events at the front of the event queue that match
@var{mask}, removing them from the queue.
If there are errors, return @code{#f}.

@xref{event-mask flags}.
(721 7 procedure #(4 0 0 events numevents action mask) #(461 0 0 0) ())
NB: This procedure is obsoleted by @code{evqueue-add},
@code{evqueue-peek} and @code{evqueue-get};
it @strong{will be removed} after 2013-12-31.

Manage the event queue, depending
on @var{action} (@pxref{event-action enums}):

@table @code
@item SDL_ADDEVENT
Add up to @var{numevents} (an integer) events from
@var{events} (a list) to the back of the event queue.

@item SDL_PEEKEVENT
Return a count (number less than or equal to @var{numevents})
of events at the front of the event queue that match @var{mask}
(@pxref{event-mask flags}), without changing the queue.

@item SDL_GETEVENT
Act like for @code{SDL_PEEKEVENT} except return a list of
matching events instead of a count, removing them from the queue.
@end table
(205 7 procedure #(0 1 0 event) #(547 0 0 0) ())
Poll for events and return @code{#t} if there are any pending.
Optional arg @var{event} specifies an event object (from
@code{make-event}) to be filled in with the next event from
the queue (if available).
(197 7 procedure #(0 1 0 event) #(574 0 0 0) ())
Wait indefinitely for and return @code{#f} only if there were errors.
Optional arg @var{event} specifies an event object (from
@code{make-event}) to be filled in with the next event from
the queue.
(61 7 procedure #(1 0 0 event) #(599 0 0 0) ())
Push @var{event} onto the queue.
Return @code{#t} on success.
(308 7 procedure #(2 0 0 filter full?) #(652 0 0 0) ())
Set the event filter to @var{filter}, or clear it if @var{filter}
is @code{#f}.  This is a procedure called with one arg, and whose
return value, if non-@code{#f}, means to keep the event, otherwise
discard it.  If @var{full?} is @code{#f}, the arg the event type (a
symbol), otherwise it is an event object.
(244 7 procedure #(0 0 0) #(677 0 0 0) ())
Return information on the current event filter, or @code{#f}
if none is set.  If there is a filter, the value is a pair
with car the filter proc, and cdr @code{#f} if the proc takes
an event type, or @code{#t} if the proc takes an event object.
(225 7 procedure #(1 1 0 type setting) #(695 0 0 0) ())
Return @code{#t} if event @var{type} (@pxref{event-type enums})
is recognized and queued, or @code{#f} if it is ignored.
If @var{setting} is specified, set the handling of
@var{type} to the truth value of @var{setting} first.
(446 7 procedure #(2 0 0 type state) #(718 0 0 0) ())
NB: This procedure is obsoleted by @code{event-type-handling}
and @strong{will be removed} after 2013-12-31.

Set or query the state of event @var{type} (@pxref{event-type enums})
processing, based on @var{state} (@pxref{event-state enums}).
If @var{state} is @code{SDL_QUERY}, return the current state.
If it is @code{SDL_IGNORE} or @code{SDL_ENABLE},
disable or enable, respectively, internal event @var{type}
processing and return @var{state}.
(173 7 procedure #(0 1 0 enable-p) #(737 0 0 0) ())
Return @code{#t} iff UNICODE keyboard translation is enabled.
Optional arg @var{enable?} if non-@code{#f}, enables UNICODE
keyboard translation, or disables it if @code{#f}.
(286 7 procedure #(2 0 0 delay interval) #(760 0 0 0) ())
Enable or disable keyboard repeat.
@var{delay} is the initial delay in ms between the time
when a key is pressed, and keyboard repeat begins.
@var{interval} is the time in ms between keyboard repeat
events.  If @var{delay} is 0, keyboard repeat is disabled.
Return @code{#t} on success.
(53 7 procedure #(0 0 0) #(776 0 0 0) ())
Return a list of pressed keys (@pxref{keysym enums}).
(59 7 procedure #(0 0 0) #(797 0 0 0) ())
Return the current key modifier state as a list of symbols.
(143 7 procedure #(1 0 0 modstate) #(810 0 0 0) ())
Set the current key modifier state to @var{modstate},
a list of symbols.  This does not change the keyboard state,
only the key modifier flags.
(447 7 procedure #(0 1 0 symbolic) #(863 0 0 0) ())
NB: This procedure is obsoleted by @code{mouse-bxy}
and @strong{will be removed} after 2013-12-31.

Return the current state of the mouse as an alist with
symbolic keys: @code{state}, @code{x} and @code{y}.
Normally, all values are integers.
However, if optional arg @var{symbolic} is non-@code{#f},
the @code{state} value is instead a (possibly empty)
list of symbols of the set:

@example
left middle right
wheel-up wheel-down
x1 x2
@end example
(294 7 procedure #(0 1 0 symbolic) #(880 0 0 0) ())
NB: This procedure is obsoleted by @code{mouse-bxy}
and @strong{will be removed} after 2013-12-31.

Return the current relative state of the mouse as an alist
with symbolic keys: @code{state}, @code{x} and @code{y}.
Optional arg @var{symbolic} has the same effect as
for @code{get-mouse-state}.
(478 7 procedure #(1 0 0 mask) #(910 0 0 0) ())
Return @code{#t} if buttons specified in @var{mask} are pressed,
otherwise @code{#f}.
@var{mask} is a symbol or a list of symbols from the set returned
by @code{get-mouse-state}.

For backward compatability, @var{mask} can also be the (integer)
logior of the buttons, using mapping:

@example
 1  left
 2  middle
 4  right
 8  wheel-up
16  wheel-down
32  x1
64  x2
@end example

For example, a value of 5 specifies both left and right buttons,
equivalent to @code{(left right)}.
(330 7 procedure #(0 1 0 relative) #(941 0 0 0) ())
Return three values: a (possibly empty) list of symbols
representing pressed mouse buttons (like @code{event:button:button}),
and two integer coordinates @var{x} and @var{y}.

Optional arg @code{relative} non-@code{#f} means the
coordinates are relative to the last time the underlying
@code{SDL_GetRelativeMouseState} was called.
(123 7 procedure #(0 0 0) #(965 0 0 0) ())
Return the current state of the application, a list of symbols.
The list may include: `mousefocus', `inputfocus', `active'.
(62 8 procedure #(2 0 0 stash symbol) #(281 0 0 0) ())
Return the number in @var{stash} associated with @var{symbol}.
(98 8 procedure #(2 0 0 stash number) #(298 0 0 0) ())
Return the symbol associated with @var{number}, or @code{#f}
if it does not belong to @var{stash}.
(214 8 procedure #(2 0 0 stash flags) #(508 0 0 0) ())
Use @var{stash} to convert @var{flags} to a number.
@var{flags} is a list of symbols;
or @code{#f}, which is taken as the empty list;
or @code{#t}, which is taken as the list of all
possible symbols in @var{stash}.
(188 8 procedure #(2 0 0 stash number) #(524 0 0 0) ())
Use @var{stash} to convert @var{number} to a list of symbols.
If the flags in @var{stash} are not sufficient to decode
@var{number}, the first element of the list is the numeric
remainder.
(370 8 procedure #(0 1 0 name) #(566 0 0 0) ())
Return the contents of stash @var{name} (a symbol), as
an alist with symbolic keys, integer values.
If @var{name} is omitted, the keys are the names of the all
the enum- and flagstashes, and the values have the form:

@example
(N TYPE)
@end example

@noindent
where @var{n} is the count of symbols in that stash,
and @var{type} is a symbol: @code{enums} or @code{flags}.
(422 9 procedure #(0 0 0) #(38 0 0 0) ())
Return information on the window manager, as a list of the
form: (VERSION SUBSYSTEM DISPLAY WINDOW FSWINDOW WMWINDOW).
VERSION is a sub-list of form: (MAJOR MINOR PATCH), where
element is an integer.  SUBSYSTEM is either the symbol
@code{x11}, or @code{#f}.  DISPLAY is a pointer (machine address)
of the X11 Display structure, converted to an integer.
WINDOW, FSWINDOW and WMWINDOW are Window identifiers (also
integers).
