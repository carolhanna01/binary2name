<html lang="en">
<head>
<title>GNU Gengen 1.4</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Gengen 1.4">
<meta name="generator" content="makeinfo 4.11">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual is for GNU Gengen
(version 1.4, 15 August 2009).
GNU Gengen (GENerator GENerator), a tool to generate a
C++ class (or C functions) for generating text, based on a template file
with parameters, after substituting some parameters.  This can be used
in code generators.

Copyright (C) 2002-2007 Lorenzo Bettini.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being "A GNU Manual," and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">GNU Gengen 1.4</h1>
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">GNU Gengen</a>
<li><a name="toc_Audience" href="#Audience">Audience</a>
<li><a name="toc_Copying" href="#Copying">GNU Gengen Copying Conditions</a>
<li><a name="toc_Installation" href="#Installation">1 Installation</a>
<ul>
<li><a href="#Installation">1.1 Download</a>
<li><a href="#Installation">1.2 Anonymous CVS Access</a>
<li><a href="#Installation">1.3 What you need to build gengen</a>
<li><a href="#Installation">1.4 Patching from a previous version</a>
</li></ul>
<li><a name="toc_The-Problem" href="#The-Problem">2 Generating code or text from within a program</a>
<li><a name="toc_The-Solution" href="#The-Solution">3 How Gengen Can Help You</a>
<li><a name="toc_Basic-Usage-in-C-and-C_002b_002b" href="#Basic-Usage-in-C-and-C_002b_002b">4 Basic Usage in C and C++</a>
<ul>
<li><a href="#Callbacks">4.1 Callbacks</a>
<li><a href="#Types">4.2 Types</a>
</li></ul>
<li><a name="toc_Conditionals" href="#Conditionals">5 Conditional statements</a>
<ul>
<li><a href="#Expression-syntax">5.1 Expression syntax</a>
</li></ul>
<li><a name="toc_Command-Options" href="#Command-Options">6 Command line options</a>
<li><a name="toc_Bugs" href="#Bugs">7 Known Bugs, Limitations, and other Misfeatures</a>
<li><a name="toc_Mailing-Lists" href="#Mailing-Lists">8 Mailing Lists</a>
<li><a name="toc_Index" href="#Index">Index</a>
</li></ul>
</div>



<div class="node">
<p><hr>
<a name="Top"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Audience">Audience</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">GNU Gengen</h2>

<p>This manual is for GNU Gengen
(version 1.4, 15 August 2009). 
GNU Gengen (GENerator GENerator), a tool to generate a
C++ class (or C functions) for generating text, based on a template file
with parameters, after substituting some parameters.  This can be used
in code generators.

   <p>Copyright &copy; 2002&ndash;2007 Lorenzo Bettini.

   <blockquote>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being &ldquo;A GNU Manual,&rdquo;
and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled &ldquo;GNU Free Documentation
License.&rdquo;

        <p>(a) The FSF's Back-Cover Text is: &ldquo;You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.&rdquo;
</blockquote>

<ul class="menu">
<li><a accesskey="1" href="#Audience">Audience</a>:                     Who this manual is for. 
<li><a accesskey="2" href="#Copying">Copying</a>:                      Your rights. 
<li><a accesskey="3" href="#Installation">Installation</a>
<li><a accesskey="4" href="#The-Problem">The Problem</a>:                  Generating code may become a pain in the neck. 
<li><a accesskey="5" href="#The-Solution">The Solution</a>:                 Let a tool generate the generator for you. 
<li><a accesskey="6" href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a>:     How to run GNU Gengen with C and C++
<li><a accesskey="7" href="#Conditionals">Conditionals</a>:                 Conditional statements
<li><a accesskey="8" href="#Command-Options">Command Options</a>:              Command line options. 
<li><a accesskey="9" href="#Bugs">Bugs</a>:                         What is lame and/or buggy in GNU Gengen 1.4
<li><a href="#Mailing-Lists">Mailing Lists</a>
<li><a href="#Index">Index</a>:                        Index. 
</ul>

<div class="node">
<p><hr>
<a name="Audience"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Copying">Copying</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Audience</h2>

<p><a name="index-Audience-1"></a><a name="index-Who-should-use-Gengen-2"></a>
GNU Gengen (<em>GENerator GENerator</em>) is a tool that, starting from a
parameterized text, called <em>template</em>, generates a text generator
that can substitute parameters with values.

   <p>This manual is written for C++ and C programmers, specifically the
<em>lazy</em> ones ;-).  If you've written any non-trivial code generator,
you probably had to write many <code>cout &lt;&lt;</code> or <code>printf</code> lines of
code, mixing fixed text to be generated and parts based on the value of
some variables.   If the text to be generated is full of parts that have
to be substituted at run-time, your code will end up containing many
instructions that print constant strings and variables; this will tend
to make the text to be generated unclear and thus also more difficult to
maintain.   Gengen can save you from this work, leaving you free to
focus on the text that has to be generated.

   <p><a name="index-parameter-3"></a><a name="index-variable-4"></a>Indeed the code to be generated will be written in a separated file
(that we call <em>template</em> file) that can contain variable parts
(that we call <em>parameters</em> or <em>variables</em>); Gengen will
generate the generator for you and this generator will also accept the
values that will be substituted in the output.

   <p>I started to develop Gengen while maintaining <em>GNU
Gengetopt</em><a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>, since
I had to generate a big amount of code and I found it quite hard to
write code to generate it, since the program ended up being full of many
printf!  That code was unclear and quite hard to maintain.

   <p>At the moment Gengen generates C++ or C code; however other target
languages are under development (e.g., Java).

   <p>NOTICE: Gengen uses code generated by Gengen itself :-)

<div class="node">
<p><hr>
<a name="Copying"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installation">Installation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Audience">Audience</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">GNU Gengen Copying Conditions</h2>

<p><a name="index-Copying-conditions-5"></a><a name="index-Conditions-for-copying-GNU-Gengen-6"></a>
GNU Gengen is free software; you are free to use, share and modify it
under the terms of the GNU General Public License that accompanies this
manual.

   <p>The code that Gengen generates is also free software; however it is
licensed with a simple all-permissive license instead of the GPL or
LGPL.  You are free to do anything you like with the generated code,
including incorporating it into or linking it with proprietary software.

<div class="node">
<p><hr>
<a name="Installation"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-Problem">The Problem</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Copying">Copying</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Installation</h2>

<p><a name="index-installation-7"></a><a name="index-download-8"></a>
See the file <samp><span class="file">INSTALL</span></samp> for detailed building and  installation
instructions; anyway if you're used to compiling Linux software that
comes with sources you may simply follow the usual procedure, i.e. untar
the file you downloaded in a directory and then:

<pre class="example">     cd &lt;source code main directory&gt;
     ./configure
     make
     make install
</pre>
   <p>Note: unless you specify a different install directory by
<code>--prefix</code> option of
configure (e.g. <code>./configure --prefix=&lt;your home&gt;</code>),
you must be root to run <code>make install</code>.

   <p>Files will be installed in the following directories:

     <dl>
<dt><code>executables</code><dd>        <code>/prefix/bin</code>
<br><dt><code>docs</code><dd>        <code>/prefix/share/doc/gengen</code>
<br><dt><code>examples</code><dd>        <code>/prefix/share/doc/gengen/examples</code>
<br><dt><code>additional files</code><dd>        <code>/prefix/share/gengen</code>
</dl>

   <p>Default value for prefix is <code>/usr/local</code>
but you may change it with <code>--prefix</code>
option to configure.

<h3 class="section">1.1 Download</h3>

<p><a name="index-download-9"></a>
You can download it from GNU's ftp site:
<a href="ftp://ftp.gnu.org/gnu/gengen">ftp://ftp.gnu.org/gnu/gengen</a> or from one of its mirrors (see
<a href="http://www.gnu.org/prep/ftp.html">http://www.gnu.org/prep/ftp.html</a>).

   <p>I do not distribute Windows binaries anymore; since, they can be easily
built by using Cygnus C/C++ compiler, available at
<a href="http://www.cygwin.com">http://www.cygwin.com</a>.  However, if you don't feel like
downloading such compiler, you can request such binaries directly to me,
by e-mail (find my e-mail at my home page) and I can send them to you.

   <p>Archives are digitally signed by me (Lorenzo Bettini) with GNU gpg
(<a href="http://www.gnupg.org">http://www.gnupg.org</a>). My GPG public key can be found at my home
page (<a href="http://www.lorenzobettini.it">http://www.lorenzobettini.it</a>).

   <p>You can also get the patches, if they are available for a particular
release (see below for patching from a previous version).

<h3 class="section">1.2 Anonymous CVS Access</h3>

<p><a name="index-CVS-10"></a>
This project's CVS repository can be checked out through anonymous
(pserver) CVS with the following instruction:

<pre class="example">     cvs -z3 -d:pserver:anonymous@cvs.savannah.gnu.org:/sources/gengen co gengen
</pre>
   <p>Further instructions can be found at the address:

   <p><a href="http://savannah.gnu.org/projects/gengen">http://savannah.gnu.org/projects/gengen</a>.

   <p>Please notice that this way you will get the latest development sources
of Gengen, which may also be unstable.  This solution is the
best if you intend to correct/extend this program: you should send me
patches against the latest cvs repository sources.

   <p>If, on the contrary, you want to get the sources of a given release,
through cvs, say, e.g., version X.Y.Z, you must specify the tag
<code>rel_X_Y_Z</code> when you run the cvs command or the <code>cvs update</code>
command.

   <p>When you compile the sources that you get through the cvs repository,
before running the <code>configure</code> and <code>make</code> commands, you
should, at least the first time, run the command:

<pre class="example">     sh autogen.sh
</pre>
   <p class="noindent">This will run the autotools commands in the correct order, and also copy
possibly missing files.  You should have installed recent versions of
<a name="index-automake-11"></a><a name="index-autoconf-12"></a><code>automake</code> and <code>autoconf</code> in order for this to succeed. 
You will also need <code>flex</code> and <code>bison</code>.

   <p>Instead of running <code>autogen.sh</code> another option is to run

<pre class="example">     autoreconf -i
</pre>
   <h3 class="section">1.3 What you need to build gengen</h3>

<p><a name="index-requirements-13"></a>
Gengen has been developed under GNU/Linux, using gcc (C++),
and bison (yacc) and flex (lex), and ported under Win32 with Cygnus
C/C++compiler, available at <a href="http://www.cygwin.com">http://www.cygwin.com</a>.  I used the
excellent GNU Autoconf and GNU Automake.  I also used Autotools
(<a href="ftp://ftp.ugcs.caltech.edu/pub/elef/autotools">ftp://ftp.ugcs.caltech.edu/pub/elef/autotools</a>) which creates a
starting source tree (according to GNU standards) with autoconf,
automake starting files.

   <p>Finally I used <em>GNU gengetopt</em>
(<a href="http://www.gnu.org/software/gengetopt">http://www.gnu.org/software/gengetopt</a>), for command line parsing.

   <p>Actually, you don't need all these tools above to build gengen
because I provide generated sources, unless you want to develop
gengen.

<h3 class="section">1.4 Patching from a previous version</h3>

<p><a name="index-patching-14"></a>
If you downloaded a patch, say
<samp><span class="file">gengen-1.3-1.3.1-patch.gz</span></samp> (i.e., the patch to go from version
1.3 to version 1.3.1), cd to the directory with sources from the
previous version (gengen-1.3) and type:

<pre class="example">     gunzip -cd ../gengen-1.3-1.3.1.patch.gz | patch -p1
</pre>
   <p>and restart the compilation process (if you had already run configure a
simple make should do).

<div class="node">
<p><hr>
<a name="The-Problem"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-Solution">The Solution</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installation">Installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Generating code or text from within a program</h2>

<p><a name="index-Generating-code-with-substitutions-15"></a><a name="index-parameter-16"></a><a name="index-template-17"></a><a name="index-cc-18"></a>
Say you are writing a C/C++ program and at some point your program
has to generate the following code:

<pre class="example">     if (i &lt; 10)
       printf("the value of i is %d", i);
</pre>
   <p class="noindent">It is not so difficult to write this piece of C++ code:

<pre class="example">     cout &lt;&lt; "if (i &lt; 10)" &lt;&lt; endl;
     cout &lt;&lt; "  printf(\"the value of i is %d\", i);" &lt;&lt; endl;
</pre>
   <p class="noindent">or the C code:

<pre class="example">     printf("if (i &lt; 10)\n");
     printf("  printf(\"the value of i is %%d\", i);\n");
</pre>
   <p class="noindent">provided that you remember to escape the <code>"</code> (and in the
C code, also the <code>%</code>).

   <p>Suppose now that the previous piece of code has to be generated many
times by your program, and every time instead of <code>i</code> another
symbol has to be generated (decided at run time).  In this case,
supposing that this value is contained in a variable <code>symb</code>,
the code for generating this code would be a little bit more
complex:

<pre class="example">     cout &lt;&lt; "if (" &lt;&lt; symb &lt;&lt; "&lt; 10)" &lt;&lt; endl;
     cout &lt;&lt; "  printf(\"the value of " &lt;&lt; symb &lt;&lt; " is %d\", "
          &lt;&lt; symb &lt;&lt; ");" &lt;&lt; endl;
</pre>
   <p class="noindent">And the C version would be even more obfuscated.

   <p>Probably you didn't even realize that you forgot to leave
a space before the <code>&lt; 10</code>; basically this is due to the fact
that this piece of code mixes the code that has to be generated
with the code that generates it, and this tends to make this part
of program less easy to maintain.  Especially if some day you
have to change the code that has to be generated, you'll have
to act on this part of the program, and probably you'll have to
execute some tests in order to be sure that you did it right.

   <p>If the code that you have to generate is a slightly more complex,
the task may easily become a pain in the neck!

<div class="node">
<p><hr>
<a name="The-Solution"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Problem">The Problem</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 How Gengen Can Help You</h2>

<p><a name="index-Overview-of-GNU-Gengen-19"></a><a name="index-parameter-20"></a><a name="index-gengen-21"></a><a name="index-cc-22"></a>
Wouldn't it be nice if you could write the code to be generated in a
separate file, let's call it <em>template</em>, say <samp><span class="file">test1.cc_skel</span></samp>
this way

<!-- Generator: GNU source-highlight, by Lorenzo Bettini, http://www.gnu.org/software/src-highlite -->
<pre class="example">     if (@i@ &lt; 10)
       printf("the value of @i@ is %d", @i@);
</pre>
   <p class="noindent">and have a tool that generates a generator, that you
can instantiate at run-time with the value that has to be substituted to
the <em>parameter</em> <code>i</code>?  If such a tool existed, and it generated
a file <samp><span class="file">test1_c.h</span></samp> with a C struct <code>test1_gen_struct</code>, then
you could write simply this code, in another file, say
<samp><span class="file">test1_gen_c.c</span></samp>:

<!-- Generator: GNU source-highlight, by Lorenzo Bettini, http://www.gnu.org/software/src-highlite -->
<pre class="example">     <b>#include</b> <tt>&lt;stdio.h&gt;</tt>
     
     <b>#include</b> <tt>"test1_c.h"</tt>
     
     <b>int</b>
     main()
     {
       <b>struct</b> test1_gen_struct gen_struct;
       gen_struct.i = <tt>"foo"</tt>;
       generate_test1(stdout, &amp;gen_struct, 0);
       printf(<tt>"</tt>\n<tt>"</tt>);
       gen_struct.i = <tt>"bar"</tt>;
       generate_test1(stdout, &amp;gen_struct, 0);
       printf(<tt>"</tt>\n<tt>"</tt>);
     
       <b>return</b> 0;
     }
     
</pre>
   <p>Alternatively, if it generated a file <samp><span class="file">test1.h</span></samp> with a C++ class
<code>test1_gen_class</code>, then you could write simply this code, in
another file, say <samp><span class="file">test1_gen.cc</span></samp>:

<!-- Generator: GNU source-highlight, by Lorenzo Bettini, http://www.gnu.org/software/src-highlite -->
<pre class="example">     <b>#include</b> <tt>&lt;iostream&gt;</tt>
     
     <b>using</b> std::cout;
     <b>using</b> std::endl;
     
     <b>#include</b> <tt>"test1.h"</tt>
     
     <b>int</b>
     main()
     {
       test1_gen_class gen_class;
       gen_class.set_i(<tt>"foo"</tt>);
       gen_class.generate_test1(cout);
       cout &lt;&lt; endl;
       gen_class.set_i(<tt>"bar"</tt>);
       gen_class.generate_test1(cout);
       cout &lt;&lt; endl;
     
       <b>return</b> 0;
     }
     
</pre>
   <p class="noindent">and when you run it you would obtain the expected output:

<pre class="example">     if (foo &lt; 10)
       printf("the value of foo is %d", foo);
     if (bar &lt; 10)
       printf("the value of bar is %d", bar);
</pre>
   <p class="noindent">Well, Gengen does right this!  Now the code that has to
be generated and the code that generates it are separated and they can
be maintained more easily: if you want to change the code that has to be
generated you act on the file <samp><span class="file">test1.cc_skel</span></samp>; alternatively, say
you need to change the value that will be substituted for <code>i</code>, you
just change the file <samp><span class="file">test1_gen.cc</span></samp> or <samp><span class="file">test1_gen_c.c</span></samp>.

   <p>Notice that the method <code>generate_test1</code> accepts an output stream
(indeed in this example the standard output stream <code>cout</code> is used),
thus the stream abstraction facilities can be exploited.  Similarly, the
C function <code>generate_test1</code> accepts a <code>FILE*</code>, so you can use
the C file abstraction.

   <p>Indeed in order to generate the C++ file <samp><span class="file">test1.h</span></samp> with the class
<code>test1_gen_class</code>, I simply had to run the following command:

<pre class="example">     gengen -i test1.cc_skel --file-name test1.h --gen-name test1
</pre>
   <p class="noindent">and in order to generate the C file <samp><span class="file">test1_c.h</span></samp> with the structure
<code>test1_gen_struct</code>, I simply had to run the following command:

<pre class="example">     gengen -i test1.cc_skel --file-name test1_c.h --gen-name test1 \
             --output-format=c
</pre>
   <p class="noindent">If I caught your attention and you would like to know
more about these options and more advanced features of Gengen, I
hope you read on :-)

<div class="node">
<p><hr>
<a name="Basic-Usage-in-C-and-C++"></a>
<a name="Basic-Usage-in-C-and-C_002b_002b"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Conditionals">Conditionals</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Solution">The Solution</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Basic Usage in C and C++</h2>

<p><a name="index-how-to-use-Gengen-23"></a><a name="index-getting-started-with-Gengen-24"></a><a name="index-template-25"></a><a name="index-parameter-26"></a><a name="index-type-27"></a><a name="index-iteration-28"></a>
We've run Gengen, and used it to produce a really spiffy, if rather
pointless, program.  Now we'll go back and look at things in
more detail.

   <p><a name="index-parameter-29"></a><a name="index-variable-30"></a>The input file for Gengen is basically any text file, where some parts
are interpreted differently, namely symbols enclosed in <code>@</code>.   We
call this input file a <em>template</em> and the symbols enclosed in
<code>@</code> <em>parameters</em> (or <em>variables</em>):

<pre class="example">     This is @name@ generated by the program @progname@.
     The code of @progname@ that generated this text was
     generated by @generator@ version @version@, made by
     Lorenzo Bettini &lt;foobar@@foo.org&gt;.
</pre>
   <p class="noindent">First all notice that, since <code>@</code> is a special
character, if you really want it to appear in the generated text you
have to repeated, as in the e-mail address <code>foobar@@foo.org</code>.

   <p>If this text is stored in the file <samp><span class="file">example_text.text_skel</span></samp> and I
process it with the following command:

<pre class="example">     gengen -i example_text.text_skel
       --file-name example_text_c.h --gen-name example_text
       --output_format=c
</pre>
   <p class="noindent">the struct <code>example_text_gen_struct</code> (option
<code>--gen-name example_text</code>) will be generated in the file
<samp><span class="file">example_text_c.h</span></samp> (option <code>--file-name example_text_c.h</code>). 
This struct will have a field for each single parameter, with the same
name of the parameter and type <code>const char *</code>.   For in instance in
this example it will contain the fields <code>name</code>, <code>progname</code>,
<code>generator</code> and <code>version</code>.   These can be used to set the
string that will be substituted at run-time for the corresponding name
in the input file (Notice that otherwise the empty string is assumed).

   <p>Notice that the fields of the structure are not initialized (i.e., they
contain random values) thus we suggest to always initialize the
structure with the following generated function:

<pre class="example">     void
     init_example_text_gen_struct(struct example_text_gen_struct *record);
</pre>
   <p>Once these values are set, the function

<pre class="example">     void generate_example_text(FILE *stream,
             example_text_gen_struct *record, unsigned int indent)
</pre>
   <p class="noindent">can be called in order to generate the text with
substitutions (using the values of the passed struct) into the stream
<code>stream</code>.  The parameter <code>indent</code> is useful to specify an
indentation in the generated text.

   <p>Alternatively, one can use the following function (even with a non
initiliazed struct) specifying the values for each field (notice the
<code>p</code> after <code>generate</code>):

<pre class="example">     void
     generatep_example_text(FILE *stream, unsigned int indent,
             const char *generator, const char *name, const char *progname,
             const char *version);
</pre>
   <p>The following example uses the generated struct in order to
generate the text twice; the second time, the name of the
parameter <code>name</code> is changed, and the indentation is set to
2<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>:

<!-- Generator: GNU source-highlight, by Lorenzo Bettini, http://www.gnu.org/software/src-highlite -->
<pre class="example">     <b>#include</b> <tt>&lt;stdio.h&gt;</tt>
     <b>#include</b> <tt>"example_text_c.h"</tt>
     
     <b>int</b>
     main()
     {
       <b>struct</b> example_text_gen_struct gen_struct;
       init_example_text_gen_struct(&amp;gen_struct);
       gen_struct.name = <tt>"an example"</tt>;
       gen_struct.progname = <tt>"example_text_gen"</tt>;
       gen_struct.generator = <tt>"Gengen"</tt>;
       gen_struct.version = <tt>"1.0"</tt>;
     
       generate_example_text(stdout, &amp;gen_struct, 0);
       printf(<tt>"</tt>\n<tt>"</tt>);
     
       printf(<tt>"</tt>\n<tt>"</tt>);
       gen_struct.name = <tt>"another example"</tt>;
       printf(<tt>"  "</tt>);
       generate_example_text(stdout, &amp;gen_struct, 2);
       printf(<tt>"</tt>\n<tt>"</tt>);
     
       <b>return</b> 0;
     }
     
</pre>
   <p class="noindent">The output of this program will be as expected:

<pre class="example">     This is an example generated by the program example_text_gen.
     The code of example_text_gen that generated this text was
     generated by Gengen version 1.0, made by
     Lorenzo Bettini &lt;foobar@foo.org&gt;.
     
       This is another example generated by the program example_text_gen.
       The code of example_text_gen that generated this text was
       generated by Gengen version 1.0, made by
       Lorenzo Bettini &lt;foobar@foo.org&gt;.
</pre>
   <p>Now, since C lacks the (wonderful :-) stream abstraction that permits
creating a stream that writes into a string (such as the
<code>ostringstream</code>),  two additional functions are provided in the
generated file, that return a (<code>malloc</code>ed) string instead of
generating the output to a file (they correspond to the two generate
functions seen above):

<pre class="example">     char *
     genstring_example_text(struct example_text_gen_struct *record,
             unsigned int indent);
     
     char *
     genstringp_example_text(unsigned int indent,
             const char *generator, const char *name, const char *progname,
             const char *version);
</pre>
   <p class="noindent">Remember: it is up to you to <code>free</code> these strings when
you don't need them anymore.

   <p>If you prefer to program in C++ you  process the file
<samp><span class="file">example_text.text_skel</span></samp> with the following command<a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a>:

<pre class="example">     gengen -i example_text.text_skel
       --file-name example_text.h --gen-name example_text
</pre>
   <p class="noindent">the class <code>example_text_gen_class</code> (option
<code>--gen-name example_text</code>) will be generated in the file
<samp><span class="file">example_text.h</span></samp> (option <code>--file-name example_text.h</code>).   This
class will have a member for each single parameter, with the same name
of the parameter and type <code>string</code>.   This class will also contain
a method <code>set_&lt;xxx&gt;</code> for each distinct <code>@xxx@</code> present in
the input file; for in instance in this example it will contain the
methods <code>set_name</code>, <code>set_progname</code>, <code>set_generator</code> and
<code>set_version</code>.   These methods get a <code>const string &amp;</code> as
parameter.   These can be used to set the string that will be
substituted at run-time for the corresponding name in the input file
(otherwise the empty string is assumed).

   <p>Notice that in C++ there's no need to call any initialization function,
since the fields in the class are automatically initialized (as empty
strings) by the constructor.  Morever, there is no version that
generates a string, as in C, since you can use the class
<code>ostringstream</code>.

   <p>Once these values are set, the method

<pre class="example">     void generate_example_text(ostream &amp;stream, unsigned int indent = 0)
</pre>
   <p class="noindent">can be called in order to generate the text with
substitutions into the stream <code>stream</code>.  The parameter
<code>indent</code> (default = 0) is useful to specify an indentation
in the generated text.

   <p>The following example uses the generated class in order to
generate the text twice; the second time, the name of the
parameter <code>name</code> is changed, and the indentation is set to
2<a rel="footnote" href="#fn-4" name="fnd-4"><sup>4</sup></a>:

<!-- Generator: GNU source-highlight, by Lorenzo Bettini, http://www.gnu.org/software/src-highlite -->
<pre class="example">     <b>#include</b> <tt>&lt;iostream&gt;</tt>
     <b>#include</b> <tt>"example_text.h"</tt>
     
     <b>using</b> std::cout;
     <b>using</b> std::endl;
     
     <b>int</b>
     main()
     {
       example_text_gen_class gen_class;
       gen_class.set_name(<tt>"an example"</tt>);
       gen_class.set_progname(<tt>"example_text_gen"</tt>);
       gen_class.set_generator(<tt>"Gengen"</tt>);
       gen_class.set_version(<tt>"1.0"</tt>);
     
       gen_class.generate_example_text(cout);
       cout &lt;&lt; endl;
     
       cout &lt;&lt; endl;
       gen_class.set_name(<tt>"another example"</tt>);
       cout &lt;&lt; <tt>"  "</tt>;
       gen_class.generate_example_text(cout, 2);
       cout &lt;&lt; endl;
     
       <b>return</b> 0;
     }
     
</pre>
   <p class="noindent">The output of this program will be as before.

   <p>This is already a useful feature of Gengen (at least that's what I think
;-).  However if the text to be generated requires some more
preprocessing, substituting only strings may not be enough.  Instead you
may want the generator to invoke a call back method when it comes to
generate a specific symbol.  This will be explained in the following
section.

<ul class="menu">
<li><a accesskey="1" href="#Callbacks">Callbacks</a>
<li><a accesskey="2" href="#Types">Types</a>
</ul>

<div class="node">
<p><hr>
<a name="Callbacks"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Types">Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a>

</div>

<h3 class="section">4.1 Callbacks</h3>

<p>You may want the generator to invoke a call back method when it comes to
generate a specific symbol, instead of relying only on strings.  This
can be achieved by specifying the <em>type</em> <code>method</code> for a
parameter.  Let me clarify this with an example.

   <p>Say that your program has to generate some functions, and you,
obviously, want all these functions to have the same definition style;
then you can create a template file <samp><span class="file">example_fundef.cc_skel</span></samp>:

<!-- Generator: GNU source-highlight, by Lorenzo Bettini, http://www.gnu.org/software/src-highlite -->
<pre class="example">     @rettype@
     @funname@(@paramtype@ @param@)
     {
       @funbody:method@
     }
</pre>
   <p class="noindent">and once again process it with the command

<pre class="example">     gengen -i example_fundef.cc_skel --file-name example_fundef.h
       --gen-name example_fundef
</pre>
   <p class="noindent">Then the generated class <code>example_fundef_gen_class</code>
will  contain  the set-methods <code>set_rettype</code>,   <code>set_funname</code>,
<code>set_paramtype</code>     and     <code>set_param</code>,   and     a    method
<code>set_funbody</code>,  but  it will  also   declare the following abstract
method:

<pre class="example">     virtual void
       generate_funbody(ostream &amp;stream, unsigned int indent) = 0;
</pre>
   <p>Thus, this class cannot be directly instantiated; instead you can derive
from this class and provide the implementation of such method, knowing
that this method will be called right when it comes to generate that
part of code, in case the variable <code>funbody</code> has not already been
set via the method <code>set_funbody</code> (indeed the virtual method is
called if <code>funbody</code> is an empty string).  Here's an example that
extends this class and uses the previous class <code>test1_gen_class</code> to
generate the function body (file <samp><span class="file">example_fundef_gen.cc</span></samp>):

<!-- Generator: GNU source-highlight, by Lorenzo Bettini, http://www.gnu.org/software/src-highlite -->
<pre class="example">     <b>#include</b> <tt>&lt;iostream&gt;</tt>
     <b>#include</b> <tt>"test1.h"</tt>
     <b>#include</b> <tt>"example_fundef.h"</tt>
     
     <b>using</b> std::cout;
     <b>using</b> std::endl;
     
     <b>class</b> my_fundef_gen : <b>public</b> example_fundef_gen_class
     {
      <b>public</b>:
       <b>virtual</b> <b>void</b> generate_funbody(ostream &amp;stream, <b>unsigned</b> <b>int</b> indent) {
         test1_gen_class body_gen;
         body_gen.set_i (param);
         body_gen.generate_test1 (stream, indent);
       }
     };
     
     <b>int</b>
     main()
     {
       my_fundef_gen fun_gen;
       fun_gen.set_rettype (<tt>"void"</tt>);
       fun_gen.set_funname (<tt>"foo_fun"</tt>);
       fun_gen.set_paramtype (<tt>"unsigned int"</tt>);
       fun_gen.set_param (<tt>"bar"</tt>);
     
       fun_gen.generate_example_fundef (std::cout);
       cout &lt;&lt; endl;
     
       <b>return</b> (0);
     }
     
</pre>
   <p class="noindent">Notice that the parameter <code>i</code> of <code>test1_gen_class</code>
is set to the same name of the inherited field <code>param</code>: this will
guarantee consistency in the generated code (the code will be
compilable) and the generated function body will use the parameter of
the function definition.  Moreover when the method <code>generate_test1</code>
is invoked, both the <code>stream</code> and <code>indent</code> parameters are
passed over, so that they will be used also by the other generator.

   <p>The generated code is once again as expected:

<pre class="example">     void
     foo_fun(unsigned int bar)
     {
       if (bar &lt; 10)
         printf("the value of bar is %d", bar);
     }
</pre>
   <p class="noindent">Notice how the indentation is handled automatically! 
Indeed the code generated by Gengen is able to keep track of the
indentation level according to the leading spaces in a line.

   <p>This scenario can take place in a code generator where you want to have
all the generated functions with the same style.  When you decide you
want to change the style you'll only have to change the file
<samp><span class="file">example_fundef.cc_skel</span></samp>, while the other parts of the programs
remain unchanged.

   <p>When a generated class contains at least an abstract method, a virtual
destructor is also generated (that basically performs no action) that is
useful if you have to destroy something allocated in the derived class.

   <p>The type <code>method</code> has also an <em>option</em>; an option is basically
a statement of the shape <code>&lt;name&gt;=&lt;value&gt;</code> and has to be specified
between brackets <code>{}</code>.   The option is <code>iteration</code>.  If one
specified <code>@funbody:method{iteration=true}@</code> then no space
would have been generated before invoking the call back method, and no
newline would have been generated after.  This could be useful when the
result of the call back method is either the empty string or a sequence
of similar items; this way if these are handled from within a loop (the
name &ldquo;iteration&rdquo; comes from this) they can be handled more easily and
uniformly (otherwise you would have to treat the first element and the
last one differently).

   <p>If you want to generate C code, you can process it with the command

<pre class="example">     gengen -i example_fundef.c_skel --file-name example_fundef.h
       --gen-name example_fundef --output-format c
</pre>
   <p class="noindent">This will generate the file <samp><span class="file">example_fundef.h</span></samp> containing the
following struct declaration:

<pre class="example">     struct example_fundef_gen_struct
     {
       const char *funbody;
       const char *funname;
       const char *param;
       const char *paramtype;
       const char *rettype;
     };
</pre>
   <p class="noindent">and some functions

<pre class="example">     void generate_example_fundef(FILE *stream,  struct
     example_fundef_gen_struct *record, unsigned int indent);
</pre>
   <p class="noindent">that, given an initialized struct, generates the output to
the file <code>stream</code>, and

<pre class="example">     void
     generatep_example_fundef(FILE *stream, unsigned int indent,
                              const char *funbody, const char *funname,
                              const char *param, const char *paramtype,
                              const char *rettype);
</pre>
   <p class="noindent">that does not require a struct, since it requires a value
for each parameter in the template file.

   <p>We suggest to use the following function in order to be sure that each
string in the struct is correctly initialized to <code>NULL</code>:

<pre class="example">     void
     init_example_fundef_gen_struct(struct example_fundef_gen_struct *r);
</pre>
   <p class="noindent">and two additional functions are provided in the
generated file, that return a (<code>malloc</code>ed) string instead of
generating the output to a file (they correspond to the two generate
functions seen above):

<pre class="example">     char *
     genstring_example_fundef(struct example_fundef_gen_struct *record,
                              unsigned int indent);
     
     char *
     genstringp_example_fundef(unsigned int indent,
                               const char *funbody, const char *funname,
                               const char *param, const char *paramtype,
                               const char *rettype);
</pre>
   <p class="noindent">Remember: it is up to you to <code>free</code> these strings when
you don't need them anymore.

   <p>As for the type <code>method</code>, instead of creating a pure virtual
method as in C++, an extern function declaration is generated:

<pre class="example">     extern
     void generate_funbody(FILE *stream,
                           struct example_fundef_gen_struct *record,
                           unsigned int indent);
</pre>
   <p class="noindent">but no code is generated for this function, so that
the programmer is required to provide a definition for this function
somewhere else in the program.   This (extern) function will be called
right when it comes to generate that part of code, in case the argument
<code>funbody</code> or the field <code>funbody</code> in the passed struct is
<code>NULL</code>.

   <p>When you use <code>@if@</code> conditionals (or <code>bool</code> parameters, see
<a href="#Types">Types</a>), the generated record fields are of type <code>short</code>, and
when you use <code>int</code> parameters the fields are of type <code>int</code>.

<ul class="menu">
<li><a accesskey="1" href="#Types">Types</a>:                        Parameter types
</ul>

<div class="node">
<p><hr>
<a name="Types"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Callbacks">Callbacks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a>

</div>

<h3 class="section">4.2 Types</h3>

<p>So far, we dealt only with parameters of type <code>method</code> or string
parameters.  Actually, unless explicitly stated, the type of parameter
is implicitly considered as <code>string</code> (and for conditional
expressions as <code>bool</code>, see <a href="#Conditionals">Conditionals</a>).  However, the type
of a parameter can be made explicit, just like we did with <code>method</code>
type.  In particular, currently, the following basic types are
available: <code>string</code>, <code>int</code> and <code>bool</code><a rel="footnote" href="#fn-5" name="fnd-5"><sup>5</sup></a>.

   <p>Since gengen does not provide variable declarations (to keep things
simple :-) you must always specify the type each time (just like for
<code>method</code> parameters), unless the type is not the default one.  Of
course, gengen will check that you use parameter types consistently,
i.e., always with the same type.

   <p>For instance, the following code is correct, since by default the type
of a parameter is of type string, thus the parameter <code>mypar</code> is
used consistently:

<pre class="example">     This is the value of the parameter @mypar@.
     And I repeat it here @mypar:string@.
</pre>
   <p class="noindent">While this example will generate an error, since the first time
<code>mypar</code> is (implicitly) of type <code>string</code>, while the second
time is of type <code>int</code>:

<pre class="example">     This is the value of the parameter @mypar@.
     And I repeat it here @mypar:int@.
</pre>
   <p class="noindent">For instance, if this file is called <samp><span class="file">foo.skel</span></samp>, gengen will issue
the following error:

<pre class="example">     foo.skel:2: variable "mypar" of type "int"
     foo.skel:2: already used with another type
     foo.skel:1: previous usage was here with type "string"
</pre>
   <p>Gengen will use the specified type to generate fields and methods of the
generated class accordintly, e.g., if a parameter is declared of type
<code>int</code> the generated set method will get an integer parameter.

   <p>When generating a parameter of type <code>int</code> the string representation
of the actual integer value will be output; while for <code>bool</code>
parameters the literal <code>true</code> or <code>false</code> will be output.

<div class="node">
<p><hr>
<a name="Conditionals"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Command-Options">Command Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Conditional statements</h2>

<p><a name="index-Conditional-statements-31"></a>
It is often useful to generate some parts only if specific conditions
are met, and other in the opposite case.  Inside the template file you
can also use the following syntax:

<pre class="example">     @if@ condvar1 @then@
     text1
     @elseif@ condvar2 @then@
     text2
     @elseif@ ... other alternatives...
     @else@
     text_else
     @endif@
</pre>
   <p class="noindent">that has the same semantics of if in programming languages you're used to,
and of course all the else parts are optional.  For every
<code>condvar</code> a boolean instance variable is added to the generated
class, and of course a corresponding set method receiving a boolean
argument.

   <p>It is important to notice a possible new line characters and spaces
after a <code>@then@</code>, <code>@else@</code> and <code>@endif@</code>, and
possible spaces before <code>@if@</code>, <code>@elseif@</code> and
<code>@else@</code> are NOT discarded during the generation of code.  Thus,
the following this code

<pre class="example">     @if@ c @then@   foo
     @else@   bar@endif@
</pre>
   <p class="noindent">will generate the following C++ code<a rel="footnote" href="#fn-6" name="fnd-6"><sup>6</sup></a>

<pre class="example">     if (c)
       {
         stream &lt;&lt; "   foo";
         stream &lt;&lt; "\n";
         stream &lt;&lt; indent_str;
       }
     else
       {
         stream &lt;&lt; "   bar";
       }
</pre>
   <p class="noindent">Notice that there are spaces before the generated
strings, as there were in the template file.

   <p>And the following code

<pre class="example">       @if@ c @then@
     foo
       @else@
     bar
     @endif@
</pre>
   <p class="noindent">will generate the following C++ code

<pre class="example">     stream &lt;&lt; "  ";
     if (c)
       {
         stream &lt;&lt; "\n";
         stream &lt;&lt; indent_str;
         stream &lt;&lt; "foo";
         stream &lt;&lt; "\n";
         stream &lt;&lt; indent_str;
         indent = 2;
         stream &lt;&lt; "  ";
       }
     else
       {
         stream &lt;&lt; "\n";
         stream &lt;&lt; indent_str;
         stream &lt;&lt; "bar";
         stream &lt;&lt; "\n";
         stream &lt;&lt; indent_str;
       }
</pre>
   <p class="noindent">Notice the two characters inserted before the
if test (that are generated independently from the evaluation of
<code>c</code>) and the new line before the then and else bodies.

   <p>If you're not confortable with this treatment of spaces and new lines in
conjunction with if statements, you can use the uppercase version of
these keywords, i.e., <code>IF</code>, <code>THEN</code>, etc.   When you use these
keywords, spaces and newlines are skipped.   For instance, the previous
example can be rewritten as follows:

<pre class="example">     @IF@ c @THEN@   foo
     @ELSE@   bar@ENDIF@
</pre>
   <p class="noindent">and the generated code will not contain the extra spaces:

<pre class="example">     if (c)
       {
         stream &lt;&lt; "foo";
         stream &lt;&lt; "\n";
         stream &lt;&lt; indent_str;
       }
     else
       {
         stream &lt;&lt; "bar";
       }
</pre>
   <p>Notice that the space &ldquo;eating&rdquo; stops at the first newline, thus, the
following code:

<pre class="example">     @IF@ c @THEN@
        foo
     @ELSE@
        bar
     @ENDIF@
</pre>
   <p class="noindent">will correctly consider the indentation in the
then and else bodies:

<pre class="example">     if (c)
       {
         stream &lt;&lt; "   foo";
         stream &lt;&lt; "\n";
         stream &lt;&lt; indent_str;
       }
     else
       {
         stream &lt;&lt; "   bar";
         stream &lt;&lt; "\n";
         stream &lt;&lt; indent_str;
       }
</pre>
   <p>Finally, you can mix uppercase and lowercase keywords in the same if
statement as you see fit.

   <p>Of course, you can nest if inside then branches, else branches, and so
on, just like you do in your programming language:

<pre class="example">     @if@ c1 @then@
     @if@ c2 @then@ foo2
     @elseif@ c3 @then@ foo3
     @endif@
     @else@   bar
     @if@ c4 @then@ foo4
     @endif@
     @endif@
</pre>
   <p class="noindent">Unfortunately, you cannot indent nested ifs.  Or better, you
can actually, but the indentation characters will be generated in the
code.  If you want to indent the nested ifs you have to use the
uppercase version.

   <p>While there is not the concept of &ldquo;variable declaration&rdquo; in the
template file, Gengen will check that you do use variables in a
consistent way (see <a href="#Types">Types</a>); thus you're not allowed to the same
name for a string variable and for the boolean expression of an if
statement (which is implicitly considered of type <code>bool</code>).   For
instance, the following code:

<pre class="example">     @foo@
     
     @if@ foo @then@ @else@ bar @endif@
</pre>
   <p class="noindent">will generate the following error:

<pre class="example">     test.h_skel:3: variable "foo" of type "bool"
     test.h_skel:3: already used with another type
     test.h_skel:1: previous usage was here with type "string"
</pre>
   <p class="noindent">On the contrary, this version will work fine, since <code>foo</code> is used
consistently:

<pre class="example">     @foo:bool@
     
     @if@ foo @then@ @else@ bar @endif@
</pre>
   <ul class="menu">
<li><a accesskey="1" href="#Expression-syntax">Expression syntax</a>:            boolean expression syntax
</ul>

<div class="node">
<p><hr>
<a name="Expression-syntax"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Conditionals">Conditionals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Conditionals">Conditionals</a>

</div>

<h3 class="section">5.1 Expression syntax</h3>

<p><a name="index-expression-syntax-32"></a>Since version 1.0, it is possible to specify complex conditional
expressions.  You then can use comparison operators <code>&lt;</code>, <code>&gt;</code>,
<code>&lt;=</code>, <code>&gt;=</code>, <code>=</code><a rel="footnote" href="#fn-7" name="fnd-7"><sup>7</sup></a> and <code>!=</code>, and boolean operators
<code>and</code>, <code>or</code> and <code>not</code>.

   <p>The precendence of these operators is the standard one, and, of course,
you're allowed to override the precedence by using parenthesis.

   <p>Gengen will perform type checking on the expressions (see <a href="#Types">Types</a>),
thus it will check that <code>and</code>, <code>or</code> and <code>not</code> are used
only on boolean expressions, and that when using the other operators,
the operands are of the same type.  Moreover, <code>&lt;</code>, <code>&gt;</code>,
<code>&lt;=</code>, <code>&gt;=</code> cannot be used on boolean expressions.  While they
can be used on string expressions, and in that case the standard
lexicographical order will be used for the comparison.

   <p>In expressions you can use constants of the basic types, and in this
case you must not specify the type: it will be automatically inferred.

   <p>Any numerical literal will be considered an integer constant; the
literals <code>true</code> and <code>false</code> will be considered boolean
constants; finally, string constants must be enclosed in <code>"</code>.

   <p>For instance, the following is a valid expression (notice that, since we
are in the context of an if expression, parameters are automatically
considered of type <code>bool</code>, thus string parameters must be
explicitly specified with type <code>string</code>):

<pre class="example">     @if@ (not foo) and (mystring:string &lt; "foo" or i:int &gt; j:int) @then@
     ...
</pre>
   <p class="noindent">Instead, the following one

<pre class="example">     @if@ (not foo) and (mystring &lt; "foo") @then@
     ...
</pre>
   <p class="noindent">will produce the following error:

<pre class="example">     test.h_skel:1: mystring and "foo" must have the same type
     test.h_skel:1: mystring has type bool, "foo" has type string
</pre>
   <div class="node">
<p><hr>
<a name="Command-Options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bugs">Bugs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Conditionals">Conditionals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Command line options</h2>

<p><a name="index-how-to-use-Gengen-33"></a>
These are the options that can be passed to GNU Gengen:

<pre class="example">       -h, --help                Print help and exit
       -V, --version             Print version and exit
       -i, --input=file          input file (default std input)
       -F, --file-name=name      name used for generating file (default stdout)
       -f, --gen-name=STRING     prefix for generated code  (default=`gengen')
           --output-format=lang  target language (cpp, c)  (default=`cpp')
           --output-dir=STRING   output directory (default current dir)
           --separate-files      output to separate files (header, source). require
                                   --file-name
           --expand-tabs         strings containing newlines are indented according
                                   to the current indentation level
           --no-gen-version      do not put gengen version in the generated file
           --test-mode           even with errors exit with 0 (this is only for
                                   testing purposes)
           --force               force regeneration of output code
</pre>
   <p class="noindent">Let us examine the ones not yet explained.

   <p><code>--separate-files</code> that makes Gengen generate the header with
class definition and a <samp><span class="file">.cc</span></samp> file with the same name specified with
<code>--file-name</code>, which contains the implementation of the generate
methods.

   <p><code>--expand-tabs</code> is pretty useful: all the variables specified in
the template files, when generated, will be correctly indented according
to the current indentation level (i.e., the indentation level at the
point where they are in the template file).  Thus, consider a slight
variation of the example seen before:

<pre class="example">     @rettype@
     @funname@(@paramtype@ @param@)
     {
       @funbody@
     }
</pre>
   <p class="noindent">where <code>funbody</code> is not of type <code>method</code>. 
Then, if you do not use the <code>--expand-tabs</code> and you set the string
<tt>if (bar &lt; 10)\n  return;</tt>, then the resulting generated code
will look the following one (the other variables are set to values as
seen before):

<pre class="example">     void
     foo_fun(unsigned int bar)
     {
       if (bar &lt; 10)
     return;
     }
</pre>
   <p class="noindent">While, if you use <code>--expand-tabs</code>, the string
containing newlines will be correctly formatted:

<pre class="example">     void
     foo_fun(unsigned int bar)
     {
       if (bar &lt; 10)
         return;
     }
</pre>
   <p>Gengen, in order to make separate compilation easier and minimize
recompilations of many files, before actually generating the output
file, checks whether a previous generated file exists and, if so,
whether there are any changes since the last generation.  If no
modification is needed, the previous generated file is not overwritten. 
This saves compilations, for instance, when you use
<code>--separate-files</code> and you only change something in the template
file that affects only the code that has to be generated (i.e., the
<code>generate</code> method itself), but not the class interface.  However,
if you want to force the generation of the output file, you can do so
with the option <code>--force</code>.

   <p>The <code>--output-format</code> permits generating code different from C++
(in the current version the other available target language is C).

   <p>The remaining options should be self-explanatory :-)

<div class="node">
<p><hr>
<a name="Bugs"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mailing-Lists">Mailing Lists</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Command-Options">Command Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Known Bugs, Limitations, and other Misfeatures</h2>

<p><a name="index-Known-Bugs-34"></a><a name="index-Limits-35"></a><a name="index-Misfeatures-36"></a>
No program is perfect, and GNU Gengen is certainly no exception. 
A partial list of problems with Gengen 1.4 can
be found in the <samp><span class="file">TODO.txt</span></samp>.

   <p>Should you discover a bug, propose an extension/feature, or just fell
like telling me what you think of this program, please send an e-mail at
the address <code>bug-gengen</code> at gnu dot org.

<div class="node">
<p><hr>
<a name="Mailing-Lists"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Index">Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bugs">Bugs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Mailing Lists</h2>

<p><a name="index-mailing-list-37"></a>
The following mailing lists are available:

   <p><code>help-gengen at gnu dot org</code>

<p class="noindent">for generic discussions about the program and for asking for help about
it (open mailing list),
<a href="http://mail.gnu.org/mailman/listinfo/help-gengen">http://mail.gnu.org/mailman/listinfo/help-gengen</a>

   <p><code>info-gengen at gnu dot org</code>

<p class="noindent">for receiving information about new releases and features (read-only
mailing list),
<a href="http://mail.gnu.org/mailman/listinfo/info-gengen">http://mail.gnu.org/mailman/listinfo/info-gengen</a>.

   <p>If you want to subscribe to a mailing list just go to the URL and follow
the instructions, or send me an e-mail and I'll subscribe you.

<div class="node">
<p><hr>
<a name="Index"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mailing-Lists">Mailing Lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-Audience-1">Audience</a>: <a href="#Audience">Audience</a></li>
<li><a href="#index-autoconf-12">autoconf</a>: <a href="#Installation">Installation</a></li>
<li><a href="#index-automake-11">automake</a>: <a href="#Installation">Installation</a></li>
<li><a href="#index-Conditional-statements-31">Conditional statements</a>: <a href="#Conditionals">Conditionals</a></li>
<li><a href="#index-Conditions-for-copying-GNU-Gengen-6">Conditions for copying GNU Gengen</a>: <a href="#Copying">Copying</a></li>
<li><a href="#index-Copying-conditions-5">Copying conditions</a>: <a href="#Copying">Copying</a></li>
<li><a href="#index-CVS-10">CVS</a>: <a href="#Installation">Installation</a></li>
<li><a href="#index-download-8">download</a>: <a href="#Installation">Installation</a></li>
<li><a href="#index-expression-syntax-32">expression syntax</a>: <a href="#Expression-syntax">Expression syntax</a></li>
<li><a href="#index-Generating-code-with-substitutions-15">Generating code with substitutions</a>: <a href="#The-Problem">The Problem</a></li>
<li><a href="#index-getting-started-with-Gengen-24">getting started with Gengen</a>: <a href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a></li>
<li><a href="#index-how-to-use-Gengen-33">how to use Gengen</a>: <a href="#Command-Options">Command Options</a></li>
<li><a href="#index-how-to-use-Gengen-23">how to use Gengen</a>: <a href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a></li>
<li><a href="#index-installation-7">installation</a>: <a href="#Installation">Installation</a></li>
<li><a href="#index-Known-Bugs-34">Known Bugs</a>: <a href="#Bugs">Bugs</a></li>
<li><a href="#index-Limits-35">Limits</a>: <a href="#Bugs">Bugs</a></li>
<li><a href="#index-mailing-list-37">mailing list</a>: <a href="#Mailing-Lists">Mailing Lists</a></li>
<li><a href="#index-Misfeatures-36">Misfeatures</a>: <a href="#Bugs">Bugs</a></li>
<li><a href="#index-Overview-of-GNU-Gengen-19">Overview of GNU Gengen</a>: <a href="#The-Solution">The Solution</a></li>
<li><a href="#index-parameter-26">parameter</a>: <a href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a></li>
<li><a href="#index-parameter-20">parameter</a>: <a href="#The-Solution">The Solution</a></li>
<li><a href="#index-parameter-16">parameter</a>: <a href="#The-Problem">The Problem</a></li>
<li><a href="#index-parameter-3">parameter</a>: <a href="#Audience">Audience</a></li>
<li><a href="#index-patching-14">patching</a>: <a href="#Installation">Installation</a></li>
<li><a href="#index-requirements-13">requirements</a>: <a href="#Installation">Installation</a></li>
<li><a href="#index-template-25">template</a>: <a href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a></li>
<li><a href="#index-template-17">template</a>: <a href="#The-Problem">The Problem</a></li>
<li><a href="#index-type-27">type</a>: <a href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a></li>
<li><a href="#index-variable-30">variable</a>: <a href="#Basic-Usage-in-C-and-C_002b_002b">Basic Usage in C and C++</a></li>
<li><a href="#index-variable-4">variable</a>: <a href="#Audience">Audience</a></li>
<li><a href="#index-Who-should-use-Gengen-2">Who should use Gengen</a>: <a href="#Audience">Audience</a></li>
   </ul>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">GNU Gengen</a>
<li><a name="toc_Audience" href="#Audience">Audience</a>
<li><a name="toc_Copying" href="#Copying">GNU Gengen Copying Conditions</a>
<li><a name="toc_Installation" href="#Installation">1 Installation</a>
<ul>
<li><a href="#Installation">1.1 Download</a>
<li><a href="#Installation">1.2 Anonymous CVS Access</a>
<li><a href="#Installation">1.3 What you need to build gengen</a>
<li><a href="#Installation">1.4 Patching from a previous version</a>
</li></ul>
<li><a name="toc_The-Problem" href="#The-Problem">2 Generating code or text from within a program</a>
<li><a name="toc_The-Solution" href="#The-Solution">3 How Gengen Can Help You</a>
<li><a name="toc_Basic-Usage-in-C-and-C_002b_002b" href="#Basic-Usage-in-C-and-C_002b_002b">4 Basic Usage in C and C++</a>
<ul>
<li><a href="#Callbacks">4.1 Callbacks</a>
<li><a href="#Types">4.2 Types</a>
</li></ul>
<li><a name="toc_Conditionals" href="#Conditionals">5 Conditional statements</a>
<ul>
<li><a href="#Expression-syntax">5.1 Expression syntax</a>
</li></ul>
<li><a name="toc_Command-Options" href="#Command-Options">6 Command line options</a>
<li><a name="toc_Bugs" href="#Bugs">7 Known Bugs, Limitations, and other Misfeatures</a>
<li><a name="toc_Mailing-Lists" href="#Mailing-Lists">8 Mailing Lists</a>
<li><a name="toc_Index" href="#Index">Index</a>
</li></ul>
</div>

<div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> <a href="http://www.gnu.org/software/gengetopt">http://www.gnu.org/software/gengetopt</a></p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> Notice that the first indentation has to be performed
manually; this behavior is useful in conjunction with a more
involved feature that will be explained later.</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> Notice
that, by default gengen produces C++ code, so you don't need to specify
the <code>--output-format</code> option.</p>

   <p class="footnote"><small>[<a name="fn-4" href="#fnd-4">4</a>]</small> Notice that the first indentation has to be performed
manually; this behavior is useful in conjunction with a more
involved feature that will be explained later.</p>

   <p class="footnote"><small>[<a name="fn-5" href="#fnd-5">5</a>]</small> This holds
since version 1.0.</p>

   <p class="footnote"><small>[<a name="fn-6" href="#fnd-6">6</a>]</small> In this section
will use generated C++ code as an example, but of course, the same
features hold for generated C code as well.</p>

   <p class="footnote"><small>[<a name="fn-7" href="#fnd-7">7</a>]</small> This is the equality operator,
not the assignment operator.</p>

   <hr></div>

</body></html>

