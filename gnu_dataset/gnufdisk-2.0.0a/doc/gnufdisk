This is gnufdisk, produced by makeinfo version 4.13 from ./gnufdisk.texi.


File: gnufdisk,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Gnufdisk specification
**********************

* Menu:

* Introduction::
* Using gnufdisk::
* Preparing your system::
* gnufdisk-common library::
* gnufdisk-debug library::
* gnufdisk-exception library::
* gnufdisk-device library::
* gnufdisk-devicemanager library::
* gnufdisk-userinterface library::
* Scheme shell::
* Backend API::
* Functions index::
* Type index::
* Variable index::

 --- The Detailed Node Listing ---

Using gnufdisk

* Invoking::
* shell interface::

gnufdisk-common library

* Page fault handling::
* Strings::
* Stacks::

gnufdisk-debug library

* Log messages::
* Warning messages::
* gnufdisk-debug example::

gnufdisk-exception library

* Throw::
* Throw handlers::
* Blocking exceptions continue or jump back::
* Unwind handlers::
* Catch::
* End try/catch context::
* gnufdisk-exception example::

gnufdisk-device library

* Error reporting::
* Geometries::
* Devices::
* Disklabels::
* Partitions::
* gnufdisk-device example::

Backend API

* Backend example::


File: gnufdisk,  Node: Introduction,  Next: Using gnufdisk,  Prev: Top,  Up: Top

Introduction
************

With this document we want to explain how we organized the source code
of GNU Fdisk.

When we designed this new version we had one rule in mind: the
development of a new graphical interface and a new backend should be
easy. To do this we have organized the code into several components.
Each one of these components provides a well defined interface, but
hides the implementation. In this way each component can be modified
and  others are not affected.

In later chapters we will examine all these components, explaining what
is their role, and how it was implemented. Most of the source code is
written in C language, some parts are written in Scheme. In this
document we assume you're familiar with these languages.


File: gnufdisk,  Node: Using gnufdisk,  Next: Preparing your system,  Prev: Introduction,  Up: Top

1 Using gnufdisk
****************

* Menu:

* Invoking::
* shell interface::


File: gnufdisk,  Node: Invoking,  Next: shell interface,  Prev: Using gnufdisk,  Up: Using gnufdisk

1.1 Invoking
============

`gnufdisk' is a small executable that takes care of loading the
implementation that you want, with the options you specified.  The
model of control to start gnufdisk is as follows:

gnufdisk IMPLEMENTATION [ ARGUMENTS ]

In this model, IMPLEMENTATION means the user interface that you want to
use.  ARGUMENTS indicates the parameters that you want to provide to
this interface.

User interfaces are separate modules, are not part of the `gnufdisk'
program, so you can only use interfaces that you have installed on your
system.  The only interface included in the program is `shell'.


File: gnufdisk,  Node: shell interface,  Prev: Invoking,  Up: Using gnufdisk

1.2 shell interface
===================

The `shell' interface allows you to use the gnufdisk scheme interpreter
interactively.  If you run gnufdisk selecting this interface, you'll be
shown the guile prompt:

     ~/$ gnufdisk shell
     guile>

In this mode you can work on devices interactively, using the language
scheme.  *Note Scheme shell::.


File: gnufdisk,  Node: Preparing your system,  Next: gnufdisk-common library,  Prev: Using gnufdisk,  Up: Top

2 Preparing your System
***********************

To develop GNU fdisk we have used various tools from the GNU project.
In this chapter we e


File: gnufdisk,  Node: gnufdisk-common library,  Next: gnufdisk-debug library,  Prev: Preparing your system,  Up: Top

3 gnufdisk-common library
*************************

In this library there are functions for general use. This library is
used by all the others.

* Menu:

* Page fault handling::
* Strings::
* Stacks::


File: gnufdisk,  Node: Page fault handling,  Next: Strings,  Prev: gnufdisk-common library,  Up: gnufdisk-common library

3.1 Page fault handling
=======================

Many times it happens that a pointer contains an invalid address. In
these cases not enough to check if its value is `NULL'. Values such as
`0x01', `0x64' and `0x345' are not equal to `NULL', but if we try to
access these addresses, our program will terminate with a `SIGSEGV'
signal. The following function allows us to check if an address is
valid:

 -- Function: int gnufdisk_check_memory ( void *ADDRESS, size_t SIZE,
          int READONLY )
     This function checks if the memory area from ADDRESS to ADDRESS +
     SIZE is accessible for reading.  If the parameter READONLY is not
     zero, then this function checks if we have write access.

     On success this function returns `0'. If an error occurs, this
     function returns `-1' and ERRNO is set with the error code.

There are cases where we do not know in advance which addresses are
used. Examples of these cases are the functions with variable number of
arguments. For these cases, the library provides the following
functions:

 -- Function: int gnufdisk_vfprintf ( FILE* STREAM, const char *FORMAT,
          va_list ARGS )
     This function behaves like `vfprintf', capturing any `SIGSEGV'
     signal. On success this function returns the number of bytes
     printed. If an error occurs the function returns -1 and errno is
     set with the appropriate code.

          Note: If the function captures a `SIGSEGV' signal, the output
          is undefined.

 -- Function: int gnufdisk_vasprintf (char **DEST, const char *FORMAT,
          va_list ARGS )
     This function behaves like `vasprintf', capturing any `SIGSEGV'
     signal. On success this function returns the number of bytes
     printed. If an error occurs the function returns -1 and errno is
     set with the appropriate code.


File: gnufdisk,  Node: Strings,  Next: Stacks,  Prev: Page fault handling,  Up: gnufdisk-common library

3.2 Strings
===========

This library includes some functions for string handling. The strings
are represented with the structure `struct gnufdisk_string'. This
structure is hidden, you can use it only throught pointers and related
functions:

 -- Function: struct gnufdisk_string* gnufdisk_string_new ( const char*
          FORMAT, ... )
     This function allocates a new string and sets its content in
     accordance with the format FORMAT (and its arguments).

     On success the function returns the pointer to the new string. If
     an error occurs the function returns `NULL' and ERRNO is set with
     the error value.

 -- Function: int gnufdisk_string_set ( struct gnufdisk_string* STRING,
          const char *FORMAT, ... )
     This function sets the contents of STRING according with the format
     FORMAT (and it's arguments).

     On success this function returns the length of the string. If an
     error occurs the function returns -1 and the variable ERRNO is set
     with the error number.

          Note: If the function fails, the contents of the string
          remains unchanged.

 -- Function: int gnufdisk_string_length ( struct gnufdisk_string*
          STRING )
     This function returns the length of the string STRING. If an error
     occurs the function returns -1 and the variable ERRNO is set with
     the error number.

 -- Function: const char* gnufdisk_string_c_string ( struct
          gnufdisk_string* STRING )
     This function returns a pointer to the string data. If an error
     occurs the function returns `NULL' and sets the variable ERRNO
     with the error number.

 -- Function: char* gnufdisk_string_c_string_dup ( struct
          gnufdisk_string* STRING )
     This function returns a pointer to the string data. Pointer must
     be freed with `free'.  If an error occurs the function returns
     `NULL' and sets the variable ERRNO with the error number.

 -- Function: int gnufdisk_string_delete ( struct gnufdisk_string*
          STRING )
     This function eliminates the string STRING and frees all its
     resources.  On success the function returns 0. If an error occurs
     the function returns -1 and ERRNO is set with the error number.


File: gnufdisk,  Node: Stacks,  Prev: Strings,  Up: gnufdisk-common library

3.3 Stacks
==========

 -- Function: struct gnufdisk_stack* gnufdisk_stack_new ( void )

 -- Function: int gnufdisk_stack_delete ( struct gnufdisk_stack* STACK )

 -- Function: int gnufdisk_stack_push ( struct gnufdisk_stack* STACK,
          void* DATA, size_t SIZE )

 -- Function: int gnufdisk_stack_pop ( struct gnufdisk_stack* STACK,
          void* DEST, size_t SIZE )


File: gnufdisk,  Node: gnufdisk-debug library,  Next: gnufdisk-exception library,  Prev: gnufdisk-common library,  Up: Top

4 gnufdisk-debug library
************************

* Menu:

* Log messages::
* Warning messages::
* gnufdisk-debug example::

GNU fdisk includes a small library to send messages to the terminal.
To use this library you must include the file `gnufdisk-debug.h'.


File: gnufdisk,  Node: Log messages,  Next: Warning messages,  Prev: gnufdisk-debug library,  Up: gnufdisk-debug library

4.1 Log messages
================

To send logging messages on the terminal you can use the following
macro:

 -- Macro: GNUFDISK_LOG ( ARGUMENTS )
     The parameter ARGUMENTS is a function-argument-list that should be
     passed to a print function. The format of these arguments is:
     (`ENABLED, FORMAT, ARGS').

     The parameter ENABLED should be a boolean expression.  If the
     evaluation of this expression is true then the message will be
     printed. Otherwise not.

     The parameter FORMAT is a printf-like format string and ARGS are
     arguments for this strings.

Once this macro is called, there are 2 ways to configure logging.  The
first is global, and then enable or disable all messges.  The second is
through the parameter ENABLED.

To enable global logging you must define the macro `GNUFDISK_DEBUG'
while compiling your source. For example, using `gcc' you can compile
with:

     gcc -DGNUFDISK_DEBUG -c -o SOURCE-FILE.O SOURCE-FILE.C

To enable or disable logging local to the source you must use the
parameter ENABLE. As mentioned above the parameter must be a boolean
expression. If  the result of this expression is 0 (zero), the message
is not displayed. For example:

     GNUFDISK_LOG((1, "I  received %d bytes", nbytes));
     GNUFDISK_LOG((0, "prepare to write..."));

The first message will be displayed. The second message is not
displayed.  Note that the  double parentheses are necessary. If we omit
this particular the C preprocessor fails.

If the macro `GNUFDISK_DEBUG' is defined and the parameter ENABLE
expands to true, the library will print the message in the following
format:

PROCESSID-THREADID:SOURCE:LINENO: MESSAGE

`PROCESSID' indicates the id of the process that sent the message.
`THREADID' indicates which thread has sent the message. The value is
printed as a sequence of hexadecimal values. `SOURCE' is the source
file name and `LINENO' the number of line where the message is sent.


File: gnufdisk,  Node: Warning messages,  Next: gnufdisk-debug example,  Prev: Log messages,  Up: gnufdisk-debug library

4.2 Warning messages
====================

To send warning messages on the terminal you can use the following
macro:

 -- Macro: GNUFDISK_WARNING ( FORMAT )
     This macro prints a warning message to STDERR. The message is
     formatted according with the string FORMAT.

     The message is printed according to the following schema: *** WARNING *** PROCESSID-THREADID:SOURCE:LINENO: MESSAGE


File: gnufdisk,  Node: gnufdisk-debug example,  Prev: Warning messages,  Up: gnufdisk-debug library

4.3 gnufdisk-debug example
==========================

In this section we will make an example of how to use the library.  The
sample program will copy a file and use the library to display
informations.  In the second part will show you how to enable and
disable logging at global level and at local level. What follows is our
source code:

     #include <stdlib.h>
     #include <stdio.h>

     /* Get definition of GNUFDISK_LOG */
     #include <gnufdisk-debug.h>

     /* We define boolean expressions as calls to getenv,
      * so that we can enable or disable local logging
      * using environment variables. */
     #define INFO (getenv("INFO") != NULL)
     #define IO (getenv("IO") != NULL)

     int main(int argc, char* argv[])
     {
       FILE* in;
       FILE* out;
       char buf[512];
       int count;

       GNUFDISK_LOG((INFO, "main: argc=%d, argv=%p", argc, argv));

       if(argc < 3)
         {
           fprintf(stderr, "USAGE: mycopy source dest\n");
           exit(EXIT_FAILURE);
         }

       if((in = fopen(argv[1], "rb")) == NULL)
         {
           perror("fopen");
           exit(EXIT_FAILURE);
         }

       GNUFDISK_LOG((INFO, "input stream: %p", in));

       if((out = fopen(argv[2], "wb")) == NULL)
         {
           perror("fopen");
           exit(EXIT_FAILURE);
         }

       GNUFDISK_LOG((INFO, "output stream: %p", out));

       while((count = fread(buf, 1, sizeof(buf), in)) > 0)
         {
           GNUFDISK_LOG((IO, "got %d bytes", count));

           if(fwrite(buf, 1, count, out) != count)
             {
               perror("fwrite");
               exit(EXIT_FAILURE);
             }
         }

       GNUFDISK_LOG((INFO, "done copy"));

       fclose(in);
       fclose(out);

       return EXIT_SUCCESS;
     }

Now that  we have written the code, we can compile. For this example we
will build two executables, the first one with debugging enabled at the
global level, the second  with debugging disabled  globally. We will
call these two executables `mycopy-with-debug' and
`mycopy-without-debug'.  Here are  two commands to compile  the two
executables:

     gcc -DGNUFDISK_DEBUG -o mycopy-with-debug mycopy.c -lgnufdisk-debug
     gcc -o mycopy-without-debug mycopy.c

Note that if the macro `GNUFDISK_DEBUG' is not defined, we do not need
to link our  executable to the library, because it is not used. Now
that the executables are compiled  we can see their behavior.  The
first executable has debug enabled  globally, then we can enable
messages using environment variables:

     $ # no log at all:
     $ ./mycopy-with-debug input-file output-file
     $ # enable logging from category INFO:
     $ INFO= ./mycopy-with-debug input-file output-file
     26925-00000000:mycopy.c:20: main: argc=3, argv=0xbfe8fb94
     26925-00000000:mycopy.c:34: input stream: 0x8a19008
     26925-00000000:mycopy.c:42: output stream: 0x8a19170
     26925-00000000:mycopy.c:55: done copy
     $ # enable logging for all categories:
     $ INFO= IO= ./mycopy-with-debug input-file output-file
     26926-00000000:mycopy.c:20: main: argc=3, argv=0xbfcef574
     26926-00000000:mycopy.c:34: input stream: 0x855e008
     26926-00000000:mycopy.c:42: output stream: 0x855e170
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 512 bytes
     26926-00000000:mycopy.c:46: got 335 bytes
     26926-00000000:mycopy.c:55: done copy

The second executable has debug disabled globally, even if we try to
enable messages using environment variables, they will not be displayed:

     $ # no log at all:
     $ ./mycopy-with-debug input-file output-file
     $ # enable logging from category INFO:
     $ INFO= ./mycopy-with-debug input-file output-file
     $ # enable logging for all categories:
     $ INFO= IO= ./mycopy-with-debug input-file output-file
     $

When the source code is compiled without defining the macro
`GNUFDISK_DEBUG', each occurrence of `GNUFDISK_LOG' is expanded in an
empty statement. In this way, we do not have an impact on the speed of
the program.


File: gnufdisk,  Node: gnufdisk-exception library,  Next: gnufdisk-device library,  Prev: gnufdisk-debug library,  Up: Top

5 gnufdisk-exception library
****************************

* Menu:

* Throw::
* Throw handlers::
* Blocking exceptions continue or jump back::
* Unwind handlers::
* Catch::
* End try/catch context::
* gnufdisk-exception example::

GNU Fdisk includes a library for exception handling. This library is
capable of handling exceptions in  multi-threaded applications  in a
flexible manner.  Exception handling is similar to the one implemented
in  most modern programming languages where we  try, catch and throw.
In addition to this we have the ability to block an exception before it
is raised,  and then continue execution  from where the exception was
created, or further back (through the  continuation points).  We can
also record functions  to clean the data before  the stack is cleared,
get information about the current state, current exception and so on.

In this chapter we will explain how this library works.  Since it is
not easy,  we begin with a flowchart  and then explain each element. The
flow chart below explains what happens when an exception is raised:


                       [image src="exception.png" ]

The following sections will examine the elements of this diagram,
associating them to the library. All macros and functions are declared
in the file `gnufdisk-exception.h'.


File: gnufdisk,  Node: Throw,  Next: Throw handlers,  Prev: gnufdisk-exception library,  Up: gnufdisk-exception library

5.1 Throw
=========

When an error occurs, and you do not know how to solve it, the best
choice is to throw an exception and let the error be managed at the
highest level. To throw an exception you can use the following macro:

 -- Macro: GNUFDISK_THROW ( MODE, RETRY, ERROR, DATA, FMT, ... )
     With this macro you can raise an exception for error ERROR (a
     signed integer value). You can decide what value to use for this
     parameter, but you can not use the value 0 (zero) because this
     value is reserved to the library.

     With the MODE parameter you can decide how this exception should be
     handled. To do this you can use the or operator (`|') and the
     following enumerations:

    `GNUFDISK_EXCEPTION_MANAGEABLE'
          The exception can be handled by a function before being
          reported and before the stack is cleared. The handler for
          this exception will be given at a higher level, at the
          beginning of the try block. You can pass data to this
          function using the parameter DATA (a void pointer).  *Note
          Throw handlers: Throw handlers.

    `GNUFDISK_EXCEPTION_LOCKABLE'
          The function that handles the exception can stop the error.
          If this happens, the stack is not cleared and execution
          continues to the next statement or jump to a retry-point. You
          can indicate a retry-point using the parameter RETRY. *Note
          Blocking exceptions: Blocking exceptions.

     With the parameter FORMAT you can enter a descriptive message for
     this error.  The parameter accepts a printf-like string. The rest
     of parameters are those required for the format-string.

Once an exception is raised, the library ensures that there is a try
context. If there is no context, the thread is finished using
pthread_kill, and the signal 6 (`SIGABORT').


File: gnufdisk,  Node: Throw handlers,  Next: Blocking exceptions continue or jump back,  Prev: Throw,  Up: gnufdisk-exception library

5.2 Throw handlers
==================

When an exception was raised, the library checks the value indicated
for the MODE parameter. If you have specified the value
`GNUFDISK_EXCEPTION_MANAGEABLE', the library checks whether a handler
has been specified. If this is specified, then calls it.

 -- Type: gnufdisk_exception_handler
     This is the type for an exception handler. It's declaration is:

     int gnufdisk_exception_handler ( void * handler_data,
                                      struct gnufdisk_exception_info *info,
                                      void *exception_data );

     The parameter HANDLER_DATA is a void pointer. The value of this
     parameter is specified when registering the handler. The parameter
     INFO is a pointer to a structure that contains information about
     this exception (see below). The parameter EXCEPTION_DATA is a void
     pointer.  Its value is specified within the macro `GNUFDISK_THROW',
     using the parameter DATA.

 -- Type: struct gnufdisk_exception_info
     This structure contains information about the  exception. Its
     members  are:
    `message'
          The error message indicated with the macro `GNUFDISK_THROW'.

    `file'
          The  source file name where  this exception was raised.

    `line'
          The line number where this exception was raised.

    `error'
          The error associated with this exception (the value given for
          parameter ERROR of `GNUFDISK_THROW')

If you want to specify an exception handler, you must do when starting
a try context, using the following macro:

 -- Macro: GNUFDISK_TRY ( HANDLER, HANDLER_ARG )
     This macro begins a context where you can manage exceptions. The
     parameter HANDLER is a  pointer to a function that manage the
     error before it is reported. The parameter HANDLER_ARG is a `void'
     pointer. You can use it to pass data to the HANDLER.


File: gnufdisk,  Node: Blocking exceptions continue or jump back,  Next: Unwind handlers,  Prev: Throw handlers,  Up: gnufdisk-exception library

5.3 Blocking exceptions continue or jump back
=============================================

If  you are able to fix an error in an exception handler, you can tell
the library that the error was resolved. To do this you must return a
zero value from the exception handler. In this case, the library checks
whether the exception can be blocked. If the exception can be blocked
then the execution continues  from where it was raised (or more back if
you specified a retry-point).

To indicate a retry-point you have to use a variable, set it to the
location where you want to jump and indicate it as a parameter RETRY
when using the macro `GNUFDISK_THROW'. To declare and set a retry-point
you can use the following macros:

 -- Type: GNUFDISK_RETRY
     This  allows you to declare  a variable where you can  jump back.

 -- Macro: GNUFDISK_RETRY_SET ( RETRY )
     With  this macro you can set  a location to jump back. The
     parameter RETRY should be a variable of type `GNUFDISK_RETRY'.

You can have multiple `GNUFDISK_RETRY' variables, but you can only use
one for each call to `GNUFDISK_THROW'. The retry mechanism is similar
to a `goto' statement, but it is not a label. Unlike the labels you can
get the address of a retry-point variable and pass it to a function.
This function can throw an exception using this variable and, if this
exception is resolved, execution jumps to where you've set the jump.


File: gnufdisk,  Node: Unwind handlers,  Next: Catch,  Prev: Blocking exceptions continue or jump back,  Up: gnufdisk-exception library

5.4 Unwind handlers
===================

You can register functions that must be called before cleaning the
stack.  We call these functions unwind-handlers because they are run
just prior to clean up the stack and move the execution at the first
properly catch block. To register/unregister handlers you must use the
following functions:

 -- Function: int gnufdisk_exception_register_unwind_handler ( void
          (*HANDLER)(void *), void *DATA )
     This function registers an unwind-handler. The parameter HANDLER is
     the pointer to the function you want to register. The parameter
     DATA is the argument you want passed to the function.

     The  return value is 0 (zero) if the handler was registered. If
     an error occurs the function returns -1 and ERRNO is set to error
     number.

 -- Function: int gnufdisk_exception_unregister_unwind_handler ( void
          (*HANDLER)(void *), void *DATA )
     This function allows to remove an handler from a try context. The
     parameters HANDLER and DATA must be the same as you entered when
     you registered the handler.

     The  return value is 0 (zero) if the handler was removed. If an
     error occurs the function returns -1 and ERRNO is set to error
     number.

You can register more than one handler, they are called in reverse
order. Each handler will be called with its argument.


File: gnufdisk,  Node: Catch,  Next: End try/catch context,  Prev: Unwind handlers,  Up: gnufdisk-exception library

5.5 Catch
=========

When an exception occurs and this is not blocked, the library calls the
registered handlers, cleans up the stack and then move code execution
on an appropriate catch block. To insert one  or more catch blocks you
must use the following macros:

 -- Macro: GNUFDISK_CATCH ( ERROR )
     This macro indicates a statement (or a block of statements)
     prepared to handle the error ERROR. The parameter ERROR is an
     integer id for the type of exception.

 -- Macro: GNUFDISK_CATCH_DEFAULT
     This macro indicates a set of instructions to be executed if the
     exception was not handled.

Within each catch block you can use the variable EXCEPTION_INFO. This
variable is an automatic variable, local to the  catch block. For more
information about the type of this variable *Note `struct
gnufdisk_exception_info': gnufdisk_exception_info.


File: gnufdisk,  Node: End try/catch context,  Next: gnufdisk-exception example,  Prev: Catch,  Up: gnufdisk-exception library

5.6 End try/catch context
=========================

At the end of a try/catch block should be a call to the macro
`GNUFDISK_EXCEPTION_END'.  This macro has the following format:

 -- Macro: GNUFDISK_EXCEPTION_END
     The macro `GNUFDISK_EXCEPTION_END' indicates the end of a context
     where you can manage exceptions.  If there are unhandled
     exceptions, they will be raised at the highest level.  If no one
     handles these exceptions, the thread will be terminated.

Then  the template to handle  exceptions using this library is as
follows:

     GNUFDISK_TRY ( HANDLER, HANDLER_ARG )
       {
         /* Code where exceptions can be raised */
       }
     [ GNUFDISK_CATCH ( ERROR )
       {
         /* Codet to manage error ERROR */
       } ]
     [ GNUFDISK_CATCH_DEFAULT
       {
         /* Default code to manage exceptions */
       } ]
     GNUFDISK_EXCEPTION_END;

The call to `GNUFDISK_TRY' is mandatory. It prepares a new environment
where you can  catch exceptions.  Following this macro there may be a
series of `GNUFDISK_CATCH', one for each error. If you want, you can
place a call to `GNUFDISK_CATCH_DEFAULT' to handle uncaught exception.
At the end there must be a call to `GNUFDISK_EXCEPTION_END'. This is
also mandatory, is used to control the final state of the context and
to release the allocated memory.


File: gnufdisk,  Node: gnufdisk-exception example,  Prev: End try/catch context,  Up: gnufdisk-exception library

5.7 gnufdisk-exception example
==============================

In this section we will make an example using the library
gnufdisk-exception.

The sample program will try to open a socket listening on port 953 and
use the library to signal errors. If the `bind' fails, we use a
throw-handler to resolve the error, and a retry-point variable to
resume operation. The following is sample code:

     #include <errno.h>
     #include <stdlib.h>
     #include <stdio.h>
     #include <errno.h>
     #include <stdint.h>
     #include <string.h>
     #include <unistd.h>
     #include <sys/socket.h>
     #include <netinet/in.h>

     #include <gnufdisk-debug.h>
     #include <gnufdisk-exception.h>

     /* define macros for GNUFDISK_LOG */
     #define ERROR (getenv("ERROR") != NULL)
     #define INFO (getenv("INFO") != NULL)

     /* This is our throw-handler */
     static int
     throw_handler (void *_udata,
                    struct gnufdisk_exception_info *_info,
                    void *_edata)
     {
       GNUFDISK_LOG ((ERROR,
                      "handle exception from %s:%d error %d (%s)",
                      _info->file,
                      _info->line,
                      _info->error,
                      strerror (_info->error)));

       switch (_info->error)
         {
         case EACCES:
         case EADDRINUSE:
           {
             /* We assume that the port is busy. We ask you
                to enter a new port or 'q' to quit. */

             char buf[32];
             struct sockaddr_in *name;
             uint16_t new_port;

             memset (buf, 0, sizeof (buf));
             name = _edata;
             new_port = ntohs (name->sin_port);
             printf ( "cannot bind socket on port %hu"
                      ", type another port or q to quit: ",
                      new_port );

             fflush (stdout);

             if (scanf ("%31s", buf) < 1 || strchr (buf, 'q') != NULL)
               return -1;

             new_port = atoi (buf);

             name->sin_port = htons (new_port);

             return 0; /* block the exception */
           }
        }

       return -1; /* let the exception continue */
     }

     static int create_socket(uint16_t _port)
     {
       int sock;
       struct sockaddr_in name;

       GNUFDISK_RETRY r1; /* retry point variable */

       GNUFDISK_LOG((INFO, "create socket on port %hu", _port));

       /* Create the socket. */
       sock = socket (PF_INET, SOCK_STREAM, 0);

       /* On failure we raise an exception. This exception
          is not manageable, an then not lockable */

       if (sock < 0)
         GNUFDISK_THROW(0, NULL, errno, NULL, "cannot create socket");

       /* bind socket */
       name.sin_family = AF_INET;
       name.sin_port = htons (_port);
       name.sin_addr.s_addr = htonl (INADDR_ANY);

       GNUFDISK_RETRY_SET(r1); /* set the retry point */

       /* On failure we raise an exception. Exception is manageable
          and lockable. Use retry point `r1' and pass the variable `name'
          as exception data. */

       if (bind (sock, (struct sockaddr *) &name, sizeof (name)) < 0)
         GNUFDISK_THROW(GNUFDISK_EXCEPTION_MANAGEABLE
                          |GNUFDISK_EXCEPTION_LOCKABLE,
                        &r1,
                        errno,
                        &name,
                        "cannot bind socket on port %hd",
                        ntohs(name.sin_port));

       return sock;
     }

     /* unwind handler to free a pointer */
     static void cleanup_memory(void* _p)
     {
       GNUFDISK_LOG((ERROR, "free memory %p", _p));
       free(_p);
     }

     /* unwind handler to close a socket */
     static void close_socket(void* _p)
     {
       GNUFDISK_LOG((ERROR, "close socket %p", _p));

       close(*(int*) _p);
     }

     int main(int argc, char* argv[])
     {
       int ret;

       /* begin a try context using `throw_handler' as throw-handler
          pass NULL as handler data */
       GNUFDISK_TRY(&throw_handler, NULL)
         {
           char* buf;
           int sock;

           /* On failure raise an exception.
              Exception is not manageable and not lockable */
           if((buf = malloc(1024)) == NULL)
             GNUFDISK_THROW(0,
                            NULL,
                            errno,
                            NULL,
                            "cannot allocate memory");

           /* register an unwind handler to free buf */
           gnufdisk_exception_register_unwind_handler(&cleanup_memory, buf);

           /* here we can have some exceptions */
           sock = create_socket(953);

           /* registers an unwind handler to close the socket */
           gnufdisk_exception_register_unwind_handler(&close_socket, &sock);

           /* continue */

           /* if we walk here, there isn't exceptions
              so we can close an cleanup explicitly */
           close(sock);
           free(buf);

           ret = EXIT_SUCCESS;
         }
       GNUFDISK_CATCH_DEFAULT
         {
           fprintf(stderr,
                   "caught an exception from %s:%d: %s\n",
                   exception_info.file,
                   exception_info.line,
                   exception_info.message);
           ret = EXIT_FAILURE;
         }
       GNUFDISK_EXCEPTION_END; /* end of exception context */

       return ret;
     }

Now that the code is written, we can compile and test our example: We
compile using gcc, and enable debugging at all levels:

     ~$ gcc -o exception -DGNUFDISK_DEBUG exception.c \
         -lgnufdisk-debug -lgnufdisk-exception
     ~$ INFO= ERROR= ./exception
     26350-c0061b40:exception.c:72: create socket on port 953
     26350-c0061b40:exception.c:29: handle exception from \
         exception.c:93 error 13 (Permission denied)
     cannot bind socket on port 953, type another port or q to quit: 80
     26350-c0061b40:exception.c:29: handle exception \
         from exception.c:93 error 13 (Permission denied)
     cannot bind socket on port 80, type another port or q to quit: 98
     26350-c0061b40:exception.c:29: handle exception from \
         exception.c:93 error 13 (Permission denied)
     cannot bind socket on port 98, type another port or q to quit: 20
     26350-c0061b40:exception.c:29: handle exception from \
         exception.c:93 error 13 (Permission denied)
     cannot bind socket on port 20, type another port or q to quit: q
     26350-c0061b40:exception.c:100: free memory 0x9450058
     caught an exception from exception.c:93: cannot bind socket on port 20
     ~$

As we can see from the logs, it was not possible to bind  using port
953. At this point there was an exception and the throw-handler has
asked to enter a new port. The user selects the port number 80, and the
exception has been blocked. This was repeated for port 80, 98 and 20,
until the user has decided to quit. This time the exception was not
locked. The library has called the `cleanup_memory', and the execution
has moved to the catch block.


File: gnufdisk,  Node: gnufdisk-device library,  Next: gnufdisk-devicemanager library,  Prev: gnufdisk-exception library,  Up: Top

6 gnufdisk-device library
*************************

* Menu:

* Error reporting::
* Geometries::
* Devices::
* Disklabels::
* Partitions::
* gnufdisk-device example::

As we said at the beginning of this document, the new version of GNU
fdisk has been built to make easier the implementation of new back-end.
With the library gnufdisk-device  we offer the possibility  to use
different implementations having the same interface. In addition, this
library is responsible for checking that data is reliable, and resume
the operation when an error occurs.

In this chapter we will examine the functions and structures exported
by this library. All public functions are declared in the file
`gnufdisk-device.h', private functions in the file
`gnufdisk-device-internals.h'.


File: gnufdisk,  Node: Error reporting,  Next: Geometries,  Prev: gnufdisk-device library,  Up: gnufdisk-device library

6.1 Error reporting
===================

Any error that occurs in this library is signaled by an exception. The
type of error is indicated  by an integer value, specific data is
provided through a union. Below is the list of errors:

`GNUFDISK_DEVICE_EMODULEPOINTER'
     Invalid `struct gnufdisk_string' pointer (address is not valid).

`GNUFDISK_DEVICE_EMODULE'
     Invalid module name (module not found).

`GNUFDISK_DEVICE_EGEOMETRYLENGTH'
     Invalid geometry length (less than or equal to 0).

`GNUFDISK_DEVICE_EGEOMETRYPOINTER'
     Invalid `struct gnufdisk_geometry' pointer (address is not valid).

`GNUFDISK_DEVICE_EGEOMETRY'
     Invalid geometry (start and/or end are not valid).

`GNUFDISK_DEVICE_EDEVICEPOINTER,'
     Invalid `struct gnmufdisk_device' pointer (address is not valid).

`GNUFDISK_DEVICE_EDEVICE'
     Invalid device (internal values are not valid)

`GNUFDISK_DEVICE_EDISKLABELPOINTER'
     Invalid `struct gnufdisk_disklabel' pointer (address is not valid).

`GNUFDISK_DEVICE_EDISKLABEL'
     Invalid disklabel (internal values are not valid).

`GNUFDISK_DEVICE_EPARTITIONPOINTER'
     Invalid `struct gnufdisk_partition' pointer (address is not valid).

`GNUFDISK_DEVICE_EPARTITION'
     Invalid partition (internal values are not valid).

`GNUFDISK_DEVICE_EPARTITIONNUMBER'
     Partition number out of range.

`GNUFDISK_DEVICE_ENOTSUP'
     Operation not supported.

`GNUFDISK_DEVICE_EPATHPOINTER'
     Invalid `struct gnufdisk_string' pointer (address is not valid).

`GNUFDISK_DEVICE_EPATH'
     Invalid device path (device is not accessible).

`GNUFDISK_DEVICE_EDESTINATIONPOINTER'
     Invalid destination pointer (address is not valid).

`GNUFDISK_DEVICE_ESIZEPOINTER'
     Invalid size pointer (address is not valid).

`GNUFDISK_DEVICE_EDISKLABELSYSTEMPOINTER'
     Invalid `struct gnufdisk_string' pointer (address is not valid).

`GNUFDISK_DEVICE_EDISKLABELSYSTEM'
     Invalid disklabel system (type is unknown).

`GNUFDISK_DEVICE_EPARTITIONTYPEPOINTER'
     Invalid `struct gnufdisk_string' pointer (address is not valid).

`GNUFDISK_DEVICE_EPARTITIONTYPE'
     Invalid partition type (type is unknown).

`GNUFDISK_DEVICE_EPARAMETERPOINTER'
     Invalid `struct gnufdisk_string' pointer (address is not valid).

`GNUFDISK_DEVICE_EPARAMETER'
     Invalid parameter (unknown by implementation).

`GNUFDISK_DEVICE_EPARAMETERDATA'
     Invalid parameter pointer (address is not valid).

`GNUFDISK_DEVICE_EPARAMETERSIZE'
     Unexpected parameter size.

`GNUFDISK_DEVICE_EREADBUFFER'
     Invalid read buffer (address is not valid).

`GNUFDISK_DEVICE_EWRITEBUFFER'
     Invalid write buffer (address is not valid).

`GNUFDISK_DEVICE_EINTERNAL'
     Internal error.

`GNUFDISK_DEVICE_ENOTOPEN'
     Device is not open.

`GNUFDISK_DEVICE_EIO'
     Lov level I/O error.

Many of these errors can be resolved through a throw-handler. Errors
that can not be resolved are not manageable by the handler (they are
not reported using the mode `GNUFDISK_EXCEPTION_MANAGEABLE').

Each error is reported along with its data. For example, the error
`GNUFDISK_DEVICE_EGEOMETRY' is accompanied by a pointer to the
geometry. The error data are always passed through the `union
gnufdisk_device_exception_data':

union gnufdisk_device_exception_data {
  struct gnufdisk_string** emodulepointer;
  struct gnufdisk_string* emodule;
  struct gnufdisk_string** edisklabelsystempointer;
  struct gnufdisk_string* edisklabelsystem;
  struct gnufdisk_string** epartitiontypepointer;
  struct gnufdisk_string* epartitiontype;
  size_t* epartitionnumber;
  struct gnufdisk_string** epathpointer;
  struct gnufdisk_string* epath;
  void*** edestinationpointer;
  size_t ** esizepointer;
  gnufdisk_integer* egeometrylength;
  struct gnufdisk_geometry** egeometrypointer;
  struct gnufdisk_geometry* egeometry;
  struct gnufdisk_device** edevicepointer;
  struct gnufdisk_disklabel** edisklabelpointer;
  struct gnufdisk_partition** epartitionpointer;
  void **ereadbuffer;
  void **ewritebuffer;
  struct gnufdisk_device* enotopen;
};

Each element of this structure corresponds to an error. You can correct
the data  and lock the exception, then the library will resume the
operation. If the values are incorrect the exception will be reported
again. Here's an example:

     static int throw_handler(void* _hdata,
       struct gnufdisk_exception_info* _info, void* _edata)
     {
       union gnufdisk_device_exception_data* exception_data;

       exception_data = _edata;

       if(_info->error == GNUFDISK_DEVICE_EGEOMETRYLENGTH)
         {
           *exception_data.egeometrylength = 1;
           return 0; /* lock the exception */
         }

       return -1; /* let the exception continue */
     }

This way you can handle any error. If you do not manage the error the
operation will be canceled.


File: gnufdisk,  Node: Geometries,  Next: Devices,  Prev: Error reporting,  Up: gnufdisk-device library

6.2 Geometries
==============

In this library, the geometry of disk is represented by the structure
`struct gnufdisk_geometry'. In this structure, the positions are
represented in logical sectors.

This structure is not public, you can use it only through pointers. To
create/destroy variables of this type you can use the following
functions:

 -- Function: struct gnufdisk_geometry* gnufdisk_geometry_new ( struct
          gnufdisk_device* DEVICE )
     This function allocates a new geometry. The parameter DEVICE
     indicates the device to which this geometry refers. This is
     necessary for the alignment and size restrictions.

          Exceptions:
         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

         `GNUFDISK_COMMON_ENOMEM'

 -- Function: void gnufdisk_geometry_delete ( struct gnufdisk_geometry*
          GEOMETRY )
     This function destroys and frees the memory allocated for geometry
     GEOMETRY.

          Exceptions:
         `GNUFDISK_DEVICE_EGEOMETRYPOINTER'

         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

Once you have allocated a variable, you can set its value.  The values
of a geometry can be expressed through logical sectors or CHS values.
To put a value through a chs triplet, you can use the following
structure:

 -- Structure: struct gnufdisk_chs
     This structure is used to indicate geometric values through a
     triple (cylinder, head, sector), its definition is as follows: struct gnufdisk_chs {
       gnufdisk_integer cylinder;
       gnufdisk_integer head;
       gnufdisk_integer sector;
     };

To set/get geometry values, you can use the following functions:

 -- Function: struct gnufdisk_geometry* gnufdisk_geometry_set ( struct
          gnufdisk_geometry *GEOMETRY, gnufdisk_integer START,
          gnufdisk_integer LENGTH )
     This function sets the geometry GEOMETRY with the values START and
     LENGTH. On success return GEOMETRY.

          Exceptions:
         `GNUFDISK_DEVICE_EGEOMETRYPOINTER'

         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EGEOMETRYLENGTH'

 -- Function: struct gnufdisk_geometry* gnufdisk_geometry_set_chs (
          struct gnufdisk_geometry *GEOMETRY, struct gnufdisk_chs
          START, struct gnufdisk_chs LENGTH )
     This function is similar to the previous one, but the values are
     indicated by chs triplets.

          Exceptions:
         `GNUFDISK_DEVICE_EGEOMETRYPOINTER'

         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EGEOMETRYLENGTH'

 -- Function: gnufdisk_integer gnufdisk_geometry_start ( struct
          gnufdisk_geometry* )
     This function returns the start sector from GEOMETRY.

          Exceptions:
         `GNUFDISK_DEVICE_EGEOMETRYPOINTER'

         `GNUFDISK_DEVICE_EDEVICEPOINTER'

 -- Function: struct gnufdisk_chs gnufdisk_geometry_start_chs ( struct
          gnufdisk_geometry* )
     This function is similar to the previous one, but the value is
     returnet throught a chs triplet.

          Exceptions:
         `GNUFDISK_DEVICE_EGEOMETRYPOINTER'

         `GNUFDISK_DEVICE_EDEVICEPOINTER'

 -- Function: gnufdisk_integer gnufdisk_geometry_end ( struct
          gnufdisk_geometry* )
     This function returns the end sector from GEOMETRY.

          Exceptions:
         `GNUFDISK_DEVICE_EGEOMETRYPOINTER'

         `GNUFDISK_DEVICE_EDEVICEPOINTER'

 -- Function: struct gnufdisk_chs gnufdisk_geometry_end_chs ( struct
          gnufdisk_geometry* )
     This function is similar to the previous one, but the value is
     returnet throught a chs triplet.

 -- Function: gnufdisk_integer gnufdisk_geometry_length ( struct
          gnufdisk_geometry* )
     This function returns the lenght of GEOMETRY in sectors.

          Exceptions:
         `GNUFDISK_DEVICE_EGEOMETRYPOINTER'

         `GNUFDISK_DEVICE_EDEVICEPOINTER'

 -- Function: struct gnufdisk_chs gnufdisk_geometry_length_chs ( struct
          gnufdisk_geometry* )
     This function is similar to the previous one, but the value is
     returnet throught a chs triplet.

          Exceptions:
         `GNUFDISK_DEVICE_EGEOMETRYPOINTER'

         `GNUFDISK_DEVICE_EDEVICEPOINTER'


File: gnufdisk,  Node: Devices,  Next: Disklabels,  Prev: Geometries,  Up: gnufdisk-device library

6.3 Devices
===========

In this library devices are represented through the structure
`gnufdisk_device'. This structure is hidden, you can use it only
through pointers.

To create or destroy `struct gnufdisk_device' variables, you can use
the following functions:

 -- Function: struct gnufdisk_device* gnufdisk_device_new ( struct
          gnufdisk_string* MODULE, struct gnufdisk_string* OPTIONS )
     With this function you can create a new variable of type `struct
     gnufdisk_device'.  The parameter MODULE indicates which
     implementation you want to use for this variable. The parameter
     OPTIONS means options that you specify for this implementation.
     *Note Backend API::.

          Exceptions:
         `GNUFDISK_DEVICE_EMODULEPOINTER'

         `GNUFDISK_DEVICE_EMODULE'

         `GNUFDISK_COMMON_ENOMEM'

 -- Function: void gnufdisk_device_delete ( struct gnufdisk_device*
          DEVICE )
     This function destroys the variable DEVICE and frees all allocated
     resources. Once destroyed, this variable is no longer usable.

          Exceptions::
         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

Once a variable has been allocated, you can perform operations on it
using the following functions:

 -- Function: void gnufdisk_device_ref ( struct gnufdisk_device* DEVICE
          )
     This function adds a reference to the variable DEVICE. Even if
     someone tries to destroy it, the variable remains allocated as
     long as you do not destroy it.

          Exceptions:
         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

 -- Function: void gnufdisk_device_open ( struct gnufdisk_device*
          DEVICE, struct gnufdisk_string* PATH )
     This function binds the variable DEVICE variable to the file PATH
     (usually a device). After calling this function, you can begin to
     perform operations on this device.

          Exceptions:
         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

         `GNUFDISK_DEVICE_EPATHPOINTER'

         `GNUFDISK_DEVICE_ENOTSUP'

 -- Function: struct gnufdisk_disklabel * gnufdisk_device_disklabel (
          struct gnufdisk_device* DEVICE )
     This function allows you to get the partition table on the device
     DEVICE.

          Exceptions:
         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

         `GNUFDISK_DEVICE_ENOTSUP'

         `GNUFDISK_DEVICE_ENOTOPEN'

         `GNUFDISK_DEVICE_EDISKLABELSYSTEM'

 -- Function: struct gnufdisk_disklabel*
gnufdisk_device_create_disklabel ( struct gnufdisk_device* DEVICE,
          struct gnufdisk_string* SYSTEM )
     This function allows you to create a new partition table on
     DEVICE. The parameter SYSTEM indicates the type of table you want
     to create.

          Exceptions:
         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

         `GNUFDIKS_DEVICE_ENOTSUP'

         `GNUFDISK_COMMON_ENOMEM'

         `GNUFDISK_DEVICE_EDISKLABELSYSTEMPOINTER'

         `GNUFDISK_DEVICE_EDISKLABELSYSTEM'

         `GNUFDISK_DEVICE_ENOTOPEN'

 -- Function: void gnufdisk_device_set_parameter ( struct
          gnufdisk_device* DEVICE, struct gnufdisk_string* PARAMETER,
          const void* DATA, size_t SIZE )
     This function allows you to set a specific parameter on DEVICE.
     PARAMETER is the name of the parameter that you want to set. The
     parameter DATA is the value that you want to set. The parameter
     SIZE indicates the size of DATA.

          Exceptions:
         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

         `GNUFDISK_DEVICE_EPARAMETERPOINTER'

         `GNUFDISK_DEVICE_EPARAMETER'

         `GNUFDISK_DEVICE_EPARAMETERDATA'

         `GNUFDISK_DEVICE_ENOTSUP'

         `GNUFDISK_DEVICE_ENOTOPEN'

 -- Function: void gnufdisk_device_get_parameter ( struct
          gnufdisk_device* DEVICE, struct gnufdisk_string* PARAMETER,
          void* DATA, size_t SIZE )
     This function allows you to read a specific parameter from DEVICE.
     PARAMETER is the name of the parameter you want to read. The
     parameter DATA is the buffer where the value will be written. The
     parameter SIZE" indicates the size of DATA buffer.

          Exceptions:
         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

         `GNUFDISK_DEVICE_EPARAMETERPOINTER'

         `GNUFDISK_DEVICE_EPARAMETER'

         `GNUFDISK_DEVICE_EPARAMETERDATA'

         `GNUFDISK_DEVICE_ENOTSUP'

         `GNUFDISK_DEVICE_ENOTOPEN'

 -- Function: void gnufdisk_device_commit ( struct gnufdisk_device*
          DEVICE )
     Any changes made to devices remains in memory. With this function
     you can make the changes effective.

          Exceptions:
         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

         `GNUFDISK_DEVICE_ENOTSUP'

         `GNUFDISK_DEVICE_ENOTOPEN'

 -- Function: void gnufdisk_device_close ( struct gnufdisk_device*
          DEVICE )
     This function closes the file associated with DEVICE. The changes
     are not made effective. If you want to write changes, you must
     call `gnufdisk_device_commit' before closing DEVICE.

          Exceptions:
         `GNUFDISK_DEVICE_EDEVICEPOINTER'

         `GNUFDISK_DEVICE_EDEVICE'

         `GNUFDISK_DEVICE_ENOTSUP'

         `GNUFDISK_DEVICE_ENOTOPEN'


File: gnufdisk,  Node: Disklabels,  Next: Partitions,  Prev: Devices,  Up: gnufdisk-device library

6.4 Disklabels
==============

Partition tables are represented by the structure `struct
gnufdisk_disklabel'. This structure is hidden, you can use it only
through pointers. Also you can not implicitly create a variable of this
type, you can only get it through a device. *Note Devices::.

Once you have a pointer of type `struct gnufdisk_disklabel', you can
perform operations using the following functions:

 -- Function: void gnufdisk_disklabel_delete ( struct
          gnufdisk_disklabel *DISKLABEL )
          Exceptions:
         `GNUFDISK_DEVICE_EDISKLABELPOINTER'

         `GNUFDISK_DEVICE_EDISKLABEL'

 -- Function: void gnufdisk_disklabel_ref ( struct gnufdisk_disklabel
          *DISKLABEL )
          Exceptions:
         `GNUFDISK_DEVICE_EDISKLABELPOINTER'

         `GNUFDISK_DEVICE_EDISKLABEL'

 -- Function: void gnufdisk_disklabel_raw ( struct gnufdisk_disklabel
          *DISKLABEL, void **DEST, size_t * SIZE )
          Exceptions:
         `GNUFDISK_DEVICE_EDISKLABELPOINTER'

         `GNUFDISK_DEVICE_EDISKLABEL'

 -- Function: struct gnufdisk_string* gnufdisk_disklabel_system (
          struct gnufdisk_disklabel* DISKLABEL )
          Exceptions:
         `GNUFDISK_DEVICE_EDISKLABELPOINTER'

         `GNUFDISK_DEVICE_EDISKLABEL'

 -- Function: struct gnufdisk_partition* gnufdisk_disklabel_partition (
          struct gnufdisk_disklabel* DISKLABEL, size_t NUMBER )
          Exceptions:
         `GNUFDISK_DEVICE_EDISKLABELPOINTER'

         `GNUFDISK_DEVICE_EDISKLABEL'

 -- Function: struct gnufdisk_partition*
gnufdisk_disklabel_create_partition ( struct gnufdisk_disklabel*
          DISKLABEL, struct gnufdisk_geometry* START_RANGE, struct
          gnufdisk_geometry* END_RANGE, struct gnufdisk_string* TYPE )
          Exceptions:
         `GNUFDISK_DEVICE_EDISKLABELPOINTER'

         `GNUFDISK_DEVICE_EDISKLABEL'

 -- Function: void gnufdisk_disklabel_remove_partition ( struct
          gnufdisk_disklabel* DISKLABEL, size_t NUMBER )
          Exceptions:
         `GNUFDISK_DEVICE_EDISKLABELPOINTER'

         `GNUFDISK_DEVICE_EDISKLABEL'

 -- Function: void gnufdisk_disklabel_set_parameter ( struct
          gnufdisk_disklabel* DISKLABEL, struct gnufdisk_string*
          PARAMETER, const void* DATA, size_t SIZE )
          Exceptions:
         `GNUFDISK_DEVICE_EDISKLABELPOINTER'

         `GNUFDISK_DEVICE_EDISKLABEL'

 -- Function: void gnufdisk_disklabel_get_parameter ( struct
          gnufdisk_disklabel* DISKLABEL, struct gnufdisk_string*
          PARAMETER, void* DATA, size_t SIZE )
          Exceptions:
         `GNUFDISK_DEVICE_EDISKLABELPOINTER'

         `GNUFDISK_DEVICE_EDISKLABEL'


File: gnufdisk,  Node: Partitions,  Next: gnufdisk-device example,  Prev: Disklabels,  Up: gnufdisk-device library

6.5 Partitions
==============

In this library partitions are represented by the structure `struct
gnufdisk_partition'. This structure is hidden, you can use it only
through pointers. Also you can not implicitly allocate variables of this
type, you can only get them through a partition table. *Note
Disklabels::.

When you have a variable of type `struct gnufdisk_partition', you can
use the following functions to work on it:

 -- Function: void gnufdisk_partition_ref ( struct gnufdisk_partition*
          PARTITION )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: void gnufdisk_partition_delete ( struct
          gnufdisk_partition* PARTITION )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: void gnufdisk_partition_set_parameter ( struct
          gnufdisk_partition* PARTITION struct gnufdisk_string*
          PARAMETER, const void* DATA, size_t SIZE )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: void gnufdisk_partition_get_parameter ( struct
          gnufdisk_partition* PARAMETER, struct gnufdisk_string* PARAM,
          void* DATA, size_t SIZE )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: struct gnufdisk_string* gnufdisk_partition_type ( struct
          gnufdisk_partition* PARTITION )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: int gnufdisk_partition_number ( struct
          gnufdisk_partition* PARTITION )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: gnufdisk_integer gnufdisk_partition_start ( struct
          gnufdisk_partition* PARTITION )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: gnufdisk_integer gnufdisk_partition_length ( struct
          gnufdisk_partition* PARTITION )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: void gnufdisk_partition_move ( struct gnufdisk_partition*
          PARTITION, struct gnufdisk_geometry* START_RANGE )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: void gnufdisk_partition_resize ( struct
          gnufdisk_partition* PARTITION, struct gnufdisk_geometry*
          END_RANGE )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: int gnufdisk_partition_read ( struct gnufdisk_partition*
          PARTITION, gnufdisk_integer START, void* BUF, size_t SIZE )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'

 -- Function: int gnufdisk_partition_write ( struct gnufdisk_partition*
          PARTITION, gnufdisk_integer SECTOR, const void* BUF, size_t
          SIZE )
          Exceptions:
         `GNUFDISK_DEVICE_EPARTITIONPOINTER'

         `GNUFDISK_DEVICE_EPARTITION'


File: gnufdisk,  Node: gnufdisk-device example,  Prev: Partitions,  Up: gnufdisk-device library

6.6 gnufdisk-device example
===========================

In this section we will make a small example of how to use the library
gnufdisk-device. Since we do not have a module, we create a basic as it
only exports a few functions:

     #include <stdio.h>
     #include <gnufdisk-device.h>
     #include <gnufdisk-device-internals.h>

     static void device_open(void *_dev, struct gnufdisk_string* _path)
     {
       printf("open `%s' with device %p\n",
              gnufdisk_string_c_string(_path), _dev);
     }

     static void device_delete(void* _dev)
     {
       printf("delete device %p\n", _dev);
       free(_dev);
     }

     static struct gnufdisk_device_operations devop = {0};

     void module_register(struct gnufdisk_string * _options,
                          struct gnufdisk_device_operations * _operations,
                          void **_private_data)
     {
       printf("register module `testmod'\n");


       devop.open = &device_open;
       devop.delete = &device_delete;

       *_operations = devop;

       *_private_data = malloc(16);
     }

Once the module is compiled, we can test its use. What follows is a
piece of code that uses the module:

     #include <stdio.h>

     #include <gnufdisk-exception.h>
     #include <gnufdisk-device.h>

     int main(int argc, char* argv[])
     {
       struct gnufdisk_string* s;
       struct gnufdisk_device* dev;

       GNUFDISK_TRY(NULL, NULL)
         {
           s = gnufdisk_string_new("testmod");
           dev = gnufdisk_device_new(s, NULL);

           gnufdisk_string_set(s, "/dev/sda");
           gnufdisk_device_open(dev, s);
           sleep(1);

           gnufdisk_device_delete(dev);
           gnufdisk_string_delete(s);
         }
       GNUFDISK_CATCH_DEFAULT
         {
           printf("caught an exception from %s:%d: %s\n",
                  exception_info.file,
                  exception_info.line,
                  exception_info.message);
         }
       GNUFDISK_EXCEPTION_END;

       return 0;
     }


File: gnufdisk,  Node: gnufdisk-devicemanager library,  Next: gnufdisk-userinterface library,  Prev: gnufdisk-device library,  Up: Top

7 gnufdisk-devicemanager library
********************************

 -- Function: struct gnufdisk_devicemanager *
          gnufdisk_devicemanager_new ( struct gnufdisk_userinterface
          *UI )

 -- Function: int gnufdisk_devicemanager_ref ( struct
          gnufdisk_devicemanager *DM )

 -- Function: int gnufdisk_devicemanager_delete ( struct
          gnufdisk_devicemanager *DM )

 -- Function: struct gnufdisk_geometry *
gnufdisk_devicemanager_geometry_new ( struct gnufdisk_devicemanager*
          DM, struct gnufdisk_device* DEV )

 -- Function: struct gnufdisk_geometry *
gnufdisk_devicemanager_geometry_duplicate ( struct
          gnufdisk_devicemanager* DM, struct gnufdisk_geometry *GEOM )

 -- Function: int gnufdisk_devicemanager_geometry_delete ( struct
          gnufdisk_devicemanager* DM, struct gnufdisk_geometry* GEOM )

 -- Function: struct gnufdisk_geometry *
gnufdisk_devicemanager_geometry_set ( struct gnufdisk_devicemanager*
          DM, struct gnufdisk_geometry* GEOM, gnufdisk_integer START,
          gnufdisk_integer END )

 -- Function: gnufdisk_integer gnufdisk_devicemanager_geometry_start (
          struct gnufdisk_devicemanager* DM, struct gnufdisk_geometry*
          GEOM)

 -- Function: struct gnufdisk_chs
gnufdisk_devicemanager_geometry_start_chs ( struct
          gnufdisk_devicemanager* DM, struct gnufdisk_geometry* GEOM )

 -- Function: gnufdisk_integer gnufdisk_devicemanager_geometry_end (
          struct gnufdisk_devicemanager* DM, struct gnufdisk_geometry*
          GEOM )

 -- Function: struct gnufdisk_chs
gnufdisk_devicemanager_geometry_end_chs ( struct
          gnufdisk_devicemanager* DM, struct gnufdisk_geometry* GEOM )

 -- Function: gnufdisk_integer gnufdisk_devicemanager_geometry_length (
          struct gnufdisk_devicemanager* DM, struct gnufdisk_geometry*
          GEOM )

 -- Function: struct gnufdisk_chs
gnufdisk_devicemanager_geometry_length_chs ( struct
          gnufdisk_devicemanager* DM, struct gnufdisk_geometry* GEOM )

 -- Function: struct gnufdisk_device *
          gnufdisk_devicemanager_device_new ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_string *MODULE,
          struct gnufdisk_string *MODULE_OPTIONS )

 -- Function: int gnufdisk_devicemanager_device_open ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_device *DEV,
          struct gnufdisk_string *PATH )

 -- Function: struct gnufdisk_disklabel *
gnufdisk_devicemanager_device_disklabel ( struct gnufdisk_devicemanager
          *DM, struct gnufdisk_device *DEV )

 -- Function: struct gnufdisk_disklabel *
gnufdisk_devicemanager_device_create_disklabel ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_device *DEV,
          struct gnufdisk_string *SYSTEM )

 -- Function: int gnufdisk_devicemanager_device_set_parameter ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_device *DEV,
          struct gnufdisk_string *PARAM, const void *DATA, size_t SIZE )

 -- Function: int gnufdisk_devicemanager_device_get_parameter ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_device *DEV,
          struct gnufdisk_string *PARAM, void *DEST, size_t SIZE )

 -- Function: int gnufdisk_devicemanager_device_commit ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_device *DEV )

 -- Function: int gnufdisk_devicemanager_device_close ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_device *DEV )

 -- Function: int gnufdisk_devicemanager_device_delete ( struct
          gnufdisk_devicemanager * DM, struct gnufdisk_device* DEV )

 -- Function: int gnufdisk_devicemanager_disklabel_raw ( struct
          gnufdisk_devicemanager * DM, struct gnufdisk_disklabel *
          DISK, void **DEST, size_t *SIZE )

 -- Function: struct gnufdisk_string *
gnufdisk_devicemanager_disklabel_system ( struct gnufdisk_devicemanager
          *DM, struct gnufdisk_disklabel *DISK )

 -- Function: struct gnufdisk_partition *
gnufdisk_devicemanager_disklabel_partition ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_disklabel *DISK,
          size_t NUMBER )

 -- Function: struct gnufdisk_partition *
gnufdisk_devicemanager_disklabel_create_partition ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_disklabel *DISK,
          struct gnufdisk_geometry *START, struct gnufdisk_geometry
          *END, struct gnufdisk_string *TYPE )

 -- Function: int gnufdisk_devicemanager_disklabel_remove_partition (
          struct gnufdisk_devicemanager *DM, struct gnufdisk_disklabel
          *DISK, size_t NUMBER )

 -- Function: int gnufdisk_devicemanager_disklabel_set_parameter (
          struct gnufdisk_devicemanager *DM, struct gnufdisk_disklabel
          *DISK, struct gnufdisk_string *PARAM, const void *DATA,
          size_t SIZE )

 -- Function: int gnufdisk_devicemanager_disklabel_get_parameter (
          struct gnufdisk_devicemanager *DM, struct gnufdisk_disklabel
          *DISK, struct gnufdisk_string *PARAM, void *DEST, size_t SIZE
          )

 -- Function: int gnufdisk_devicemanager_partition_set_parameter (
          struct gnufdisk_devicemanager *DM, struct gnufdisk_partition
          *PART, struct gnufdisk_string *PARAM, const void *DATA,
          size_t SIZE )

 -- Function: int gnufdisk_devicemanager_disklabel_delete ( struct
          gnufdisk_devicemanager* DM, struct gnufdisk_disklabel* DISK )

 -- Function: int gnufdisk_devicemanager_partition_get_parameter (
          struct gnufdisk_devicemanager *DM, struct gnufdisk_partition
          *PART, struct gnufdisk_string *PARAM, void *DEST, size_t SIZE
          )

 -- Function: struct gnufdisk_string *
gnufdisk_devicemanager_partition_type ( struct gnufdisk_devicemanager
          *DM, struct gnufdisk_partition *PART )

 -- Function: gnufdisk_integer gnufdisk_devicemanager_partition_start (
          struct gnufdisk_devicemanager* DM, struct gnufdisk_partition
          *PART )

 -- Function: gnufdisk_integer gnufdisk_devicemanager_partition_length
          ( struct gnufdisk_devicemanager* DM, struct
          gnufdisk_partition *PART )

 -- Function: int gnufdisk_devicemanager_partition_number ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_partition *PART )

 -- Function: int gnufdisk_devicemanager_partition_move ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_partition *PART,
          struct gnufdisk_geometry *RANGE )

 -- Function: int gnufdisk_devicemanager_partition_resize ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_partition *PART,
          struct gnufdisk_geometry *RANGE )

 -- Function: int gnufdisk_devicemanager_partition_read ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_partition *PART,
          gnufdisk_integer START, void *BUF, size_t SIZE)

 -- Function: int gnufdisk_devicemanager_partition_write ( struct
          gnufdisk_devicemanager *DM, struct gnufdisk_partition *PART,
          gnufdisk_integer START, const void *BUF, size_t SIZE )

 -- Function: int gnufdisk_devicemanager_partition_delete ( struct
          gnufdisk_devicemanager* DM, struct gnufdisk_partition* PART )


File: gnufdisk,  Node: gnufdisk-userinterface library,  Next: Scheme shell,  Prev: gnufdisk-devicemanager library,  Up: Top

8 gnufdisk-userinterface library
********************************

 -- Function: struct gnufdisk_userinterface* gnufdisk_userinterface_new
          ( void )

 -- Function: int gnufdisk_userinterface_ref ( struct
          gnufdisk_userinterface* UI )

 -- Function: int gnufdisk_userinterface_delete ( struct
          gnufdisk_userinterface* UI )

 -- Function: int gnufdisk_userinterface_run ( struct
          gnufdisk_userinterface* UI, struct gnufdisk_string*
          IMPLEMENTATION, int ARGC, char **ARGV )

 -- Function: int gnufdisk_userinterface_print ( struct
          gnufdisk_userinterface* UI, const char* FORMAT, ... )

 -- Function: int gnufdisk_userinterface_yes_no ( struct
          gnufdisk_userinterface* UI, const char * FORMAT, ... )

 -- Function: struct gnufdisk_string* gnufdisk_userinterface_get_path (
          struct gnufdisk_userinterface* UI, const char *FORMAT, ... )

 -- Function: struct gnufdisk_string*
gnufdisk_userinterface_get_disklabel_system ( struct
          gnufdisk_userinterface* UI, const char* FORMAT, ... )

 -- Function: int gnufdisk_userinterface_get_geometry ( struct
          gnufdisk_userinterface* UI, struct gnufdisk_devicemanager*
          DM, struct gnufdisk_geometry* GEOM, const char* FORMAT, ... )

 -- Function: struct gnufdisk_string*
gnufdisk_userinterface_get_partition_type ( struct
          gnufdisk_userinterface* UI, const char* FORMAT, ... )


File: gnufdisk,  Node: Scheme shell,  Next: Backend API,  Prev: gnufdisk-userinterface library,  Up: Top

9 Scheme shell
**************

To run gnufdisk in shell mode:
     ~$ gnufdisk shell
     guile>

In shell mode you can use all symbols, plus the `gnufdisk-help'

 -- Variable: *userinterface*

 -- Variable: *command-line*

 -- Function: gnufdisk-help

 -- Function: gnufdisk-make-geometry DEVICEMANAGER

 -- Function: gnufdisk-geometry? GEOMETRY

 -- Function: gnufdisk-geometry-set GEOMETRY START LENGTH

 -- Function: gnufdisk-geometry-start GEOMETRY

 -- Function: gnufdisk-geometry-end GEOMETRY

 -- Function: gnufdisk-geometry-length GEOMETRY

 -- Function: gnufdisk-make-devicemanager USERINTERFACE

 -- Function: gnufdisk-devicemanager? DEVICEMANAGER

 -- Function: gnufdisk-devicemanager-make-device DEVICEMANAGER MODULE
          OPTIONS

 -- Function: gnufdisk-device? DEVICE

 -- Function: gnufdisk-device-open DEVICE PATH

 -- Function: gnufdisk-device-disklabel DEVICE

 -- Function: gnufdisk-device-create-disklabel DEVICE SYSTEM

 -- Function: gnufdisk-device-set-parameter DEVICE NAME VALUE

 -- Function: gnufdisk-device-get-parameter DEVICE NAME TYPE
          Types:
         `'INT'

         `'INTEGER'

         `'STR'

         `'STRING'

 -- Function: gnufdisk-device-commit DEVICE

 -- Function: gnufdisk-device-close DEVICE

 -- Function: gnufdisk-disklabel? DISKLABEL

 -- Function: gnufdisk-disklabel-raw DISKLABEL

 -- Function: gnufdisk-disklabel-system DISKLABEL

 -- Function: gnufdisk-disklabel-partition DISKLABEL NUMBER

 -- Function: gnufdisk-disklabel-create-partition DISKLABEL START-RANGE
          END-RANGE SYSTEM

 -- Function: gnufdisk-disklabel-remove-partition DISKLABEL NUMBER

 -- Function: gnufdisk-disklabel-set-parameter DISKLABEL NAME VALUE

 -- Function: gnufdisk-disklabel-get-parameter DISKLABEL NAME TYPE
          Types:
         `'INT'

         `'INTEGER'

         `'STR'

         `'STRING'

 -- Function: gnufdisk-partition? PARTITION

 -- Function: gnufdisk-partition-set-parameter PARTITION NAME VALUE

 -- Function: gnufdisk-partition-get-parameter PARTITION NAME TYPE
          Types:
         `'INT'

         `'INTEGER'

         `'STR'

         `'STRING'

 -- Function: gnufdisk-partition-type PARTITION

 -- Function: gnufdisk-partition-geometry PARTITION DEVICE

 -- Function: gnufdisk-partition-number PARTITION

 -- Function: gnufdisk-partition-move PARTITION START-RANGE

 -- Function: gnufdisk-partition-resize PARTITION END-RANGE

 -- Function: gnufdisk-partition-read PARTITION START-SECTOR SIZE

 -- Function: gnufdisk-partition-write PARTITION START-SECTOR RAW-DATA

 -- Function: gnufdisk-raw? RAW-DATA

 -- Function: gnufdisk-userinterface-set-hook USERINTERFACE NAME
          PROCEDURE
          Hooks::

           -- Function: print MESSAGE

           -- Function: error MESSAGE

           -- Function: yes-no MESSAGE

           -- Function: get-path MESSAGE

           -- Function: get-disklabel-system MESSAGE

           -- Function: get-geometry MESSAGE GEOM

           -- Function: get-partition-system MESSAGE



File: gnufdisk,  Node: Backend API,  Next: Functions index,  Prev: Scheme shell,  Up: Top

10 Backend API
**************

* Menu:

* Backend example::

 -- Type: struct gnufdisk_device_operations
     struct gnufdisk_device_operations
     {
       void (*open)(void*, struct gnufdisk_string*);
       void (*disklabel)(void*,
                         struct gnufdisk_disklabel_operations*,
                         void**);
       void (*create_disklabel)(void*,
                                struct gnufdisk_string*,
                                struct gnufdisk_disklabel_operations*,
                                void**);
       void (*set_parameter)(void*,
                             struct gnufdisk_string*,
                             const void*,
                             size_t);
       void (*get_parameter)(void*,
                             struct gnufdisk_string*,
                             void*,
                             size_t);
       void (*commit)(void*);
       void (*close)(void*);
       void (*delete)(void*);
     };

 -- Type: struct gnufdisk_disklabel_operations
     struct gnufdisk_disklabel_operations
     {
       void (*raw)(void*, void**, size_t*);
       struct gnufdisk_string* (*system)(void*);
       void (*partition)(void*,
                         size_t,
                         struct gnufdisk_partition_operations*,
                         void**);
       void (*create_partition)(void*,
                                struct gnufdisk_geometry*,
                                struct gnufdisk_geometry*,
                                struct gnufdisk_string*,
                                struct gnufdisk_partition_operations*,
                                void**);
       void (*remove_partition)(void*, size_t);
       void (*set_parameter)(void*,
                             struct gnufdisk_string*,
                             const void*,
                             size_t);
       void (*get_parameter)(void*,
                             struct gnufdisk_string*,
                             void*,
                             size_t);
       void (*delete)(void*);
     };

 -- Type: struct gnufdisk_partition_operations
     struct gnufdisk_partition_operations
     {
       void (*set_parameter)(void*,
                             struct gnufdisk_string*,
                             const void*,
                             size_t);
       void (*get_parameter)(void*,
                             struct gnufdisk_string*,
                             void*,
                             size_t);
       struct gnufdisk_string* (*type)(void*);
       gnufdisk_integer (*start)(void*);
       gnufdisk_integer (*length)(void*);
       int (*number)(void*);
       void (*move)(void*, struct gnufdisk_geometry*);
       void (*resize)(void*, struct gnufdisk_geometry*);
       int (*read)(void*,
                   gnufdisk_integer,
                   void*,
                   size_t);
       int (*write)(void*,
                    gnufdisk_integer,
                    const void*,
                    size_t _size);
       void (*delete)(void*);
     };

 -- Function: int register_module ( struct gnufdisk_device_operations*
          DEVOPS, void **PDATA )


File: gnufdisk,  Node: Backend example,  Prev: Backend API,  Up: Backend API

10.1 Backend example
====================

     #include <stdlib.h>
     #include <string.h>

     #include <gnufdisk-debug.h>
     #include <gnufdisk-exception.h>
     #include <gnufdisk-device-internals.h>

     #define INFO (getenv("SAMPLE_BACKEND") != NULL)

     static size_t ndev = 0;
     static size_t ndisk = 0;
     static size_t npart = 0;

     static void
     partition_set_parameter (void *_data,
     			 struct gnufdisk_string *_name,
     			 const void *_pdata, size_t _psize)
     {
       GNUFDISK_LOG ((INFO,
     		 "partition_set_parameter(%s, %p, %p, %u)",
     		 _data, _name, _pdata, _psize));
     }

     static void
     partition_get_parameter (void *_data,
     			 struct gnufdisk_string *_name,
     			 void *_pdata, size_t _psize)
     {
       GNUFDISK_LOG ((INFO,
     		 "partition_get_parameter(%s, %p, %p, %u)",
     		 _data, _name, _pdata, _psize));
     }

     static struct gnufdisk_string *
     partition_type (void *_data)
     {
       struct gnufdisk_string *s;

       GNUFDISK_LOG ((INFO, "partition_type(%s)", _data));

       if ((s = gnufdisk_string_new ("undefined")) == NULL)
         GNUFDISK_THROW (0, NULL, GNUFDISK_DEVICE_ENOMEM, NULL,
     		    "can not allocate memory");

       return s;
     }

     static gnufdisk_integer
     partition_start (void *_data)
     {
       GNUFDISK_LOG ((INFO, "partition_start(%s)", _data));
       return 0xffff;
     }

     static gnufdisk_integer
     partition_end (void *_data)
     {
       GNUFDISK_LOG ((INFO, "partition_end(%s)", _data));
       return 0xffff;
     }

     static int
     partition_number (void *_data)
     {
       GNUFDISK_LOG ((INFO, "partition_number(%s)", _data));
       return 0x45;
     }

     static void
     partition_move (void *_data, struct gnufdisk_geometry *_s)
     {
       GNUFDISK_LOG ((INFO, "partition_move(%s, %p)", _data, _s));
     }

     static void
     partition_resize (void *_data, struct gnufdisk_geometry *_e)
     {
       GNUFDISK_LOG ((INFO, "partition_resize(%s, %p)", _data, _e));
     }

     static int
     partition_read (void *_data, gnufdisk_integer _sector, void *_dest,
     		size_t _size)
     {
       GNUFDISK_LOG ((INFO, "partition_read(%s, %lld, %p, %u)",
             _data, _sector, _dest, _size));
       return _size;
     }

     static int
     partition_write (void *_data, gnufdisk_integer _sector,
         const void *_src, size_t _size)
     {
       GNUFDISK_LOG ((INFO, "partition_write(%s, %lld, %p, %u)",
             _data, _sector, _src, _size));
     }

     static void
     partition_delete (void *_data)
     {
       GNUFDISK_LOG ((INFO, "partition_delete(%s)", _data));
       free(_data);
     }

     static struct gnufdisk_partition_operations partition_operations = {
       &partition_set_parameter,
       &partition_get_parameter,
       &partition_type,
       &partition_start,
       &partition_end,
       &partition_number,
       &partition_move,
       &partition_resize,
       &partition_read,
       &partition_write,
       &partition_delete
     };


     static void
     disklabel_raw (void *_data, void **_dest, size_t * _size)
     {
       GNUFDISK_LOG ((INFO, "disklabel_raw(%s, %p, %p)",
             _data, _dest, _size));

       if ((*_dest = malloc (512)) == NULL)
         GNUFDISK_THROW (0, NULL, GNUFDISK_DEVICE_ENOMEM, NULL,
     		    "can not allocate memory");

       *_size = 512;
     }

     static struct gnufdisk_string *
     disklabel_system (void *_data)
     {
       struct gnufdisk_string *s;

       GNUFDISK_LOG ((INFO, "disklabel_system(%s)", _data));

       if ((s = gnufdisk_string_new ("BSD")) == NULL)
         GNUFDISK_THROW (0, NULL, GNUFDISK_DEVICE_ENOMEM, NULL,
     		    "can not allocate memory");

       return s;
     }

     static void
     disklabel_partition (void *_data, size_t _n,
     		     struct gnufdisk_partition_operations *_operations,
     		     void **_specific)
     {
       char buf[64];

       GNUFDISK_LOG ((INFO, "disklabel_partition(%s, %u, %p, %p)",
             _data, _n, _operations, _specific));

       memcpy (_operations, &partition_operations,
           sizeof (partition_operations));

       npart++;

       snprintf(buf, sizeof(buf), "PARTITION %u", npart);

       *_specific = strdup(buf);
     }

     static void
     disklabel_create_partition (void *_data,
     			    struct gnufdisk_geometry *_s,
     			    struct gnufdisk_geometry *_e,
     			    struct gnufdisk_string *_type,
     			    struct gnufdisk_partition_operations
                 *_operations,
     			    void **_specific)
     {
       char buf[64];

       GNUFDISK_LOG ((INFO,
     		 "disklabel_create_partition(%s, %p, %p, %p, %p, %p)",
     		 _data, _s, _e, _type, _operations, _specific));

       memcpy (_operations,
           &partition_operations, sizeof (partition_operations));

       npart++;

       snprintf(buf, sizeof(buf), "PARTITION %u", npart);
       *_specific = strdup(buf);
     }

     static void
     disklabel_remove_partition (void *_data, size_t _n)
     {
       GNUFDISK_LOG ((INFO,
             "disklabel_remove_partition(%s, %u)", _data, _n));
     }

     static void
     disklabel_set_parameter (void *_data, struct gnufdisk_string *_name,
     			 const void *_pdata, size_t _psize)
     {
       GNUFDISK_LOG ((INFO,
             "disklabel_set_parameter(%s, %p, %p, %u)", _data,
     		    _name, _pdata, _psize));
     }

     static void
     disklabel_get_parameter (void *_data, struct gnufdisk_string *_name,
     			 void *_pdata, size_t _psize)
     {
       GNUFDISK_LOG ((INFO, "disklabel_get_parameter(%s, %p, %p, %u)", _data,
     		 _name, _pdata, _psize));
     }

     static void
     disklabel_delete (void *_data)
     {
       GNUFDISK_LOG ((INFO, "disklabel_delete(%s)", _data));
       free(_data);
     }

     static struct gnufdisk_disklabel_operations disklabel_operations = {
       &disklabel_raw,
       &disklabel_system,
       &disklabel_partition,
       &disklabel_create_partition,
       &disklabel_remove_partition,
       &disklabel_set_parameter,
       &disklabel_get_parameter,
       &disklabel_delete
     };


     static void
     device_open (void *_data, struct gnufdisk_string *_path)
     {
       GNUFDISK_LOG ((INFO, "device_open(%s, %p)", _data, _path));
     }

     static void
     device_disklabel (void *_data,
     		  struct gnufdisk_disklabel_operations *_operations,
     		  void **_specific)
     {
       char buf[64];

       GNUFDISK_LOG ((INFO, "device_disklabel(%s, %p, %p)",
             _data, _operations, _specific));

       memcpy (_operations,
           &disklabel_operations, sizeof (disklabel_operations));

       ndisk++;

       snprintf(buf, sizeof(buf), "DISKLABEL %u", ndisk);

       *_specific = strdup(buf);
     }

     static void
     device_create_disklabel (void *_data, struct gnufdisk_string *_type,
       struct gnufdisk_disklabel_operations *_operations, void **_specific)
     {
       char buf[64];

       GNUFDISK_LOG ((INFO, "device_create_disklabel(%s, %p, %p, %p)",
             _data, _type, _operations, _specific));

       memcpy (_operations,
         &disklabel_operations, sizeof (disklabel_operations));

       ndisk++;

       snprintf(buf, sizeof(buf), "DISKLABEL %u", ndisk);

       *_specific = strdup(buf);
     }

     static void
     device_set_parameter (void *_data, struct gnufdisk_string *_parameter,
     		      const void *_pdata, size_t _psize)
     {
       GNUFDISK_LOG ((INFO, "device_set_parameter(%s, %p, %p, %u)", _data,
     		 _parameter, _pdata, _psize));
     }

     static void
     device_get_parameter (void *_data, struct gnufdisk_string *_parameter,
     		      void *_pdata, size_t _psize)
     {
       char *param;

       GNUFDISK_LOG ((INFO, "device_get_parameter(%s, %p, %p, %u)", _data,
     		 _parameter, _pdata, _psize));

       if ((param = gnufdisk_string_c_string_dup (_parameter)) == NULL)
         GNUFDISK_THROW (0, NULL, GNUFDISK_DEVICE_ENOMEM, NULL,
     		    "can not allocate memory");

       gnufdisk_exception_register_unwind_handler (&free, param);

       if (strcmp (param, "SECTORS-PER-TRACK") == 0)
         {
           if (_psize != sizeof (gnufdisk_integer))
     	GNUFDISK_THROW (0, NULL, GNUFDISK_DEVICE_EPARAMETERSIZE, NULL,
     			"unexpected parameter size: %u", _psize);

           *((gnufdisk_integer *) _pdata) = 0xff;
         }
       else if (strcmp (param, "HEADS-PER-CYLINDER") == 0)
         {
           if (_psize != sizeof (gnufdisk_integer))
     	GNUFDISK_THROW (0, NULL, GNUFDISK_DEVICE_EPARAMETERSIZE, NULL,
     			"unexpected parameter size: %u", _psize);

           *((gnufdisk_integer *) _pdata) = 0x02;
         }
       else
         GNUFDISK_THROW (0, NULL, GNUFDISK_DEVICE_EPARAMETER, NULL,
     		    "parameter `%s' is not supported", param);

       free (param);
     }

     static void
     device_commit (void *_data)
     {
       GNUFDISK_LOG ((INFO, "device_commit(%s)", _data));
     }

     static void
     device_close (void *_data)
     {
       GNUFDISK_LOG ((INFO, "device_close(%s)", _data));
     }

     static void
     device_delete (void *_data)
     {
       GNUFDISK_LOG ((INFO, "device_delete(%s)", _data));
       free(_data);
     }

     static struct gnufdisk_device_operations device_operations = {
       &device_open,
       &device_disklabel,
       &device_create_disklabel,
       &device_set_parameter,
       &device_get_parameter,
       &device_commit,
       &device_close,
       &device_delete
     };

     void
     module_register (struct gnufdisk_string *_options,
     		 struct gnufdisk_device_operations *_operations,
     		 void **_pdata)
     {
       char buf[64];

       GNUFDISK_LOG ((INFO, "register_module(%p, %p, %p)",
         _options, _operations, _pdata));

       memcpy (_operations,
         &device_operations, sizeof (device_operations));

       ndev++;

       snprintf(buf, sizeof(buf), "DEVICE %u", ndev);
       *_pdata = strdup(buf);
     }


File: gnufdisk,  Node: Functions index,  Next: Type index,  Prev: Backend API,  Up: Top

Appendix A Functions index
**************************

 [index ]
* Menu:

* error:                                 Scheme shell.        (line 123)
* get-disklabel-system:                  Scheme shell.        (line 129)
* get-geometry:                          Scheme shell.        (line 131)
* get-partition-system:                  Scheme shell.        (line 133)
* get-path:                              Scheme shell.        (line 127)
* gnufdisk-device-close:                 Scheme shell.        (line  60)
* gnufdisk-device-commit:                Scheme shell.        (line  58)
* gnufdisk-device-create-disklabel:      Scheme shell.        (line  44)
* gnufdisk-device-disklabel:             Scheme shell.        (line  42)
* gnufdisk-device-get-parameter:         Scheme shell.        (line  48)
* gnufdisk-device-open:                  Scheme shell.        (line  40)
* gnufdisk-device-set-parameter:         Scheme shell.        (line  46)
* gnufdisk-device?:                      Scheme shell.        (line  38)
* gnufdisk-devicemanager-make-device:    Scheme shell.        (line  36)
* gnufdisk-devicemanager?:               Scheme shell.        (line  33)
* gnufdisk-disklabel-create-partition:   Scheme shell.        (line  71)
* gnufdisk-disklabel-get-parameter:      Scheme shell.        (line  77)
* gnufdisk-disklabel-partition:          Scheme shell.        (line  68)
* gnufdisk-disklabel-raw:                Scheme shell.        (line  64)
* gnufdisk-disklabel-remove-partition:   Scheme shell.        (line  73)
* gnufdisk-disklabel-set-parameter:      Scheme shell.        (line  75)
* gnufdisk-disklabel-system:             Scheme shell.        (line  66)
* gnufdisk-disklabel?:                   Scheme shell.        (line  62)
* gnufdisk-geometry-end:                 Scheme shell.        (line  27)
* gnufdisk-geometry-length:              Scheme shell.        (line  29)
* gnufdisk-geometry-set:                 Scheme shell.        (line  23)
* gnufdisk-geometry-start:               Scheme shell.        (line  25)
* gnufdisk-geometry?:                    Scheme shell.        (line  21)
* gnufdisk-help:                         Scheme shell.        (line  17)
* gnufdisk-make-devicemanager:           Scheme shell.        (line  31)
* gnufdisk-make-geometry:                Scheme shell.        (line  19)
* gnufdisk-partition-geometry:           Scheme shell.        (line 103)
* gnufdisk-partition-get-parameter:      Scheme shell.        (line  91)
* gnufdisk-partition-move:               Scheme shell.        (line 107)
* gnufdisk-partition-number:             Scheme shell.        (line 105)
* gnufdisk-partition-read:               Scheme shell.        (line 111)
* gnufdisk-partition-resize:             Scheme shell.        (line 109)
* gnufdisk-partition-set-parameter:      Scheme shell.        (line  89)
* gnufdisk-partition-type:               Scheme shell.        (line 101)
* gnufdisk-partition-write:              Scheme shell.        (line 113)
* gnufdisk-partition?:                   Scheme shell.        (line  87)
* gnufdisk-raw?:                         Scheme shell.        (line 115)
* gnufdisk-userinterface-set-hook:       Scheme shell.        (line 118)
* GNUFDISK_CATCH:                        Catch.               (line  12)
* GNUFDISK_CATCH_DEFAULT:                Catch.               (line  17)
* gnufdisk_check_memory:                 Page fault handling. (line  15)
* gnufdisk_device_close:                 Devices.             (line 167)
* gnufdisk_device_commit:                Devices.             (line 153)
* gnufdisk_device_create_disklabel:      Devices.             (line  86)
* gnufdisk_device_delete:                Devices.             (line  30)
* gnufdisk_device_disklabel:             Devices.             (line  69)
* gnufdisk_device_get_parameter:         Devices.             (line 131)
* gnufdisk_device_new:                   Devices.             (line  15)
* gnufdisk_device_open:                  Devices.             (line  54)
* gnufdisk_device_ref:                   Devices.             (line  43)
* gnufdisk_device_set_parameter:         Devices.             (line 108)
* gnufdisk_devicemanager_delete:         gnufdisk-devicemanager library.
                                                              (line  15)
* gnufdisk_devicemanager_device_close:   gnufdisk-devicemanager library.
                                                              (line  87)
* gnufdisk_devicemanager_device_commit:  gnufdisk-devicemanager library.
                                                              (line  84)
* gnufdisk_devicemanager_device_create_disklabel: gnufdisk-devicemanager library.
                                                              (line  73)
* gnufdisk_devicemanager_device_delete:  gnufdisk-devicemanager library.
                                                              (line  90)
* gnufdisk_devicemanager_device_disklabel: gnufdisk-devicemanager library.
                                                              (line  68)
* gnufdisk_devicemanager_device_get_parameter: gnufdisk-devicemanager library.
                                                              (line  81)
* gnufdisk_devicemanager_device_new:     gnufdisk-devicemanager library.
                                                              (line  60)
* gnufdisk_devicemanager_device_open:    gnufdisk-devicemanager library.
                                                              (line  64)
* gnufdisk_devicemanager_device_set_parameter: gnufdisk-devicemanager library.
                                                              (line  77)
* gnufdisk_devicemanager_disklabel_create_partition: gnufdisk-devicemanager library.
                                                              (line 109)
* gnufdisk_devicemanager_disklabel_delete: gnufdisk-devicemanager library.
                                                              (line 131)
* gnufdisk_devicemanager_disklabel_get_parameter: gnufdisk-devicemanager library.
                                                              (line 123)
* gnufdisk_devicemanager_disklabel_partition: gnufdisk-devicemanager library.
                                                              (line 103)
* gnufdisk_devicemanager_disklabel_raw:  gnufdisk-devicemanager library.
                                                              (line  94)
* gnufdisk_devicemanager_disklabel_remove_partition: gnufdisk-devicemanager library.
                                                              (line 113)
* gnufdisk_devicemanager_disklabel_set_parameter: gnufdisk-devicemanager library.
                                                              (line 118)
* gnufdisk_devicemanager_disklabel_system: gnufdisk-devicemanager library.
                                                              (line  98)
* gnufdisk_devicemanager_geometry_delete: gnufdisk-devicemanager library.
                                                              (line  26)
* gnufdisk_devicemanager_geometry_duplicate: gnufdisk-devicemanager library.
                                                              (line  23)
* gnufdisk_devicemanager_geometry_end:   gnufdisk-devicemanager library.
                                                              (line  43)
* gnufdisk_devicemanager_geometry_end_chs: gnufdisk-devicemanager library.
                                                              (line  47)
* gnufdisk_devicemanager_geometry_length: gnufdisk-devicemanager library.
                                                              (line  51)
* gnufdisk_devicemanager_geometry_length_chs: gnufdisk-devicemanager library.
                                                              (line  55)
* gnufdisk_devicemanager_geometry_new:   gnufdisk-devicemanager library.
                                                              (line  19)
* gnufdisk_devicemanager_geometry_set:   gnufdisk-devicemanager library.
                                                              (line  31)
* gnufdisk_devicemanager_geometry_start: gnufdisk-devicemanager library.
                                                              (line  35)
* gnufdisk_devicemanager_geometry_start_chs: gnufdisk-devicemanager library.
                                                              (line  39)
* gnufdisk_devicemanager_new:            gnufdisk-devicemanager library.
                                                              (line   9)
* gnufdisk_devicemanager_partition_delete: gnufdisk-devicemanager library.
                                                              (line 170)
* gnufdisk_devicemanager_partition_get_parameter: gnufdisk-devicemanager library.
                                                              (line 136)
* gnufdisk_devicemanager_partition_length: gnufdisk-devicemanager library.
                                                              (line 148)
* gnufdisk_devicemanager_partition_move: gnufdisk-devicemanager library.
                                                              (line 155)
* gnufdisk_devicemanager_partition_number: gnufdisk-devicemanager library.
                                                              (line 151)
* gnufdisk_devicemanager_partition_read: gnufdisk-devicemanager library.
                                                              (line 163)
* gnufdisk_devicemanager_partition_resize: gnufdisk-devicemanager library.
                                                              (line 159)
* gnufdisk_devicemanager_partition_set_parameter: gnufdisk-devicemanager library.
                                                              (line 128)
* gnufdisk_devicemanager_partition_start: gnufdisk-devicemanager library.
                                                              (line 144)
* gnufdisk_devicemanager_partition_type: gnufdisk-devicemanager library.
                                                              (line 140)
* gnufdisk_devicemanager_partition_write: gnufdisk-devicemanager library.
                                                              (line 167)
* gnufdisk_devicemanager_ref:            gnufdisk-devicemanager library.
                                                              (line  12)
* gnufdisk_disklabel_create_partition:   Disklabels.          (line  53)
* gnufdisk_disklabel_delete:             Disklabels.          (line  16)
* gnufdisk_disklabel_get_parameter:      Disklabels.          (line  76)
* gnufdisk_disklabel_partition:          Disklabels.          (line  44)
* gnufdisk_disklabel_raw:                Disklabels.          (line  30)
* gnufdisk_disklabel_ref:                Disklabels.          (line  23)
* gnufdisk_disklabel_remove_partition:   Disklabels.          (line  60)
* gnufdisk_disklabel_set_parameter:      Disklabels.          (line  68)
* gnufdisk_disklabel_system:             Disklabels.          (line  37)
* GNUFDISK_EXCEPTION_END:                End try/catch context.
                                                              (line  10)
* gnufdisk_exception_register_unwind_handler: Unwind handlers.
                                                              (line  14)
* gnufdisk_exception_unregister_unwind_handler: Unwind handlers.
                                                              (line  24)
* gnufdisk_geometry_delete:              Geometries.          (line  29)
* gnufdisk_geometry_end:                 Geometries.          (line 101)
* gnufdisk_geometry_end_chs:             Geometries.          (line 110)
* gnufdisk_geometry_length:              Geometries.          (line 115)
* gnufdisk_geometry_length_chs:          Geometries.          (line 124)
* gnufdisk_geometry_new:                 Geometries.          (line  16)
* gnufdisk_geometry_set:                 Geometries.          (line  57)
* gnufdisk_geometry_set_chs:             Geometries.          (line  70)
* gnufdisk_geometry_start:               Geometries.          (line  82)
* gnufdisk_geometry_start_chs:           Geometries.          (line  91)
* GNUFDISK_LOG:                          Log messages.        (line  10)
* gnufdisk_partition_delete:             Partitions.          (line  24)
* gnufdisk_partition_get_parameter:      Partitions.          (line  40)
* gnufdisk_partition_length:             Partitions.          (line  68)
* gnufdisk_partition_move:               Partitions.          (line  75)
* gnufdisk_partition_number:             Partitions.          (line  54)
* gnufdisk_partition_read:               Partitions.          (line  90)
* gnufdisk_partition_ref:                Partitions.          (line  17)
* gnufdisk_partition_resize:             Partitions.          (line  83)
* gnufdisk_partition_set_parameter:      Partitions.          (line  32)
* gnufdisk_partition_start:              Partitions.          (line  61)
* gnufdisk_partition_type:               Partitions.          (line  47)
* gnufdisk_partition_write:              Partitions.          (line  98)
* GNUFDISK_RETRY_SET:                    Blocking exceptions continue or jump back.
                                                              (line  22)
* gnufdisk_stack_delete:                 Stacks.              (line   9)
* gnufdisk_stack_new:                    Stacks.              (line   7)
* gnufdisk_stack_pop:                    Stacks.              (line  15)
* gnufdisk_stack_push:                   Stacks.              (line  12)
* gnufdisk_string_c_string:              Strings.             (line  40)
* gnufdisk_string_c_string_dup:          Strings.             (line  46)
* gnufdisk_string_delete:                Strings.             (line  52)
* gnufdisk_string_length:                Strings.             (line  34)
* gnufdisk_string_new:                   Strings.             (line  13)
* gnufdisk_string_set:                   Strings.             (line  22)
* GNUFDISK_THROW:                        Throw.               (line  11)
* GNUFDISK_TRY:                          Throw handlers.      (line  45)
* gnufdisk_userinterface_delete:         gnufdisk-userinterface library.
                                                              (line  14)
* gnufdisk_userinterface_get_disklabel_system: gnufdisk-userinterface library.
                                                              (line  31)
* gnufdisk_userinterface_get_geometry:   gnufdisk-userinterface library.
                                                              (line  35)
* gnufdisk_userinterface_get_partition_type: gnufdisk-userinterface library.
                                                              (line  39)
* gnufdisk_userinterface_get_path:       gnufdisk-userinterface library.
                                                              (line  27)
* gnufdisk_userinterface_new:            gnufdisk-userinterface library.
                                                              (line   8)
* gnufdisk_userinterface_print:          gnufdisk-userinterface library.
                                                              (line  21)
* gnufdisk_userinterface_ref:            gnufdisk-userinterface library.
                                                              (line  11)
* gnufdisk_userinterface_run:            gnufdisk-userinterface library.
                                                              (line  18)
* gnufdisk_userinterface_yes_no:         gnufdisk-userinterface library.
                                                              (line  24)
* gnufdisk_vasprintf:                    Page fault handling. (line  39)
* gnufdisk_vfprintf:                     Page fault handling. (line  29)
* GNUFDISK_WARNING:                      Warning messages.    (line  10)
* print:                                 Scheme shell.        (line 121)
* register_module:                       Backend API.         (line  91)
* yes-no:                                Scheme shell.        (line 125)


File: gnufdisk,  Node: Type index,  Next: Variable index,  Prev: Functions index,  Up: Top

Appendix B Type index
*********************

 [index ]
* Menu:

* gnufdisk_exception_handler:            Throw handlers.       (line 12)
* GNUFDISK_RETRY:                        Blocking exceptions continue or jump back.
                                                               (line 19)
* struct gnufdisk_chs:                   Geometries.           (line 45)
* struct gnufdisk_device_operations:     Backend API.          (line 11)
* struct gnufdisk_disklabel_operations:  Backend API.          (line 35)
* struct gnufdisk_exception_info:        Throw handlers.       (line 26)
* struct gnufdisk_partition_operations:  Backend API.          (line 62)


File: gnufdisk,  Node: Variable index,  Prev: Type index,  Up: Top

Appendix C Variable index
*************************

 [index ]
* Menu:

* *command-line*:                        Scheme shell.         (line 15)
* *userinterface*:                       Scheme shell.         (line 13)
* exception_info:                        Catch.                (line 20)



Tag Table:
Node: Top0
Node: Introduction1147
Node: Using gnufdisk1978
Node: Invoking2158
Node: shell interface2873
Node: Preparing your system3303
Node: gnufdisk-common library3557
Node: Page fault handling3882
Node: Strings5829
Node: Stacks8155
Node: gnufdisk-debug library8610
Node: Log messages8998
Node: Warning messages11073
Node: gnufdisk-debug example11593
Node: gnufdisk-exception library16338
Node: Throw17768
Node: Throw handlers19756
Ref: gnufdisk_exception_info20879
Node: Blocking exceptions continue or jump back21804
Ref: Blocking exceptions22045
Node: Unwind handlers23367
Node: Catch24873
Node: End try/catch context25858
Node: gnufdisk-exception example27334
Node: gnufdisk-device library34527
Node: Error reporting35431
Node: Geometries40376
Node: Devices44683
Node: Disklabels50193
Node: Partitions52946
Node: gnufdisk-device example56312
Node: gnufdisk-devicemanager library58439
Node: gnufdisk-userinterface library65719
Node: Scheme shell67266
Node: Backend API70382
Node: Backend example73643
Node: Functions index83788
Node: Type index99837
Node: Variable index100593

End Tag Table
